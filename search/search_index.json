{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Hello \ud83d\udc4b What is this? A guide book on data science for busy and equally lazy Data Scientists \ud83d\ude04 What does this include? While the book started as a collection of snippets, the plan is to overtime include details about the algorithms, applications, tools, best practices and much more to make this the ultimate guide for a budding or experienced Data Scientists. Why this? While there are lots of good quality articles on several data science topics, the major downside is that they are scattered across the web. This guide tries to consolidate the most relevant topics into one place. How to read? As the name suggests, this is a lazy book for lazy people \ud83d\ude04. On a serious note, there is no specific order. Feel free to search for the topic you are interested in and start reading. How to contribute? Any contribution (typo, error, new topic request, etc) is appreciated. Just create an issue, or start a new discussion on github, and I will be happy to discuss the idea! How to appreciate? Maybe you can do two things? -- (1) Say hello to me on LinkedIn , and/or (2) Click on the \u2b50 @ github ? Thnx! How to cite? Add the following to your bib file, @misc{mohitlazydatascience, title = \"A Lazy Data Science Guide\", author = \"Mohit Mayank\", journal = \"mohitmayank.com\", year = \"2021\", url = \"http://mohitmayank.com/a_lazy_data_science_guide/\" } -- Mohit Mayank","title":"Hello"},{"location":"#hello","text":"What is this? A guide book on data science for busy and equally lazy Data Scientists \ud83d\ude04 What does this include? While the book started as a collection of snippets, the plan is to overtime include details about the algorithms, applications, tools, best practices and much more to make this the ultimate guide for a budding or experienced Data Scientists. Why this? While there are lots of good quality articles on several data science topics, the major downside is that they are scattered across the web. This guide tries to consolidate the most relevant topics into one place. How to read? As the name suggests, this is a lazy book for lazy people \ud83d\ude04. On a serious note, there is no specific order. Feel free to search for the topic you are interested in and start reading. How to contribute? Any contribution (typo, error, new topic request, etc) is appreciated. Just create an issue, or start a new discussion on github, and I will be happy to discuss the idea! How to appreciate? Maybe you can do two things? -- (1) Say hello to me on LinkedIn , and/or (2) Click on the \u2b50 @ github ? Thnx! How to cite? Add the following to your bib file, @misc{mohitlazydatascience, title = \"A Lazy Data Science Guide\", author = \"Mohit Mayank\", journal = \"mohitmayank.com\", year = \"2021\", url = \"http://mohitmayank.com/a_lazy_data_science_guide/\" } -- Mohit Mayank","title":"Hello \ud83d\udc4b"},{"location":"audio_intelligence/audio_snippets/","text":"Audio Intelligence Snippets Here are some code snippets that you might find useful when playing around with audio files \ud83d\ude09 Load WAV file and check file stats To check some basic stats of a wav file, we can use wave package 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # import import wave # Open the wave file and extract some properties file_path = f ' { dataset_folder } /call_1.wav' with wave . open ( file_path , 'rb' ) as wav_file : n_channels = wav_file . getnchannels () sample_width = wav_file . getsampwidth () frame_rate = wav_file . getframerate () n_frames = wav_file . getnframes () comp_type = wav_file . getcomptype () comp_name = wav_file . getcompname () # read the data data = wav_file . readframes ( n_frames ) # structure the required stats wav_file_stats = { \"Number of Channels\" : n_channels , \"Sample Width\" : sample_width , \"Frame Rate\" : frame_rate , \"Number of Frames\" : n_frames , \"Compression Type\" : comp_type , \"Compression Name\" : comp_name } # print print ( wav_file_stats ) # Example output: # {'Number of Channels': 1, # 'Sample Width': 2, # 'Frame Rate': 22050, # 'Number of Frames': 3821760, # 'Compression Type': 'NONE', # 'Compression Name': 'not compressed'} We can also scipy package for wav file loading and printing stats 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # import from scipy.io import wavfile # let's define a function to print the stats def print_wav_stats ( sample_rate , data ): print ( f \"Sample rate: { sample_rate } Hz\" ) print ( f \"Data type: { data . dtype } \" ) print ( f \"Duration: { data . shape [ 0 ] / sample_rate } seconds\" ) print ( f \"Number of samples: { data . shape [ 0 ] } \" ) print ( f \"Value range: { data . min () } to { data . max () } \" ) print ( f \"Channels: { data . shape } \" ) # Load the wav file file_path = f ' { dataset_folder } /call_1.wav' sample_rate , data = wavfile . read ( file_path ) # print stats, example below print_wav_stats ( sample_rate , data ) # Sample rate: 48000 Hz # Data type: int16 # Duration: 1.18 seconds # Number of samples: 56640 # Value range: -1787 to 1835 # Channels: (56640, 2) Note scipy returns data in an array with shape (n_samples, n_channels) . Whereas wave package returns data in bytes format. Get WAV file duration in seconds You can check the above section or below is a readymade function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # import import wave def print_wav_duration ( file_path ): # Open the wave file with wave . open ( file_path , 'rb' ) as wav_file : # Extract the frame rate and number of frames frame_rate = wav_file . getframerate () n_frames = wav_file . getnframes () # Calculate duration duration = n_frames / float ( frame_rate ) print ( f \"The duration of the file is: { duration } seconds.\" ) # Example usage with a placeholder file path # You would replace 'path/to/file.wav' with the actual file path of your .wav file print_wav_duration ( 'path/to/file.wav' ) Convert Dual Channel WAV file to Mono Let's first do this with scipy package 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # import from scipy.io import wavfile def stereo_to_mono ( file_path ): # Load the stereo wave file sample_rate , data = wavfile . read ( file_path ) # Check if it's already mono if data . shape [ 1 ] != 2 : return \"The file is not a stereo file.\" # Convert to mono by taking the mean of the two channels mono_data = data . mean ( axis = 1 ) # <--- THIS IS THE ONLY IMPORTANT LINE # Set the file path for output mono_file_path = file_path . replace ( \".wav\" , \"_mono.wav\" ) # Save the mono file wavfile . write ( mono_file_path , sample_rate , mono_data . astype ( data . dtype )) return f \"Stereo file converted to mono: { mono_file_path } \" Same can be done with wave and numpy packages 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import wave import numpy as np def stereo_to_mono ( file_path ): # Open the stereo wave file with wave . open ( file_path , 'rb' ) as stereo_wav : # Check if it's already mono if stereo_wav . getnchannels () != 2 : return \"The file is not a stereo file.\" # Read the stereo wave file data frames = stereo_wav . readframes ( stereo_wav . getnframes ()) # Convert frames to numpy array frames = np . frombuffer ( frames , dtype = np . int16 ) # Reshape the data to 2 columns for stereo frames = np . reshape ( frames , ( - 1 , 2 )) # Take the mean of the two channels to convert to mono mono_frames = frames . mean ( axis = 1 , dtype = np . int16 ) # Get stereo file params to use for mono file params = stereo_wav . getparams () num_frames = len ( mono_frames ) # Set the file path for output mono_file_path = file_path . replace ( \".wav\" , \"_mono.wav\" ) # Create a new wave file for mono with wave . open ( mono_file_path , 'wb' ) as mono_wav : # Set parameters for mono (nchannels=1) mono_wav . setparams (( 1 , params . sampwidth , params . framerate , num_frames , params . comptype , params . compname )) # Write frames for mono mono_wav . writeframes ( mono_frames . tobytes ()) return f \"Stereo file converted to mono: { mono_file_path } \" # Replace with an actual file path to a stereo wav file # e.g., stereo_to_mono(\"path/to/stereo_file.wav\") stereo_to_mono ( f ' { dataset_folder } /call_5.wav' ) Downsample WAV file Let's first do this with scipy package 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # import from scipy.io import wavfile import scipy.signal as sps # Define a function to downsample a wave file def downsample_wav ( file_path , target_sample_rate = 16000 ): \"\"\"Downsample a wave file to a target sample rate. Args: file_path (str): The path to the wave file. target_sample_rate (int): The target sample rate to downsample to. Returns: str: A message indicating the success of the operation. \"\"\" # Load the wave file sample_rate , data = wavfile . read ( file_path ) # Check if the target sample rate is the same as the original if sample_rate == target_sample_rate : return \"The file is already at the target sample rate.\" # Calculate the new number of samples new_num_samples = int ( data . shape [ 0 ] * target_sample_rate / sample_rate ) # Resample the data new_data = sps . resample ( data , number_of_samples ) # Set the file path for output downsampled_file_path = file_path . replace ( \".wav\" , f \"_downsampled_ { target_sample_rate } .wav\" ) # Save the downsampled file wavfile . write ( downsampled_file_path , target_sample_rate , new_data . astype ( data . dtype )) # return a message indicating the success of the operation return f \"File downsampled to { target_sample_rate } Hz: { downsampled_file_path } \" Warning Before saving .wav file using scipy , make sure the dtype is int16 .","title":"Code Snippets"},{"location":"audio_intelligence/audio_snippets/#audio-intelligence-snippets","text":"Here are some code snippets that you might find useful when playing around with audio files \ud83d\ude09","title":"Audio Intelligence Snippets"},{"location":"audio_intelligence/audio_snippets/#load-wav-file-and-check-file-stats","text":"To check some basic stats of a wav file, we can use wave package 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # import import wave # Open the wave file and extract some properties file_path = f ' { dataset_folder } /call_1.wav' with wave . open ( file_path , 'rb' ) as wav_file : n_channels = wav_file . getnchannels () sample_width = wav_file . getsampwidth () frame_rate = wav_file . getframerate () n_frames = wav_file . getnframes () comp_type = wav_file . getcomptype () comp_name = wav_file . getcompname () # read the data data = wav_file . readframes ( n_frames ) # structure the required stats wav_file_stats = { \"Number of Channels\" : n_channels , \"Sample Width\" : sample_width , \"Frame Rate\" : frame_rate , \"Number of Frames\" : n_frames , \"Compression Type\" : comp_type , \"Compression Name\" : comp_name } # print print ( wav_file_stats ) # Example output: # {'Number of Channels': 1, # 'Sample Width': 2, # 'Frame Rate': 22050, # 'Number of Frames': 3821760, # 'Compression Type': 'NONE', # 'Compression Name': 'not compressed'} We can also scipy package for wav file loading and printing stats 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # import from scipy.io import wavfile # let's define a function to print the stats def print_wav_stats ( sample_rate , data ): print ( f \"Sample rate: { sample_rate } Hz\" ) print ( f \"Data type: { data . dtype } \" ) print ( f \"Duration: { data . shape [ 0 ] / sample_rate } seconds\" ) print ( f \"Number of samples: { data . shape [ 0 ] } \" ) print ( f \"Value range: { data . min () } to { data . max () } \" ) print ( f \"Channels: { data . shape } \" ) # Load the wav file file_path = f ' { dataset_folder } /call_1.wav' sample_rate , data = wavfile . read ( file_path ) # print stats, example below print_wav_stats ( sample_rate , data ) # Sample rate: 48000 Hz # Data type: int16 # Duration: 1.18 seconds # Number of samples: 56640 # Value range: -1787 to 1835 # Channels: (56640, 2) Note scipy returns data in an array with shape (n_samples, n_channels) . Whereas wave package returns data in bytes format.","title":"Load WAV file and check file stats"},{"location":"audio_intelligence/audio_snippets/#get-wav-file-duration-in-seconds","text":"You can check the above section or below is a readymade function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # import import wave def print_wav_duration ( file_path ): # Open the wave file with wave . open ( file_path , 'rb' ) as wav_file : # Extract the frame rate and number of frames frame_rate = wav_file . getframerate () n_frames = wav_file . getnframes () # Calculate duration duration = n_frames / float ( frame_rate ) print ( f \"The duration of the file is: { duration } seconds.\" ) # Example usage with a placeholder file path # You would replace 'path/to/file.wav' with the actual file path of your .wav file print_wav_duration ( 'path/to/file.wav' )","title":"Get WAV file duration in seconds"},{"location":"audio_intelligence/audio_snippets/#convert-dual-channel-wav-file-to-mono","text":"Let's first do this with scipy package 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # import from scipy.io import wavfile def stereo_to_mono ( file_path ): # Load the stereo wave file sample_rate , data = wavfile . read ( file_path ) # Check if it's already mono if data . shape [ 1 ] != 2 : return \"The file is not a stereo file.\" # Convert to mono by taking the mean of the two channels mono_data = data . mean ( axis = 1 ) # <--- THIS IS THE ONLY IMPORTANT LINE # Set the file path for output mono_file_path = file_path . replace ( \".wav\" , \"_mono.wav\" ) # Save the mono file wavfile . write ( mono_file_path , sample_rate , mono_data . astype ( data . dtype )) return f \"Stereo file converted to mono: { mono_file_path } \" Same can be done with wave and numpy packages 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import wave import numpy as np def stereo_to_mono ( file_path ): # Open the stereo wave file with wave . open ( file_path , 'rb' ) as stereo_wav : # Check if it's already mono if stereo_wav . getnchannels () != 2 : return \"The file is not a stereo file.\" # Read the stereo wave file data frames = stereo_wav . readframes ( stereo_wav . getnframes ()) # Convert frames to numpy array frames = np . frombuffer ( frames , dtype = np . int16 ) # Reshape the data to 2 columns for stereo frames = np . reshape ( frames , ( - 1 , 2 )) # Take the mean of the two channels to convert to mono mono_frames = frames . mean ( axis = 1 , dtype = np . int16 ) # Get stereo file params to use for mono file params = stereo_wav . getparams () num_frames = len ( mono_frames ) # Set the file path for output mono_file_path = file_path . replace ( \".wav\" , \"_mono.wav\" ) # Create a new wave file for mono with wave . open ( mono_file_path , 'wb' ) as mono_wav : # Set parameters for mono (nchannels=1) mono_wav . setparams (( 1 , params . sampwidth , params . framerate , num_frames , params . comptype , params . compname )) # Write frames for mono mono_wav . writeframes ( mono_frames . tobytes ()) return f \"Stereo file converted to mono: { mono_file_path } \" # Replace with an actual file path to a stereo wav file # e.g., stereo_to_mono(\"path/to/stereo_file.wav\") stereo_to_mono ( f ' { dataset_folder } /call_5.wav' )","title":"Convert Dual Channel WAV file to Mono"},{"location":"audio_intelligence/audio_snippets/#downsample-wav-file","text":"Let's first do this with scipy package 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # import from scipy.io import wavfile import scipy.signal as sps # Define a function to downsample a wave file def downsample_wav ( file_path , target_sample_rate = 16000 ): \"\"\"Downsample a wave file to a target sample rate. Args: file_path (str): The path to the wave file. target_sample_rate (int): The target sample rate to downsample to. Returns: str: A message indicating the success of the operation. \"\"\" # Load the wave file sample_rate , data = wavfile . read ( file_path ) # Check if the target sample rate is the same as the original if sample_rate == target_sample_rate : return \"The file is already at the target sample rate.\" # Calculate the new number of samples new_num_samples = int ( data . shape [ 0 ] * target_sample_rate / sample_rate ) # Resample the data new_data = sps . resample ( data , number_of_samples ) # Set the file path for output downsampled_file_path = file_path . replace ( \".wav\" , f \"_downsampled_ { target_sample_rate } .wav\" ) # Save the downsampled file wavfile . write ( downsampled_file_path , target_sample_rate , new_data . astype ( data . dtype )) # return a message indicating the success of the operation return f \"File downsampled to { target_sample_rate } Hz: { downsampled_file_path } \" Warning Before saving .wav file using scipy , make sure the dtype is int16 .","title":"Downsample WAV file"},{"location":"audio_intelligence/connectionist_temporal_classification/","text":"Introduction Connectionist Temporal Classification (CTC) is the algorithm to assign probability score to an output Y given any input X. The main advantage is that the size of X and Y do not have to match! This makes CTC an ideal algorithm for use cases like speech recogition and handwriting recoginition where the input and output do not usually match. Take the example of speech recognition. The input is usually a waveform of audio that could contains 16,000 samples per second (if sampling rate is 16kHz). But in a second, we hardly speak a word that could be 5-6 characters. So in ASR we are trying to map a large amount of input to much smaller sized output. This is just one of the use cases where CTC shines. Message collapsing using CTC. Created using the tool available here Understanding CTC To understand the CTC algorithm, we need to understand three aspects. Let's go through them one by one. Collapsing In ASR, while the output is much smaller, we start with normal classification on the input. For this, we first divide the input into multiple equal sized tokens. For example, we can take 400 samples at a time (for 16kHz sampled audio that is 25ms of speech). Now we need to classify each one of these samples into characters available in the vocabulary. For a normal english language we will have all the alphanumeric characters plus some special tokens (not special characters) as the vocabulary. Note In ASR vocab, we do not put any of the special characters for which there is no sound. For example there is no sound for . . But we could identify ' in It's , so it could be there. This will give us a long sequence of characters, and this is where collapsing logic of CTC comes into picture. The idea is to combine consecutive repetitive characters together. For example, hhhhiiiii could be simply written as hi . Now we also want to handle two special cases, (1) there could be spaces between two words, (2) there could be multiple repetitive characters in a valid word like double l in hello . For these cases, we can add two special tokens in the vocab, say [BRK] and [SEP] respectively. So a word like hello could be decoded if we get the classification output as hhelll[SEP]llo . This means for a complicated task like ASR, we can continue with a simple classification task at the output layer and later let CTC decoding logic handle the rest. But the next question is, \"how can we teach model to predict these outputs?\" \ud83e\udd14 Note The overall collapsing algorithm is like this -- (1) First, collapse the consecutive characters, (2) Next remove any [SEP] tokens, and (3) Finally replace [BRK] tokens with space. Relevant Paths For any given sample (time step), the output will be a probability distribution for each character in the vocab (imagine using softmax) . Suppose we only have 3 samples (three time steps) and 3 different characters in the vocab, then we can have \\(3^3=27\\) possible paths to choose from. An example is shown below where you could imagine paths (dashed lines) going from any left circle to every circle in the next time step. One possible path for transcribing hi One interesting property of CTC is that there could be multiple true possible paths. For CTC to transcribe hi any of the following will do -- hhi , hii , h[SEP]i , hi[SEP] or [SEP]hi . Hence the true relevant paths here are 5 out of all 27 available ones. Looking from the perspective of training neural networks, we want to penalize the irrelevant paths and increase the probability of the relevant ones. This is done by two ways, We can train to increase the probability of the characters in the relevant paths at the respective time step. In our case, we can increase the probability of h and [SEP] at the 1st time step as these are the only available choices in set of relevant paths! This can be repeated for the other time steps as well. But this approach has one major con - it is training at time step level and not path level. So even if the probabilities at each step improves, output paths could still not be a relevant one. Another approach is to consider the context of the path by using models like RNN that can compute per step wise probabilities wrt the overall path probability. We take product of probability of all steps in a relevant path ( \\(\\prod_{t=1}^{T}p_t (a_t | X)\\) ) and then sum the path probabilities of the relevant paths ( \\(\\sum_{A\\epsilon A_{X,Y}}^{}\\) ). This gives us the CTC conditional probability, which we want to maximize. \\[ P(Y|X) = \\sum_{A\\epsilon A_{X,Y}}^{}\\prod_{t=1}^{T}p_t (a_t | X) \\] Note This interesting property of CTC helps us to train ASR model without perfect data annotations, where we will have to assign labels to each individual tokens of input. We just need the input audio stream and the expected output transcription and CTC loss takes care of the rest. In fact, famous deep learning frameworks like PyTorch has CTCLoss available for easy use! Inference Now after training the model, we want it to work during the inference. Here, we won't know the correct transcription or the relevant paths, so we will have to find one. For this we can employ a couple of approaches, The easiest approach is to go greedy! At each time step, we pick the token with the highest probability. But this could lead to suboptimal outputs as some time steps could have high probability but incorrect predictions. Also remember we trained the model to improve the summation of probabilty for all relevant paths. Now there could be a scenario where one irrelevant path (say [SEP]ih ) has more probability than all individual paths, but the summation of two relevant paths are higher (say hi[SEP] and hii ). Apart from this, as the predictions are at time step level, they are independent of context and this could lead to other issues like spelling mistakes and wrong grammer. The next approach could be to use Beam search where we keep exploring top N paths, where N is the beam size. To handle the above problem, we can modify the beam search where before selecting the next paths to explore, we consider the summation of the explored paths so far by applying CTC collapsing. More details can be found here and an implementation is here . Another approach could be to utilise a language model for decoding. This will take care of the spelling mistakes and grammer issues. For this we can either use n-gram language model or a neural language model. While neural language model is more powerful, it is more complicated to implement and will be much slower, and the comparitive gain in improvement wrt n-gram is not that much ( Wav2vec2 ). There are several open source packages that can be utilised to create a language model like KenML and then use it for decoding with pyctcdecode . Additional Materials Distill - Sequence Modeling With CTC An Intuitive Explanation of Connectionist Temporal Classification Boosting Wav2Vec2 with n-grams in \ud83e\udd17 Transformers","title":"Connectionist Temporal Classification"},{"location":"audio_intelligence/connectionist_temporal_classification/#introduction","text":"Connectionist Temporal Classification (CTC) is the algorithm to assign probability score to an output Y given any input X. The main advantage is that the size of X and Y do not have to match! This makes CTC an ideal algorithm for use cases like speech recogition and handwriting recoginition where the input and output do not usually match. Take the example of speech recognition. The input is usually a waveform of audio that could contains 16,000 samples per second (if sampling rate is 16kHz). But in a second, we hardly speak a word that could be 5-6 characters. So in ASR we are trying to map a large amount of input to much smaller sized output. This is just one of the use cases where CTC shines. Message collapsing using CTC. Created using the tool available here","title":"Introduction"},{"location":"audio_intelligence/connectionist_temporal_classification/#understanding-ctc","text":"To understand the CTC algorithm, we need to understand three aspects. Let's go through them one by one.","title":"Understanding CTC"},{"location":"audio_intelligence/connectionist_temporal_classification/#collapsing","text":"In ASR, while the output is much smaller, we start with normal classification on the input. For this, we first divide the input into multiple equal sized tokens. For example, we can take 400 samples at a time (for 16kHz sampled audio that is 25ms of speech). Now we need to classify each one of these samples into characters available in the vocabulary. For a normal english language we will have all the alphanumeric characters plus some special tokens (not special characters) as the vocabulary. Note In ASR vocab, we do not put any of the special characters for which there is no sound. For example there is no sound for . . But we could identify ' in It's , so it could be there. This will give us a long sequence of characters, and this is where collapsing logic of CTC comes into picture. The idea is to combine consecutive repetitive characters together. For example, hhhhiiiii could be simply written as hi . Now we also want to handle two special cases, (1) there could be spaces between two words, (2) there could be multiple repetitive characters in a valid word like double l in hello . For these cases, we can add two special tokens in the vocab, say [BRK] and [SEP] respectively. So a word like hello could be decoded if we get the classification output as hhelll[SEP]llo . This means for a complicated task like ASR, we can continue with a simple classification task at the output layer and later let CTC decoding logic handle the rest. But the next question is, \"how can we teach model to predict these outputs?\" \ud83e\udd14 Note The overall collapsing algorithm is like this -- (1) First, collapse the consecutive characters, (2) Next remove any [SEP] tokens, and (3) Finally replace [BRK] tokens with space.","title":"Collapsing"},{"location":"audio_intelligence/connectionist_temporal_classification/#relevant-paths","text":"For any given sample (time step), the output will be a probability distribution for each character in the vocab (imagine using softmax) . Suppose we only have 3 samples (three time steps) and 3 different characters in the vocab, then we can have \\(3^3=27\\) possible paths to choose from. An example is shown below where you could imagine paths (dashed lines) going from any left circle to every circle in the next time step. One possible path for transcribing hi One interesting property of CTC is that there could be multiple true possible paths. For CTC to transcribe hi any of the following will do -- hhi , hii , h[SEP]i , hi[SEP] or [SEP]hi . Hence the true relevant paths here are 5 out of all 27 available ones. Looking from the perspective of training neural networks, we want to penalize the irrelevant paths and increase the probability of the relevant ones. This is done by two ways, We can train to increase the probability of the characters in the relevant paths at the respective time step. In our case, we can increase the probability of h and [SEP] at the 1st time step as these are the only available choices in set of relevant paths! This can be repeated for the other time steps as well. But this approach has one major con - it is training at time step level and not path level. So even if the probabilities at each step improves, output paths could still not be a relevant one. Another approach is to consider the context of the path by using models like RNN that can compute per step wise probabilities wrt the overall path probability. We take product of probability of all steps in a relevant path ( \\(\\prod_{t=1}^{T}p_t (a_t | X)\\) ) and then sum the path probabilities of the relevant paths ( \\(\\sum_{A\\epsilon A_{X,Y}}^{}\\) ). This gives us the CTC conditional probability, which we want to maximize. \\[ P(Y|X) = \\sum_{A\\epsilon A_{X,Y}}^{}\\prod_{t=1}^{T}p_t (a_t | X) \\] Note This interesting property of CTC helps us to train ASR model without perfect data annotations, where we will have to assign labels to each individual tokens of input. We just need the input audio stream and the expected output transcription and CTC loss takes care of the rest. In fact, famous deep learning frameworks like PyTorch has CTCLoss available for easy use!","title":"Relevant Paths"},{"location":"audio_intelligence/connectionist_temporal_classification/#inference","text":"Now after training the model, we want it to work during the inference. Here, we won't know the correct transcription or the relevant paths, so we will have to find one. For this we can employ a couple of approaches, The easiest approach is to go greedy! At each time step, we pick the token with the highest probability. But this could lead to suboptimal outputs as some time steps could have high probability but incorrect predictions. Also remember we trained the model to improve the summation of probabilty for all relevant paths. Now there could be a scenario where one irrelevant path (say [SEP]ih ) has more probability than all individual paths, but the summation of two relevant paths are higher (say hi[SEP] and hii ). Apart from this, as the predictions are at time step level, they are independent of context and this could lead to other issues like spelling mistakes and wrong grammer. The next approach could be to use Beam search where we keep exploring top N paths, where N is the beam size. To handle the above problem, we can modify the beam search where before selecting the next paths to explore, we consider the summation of the explored paths so far by applying CTC collapsing. More details can be found here and an implementation is here . Another approach could be to utilise a language model for decoding. This will take care of the spelling mistakes and grammer issues. For this we can either use n-gram language model or a neural language model. While neural language model is more powerful, it is more complicated to implement and will be much slower, and the comparitive gain in improvement wrt n-gram is not that much ( Wav2vec2 ). There are several open source packages that can be utilised to create a language model like KenML and then use it for decoding with pyctcdecode .","title":"Inference"},{"location":"audio_intelligence/connectionist_temporal_classification/#additional-materials","text":"Distill - Sequence Modeling With CTC An Intuitive Explanation of Connectionist Temporal Classification Boosting Wav2Vec2 with n-grams in \ud83e\udd17 Transformers","title":"Additional Materials"},{"location":"audio_intelligence/interview_questions/","text":"Here are some questions and their answers to make you ready for your next interview. Best of luck \ud83d\udc4b Question Answer What is the difference between Sample Rate, Bit Depth and Bit Rate? Sample rate is the number of audio samples recorded per unit of time. For example, an audio with 16kHz sample rate, means that for one second, we have captured 16000 samples. Bit Depth measures how precisely the samples were encoded. Here for a 16kHz sample rate audio, if the bit depth is 8 bits, it means we are using 8 bits of data to store each 16k samples per second. Bit rate is the amount of bits that are recorded per unit of time. For the above example, it means we have 16k * 8 bits of data per second i.e. 128kbps Question Answer What is the difference between Frame, Frame rate, Number of Channels and Sample size? Frame : one sample of the audio data per channel. Frame rate: the number of times per unit time the sound data is sampled. Same as sample rate. Number of channels: indicates if the audio is mono, stereo, or quadro. The sample size: the size of each sample in bytes. Question Answer What is the difference between i-vector, d-vector and x-vector? All of these are vector representation of the audio to capture the speaker information. Let's go through them, i-vector extraction is essentially a dimensionality reduction of the GMM supervector. Refer SO Question d-vector use the Long Short-Term Memory (LSTM) model to the process each individual frame (along with its context) to obtain a frame-level embedding, and average all the frame-level embeddings to obtain the segment-level embedding which can be used as the speaker embedding. Refer paper x-vector take a sliding window of frames as input, and it uses Time Delay Neural Networks (TDNN) to handle the context, to get the frame-level representation. It then has a statistics pooling layer to get the mean and sd of the frame-level embeddings. And then pass the mean and sd to a linear layer to get the segment-level embedding. Refer the original Paper , OxfordWaveResearch Slides and post on r/speechtech","title":"Interview Questions"},{"location":"audio_intelligence/interview_questions/#what-is-the-difference-between-sample-rate-bit-depth-and-bit-rate","text":"Sample rate is the number of audio samples recorded per unit of time. For example, an audio with 16kHz sample rate, means that for one second, we have captured 16000 samples. Bit Depth measures how precisely the samples were encoded. Here for a 16kHz sample rate audio, if the bit depth is 8 bits, it means we are using 8 bits of data to store each 16k samples per second. Bit rate is the amount of bits that are recorded per unit of time. For the above example, it means we have 16k * 8 bits of data per second i.e. 128kbps Question Answer","title":"What is the difference between Sample Rate, Bit Depth and Bit Rate?"},{"location":"audio_intelligence/interview_questions/#what-is-the-difference-between-frame-frame-rate-number-of-channels-and-sample-size","text":"Frame : one sample of the audio data per channel. Frame rate: the number of times per unit time the sound data is sampled. Same as sample rate. Number of channels: indicates if the audio is mono, stereo, or quadro. The sample size: the size of each sample in bytes. Question Answer","title":"What is the difference between Frame, Frame rate, Number of Channels and Sample size?"},{"location":"audio_intelligence/interview_questions/#what-is-the-difference-between-i-vector-d-vector-and-x-vector","text":"All of these are vector representation of the audio to capture the speaker information. Let's go through them, i-vector extraction is essentially a dimensionality reduction of the GMM supervector. Refer SO Question d-vector use the Long Short-Term Memory (LSTM) model to the process each individual frame (along with its context) to obtain a frame-level embedding, and average all the frame-level embeddings to obtain the segment-level embedding which can be used as the speaker embedding. Refer paper x-vector take a sliding window of frames as input, and it uses Time Delay Neural Networks (TDNN) to handle the context, to get the frame-level representation. It then has a statistics pooling layer to get the mean and sd of the frame-level embeddings. And then pass the mean and sd to a linear layer to get the segment-level embedding. Refer the original Paper , OxfordWaveResearch Slides and post on r/speechtech","title":"What is the difference between i-vector, d-vector and x-vector?"},{"location":"audio_intelligence/neural_audio_codecs/","text":"Neural Audio Codecs Introduction Neural audio codecs are a new generation of audio compression tools powered by deep learning. Unlike traditional codecs, which rely on hand-crafted signal processing, neural codecs learn to compress and reconstruct audio directly from data, achieving much higher quality at lower bitrates. In this guide, we\u2019ll explore three leading neural audio codecs\u2014SoundStream, EnCodec, and HILCodec\u2014highlighting what makes each unique. You\u2019ll also find practical code examples showing how to use neural audio codecs to compress and reconstruct audio, so you can experience their capabilities firsthand. Traditional Audio Codecs Traditional audio codecs rely on signal processing techniques rooted in psychoacoustic models, which discard imperceptible audio components to reduce file sizes. Traditional audio codecs fall into two main camps, Waveform Codecs Goal: Reproduce the original audio as closely as possible, sample by sample. How They Work: They take the audio signal (which is a waveform in the time domain) and convert it into another form, usually the time-frequency domain, using a mathematical process called a transform . After transformation, they compress the data by quantizing (rounding off) the numbers and encoding them efficiently. When you want to listen to the audio, the codec reverses the process to get back to the time-domain waveform. Features: They don't make many assumptions about what kind of audio they're compressing, so they work for all types of sounds\u2014music, speech, noise, etc. They sound great at medium to high bitrates (more data per second), but at low bitrates (less data), you might hear strange artifacts or loss of quality. Examples: MP3, Opus, AAC. Parametric Codecs Goal: Reproduce audio that sounds like the original, even if it's not identical sample by sample. How They Work: They assume the audio is of a specific type (usually speech). Instead of saving the whole waveform, they analyze the audio and extract important features or parameters (like pitch, tone, speed). Only these parameters are compressed and sent. The decoder then uses a model to synthesize (recreate) the audio using the parameters. Features: They are very efficient at low bitrates and can produce understandable speech with very little data. They don't try to perfectly recreate every detail, just make the audio sound similar to the original to our ears. They usually work best for speech and may not be suitable for music or complex sounds. Examples: Some VoIP codecs, like EVS or MELP. Both approaches rely on hand-crafted signal processing pipelines, which limit their flexibility and performance\u2014especially as we demand better quality at lower bitrates, and for more diverse content (music, ambient sounds, etc.). Did you know? The Opus codec, standardized in 2012, is the audio engine behind popular apps like Zoom, Microsoft Teams, Google Meet, and even YouTube streaming! Its widespread adoption means that hundreds of millions of people use Opus every day\u2014often without even realizing it. Meanwhile, the Enhanced Voice Services (EVS) codec, designed for Voice over LTE (VoLTE), is taking over as the new standard for mobile calls, offering improved quality and full compatibility with older systems. Neural Audio Codecs Neural audio codecs use deep learning to learn efficient, perceptually meaningful representations of audio directly from data. This opens the door to higher quality, lower bitrates, and new features like joint enhancement and compression. These systems typically consist of three components: An encoder that converts raw audio into a compressed latent representation. A quantizer that maps continuous latent vectors to discrete symbols for efficient storage/transmission. A decoder that reconstructs audio from the quantized representation. Neural Audio Codecs Architecture The key advantage lies in their end-to-end training process, where all components are optimized jointly to minimize perceptual differences between original and reconstructed audio. This data-driven approach allows neural codecs to adapt to complex audio patterns that challenge rule-based systems, particularly at ultra-low bitrates (<6 kbps). SoundStream: End-to-End Neural Audio Coding SoundStream is a fully end-to-end neural audio codec that can compress speech, music, and general audio at bitrates as low as 3 kbps\u2014outperforming traditional codecs at much higher bitrates. Key Innovations End-to-End Training: The entire pipeline\u2014encoder, quantizer, and decoder\u2014is trained jointly, optimizing for both reconstruction accuracy and perceptual quality via adversarial losses. Residual Vector Quantization (RVQ): Instead of a single quantization step, SoundStream uses a multi-stage (residual) vector quantizer. This allows it to represent audio more efficiently and enables bitrate scalability. Bitrate Scalability: Thanks to a novel \"quantizer dropout\" during training, a single SoundStream model can operate at different bitrates (3\u201318 kbps) with minimal quality loss. Low Latency & Real-Time: The model is fully convolutional and causal, making it suitable for low-latency, real-time applications\u2014even on a smartphone CPU. Joint Compression and Enhancement: SoundStream can simultaneously compress and enhance audio (e.g., denoise speech) with no extra latency. SoundStream Architecture. Source: [1] Architectural Design The system uses a fully convolutional U-Net structure with strided convolutions for downsampling and transposed convolutions for upsampling. A residual vector quantizer (RVQ) between encoder and decoder discretizes the latent space while maintaining reconstruction fidelity. Crucially, SoundStream introduced structured dropout during training, enabling a single model to operate across multiple bitrates (3-18 kbps) without quality degradation. SoundStream Encoder-Decoder Architecture. Source: [1] Training Methodology SoundStream combines adversarial training with multi-resolution spectral losses: A GAN discriminator distinguishes real/fake audio samples, forcing the decoder to generate perceptually convincing outputs. Multi-scale spectrogram losses ensure accurate frequency domain reconstruction. Feature matching losses align intermediate layer activations between original and reconstructed audio. SoundStream Discriminator Architecture. Source: [1] Results The results are impressive: At 3 kbps, SoundStream outperforms Opus at 12 kbps and approaches the quality of EVS at 9.6 kbps. It works for speech, music, and general audio\u2014not just speech. Subjective tests (MUSHRA) show that listeners prefer SoundStream's output at low bitrates over traditional codecs. SoundStream Performance Results. Source: [1] EnCodec: High-Fidelity Neural Compression Meta's EnCodec (2022) builds on SoundStream's foundation while addressing scalability and stability challenges. EnCodec Architecture. Source: [2] Key Innovations Spectrogram Adversary : EnCodec replaces SoundStream's waveform discriminator with a multi-scale spectrogram discriminator , which analyzes audio at different time-frequency resolutions. This modification: Reduces artifacts caused by phase inconsistencies in waveform-based GANs Improves training stability through better gradient signals Enables effective handling of stereo audio at 48 kHz sampling rates EnCodec's Multi-scale Spectrogram Discriminator. Source: [2] Loss Balancing Mechanism : The authors introduced a gradient-balancing technique that dynamically adjusts loss weights based on their contribution to the total gradient magnitude. This innovation decouples hyperparameter tuning from loss function scales, significantly simplifying training. Latent Space Compression : EnCodec demonstrates how lightweight Transformer models can further compress the quantized latent representation by 40%, enabling variable-rate compression without retraining. Subjective evaluations show EnCodec outperforming EVS at 16.4 kbps while operating at 9 kbps, with particularly strong performance on music and noisy speech. Results EnCodec was rigorously evaluated across a range of bitrates and content types (speech, music, noisy and reverberant speech). Key findings include: Superior Quality: At all tested bitrates (1.5, 3, 6, 12 kbps for 24 kHz; 6, 12, 24 kbps for 48 kHz), EnCodec outperformed traditional codecs and previous neural models in both objective and subjective (MUSHRA) tests. Versatility: Works seamlessly for both speech and music, and robustly handles challenging conditions like noise and reverberation. Efficiency: Achieves real-time encoding and decoding on a single CPU core, making it practical for large-scale deployment. EnCodec Performance Results. Source: [2] HILCodec: Lightweight and Efficient Streaming The 2024 HILCodec paper addresses critical limitations in prior neural codecs\u2014model complexity and streaming efficiency [3]. HILCodec Architecture. Source: [3] Key Innovations Variance-Constrained Wave-U-Net Through theoretical analysis, the authors identified that standard Wave-U-Net architectures suffer from exponential variance growth in deeper layers, leading to unstable training and performance degradation. HILCodec introduces: L2-normalization after each residual block to control activation scales Depthwise separable convolutions to maintain receptive field while reducing parameters Causal convolutions with 20ms latency for real-time streaming Distortion-Free Discriminator Traditional waveform discriminators introduce spectral distortions by prioritizing time-domain accuracy. HILCodec's discriminator uses parallel filter banks analyzing different frequency bands, ensuring artifact-free reconstructions across the audible spectrum. HILCodec's Distortion-Free Discriminator. Source: [3] Results HILCodec matches or outperforms both traditional and leading neural codecs (like SoundStream, EnCodec, and HiFi-Codec) in subjective and objective tests, across various audio types (speech, music, environmental sounds) and bitrates (1.5\u20139 kbps). It achieves this with: Lower computational complexity : Real-time on a single CPU thread Superior or comparable perceptual quality : Especially at very low bitrates Streamable design : Suitable for live audio and embedded applications HILCodec Performance Results. Source: [3] SNAC: Multi-Scale Neural Audio Codec SNAC (Multi-Scale Neural Audio Codec), introduced in 2024, extends the Residual Vector Quantization (RVQ) framework by introducing quantization at different temporal resolutions, enabling more efficient compression through multi-scale discrete audio representations [4]. RVQ Multi-Scale Quantization. Source: [4] Key Innovations Multi-Scale Residual Vector Quantization : Unlike traditional RVQ approaches that operate at a fixed temporal resolution, SNAC employs a hierarchy of quantizers operating at multiple temporal resolutions. At each quantization iteration, the residuals are downsampled by a factor \\(W_i\\) , quantized, and then upsampled back to match the original temporal resolution. This multi-scale approach allows the codec to capture both coarse and fine audio details more efficiently: Coarse temporal structure (like prosody and semantic patterns) is captured at lower frame rates Fine acoustic details are preserved at higher frame rates This hierarchical organization aligns with how human auditory cortex processes acoustic signals Noise Block : After each upsampling layer, SNAC introduces a Noise Block that adds input-dependent stochasticity. The block updates activations as: \\[ \\mathbf{x} \\leftarrow \\mathbf{x} + \\text{Linear}(\\mathbf{x}) \\odot {\\epsilon}, \\text{where } \\epsilon \\sim \\mathcal{N}(0,1) \\text{ is Gaussian noise.} \\] This mechanism enhances decoder expressiveness, improves reconstruction quality, and leads to better codebook utilization. Depthwise Convolution : SNAC incorporates depthwise separable convolutions in the generator to reduce parameters and stabilize training. This is particularly beneficial for GAN-based vocoders, which are notoriously unstable during training. Local Windowed Attention : The model uses local windowed attention mechanisms, enabling efficient processing of longer audio sequences while maintaining computational efficiency. Architectural Design SNAC builds upon the RVQGAN framework, maintaining the encoder-decoder structure with a cascade of vector quantization layers. The key difference lies in the multi-scale quantization strategy: instead of quantizing all residuals at the same temporal resolution, SNAC applies a hierarchy of quantizers with variable frame rates. Average pooling is used for downsampling, while nearest-neighbor interpolation handles upsampling to restore the original temporal resolution. Results SNAC demonstrates superior compression efficiency compared to existing neural audio codecs: Speech Performance: At 0.98 kbps, SNAC achieves a MUSHRA score of \\(88.4 \\pm 2.6\\) , outperforming EnCodec at 1.5 kbps ( \\(39.1 \\pm 3.0\\) ) and DAC at 0.8 kbps ( \\(33.0 \\pm 4.4\\) ) Achieves competitive ViSQOL (4.14) and SI-SDR (0.82) scores even at ultra-low bitrates Lower Mel-spectrogram and STFT reconstruction errors compared to EnCodec at similar bitrates Music Performance: At 1.9 kbps, achieves MUSHRA score of \\(77.9 \\pm 4.3\\) , competitive with DAC at 2.5 kbps ( \\(54.0 \\pm 6.0\\) ) At 2.6 kbps, achieves MUSHRA score of \\(76.8 \\pm 4.6\\) with ViSQOL of 4.04 and SI-SDR of 5.17 Demonstrates effective handling of musical structures across multiple timescales The multi-scale approach enables SNAC to achieve better quality at lower bitrates by adapting to audio structure across multiple temporal resolutions, making it particularly effective for capturing both local acoustic details and long-term patterns in speech and music. SNAC Performance Results. Source: [4] Code Let's walk through a hands-on example to see how to use one of these neural audio codecs in practice. Here, we will use EnCodec [2], but the fundamental steps are similar for other codecs like SoundStream or HILCodec. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # Load the required packages from audiotools import AudioSignal from transformers import EncodecModel , AutoProcessor # Step 1: load the EnCodec model and processor model = EncodecModel . from_pretrained ( \"facebook/encodec_24khz\" ) processor = AutoProcessor . from_pretrained ( \"facebook/encodec_24khz\" ) # Note: you can also use \"facebook/encodec_48khz\" for higher sampling rates # Step 2: load an audio file audio_file = \"samples/neural_codec_input.wav\" # replace with your audio file path audio = AudioSignal ( audio_file ) audio = audio . resample ( 24000 ) # resample to 24kHz audio = audio . to_mono () # convert to mono frame_rate = audio . sample_rate # get the sample rate audio_sample = audio . audio_data . reshape ( - 1 ) # get the reshaped audio samples # Step 3: Preprocess the audio inputs = processor ( raw_audio = audio_sample , sampling_rate = frame_rate , return_tensors = \"pt\" ) # Step 4: Encode the audio encoder_outputs = model . encode ( inputs [ \"input_values\" ], inputs [ \"padding_mask\" ]) # Step 5: Decode the audio audio_values = model . decode ( encoder_outputs . audio_codes , encoder_outputs . audio_scales , inputs [ \"padding_mask\" ])[ 0 ] # OR replace Step 4 and 5: Forward pass on the input audio_values = model ( inputs [ \"input_values\" ], inputs [ \"padding_mask\" ]) . audio_values Let's go through the important code steps: Load the EnCodec Model and Processor We use the facebook/encodec_24khz model, optimized for 24 kHz audio. The processor handles audio preprocessing, including splitting audio for batch operations and creating the padding_mask , that indicates which positions in the input are real audio (1) and which are padding (0) to be ignored by the model. Hint You can also use facebook/encodec_48khz for higher sampling rates, but in this example, we will stick to 24 kHz for simplicity. Loading the Audio We load an audio file, resample it to 24 kHz, and convert it to mono. The audio data is reshaped into a 1D array for processing. In this example, we use a sample audio file named neural_codec_input.wav (listen to it below) that is 10 seconds long and after resampling, has the shape of torch.Size([240000]) and looks like tensor([0.0088, 0.0117, 0.0194, ..., 0.0390, 0.0460, 0.0213]) Original Audio: Your browser does not support the audio element. Preprocessing the Audio The audio is processed using the EnCodec processor, which prepares it for encoding by creating input tensors and a padding mask. The padding mask is crucial for handling variable-length audio inputs, ensuring that the model only processes valid audio samples. The inputs looks like {'input_values': tensor([[ 0.0088, 0.0117, 0.0194, ..., 0.0390, 0.0460, 0.0213]]), 'padding_mask': tensor([[1, 1, 1, ..., 1, 1, 1]])} . If you notice, the input_values tensor contains the audio samples exactly as we have loaded, and the padding_mask indicates that all positions are valid (1) since we have a single audio sample without padding. Encoding the Audio The encode method processes the input audio, producing quantized latent representations ( audio_codes ) and scales for decoding. This step compresses the audio into a more compact form. One important aspect here is the bandwidth - this is how much data the compressed audio will use per second. Lower bandwidth means smaller files but lower audio quality; higher bandwidth means better quality but larger files. Bandwidth is correlated to the codebooks used in the quantization step, the relation is shown below, (for Encodec 24kHz model) : Bandwidth (kbps) Number of Codebooks (n_q) 1.5 2 3 4 6 8 12 16 24 32 So, bandwidth = 1.5 will use 2 codebooks, while bandwidth = 24 will use 32 codebooks. The number of codebooks directly affects the quality and size of the compressed audio. If we try with bandwidth = 1.5 , the audio_codes will have shape torch.Size([1, 1, 2, 750]) and looks like tensor([[[[727, 407, 906, ..., 561, 424, 925], [946, 734, 949, ..., 673, 769, 987]]]]) But in case of bandwidth = 24 , the audio_codes will have shape torch.Size([1, 1, 32, 750]) and looks like tensor([[[[ 727, 407, 906, ..., 561, 424, 925], [ 946, 734, 949, ..., 673, 769, 987], [ 988, 21, 623, ..., 870, 1023, 452], ..., [ 792, 792, 220, ..., 419, 1011, 422], [ 502, 550, 893, ..., 328, 832, 450], [ 681, 906, 872, ..., 820, 601, 658]]]]) Hint If you're wondering how bandwidth relates to the number of codebooks in EnCodec, here's how it works: The encoder produces 75 steps per second of audio (i.e. 750 steps for a 10-second clip) per codebook ( N_q ). For example, with bandwidth = 1.5 , there are 2 codebooks, so you get a total of 2 \u00d7 75 = 150 codes per second. Now, in EnCodec, each codebook has 1024 unique entries which can be represented by 10bit id (as \\(log_2(1024) = 10\\) ). So, the total number of bits per second is 150 (steps) * 10 (id) = 1500 bits/s which corresponds to 1.5 kbps. Similarly, with bandwidth = 24 , there are 32 codebooks, resulting in 32 \u00d7 75 = 2400 codes, or 2400*10 = 24000 bits/s which corresponds to 24 kbps. Note SNAC uses a similar approach, but with a multi-scale quantization strategy, where the quantization is done at different temporal resolutions which results in token rates of 12Hz, ~24Hz and ~48Hz. This means the shape of the quantized audio (24 kHz Speech model) follows the shape of (12 * seconds, 24 * seconds, 48 * seconds). Example: for a 10 second audio, the shape will be ~(120, 240, 480). Notice one thing, an audio of 10 seconds that used 240k samples is now compressed into (N_q, 750) where N_q is the number of codebooks used. For bandwidth = 1.5 , the shape is (2, 750) and the compression ratio is 160x and for bandwidth = 24 , the shape is (32, 750) and the compression ratio is 10x! Quite impressive, right? Decoding the Audio The decode method reconstructs the audio from the quantized codes and scales. The output is a tensor of audio samples, which can be saved as a WAV file or played directly. The shape of the output audio tensor will be (1, 240000) for 10 seconds of audio at 24 kHz. If you play the audio file neural_codec_input.wav , you will hear the original audio. After running the code, you can listen to the output generated by EnCodec. Both are presented below, Original Audio: (48KHz) Your browser does not support the audio element. Encodec Output: (24KHz; Bandwidth: 1.5 kbps) Your browser does not support the audio element. Encodec Output: (24KHz; Bandwidth: 24 kbps) Your browser does not support the audio element. As you can hear, while there are some distortions, the output is audible and is able to maintain the speech of the original audio. This demonstrates the effectiveness of neural codecs in audio compression. Comparative Analysis The evolution of neural codecs reveals several key trends: Characteristic SoundStream[1] EnCodec[2] HILCodec[3] SNAC[4] Max Sampling Rate 24 kHz 48 kHz 24 kHz 44.1 kHz Real-Time Streaming Yes Yes Yes Yes Model Size (Params) 18M 32M 9M 54.5M Music Handling Moderate Excellent Excellent Excellent Quantization Scheme RVQ (8-32 dim) RVQ (32 dim) RVQ (64 dim) Multi-Scale RVQ Challenges and Future Directions While neural codecs demonstrate remarkable capabilities, several open challenges remain: Computational Complexity : Even lightweight models like HILCodec require 1-2 GFLOPS, posing deployment challenges on ultra-low-power devices. Generalization : Most models are trained on specific audio types (speech/music), struggling with uncommon sounds like ultrasonic frequencies or simultaneous overlapping sources. Standardization : Unlike traditional codecs with well-defined bitstream formats, neural codecs lack interoperability standards, hindering widespread adoption. Emerging research directions include: Few-shot Adaptation : Allowing codecs to dynamically adjust to new speaker voices or musical instruments without retraining Neural Post-Processing : Combining traditional codecs with neural enhancers for backward compatibility Energy-Efficient Architectures : Exploring sparsity and quantization-aware training for edge deployment Conclusion Neural audio codecs represent a paradigm shift in audio compression, offering unprecedented quality/bitrate ratios through data-driven learning. From SoundStream's foundational architecture to HILCodec's efficient streaming design, and SNAC's multi-scale quantization approach, each iteration brings us closer to practical applications in telecommunication, media streaming, and immersive audio. As research addresses current limitations in complexity and generalization, these AI-powered codecs are poised to become the new standard for audio compression across industries. References [1] SoundStream: An End-to-End Neural Audio Codec - Paper | Video [2] EnCodec: High Fidelity Neural Audio Compression - Paper | Code [3] HILCodec: High Fidelity and Lightweight Neural Audio Codec [4] SNAC: Multi-Scale Neural Audio Codec - Paper | Code","title":"Neural Audio Codecs"},{"location":"audio_intelligence/neural_audio_codecs/#neural-audio-codecs","text":"","title":"Neural Audio Codecs"},{"location":"audio_intelligence/neural_audio_codecs/#introduction","text":"Neural audio codecs are a new generation of audio compression tools powered by deep learning. Unlike traditional codecs, which rely on hand-crafted signal processing, neural codecs learn to compress and reconstruct audio directly from data, achieving much higher quality at lower bitrates. In this guide, we\u2019ll explore three leading neural audio codecs\u2014SoundStream, EnCodec, and HILCodec\u2014highlighting what makes each unique. You\u2019ll also find practical code examples showing how to use neural audio codecs to compress and reconstruct audio, so you can experience their capabilities firsthand.","title":"Introduction"},{"location":"audio_intelligence/neural_audio_codecs/#traditional-audio-codecs","text":"Traditional audio codecs rely on signal processing techniques rooted in psychoacoustic models, which discard imperceptible audio components to reduce file sizes. Traditional audio codecs fall into two main camps,","title":"Traditional Audio Codecs"},{"location":"audio_intelligence/neural_audio_codecs/#waveform-codecs","text":"Goal: Reproduce the original audio as closely as possible, sample by sample. How They Work: They take the audio signal (which is a waveform in the time domain) and convert it into another form, usually the time-frequency domain, using a mathematical process called a transform . After transformation, they compress the data by quantizing (rounding off) the numbers and encoding them efficiently. When you want to listen to the audio, the codec reverses the process to get back to the time-domain waveform. Features: They don't make many assumptions about what kind of audio they're compressing, so they work for all types of sounds\u2014music, speech, noise, etc. They sound great at medium to high bitrates (more data per second), but at low bitrates (less data), you might hear strange artifacts or loss of quality. Examples: MP3, Opus, AAC.","title":"Waveform Codecs"},{"location":"audio_intelligence/neural_audio_codecs/#parametric-codecs","text":"Goal: Reproduce audio that sounds like the original, even if it's not identical sample by sample. How They Work: They assume the audio is of a specific type (usually speech). Instead of saving the whole waveform, they analyze the audio and extract important features or parameters (like pitch, tone, speed). Only these parameters are compressed and sent. The decoder then uses a model to synthesize (recreate) the audio using the parameters. Features: They are very efficient at low bitrates and can produce understandable speech with very little data. They don't try to perfectly recreate every detail, just make the audio sound similar to the original to our ears. They usually work best for speech and may not be suitable for music or complex sounds. Examples: Some VoIP codecs, like EVS or MELP. Both approaches rely on hand-crafted signal processing pipelines, which limit their flexibility and performance\u2014especially as we demand better quality at lower bitrates, and for more diverse content (music, ambient sounds, etc.). Did you know? The Opus codec, standardized in 2012, is the audio engine behind popular apps like Zoom, Microsoft Teams, Google Meet, and even YouTube streaming! Its widespread adoption means that hundreds of millions of people use Opus every day\u2014often without even realizing it. Meanwhile, the Enhanced Voice Services (EVS) codec, designed for Voice over LTE (VoLTE), is taking over as the new standard for mobile calls, offering improved quality and full compatibility with older systems.","title":"Parametric Codecs"},{"location":"audio_intelligence/neural_audio_codecs/#neural-audio-codecs_1","text":"Neural audio codecs use deep learning to learn efficient, perceptually meaningful representations of audio directly from data. This opens the door to higher quality, lower bitrates, and new features like joint enhancement and compression. These systems typically consist of three components: An encoder that converts raw audio into a compressed latent representation. A quantizer that maps continuous latent vectors to discrete symbols for efficient storage/transmission. A decoder that reconstructs audio from the quantized representation. Neural Audio Codecs Architecture The key advantage lies in their end-to-end training process, where all components are optimized jointly to minimize perceptual differences between original and reconstructed audio. This data-driven approach allows neural codecs to adapt to complex audio patterns that challenge rule-based systems, particularly at ultra-low bitrates (<6 kbps).","title":"Neural Audio Codecs"},{"location":"audio_intelligence/neural_audio_codecs/#soundstream-end-to-end-neural-audio-coding","text":"SoundStream is a fully end-to-end neural audio codec that can compress speech, music, and general audio at bitrates as low as 3 kbps\u2014outperforming traditional codecs at much higher bitrates.","title":"SoundStream: End-to-End Neural Audio Coding"},{"location":"audio_intelligence/neural_audio_codecs/#key-innovations","text":"End-to-End Training: The entire pipeline\u2014encoder, quantizer, and decoder\u2014is trained jointly, optimizing for both reconstruction accuracy and perceptual quality via adversarial losses. Residual Vector Quantization (RVQ): Instead of a single quantization step, SoundStream uses a multi-stage (residual) vector quantizer. This allows it to represent audio more efficiently and enables bitrate scalability. Bitrate Scalability: Thanks to a novel \"quantizer dropout\" during training, a single SoundStream model can operate at different bitrates (3\u201318 kbps) with minimal quality loss. Low Latency & Real-Time: The model is fully convolutional and causal, making it suitable for low-latency, real-time applications\u2014even on a smartphone CPU. Joint Compression and Enhancement: SoundStream can simultaneously compress and enhance audio (e.g., denoise speech) with no extra latency. SoundStream Architecture. Source: [1]","title":"Key Innovations"},{"location":"audio_intelligence/neural_audio_codecs/#architectural-design","text":"The system uses a fully convolutional U-Net structure with strided convolutions for downsampling and transposed convolutions for upsampling. A residual vector quantizer (RVQ) between encoder and decoder discretizes the latent space while maintaining reconstruction fidelity. Crucially, SoundStream introduced structured dropout during training, enabling a single model to operate across multiple bitrates (3-18 kbps) without quality degradation. SoundStream Encoder-Decoder Architecture. Source: [1]","title":"Architectural Design"},{"location":"audio_intelligence/neural_audio_codecs/#training-methodology","text":"SoundStream combines adversarial training with multi-resolution spectral losses: A GAN discriminator distinguishes real/fake audio samples, forcing the decoder to generate perceptually convincing outputs. Multi-scale spectrogram losses ensure accurate frequency domain reconstruction. Feature matching losses align intermediate layer activations between original and reconstructed audio. SoundStream Discriminator Architecture. Source: [1]","title":"Training Methodology"},{"location":"audio_intelligence/neural_audio_codecs/#results","text":"The results are impressive: At 3 kbps, SoundStream outperforms Opus at 12 kbps and approaches the quality of EVS at 9.6 kbps. It works for speech, music, and general audio\u2014not just speech. Subjective tests (MUSHRA) show that listeners prefer SoundStream's output at low bitrates over traditional codecs. SoundStream Performance Results. Source: [1]","title":"Results"},{"location":"audio_intelligence/neural_audio_codecs/#encodec-high-fidelity-neural-compression","text":"Meta's EnCodec (2022) builds on SoundStream's foundation while addressing scalability and stability challenges. EnCodec Architecture. Source: [2]","title":"EnCodec: High-Fidelity Neural Compression"},{"location":"audio_intelligence/neural_audio_codecs/#key-innovations_1","text":"Spectrogram Adversary : EnCodec replaces SoundStream's waveform discriminator with a multi-scale spectrogram discriminator , which analyzes audio at different time-frequency resolutions. This modification: Reduces artifacts caused by phase inconsistencies in waveform-based GANs Improves training stability through better gradient signals Enables effective handling of stereo audio at 48 kHz sampling rates EnCodec's Multi-scale Spectrogram Discriminator. Source: [2] Loss Balancing Mechanism : The authors introduced a gradient-balancing technique that dynamically adjusts loss weights based on their contribution to the total gradient magnitude. This innovation decouples hyperparameter tuning from loss function scales, significantly simplifying training. Latent Space Compression : EnCodec demonstrates how lightweight Transformer models can further compress the quantized latent representation by 40%, enabling variable-rate compression without retraining. Subjective evaluations show EnCodec outperforming EVS at 16.4 kbps while operating at 9 kbps, with particularly strong performance on music and noisy speech.","title":"Key Innovations"},{"location":"audio_intelligence/neural_audio_codecs/#results_1","text":"EnCodec was rigorously evaluated across a range of bitrates and content types (speech, music, noisy and reverberant speech). Key findings include: Superior Quality: At all tested bitrates (1.5, 3, 6, 12 kbps for 24 kHz; 6, 12, 24 kbps for 48 kHz), EnCodec outperformed traditional codecs and previous neural models in both objective and subjective (MUSHRA) tests. Versatility: Works seamlessly for both speech and music, and robustly handles challenging conditions like noise and reverberation. Efficiency: Achieves real-time encoding and decoding on a single CPU core, making it practical for large-scale deployment. EnCodec Performance Results. Source: [2]","title":"Results"},{"location":"audio_intelligence/neural_audio_codecs/#hilcodec-lightweight-and-efficient-streaming","text":"The 2024 HILCodec paper addresses critical limitations in prior neural codecs\u2014model complexity and streaming efficiency [3]. HILCodec Architecture. Source: [3]","title":"HILCodec: Lightweight and Efficient Streaming"},{"location":"audio_intelligence/neural_audio_codecs/#key-innovations_2","text":"Variance-Constrained Wave-U-Net Through theoretical analysis, the authors identified that standard Wave-U-Net architectures suffer from exponential variance growth in deeper layers, leading to unstable training and performance degradation. HILCodec introduces: L2-normalization after each residual block to control activation scales Depthwise separable convolutions to maintain receptive field while reducing parameters Causal convolutions with 20ms latency for real-time streaming Distortion-Free Discriminator Traditional waveform discriminators introduce spectral distortions by prioritizing time-domain accuracy. HILCodec's discriminator uses parallel filter banks analyzing different frequency bands, ensuring artifact-free reconstructions across the audible spectrum. HILCodec's Distortion-Free Discriminator. Source: [3]","title":"Key Innovations"},{"location":"audio_intelligence/neural_audio_codecs/#results_2","text":"HILCodec matches or outperforms both traditional and leading neural codecs (like SoundStream, EnCodec, and HiFi-Codec) in subjective and objective tests, across various audio types (speech, music, environmental sounds) and bitrates (1.5\u20139 kbps). It achieves this with: Lower computational complexity : Real-time on a single CPU thread Superior or comparable perceptual quality : Especially at very low bitrates Streamable design : Suitable for live audio and embedded applications HILCodec Performance Results. Source: [3]","title":"Results"},{"location":"audio_intelligence/neural_audio_codecs/#snac-multi-scale-neural-audio-codec","text":"SNAC (Multi-Scale Neural Audio Codec), introduced in 2024, extends the Residual Vector Quantization (RVQ) framework by introducing quantization at different temporal resolutions, enabling more efficient compression through multi-scale discrete audio representations [4]. RVQ Multi-Scale Quantization. Source: [4]","title":"SNAC: Multi-Scale Neural Audio Codec"},{"location":"audio_intelligence/neural_audio_codecs/#key-innovations_3","text":"Multi-Scale Residual Vector Quantization : Unlike traditional RVQ approaches that operate at a fixed temporal resolution, SNAC employs a hierarchy of quantizers operating at multiple temporal resolutions. At each quantization iteration, the residuals are downsampled by a factor \\(W_i\\) , quantized, and then upsampled back to match the original temporal resolution. This multi-scale approach allows the codec to capture both coarse and fine audio details more efficiently: Coarse temporal structure (like prosody and semantic patterns) is captured at lower frame rates Fine acoustic details are preserved at higher frame rates This hierarchical organization aligns with how human auditory cortex processes acoustic signals Noise Block : After each upsampling layer, SNAC introduces a Noise Block that adds input-dependent stochasticity. The block updates activations as: \\[ \\mathbf{x} \\leftarrow \\mathbf{x} + \\text{Linear}(\\mathbf{x}) \\odot {\\epsilon}, \\text{where } \\epsilon \\sim \\mathcal{N}(0,1) \\text{ is Gaussian noise.} \\] This mechanism enhances decoder expressiveness, improves reconstruction quality, and leads to better codebook utilization. Depthwise Convolution : SNAC incorporates depthwise separable convolutions in the generator to reduce parameters and stabilize training. This is particularly beneficial for GAN-based vocoders, which are notoriously unstable during training. Local Windowed Attention : The model uses local windowed attention mechanisms, enabling efficient processing of longer audio sequences while maintaining computational efficiency.","title":"Key Innovations"},{"location":"audio_intelligence/neural_audio_codecs/#architectural-design_1","text":"SNAC builds upon the RVQGAN framework, maintaining the encoder-decoder structure with a cascade of vector quantization layers. The key difference lies in the multi-scale quantization strategy: instead of quantizing all residuals at the same temporal resolution, SNAC applies a hierarchy of quantizers with variable frame rates. Average pooling is used for downsampling, while nearest-neighbor interpolation handles upsampling to restore the original temporal resolution.","title":"Architectural Design"},{"location":"audio_intelligence/neural_audio_codecs/#results_3","text":"SNAC demonstrates superior compression efficiency compared to existing neural audio codecs: Speech Performance: At 0.98 kbps, SNAC achieves a MUSHRA score of \\(88.4 \\pm 2.6\\) , outperforming EnCodec at 1.5 kbps ( \\(39.1 \\pm 3.0\\) ) and DAC at 0.8 kbps ( \\(33.0 \\pm 4.4\\) ) Achieves competitive ViSQOL (4.14) and SI-SDR (0.82) scores even at ultra-low bitrates Lower Mel-spectrogram and STFT reconstruction errors compared to EnCodec at similar bitrates Music Performance: At 1.9 kbps, achieves MUSHRA score of \\(77.9 \\pm 4.3\\) , competitive with DAC at 2.5 kbps ( \\(54.0 \\pm 6.0\\) ) At 2.6 kbps, achieves MUSHRA score of \\(76.8 \\pm 4.6\\) with ViSQOL of 4.04 and SI-SDR of 5.17 Demonstrates effective handling of musical structures across multiple timescales The multi-scale approach enables SNAC to achieve better quality at lower bitrates by adapting to audio structure across multiple temporal resolutions, making it particularly effective for capturing both local acoustic details and long-term patterns in speech and music. SNAC Performance Results. Source: [4]","title":"Results"},{"location":"audio_intelligence/neural_audio_codecs/#code","text":"Let's walk through a hands-on example to see how to use one of these neural audio codecs in practice. Here, we will use EnCodec [2], but the fundamental steps are similar for other codecs like SoundStream or HILCodec. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # Load the required packages from audiotools import AudioSignal from transformers import EncodecModel , AutoProcessor # Step 1: load the EnCodec model and processor model = EncodecModel . from_pretrained ( \"facebook/encodec_24khz\" ) processor = AutoProcessor . from_pretrained ( \"facebook/encodec_24khz\" ) # Note: you can also use \"facebook/encodec_48khz\" for higher sampling rates # Step 2: load an audio file audio_file = \"samples/neural_codec_input.wav\" # replace with your audio file path audio = AudioSignal ( audio_file ) audio = audio . resample ( 24000 ) # resample to 24kHz audio = audio . to_mono () # convert to mono frame_rate = audio . sample_rate # get the sample rate audio_sample = audio . audio_data . reshape ( - 1 ) # get the reshaped audio samples # Step 3: Preprocess the audio inputs = processor ( raw_audio = audio_sample , sampling_rate = frame_rate , return_tensors = \"pt\" ) # Step 4: Encode the audio encoder_outputs = model . encode ( inputs [ \"input_values\" ], inputs [ \"padding_mask\" ]) # Step 5: Decode the audio audio_values = model . decode ( encoder_outputs . audio_codes , encoder_outputs . audio_scales , inputs [ \"padding_mask\" ])[ 0 ] # OR replace Step 4 and 5: Forward pass on the input audio_values = model ( inputs [ \"input_values\" ], inputs [ \"padding_mask\" ]) . audio_values Let's go through the important code steps:","title":"Code"},{"location":"audio_intelligence/neural_audio_codecs/#load-the-encodec-model-and-processor","text":"We use the facebook/encodec_24khz model, optimized for 24 kHz audio. The processor handles audio preprocessing, including splitting audio for batch operations and creating the padding_mask , that indicates which positions in the input are real audio (1) and which are padding (0) to be ignored by the model. Hint You can also use facebook/encodec_48khz for higher sampling rates, but in this example, we will stick to 24 kHz for simplicity.","title":"Load the EnCodec Model and Processor"},{"location":"audio_intelligence/neural_audio_codecs/#loading-the-audio","text":"We load an audio file, resample it to 24 kHz, and convert it to mono. The audio data is reshaped into a 1D array for processing. In this example, we use a sample audio file named neural_codec_input.wav (listen to it below) that is 10 seconds long and after resampling, has the shape of torch.Size([240000]) and looks like tensor([0.0088, 0.0117, 0.0194, ..., 0.0390, 0.0460, 0.0213]) Original Audio: Your browser does not support the audio element.","title":"Loading the Audio"},{"location":"audio_intelligence/neural_audio_codecs/#preprocessing-the-audio","text":"The audio is processed using the EnCodec processor, which prepares it for encoding by creating input tensors and a padding mask. The padding mask is crucial for handling variable-length audio inputs, ensuring that the model only processes valid audio samples. The inputs looks like {'input_values': tensor([[ 0.0088, 0.0117, 0.0194, ..., 0.0390, 0.0460, 0.0213]]), 'padding_mask': tensor([[1, 1, 1, ..., 1, 1, 1]])} . If you notice, the input_values tensor contains the audio samples exactly as we have loaded, and the padding_mask indicates that all positions are valid (1) since we have a single audio sample without padding.","title":"Preprocessing the Audio"},{"location":"audio_intelligence/neural_audio_codecs/#encoding-the-audio","text":"The encode method processes the input audio, producing quantized latent representations ( audio_codes ) and scales for decoding. This step compresses the audio into a more compact form. One important aspect here is the bandwidth - this is how much data the compressed audio will use per second. Lower bandwidth means smaller files but lower audio quality; higher bandwidth means better quality but larger files. Bandwidth is correlated to the codebooks used in the quantization step, the relation is shown below, (for Encodec 24kHz model) : Bandwidth (kbps) Number of Codebooks (n_q) 1.5 2 3 4 6 8 12 16 24 32 So, bandwidth = 1.5 will use 2 codebooks, while bandwidth = 24 will use 32 codebooks. The number of codebooks directly affects the quality and size of the compressed audio. If we try with bandwidth = 1.5 , the audio_codes will have shape torch.Size([1, 1, 2, 750]) and looks like tensor([[[[727, 407, 906, ..., 561, 424, 925], [946, 734, 949, ..., 673, 769, 987]]]]) But in case of bandwidth = 24 , the audio_codes will have shape torch.Size([1, 1, 32, 750]) and looks like tensor([[[[ 727, 407, 906, ..., 561, 424, 925], [ 946, 734, 949, ..., 673, 769, 987], [ 988, 21, 623, ..., 870, 1023, 452], ..., [ 792, 792, 220, ..., 419, 1011, 422], [ 502, 550, 893, ..., 328, 832, 450], [ 681, 906, 872, ..., 820, 601, 658]]]]) Hint If you're wondering how bandwidth relates to the number of codebooks in EnCodec, here's how it works: The encoder produces 75 steps per second of audio (i.e. 750 steps for a 10-second clip) per codebook ( N_q ). For example, with bandwidth = 1.5 , there are 2 codebooks, so you get a total of 2 \u00d7 75 = 150 codes per second. Now, in EnCodec, each codebook has 1024 unique entries which can be represented by 10bit id (as \\(log_2(1024) = 10\\) ). So, the total number of bits per second is 150 (steps) * 10 (id) = 1500 bits/s which corresponds to 1.5 kbps. Similarly, with bandwidth = 24 , there are 32 codebooks, resulting in 32 \u00d7 75 = 2400 codes, or 2400*10 = 24000 bits/s which corresponds to 24 kbps. Note SNAC uses a similar approach, but with a multi-scale quantization strategy, where the quantization is done at different temporal resolutions which results in token rates of 12Hz, ~24Hz and ~48Hz. This means the shape of the quantized audio (24 kHz Speech model) follows the shape of (12 * seconds, 24 * seconds, 48 * seconds). Example: for a 10 second audio, the shape will be ~(120, 240, 480). Notice one thing, an audio of 10 seconds that used 240k samples is now compressed into (N_q, 750) where N_q is the number of codebooks used. For bandwidth = 1.5 , the shape is (2, 750) and the compression ratio is 160x and for bandwidth = 24 , the shape is (32, 750) and the compression ratio is 10x! Quite impressive, right?","title":"Encoding the Audio"},{"location":"audio_intelligence/neural_audio_codecs/#decoding-the-audio","text":"The decode method reconstructs the audio from the quantized codes and scales. The output is a tensor of audio samples, which can be saved as a WAV file or played directly. The shape of the output audio tensor will be (1, 240000) for 10 seconds of audio at 24 kHz. If you play the audio file neural_codec_input.wav , you will hear the original audio. After running the code, you can listen to the output generated by EnCodec. Both are presented below, Original Audio: (48KHz) Your browser does not support the audio element. Encodec Output: (24KHz; Bandwidth: 1.5 kbps) Your browser does not support the audio element. Encodec Output: (24KHz; Bandwidth: 24 kbps) Your browser does not support the audio element. As you can hear, while there are some distortions, the output is audible and is able to maintain the speech of the original audio. This demonstrates the effectiveness of neural codecs in audio compression.","title":"Decoding the Audio"},{"location":"audio_intelligence/neural_audio_codecs/#comparative-analysis","text":"The evolution of neural codecs reveals several key trends: Characteristic SoundStream[1] EnCodec[2] HILCodec[3] SNAC[4] Max Sampling Rate 24 kHz 48 kHz 24 kHz 44.1 kHz Real-Time Streaming Yes Yes Yes Yes Model Size (Params) 18M 32M 9M 54.5M Music Handling Moderate Excellent Excellent Excellent Quantization Scheme RVQ (8-32 dim) RVQ (32 dim) RVQ (64 dim) Multi-Scale RVQ","title":"Comparative Analysis"},{"location":"audio_intelligence/neural_audio_codecs/#challenges-and-future-directions","text":"While neural codecs demonstrate remarkable capabilities, several open challenges remain: Computational Complexity : Even lightweight models like HILCodec require 1-2 GFLOPS, posing deployment challenges on ultra-low-power devices. Generalization : Most models are trained on specific audio types (speech/music), struggling with uncommon sounds like ultrasonic frequencies or simultaneous overlapping sources. Standardization : Unlike traditional codecs with well-defined bitstream formats, neural codecs lack interoperability standards, hindering widespread adoption. Emerging research directions include: Few-shot Adaptation : Allowing codecs to dynamically adjust to new speaker voices or musical instruments without retraining Neural Post-Processing : Combining traditional codecs with neural enhancers for backward compatibility Energy-Efficient Architectures : Exploring sparsity and quantization-aware training for edge deployment","title":"Challenges and Future Directions"},{"location":"audio_intelligence/neural_audio_codecs/#conclusion","text":"Neural audio codecs represent a paradigm shift in audio compression, offering unprecedented quality/bitrate ratios through data-driven learning. From SoundStream's foundational architecture to HILCodec's efficient streaming design, and SNAC's multi-scale quantization approach, each iteration brings us closer to practical applications in telecommunication, media streaming, and immersive audio. As research addresses current limitations in complexity and generalization, these AI-powered codecs are poised to become the new standard for audio compression across industries.","title":"Conclusion"},{"location":"audio_intelligence/neural_audio_codecs/#references","text":"[1] SoundStream: An End-to-End Neural Audio Codec - Paper | Video [2] EnCodec: High Fidelity Neural Audio Compression - Paper | Code [3] HILCodec: High Fidelity and Lightweight Neural Audio Codec [4] SNAC: Multi-Scale Neural Audio Codec - Paper | Code","title":"References"},{"location":"audio_intelligence/speaker_diarization/","text":"Introduction Speaker Diarization is the process of segregating different speakers from an audio stream. It is used to answer the question \"who spoke when?\". So if the input is a audio stream with 5 speakers, the output will contain the timestamp in audio when different speakers spoke. A sample output for a conversation between 3 people (differers) could be, start=0.2s stop=1.5s speaker_A start=1.8s stop=3.9s speaker_B start=4.2s stop=5.7s speaker_A start=6.2s stop=7.8s speaker_C ... Note In speaker diarization we separate the speakers (cluster) and not identify them (classify). Hence the output contains anonymous identifiers like speaker_A , speaker_B , etc and not the actual names of the persons. Traditional Diarization Approach The generic approach for Speaker Diarization [1] Traditional Speaker Diarization systems can be generalised into a 5 step process. These are, Feature extraction : here we transform the raw waveform into audio features like mel spectrogram. Voice activity detection : here we identify the chunks in the audio where some voice activity was observed. As we are not interested in silence and noise, we ignore those irrelevant chunks. Speaker change detection : here we identify the speaker changepoints in the conversation present in the audio. It is either capture by heuristic approach, classical algorithms or modern neural blocks. It will further divide the chunks from last step into subchunks. Speech turn representation : here we encode each subchunk by creating feature representations. Recent trends gives preference to neural approach where subchunks are encoded into context aware vector representation. Hint We can use any audio representation algorithm or model for this task. Recently d or x vectors are preferred. One example using speechbrain package is 1 2 3 4 5 6 7 # import import torch from speechbrain.pretrained import EncoderClassifier # load the model encoder = EncoderClassifier . from_hparams ( source = \"speechbrain/spkrec-ecapa-voxceleb\" ) # encode the audio chunk embedding = encoder . encode_batch ( torch . from_numpy ( chunk )) Speech turn clustering : here we cluster the subchunks based on their vector representation. Different clustering algorithms could be applied based on availability of cluster count ( k ) and embedding process of the previous step. Hint While Kmeans is the defacto clustering algorithm, it might create some problems if we use it for speaker diarization. Here are a few problem cases mentioned in [5] Non-gaussian data: speech data are often non-gaussian Imbalanced data: one person may speak more than the other Gender/Age/Racial effects: inter-gender difference is large but intra-gender differences are small. Overlapping speech: overlapping speech creates connections between clusters Kmeans algorithms will not be able to handle these issues of the audio data and will perform incorrect clustering. Hence we can use Spectral Clustering that can overcome all of the mentioned issues! The final output will be the clusters of different subchunks from the audio stream. Each cluster can be given an anonymous identifier (speaker_a, ..) and then it can be mapped with the audio stream to create the speaker aware audio timeline. Metrics Diarization Error Rate (DER) Diarization error rate (DER) provides an estimation (O is good, higher is bad; max may exceed 100%) of diarization performance by calculating the sum of following individual metrics, [2] Speaker error: percentage of scored time for which the wrong speaker id is assigned within a speech region False alarm speech: percentage of scored time for which a nonspeech region is incorrectly marked as containing speech Missed speech: percentage of scored time for which a speech region is incorrectly marked as not containing speech \\[\\text{DER} = \\frac{(\\text{Speaker error} + \\text{False alarm speech} + \\text{Missed speech})}{\\text{Total Duration}}\\] Note Many literature may only report the speaker error in DER. Be aware of such usage. To better understand the individual metrics we can refer an example call timeline that is shown below, Example timeline of an audio with two speakers A and B. We have the original and predicted diarization timeline for the complete duration of call denoted in green for A and pink for B. For each segment, we have mapping of 0, 1, 2, 3 and tick for overlap, speaker error, false alarm, missed speech and correct segment respectively. Note Here we assumed that the mapping of speakers A to A and B to B between the original and predicted transcript is available. But this doesn't happen many times. As diarization is a clustering task, the grouping might be correct but the naming of the groups could be different. One example is where the speaking order in original could be A, B, A, C, D but in predicted it could be X, Y, X, Z, M . While the diarization is correct, the naming is different which should be handeled separately. For this, we can use Hungarian Algorithm to find the optimal map between the speakers in original and predicted before computing the DER. Hint Some packages like [1] and [2] may request the data (both original and predicted timeline) in Rich Transcription Time Marked (RTTM) file format. It is a space-delimited text file that contains one line for each segment with details like start time, duration and speaker name. Refer this for more details. Here is the code to convert RTTM file to CSV file using pandas : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def convert_rttm_to_csv ( file ): \"\"\" Inputs: file: str file path of the rttm file to be converted Outputs: df: dataframe Dataframe containing the extracted information from the rttm file \"\"\" # read the file df = pd . read_csv ( file , delimiter = \" \" , header = None ) df = df [[ 3 , 4 , 7 ]] df . columns = [ 'start_time' , 'duration' , 'speaker_name' ] # compute the end time df [ 'end_time' ] = df [ 'start_time' ] + df [ 'duration' ] # convert time to miliseconds df [ 'start_time' ] *= 1000 df [ 'end_time' ] *= 1000 # sort the df based on the start_time df . sort_values ( by = [ 'start_time' ], inplace = True ) # return return df Jaccard Error Rate (JER) While DER is estimated on whole utterance, in JER, per-speaker error rates are computed and then averaged. In this way, JER tries to give equal weightage to each speaker. Below is the formulation of JER, \\[\\text{JER} = \\frac{1}{N} \\sum_{i}^{N_{ref}} \\frac{(\\text{Speaker Error}_i + \\text{False alarm speech}_i + \\text{Missed speech}_i)}{Total_i}\\] Here, \\(Total_i\\) is the union of ith speaker's speaking time in reference and predicted transcript. \\(N_{ref}\\) is the number of speakers in reference script. Note, contrary to DER, JER never exceed 100%. Code PyAnnote Pyannote Audio provides readymade models and neural building blocks for Speaker diarization and other speech related tasks. While the models are also available on HuggingFace , Pyannote is super easy to use. Below is an example from the github repository of the package: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # Install pyannote ! pip install pyannote . audio # for mac if you get \"OSError: sndfile library not found\" # !conda install -c conda-forge libsndfile # instantiate pretrained speaker diarization pipeline from pyannote.audio import Pipeline pipeline = Pipeline . from_pretrained ( \"pyannote/speaker-diarization\" ) # apply pretrained pipeline diarization = pipeline ( \"audio.wav\" ) # print the result for turn , _ , speaker in diarization . itertracks ( yield_label = True ): print ( f \"start= { turn . start : .1f } s stop= { turn . end : .1f } s speaker_ { speaker } \" ) # start=0.2s stop=1.5s speaker_A # start=1.8s stop=3.9s speaker_B # start=4.2s stop=5.7s speaker_A # ... Hint As per my observation, PyAnnote is quite slow on CPU. Keep this in mind while experimenting with the package. References [1] PyAnnoteAudio - Code | Paper [2] Dscore - Code [3] A Review of Speaker Diarization: Recent Advances with Deep Learning - Paper [4] Low-dimensional speech representation based on Factor Analysis and its applications - Slides [5] Speaker Diarization with LSTM - Paper | Code | Video","title":"Speaker Diarization"},{"location":"audio_intelligence/speaker_diarization/#introduction","text":"Speaker Diarization is the process of segregating different speakers from an audio stream. It is used to answer the question \"who spoke when?\". So if the input is a audio stream with 5 speakers, the output will contain the timestamp in audio when different speakers spoke. A sample output for a conversation between 3 people (differers) could be, start=0.2s stop=1.5s speaker_A start=1.8s stop=3.9s speaker_B start=4.2s stop=5.7s speaker_A start=6.2s stop=7.8s speaker_C ... Note In speaker diarization we separate the speakers (cluster) and not identify them (classify). Hence the output contains anonymous identifiers like speaker_A , speaker_B , etc and not the actual names of the persons.","title":"Introduction"},{"location":"audio_intelligence/speaker_diarization/#traditional-diarization-approach","text":"The generic approach for Speaker Diarization [1] Traditional Speaker Diarization systems can be generalised into a 5 step process. These are, Feature extraction : here we transform the raw waveform into audio features like mel spectrogram. Voice activity detection : here we identify the chunks in the audio where some voice activity was observed. As we are not interested in silence and noise, we ignore those irrelevant chunks. Speaker change detection : here we identify the speaker changepoints in the conversation present in the audio. It is either capture by heuristic approach, classical algorithms or modern neural blocks. It will further divide the chunks from last step into subchunks. Speech turn representation : here we encode each subchunk by creating feature representations. Recent trends gives preference to neural approach where subchunks are encoded into context aware vector representation. Hint We can use any audio representation algorithm or model for this task. Recently d or x vectors are preferred. One example using speechbrain package is 1 2 3 4 5 6 7 # import import torch from speechbrain.pretrained import EncoderClassifier # load the model encoder = EncoderClassifier . from_hparams ( source = \"speechbrain/spkrec-ecapa-voxceleb\" ) # encode the audio chunk embedding = encoder . encode_batch ( torch . from_numpy ( chunk )) Speech turn clustering : here we cluster the subchunks based on their vector representation. Different clustering algorithms could be applied based on availability of cluster count ( k ) and embedding process of the previous step. Hint While Kmeans is the defacto clustering algorithm, it might create some problems if we use it for speaker diarization. Here are a few problem cases mentioned in [5] Non-gaussian data: speech data are often non-gaussian Imbalanced data: one person may speak more than the other Gender/Age/Racial effects: inter-gender difference is large but intra-gender differences are small. Overlapping speech: overlapping speech creates connections between clusters Kmeans algorithms will not be able to handle these issues of the audio data and will perform incorrect clustering. Hence we can use Spectral Clustering that can overcome all of the mentioned issues! The final output will be the clusters of different subchunks from the audio stream. Each cluster can be given an anonymous identifier (speaker_a, ..) and then it can be mapped with the audio stream to create the speaker aware audio timeline.","title":"Traditional Diarization Approach"},{"location":"audio_intelligence/speaker_diarization/#metrics","text":"","title":"Metrics"},{"location":"audio_intelligence/speaker_diarization/#diarization-error-rate-der","text":"Diarization error rate (DER) provides an estimation (O is good, higher is bad; max may exceed 100%) of diarization performance by calculating the sum of following individual metrics, [2] Speaker error: percentage of scored time for which the wrong speaker id is assigned within a speech region False alarm speech: percentage of scored time for which a nonspeech region is incorrectly marked as containing speech Missed speech: percentage of scored time for which a speech region is incorrectly marked as not containing speech \\[\\text{DER} = \\frac{(\\text{Speaker error} + \\text{False alarm speech} + \\text{Missed speech})}{\\text{Total Duration}}\\] Note Many literature may only report the speaker error in DER. Be aware of such usage. To better understand the individual metrics we can refer an example call timeline that is shown below, Example timeline of an audio with two speakers A and B. We have the original and predicted diarization timeline for the complete duration of call denoted in green for A and pink for B. For each segment, we have mapping of 0, 1, 2, 3 and tick for overlap, speaker error, false alarm, missed speech and correct segment respectively. Note Here we assumed that the mapping of speakers A to A and B to B between the original and predicted transcript is available. But this doesn't happen many times. As diarization is a clustering task, the grouping might be correct but the naming of the groups could be different. One example is where the speaking order in original could be A, B, A, C, D but in predicted it could be X, Y, X, Z, M . While the diarization is correct, the naming is different which should be handeled separately. For this, we can use Hungarian Algorithm to find the optimal map between the speakers in original and predicted before computing the DER. Hint Some packages like [1] and [2] may request the data (both original and predicted timeline) in Rich Transcription Time Marked (RTTM) file format. It is a space-delimited text file that contains one line for each segment with details like start time, duration and speaker name. Refer this for more details. Here is the code to convert RTTM file to CSV file using pandas : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def convert_rttm_to_csv ( file ): \"\"\" Inputs: file: str file path of the rttm file to be converted Outputs: df: dataframe Dataframe containing the extracted information from the rttm file \"\"\" # read the file df = pd . read_csv ( file , delimiter = \" \" , header = None ) df = df [[ 3 , 4 , 7 ]] df . columns = [ 'start_time' , 'duration' , 'speaker_name' ] # compute the end time df [ 'end_time' ] = df [ 'start_time' ] + df [ 'duration' ] # convert time to miliseconds df [ 'start_time' ] *= 1000 df [ 'end_time' ] *= 1000 # sort the df based on the start_time df . sort_values ( by = [ 'start_time' ], inplace = True ) # return return df","title":"Diarization Error Rate (DER)"},{"location":"audio_intelligence/speaker_diarization/#jaccard-error-rate-jer","text":"While DER is estimated on whole utterance, in JER, per-speaker error rates are computed and then averaged. In this way, JER tries to give equal weightage to each speaker. Below is the formulation of JER, \\[\\text{JER} = \\frac{1}{N} \\sum_{i}^{N_{ref}} \\frac{(\\text{Speaker Error}_i + \\text{False alarm speech}_i + \\text{Missed speech}_i)}{Total_i}\\] Here, \\(Total_i\\) is the union of ith speaker's speaking time in reference and predicted transcript. \\(N_{ref}\\) is the number of speakers in reference script. Note, contrary to DER, JER never exceed 100%.","title":"Jaccard Error Rate (JER)"},{"location":"audio_intelligence/speaker_diarization/#code","text":"","title":"Code"},{"location":"audio_intelligence/speaker_diarization/#pyannote","text":"Pyannote Audio provides readymade models and neural building blocks for Speaker diarization and other speech related tasks. While the models are also available on HuggingFace , Pyannote is super easy to use. Below is an example from the github repository of the package: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # Install pyannote ! pip install pyannote . audio # for mac if you get \"OSError: sndfile library not found\" # !conda install -c conda-forge libsndfile # instantiate pretrained speaker diarization pipeline from pyannote.audio import Pipeline pipeline = Pipeline . from_pretrained ( \"pyannote/speaker-diarization\" ) # apply pretrained pipeline diarization = pipeline ( \"audio.wav\" ) # print the result for turn , _ , speaker in diarization . itertracks ( yield_label = True ): print ( f \"start= { turn . start : .1f } s stop= { turn . end : .1f } s speaker_ { speaker } \" ) # start=0.2s stop=1.5s speaker_A # start=1.8s stop=3.9s speaker_B # start=4.2s stop=5.7s speaker_A # ... Hint As per my observation, PyAnnote is quite slow on CPU. Keep this in mind while experimenting with the package.","title":"PyAnnote"},{"location":"audio_intelligence/speaker_diarization/#references","text":"[1] PyAnnoteAudio - Code | Paper [2] Dscore - Code [3] A Review of Speaker Diarization: Recent Advances with Deep Learning - Paper [4] Low-dimensional speech representation based on Factor Analysis and its applications - Slides [5] Speaker Diarization with LSTM - Paper | Code | Video","title":"References"},{"location":"audio_intelligence/stt/","text":"Introduction Speech to text task is known by many names, be it Audio Transcription or Automatic Speech Recognition (ASR). Basically, it's the process of generating textual transcription of a conversation, where speech is provided as input and we get text as output. The task is quite complex as it has depedency on several other modules like Voice activity detection and speaker diarization. On top of this, the core transcription module should be able to handle multiple languages, accents and domain specific keywords. We can perform transcriptions in either of the two ways, Online transcription : this is for live use cases where you want to stream ongoing data and perform transcription on the go. For example, an ongoing sales or customer support call or news event, etc. Usually a smaller and faster (hence less accurate) model is used for this. Offline transcription : this is delayed transcription that happens after the call or recording is over. For example, recorded telecast or OTT series's caption, etc. Usually a relatively bigger and more accurate (hence slower) model is used for this. a painting of a woman hand to ear listening to some speech and writing it down in a paper; (Generated by DallE) Available Solutions (Paid) There are a lot of ASR services available online. In fact, there are several startups that only does ASR \ud83e\udd2f. We will try to go through some paid as well as open source options for ASR, so that you are ready to use ASR from day zero using paid option or built an inhouse option using the open source ones. Some of the most popular, widely used but paid ones are as follows, (by any means not the complete list) Amazon Transcribe Google Speech to text Azure Speech to text : AssemblyAI Deepgram Note Please consider accuracy, additional features and cost before selecting any of the above services for your use case. The accuracy of each of the above services are arguably on par, but may vary based on specific domain. For example, one may perform better for healthcare domain, while the other on sales. Be sure to try them out before selecting one. There are several advantages of using paid ASR services, They take care of the major headache in the transcription space like support for multiple languages and accents. Their model is constantly fine-tuned to improve the performance on existing language and even to add support for new ones. They take care of output formatting like adding punctuations, sentence breaks, speaker diarization etc. Otherwise for a inhouse ASR system, we will have to build these as well. They take care of hosting the ASR models. Depending on the use case (for example if you want live transcription which needs to be super fast) , we may end up spending substantially on GPU computes and hardware management. Finally, there has been a trend of providing audio intelligence features on top of core transcription services. For example, AssemblyAI provides add on services like sentiment analysis, entity detection, Auto Chapters, etc. The one and the major con of these services, as you might have guessed, is cost \ud83d\udcb2 Available Solutions (Open Source) Apart from the paid services, there are a lot of open source ASR services available. They are available in form of packages, frameworks or even trained AI models. One major advantage of these models (apart for being free) is that we can further finetune them for our usecase (ex: for our domain and accent) . But this comes at a cost of having to deploy and maintain the complete system model ourself. Some of the widely used open-source ASR systems (\ud83d\udce6 is package and \ud83e\udde0 is model) are, \ud83d\udce6 TensorFlowASR \ud83d\udce6 DeepSpeech \ud83e\udde0 Wav2Vec2 \ud83e\udde0 HuBERT Evaluation Metrics While there are multiple options for ASR, it is important to know how to quantitively compare different ASR systems. To begin, we need the data -- (1) golden transcripts i.e. the source of truth generated by some accurate model or human annotators, and (2) system outputs i.e. output of the model you want to test. Comparing golden transcripts against system output, at word level, we can observe following scenarios -- (1) hit ( \\(H\\) ): word matching in both, (2) insertion ( \\(I\\) ): words only present in system output but not in golden transcripts, (3) deletion ( \\(D\\) ): words only present in golden transcripts but not in system output, (4) substitution ( \\(S\\) ): words substitued in the system output. Word classification of golden transcription (below) \u201cmy computer\u2019s deaf in\u2019he?\u201d against the system output (above) [1] To evaluate the performance, first we need to align the two sentences such that it minimises the errors i.e \\(S+D+I\\) . For this Viterbi alignment is the preferred choice. Once done, we just need to use any metric to quantify the performance. They could be, WER (Word error rate) WER is the proportion of the word errors to the words processed. It's formula is as follows, \\[WER = \\frac{S+D+I}{H+S+D}\\] Note The upper range of WER is not bounded by 1, but by \\(max(N_g, N_s)/N_g\\) where \\(N_g\\) is the number of words in the golden transcription and \\(N_s\\) is the number of words in the system output. So don't be suprised if you get WER > 1, it just means that the system output has a lot more insertions than required (which is bad btw \u274c) MER (Match error rate) MER normalizes the WER by considering the insertions in the denominator. It's formula is as follows, \\[MER = \\frac{S+D+I}{H+S+D+I}\\] Hint If for some transcription, \\(MER = WER\\) , it means there are 0 insertions. Code Recent advances in artificial intelligence and specially transfer learning has lead to release of several pre-trained ASR models that are ready to use from day one. In case you want to improve the accuracy for your domain, we can even fine tune the model further! One of the most famous models right now is Facebook's Wav2Vec2 . We will use this model for coding purposes. More models can be found here . Offline transcription using Wav2Vec2 (CTC) Here is the code to perform offline transcription using Wav2Vec2 model with transformer package. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # import import torch import librosa from transformers import Wav2Vec2ForCTC , Wav2Vec2Tokenizer # load the tokenizer and model tokenizer = Wav2Vec2Tokenizer . from_pretrained ( \"facebook/wav2vec2-large-960h\" ) model = Wav2Vec2ForCTC . from_pretrained ( \"facebook/wav2vec2-large-960h\" ) # load the audio data (use your own wav file here!) input_audio , sr = librosa . load ( 'my_wav_file.wav' , sr = 16000 ) # tokenize input_values = tokenizer ( input_audio , return_tensors = \"pt\" , padding = \"longest\" ) . input_values # retrieve logits logits = model ( input_values ) . logits # take argmax and decode predicted_ids = torch . argmax ( logits , dim =- 1 ) transcription = tokenizer . batch_decode ( predicted_ids ) # print the output print ( transcription ) Online transcription using Wav2Vec2 (CTC) For live transcription using Wav2Vec2, we can utilize wav2vec2-live package. Once you have cloned the repo and installed the packages from requirements.txt , the live transcription can be started with (taken from the package readme and modified) , 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # import from live_asr import LiveWav2Vec2 # load model english_model = \"facebook/wav2vec2-large-960h-lv60-self\" asr = LiveWav2Vec2 ( english_model , device_name = \"default\" ) # start the live ASR asr . start () try : while True : text , sample_length , inference_time = asr . get_last_text () print ( f \"Duration: { sample_length : .3f } s \\t Speed: { inference_time : .3f } s \\t { text } \" ) except KeyboardInterrupt : asr . stop () This starts the Live ASR on your terminal. The code listen to the audio in your microphone, identifies the chunks with voice using VAD and then pass the voiced chunks to Wave2Vec2 for transcription. One sample output is shown below, listening to your voice Duration: 0 .780s Speed: 0 .205s hello Duration: 0 .780s Speed: 0 .190s hello Duration: 0 .960s Speed: 0 .223s my name .... References [1] From WER and RIL to MER and WIL: improved evaluation measures for connected speech recognition Cheers","title":"STT Introduction"},{"location":"audio_intelligence/stt/#introduction","text":"Speech to text task is known by many names, be it Audio Transcription or Automatic Speech Recognition (ASR). Basically, it's the process of generating textual transcription of a conversation, where speech is provided as input and we get text as output. The task is quite complex as it has depedency on several other modules like Voice activity detection and speaker diarization. On top of this, the core transcription module should be able to handle multiple languages, accents and domain specific keywords. We can perform transcriptions in either of the two ways, Online transcription : this is for live use cases where you want to stream ongoing data and perform transcription on the go. For example, an ongoing sales or customer support call or news event, etc. Usually a smaller and faster (hence less accurate) model is used for this. Offline transcription : this is delayed transcription that happens after the call or recording is over. For example, recorded telecast or OTT series's caption, etc. Usually a relatively bigger and more accurate (hence slower) model is used for this. a painting of a woman hand to ear listening to some speech and writing it down in a paper; (Generated by DallE)","title":"Introduction"},{"location":"audio_intelligence/stt/#available-solutions-paid","text":"There are a lot of ASR services available online. In fact, there are several startups that only does ASR \ud83e\udd2f. We will try to go through some paid as well as open source options for ASR, so that you are ready to use ASR from day zero using paid option or built an inhouse option using the open source ones. Some of the most popular, widely used but paid ones are as follows, (by any means not the complete list) Amazon Transcribe Google Speech to text Azure Speech to text : AssemblyAI Deepgram Note Please consider accuracy, additional features and cost before selecting any of the above services for your use case. The accuracy of each of the above services are arguably on par, but may vary based on specific domain. For example, one may perform better for healthcare domain, while the other on sales. Be sure to try them out before selecting one. There are several advantages of using paid ASR services, They take care of the major headache in the transcription space like support for multiple languages and accents. Their model is constantly fine-tuned to improve the performance on existing language and even to add support for new ones. They take care of output formatting like adding punctuations, sentence breaks, speaker diarization etc. Otherwise for a inhouse ASR system, we will have to build these as well. They take care of hosting the ASR models. Depending on the use case (for example if you want live transcription which needs to be super fast) , we may end up spending substantially on GPU computes and hardware management. Finally, there has been a trend of providing audio intelligence features on top of core transcription services. For example, AssemblyAI provides add on services like sentiment analysis, entity detection, Auto Chapters, etc. The one and the major con of these services, as you might have guessed, is cost \ud83d\udcb2","title":"Available Solutions (Paid)"},{"location":"audio_intelligence/stt/#available-solutions-open-source","text":"Apart from the paid services, there are a lot of open source ASR services available. They are available in form of packages, frameworks or even trained AI models. One major advantage of these models (apart for being free) is that we can further finetune them for our usecase (ex: for our domain and accent) . But this comes at a cost of having to deploy and maintain the complete system model ourself. Some of the widely used open-source ASR systems (\ud83d\udce6 is package and \ud83e\udde0 is model) are, \ud83d\udce6 TensorFlowASR \ud83d\udce6 DeepSpeech \ud83e\udde0 Wav2Vec2 \ud83e\udde0 HuBERT","title":"Available Solutions (Open Source)"},{"location":"audio_intelligence/stt/#evaluation-metrics","text":"While there are multiple options for ASR, it is important to know how to quantitively compare different ASR systems. To begin, we need the data -- (1) golden transcripts i.e. the source of truth generated by some accurate model or human annotators, and (2) system outputs i.e. output of the model you want to test. Comparing golden transcripts against system output, at word level, we can observe following scenarios -- (1) hit ( \\(H\\) ): word matching in both, (2) insertion ( \\(I\\) ): words only present in system output but not in golden transcripts, (3) deletion ( \\(D\\) ): words only present in golden transcripts but not in system output, (4) substitution ( \\(S\\) ): words substitued in the system output. Word classification of golden transcription (below) \u201cmy computer\u2019s deaf in\u2019he?\u201d against the system output (above) [1] To evaluate the performance, first we need to align the two sentences such that it minimises the errors i.e \\(S+D+I\\) . For this Viterbi alignment is the preferred choice. Once done, we just need to use any metric to quantify the performance. They could be,","title":"Evaluation Metrics"},{"location":"audio_intelligence/stt/#wer-word-error-rate","text":"WER is the proportion of the word errors to the words processed. It's formula is as follows, \\[WER = \\frac{S+D+I}{H+S+D}\\] Note The upper range of WER is not bounded by 1, but by \\(max(N_g, N_s)/N_g\\) where \\(N_g\\) is the number of words in the golden transcription and \\(N_s\\) is the number of words in the system output. So don't be suprised if you get WER > 1, it just means that the system output has a lot more insertions than required (which is bad btw \u274c)","title":"WER (Word error rate)"},{"location":"audio_intelligence/stt/#mer-match-error-rate","text":"MER normalizes the WER by considering the insertions in the denominator. It's formula is as follows, \\[MER = \\frac{S+D+I}{H+S+D+I}\\] Hint If for some transcription, \\(MER = WER\\) , it means there are 0 insertions.","title":"MER (Match error rate)"},{"location":"audio_intelligence/stt/#code","text":"Recent advances in artificial intelligence and specially transfer learning has lead to release of several pre-trained ASR models that are ready to use from day one. In case you want to improve the accuracy for your domain, we can even fine tune the model further! One of the most famous models right now is Facebook's Wav2Vec2 . We will use this model for coding purposes. More models can be found here .","title":"Code"},{"location":"audio_intelligence/stt/#offline-transcription-using-wav2vec2-ctc","text":"Here is the code to perform offline transcription using Wav2Vec2 model with transformer package. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # import import torch import librosa from transformers import Wav2Vec2ForCTC , Wav2Vec2Tokenizer # load the tokenizer and model tokenizer = Wav2Vec2Tokenizer . from_pretrained ( \"facebook/wav2vec2-large-960h\" ) model = Wav2Vec2ForCTC . from_pretrained ( \"facebook/wav2vec2-large-960h\" ) # load the audio data (use your own wav file here!) input_audio , sr = librosa . load ( 'my_wav_file.wav' , sr = 16000 ) # tokenize input_values = tokenizer ( input_audio , return_tensors = \"pt\" , padding = \"longest\" ) . input_values # retrieve logits logits = model ( input_values ) . logits # take argmax and decode predicted_ids = torch . argmax ( logits , dim =- 1 ) transcription = tokenizer . batch_decode ( predicted_ids ) # print the output print ( transcription )","title":"Offline transcription using Wav2Vec2 (CTC)"},{"location":"audio_intelligence/stt/#online-transcription-using-wav2vec2-ctc","text":"For live transcription using Wav2Vec2, we can utilize wav2vec2-live package. Once you have cloned the repo and installed the packages from requirements.txt , the live transcription can be started with (taken from the package readme and modified) , 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # import from live_asr import LiveWav2Vec2 # load model english_model = \"facebook/wav2vec2-large-960h-lv60-self\" asr = LiveWav2Vec2 ( english_model , device_name = \"default\" ) # start the live ASR asr . start () try : while True : text , sample_length , inference_time = asr . get_last_text () print ( f \"Duration: { sample_length : .3f } s \\t Speed: { inference_time : .3f } s \\t { text } \" ) except KeyboardInterrupt : asr . stop () This starts the Live ASR on your terminal. The code listen to the audio in your microphone, identifies the chunks with voice using VAD and then pass the voiced chunks to Wave2Vec2 for transcription. One sample output is shown below, listening to your voice Duration: 0 .780s Speed: 0 .205s hello Duration: 0 .780s Speed: 0 .190s hello Duration: 0 .960s Speed: 0 .223s my name ....","title":"Online transcription using Wav2Vec2 (CTC)"},{"location":"audio_intelligence/stt/#references","text":"[1] From WER and RIL to MER and WIL: improved evaluation measures for connected speech recognition Cheers","title":"References"},{"location":"audio_intelligence/training_tts/","text":"Training LLM-Based + Neural Codec TTS Models Introduction Training Text-to-Speech (TTS) models from scratch can be approached in multiple ways, each with its own advantages and trade-offs. The most common approaches include: End-to-End Neural TTS : Training models like VITS or FastSpeech 2s that directly generate mel-spectrograms or waveforms from text LLM-Based + Neural Codec : Leveraging pretrained language models to generate discrete audio tokens from neural codecs, then decoding them to audio In this guide, we'll focus on the LLM-based + Neural Codec approach, which has gained significant traction due to its ability to leverage powerful pretrained language models and achieve high-quality speech synthesis. This method treats audio generation as a sequence-to-sequence problem, where the model learns to predict discrete audio tokens (from neural codecs like SNAC or EnCodec ) given text input. Why LLM + Neural Codec? This approach benefits from: Transfer Learning : Leveraging knowledge from large pretrained language models Discrete Tokenization : Converting audio to discrete tokens makes it compatible with language model architectures Scalability : Can handle long audio sequences efficiently Flexibility : Easy to extend to multi-speaker or multilingual scenarios Overview of the Approach The LLM-based TTS training pipeline consists of several key steps: Audio Tokenization : Convert audio waveforms into discrete tokens using a neural codec (e.g., SNAC, EnCodec) Vocabulary Extension : Add audio tokens to the language model's vocabulary Data Preparation : Format training data as text-audio token pairs Model Training : Fine-tune the language model to predict audio tokens given text Inference : Generate audio tokens from text, then decode them back to audio using the neural codec flowchart TD subgraph Data Preparation direction LR A[Text Input] --> B[Audio Recording] B --> C[Neural Codec] end subgraph Model Training direction RL D[Extend LLM Vocabulary] --> E[Model Training] E --> F[Inference] end C -- \"Discrete Audio Tokens\" --> D F -- \"Decode\" --> H[Neural Codec Decoder] H -- \"Audio\" --> I[Audio Output] Main Concepts Let's understand the key concepts of this approach in detail. We will start with a dataset where we have (audio, text) pairs. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # import import os from datasets import load_dataset , Audio # load the dataset dataset = load_dataset ( \"MrDragonFox/Elise\" , split = \"train\" ) # print the dataset print ( dataset ) # Output: # Dataset({ # features: ['audio', 'text'], # num_rows: 1195 # }) # print one sample print ( dataset [ 0 ]) # Output: # {'audio': {'path': 'eaa31ab9.wav', # 'array': array([ 0. , 0. , 0. , ..., -0.00469971, # -0.00558472, -0.00915527]), # 'sampling_rate': 22050}, # 'text': 'Please have mercy on my dainty, frail body. Your coils are so strong and powerful, and I am powerless to resist.'} As you can see, we have MrDragonFox/Elise dataset 1195 samples with (audio, text) pairs along with metadata like sampling_rate . Now let's pick one random sample and play the audio. 1 2 3 4 5 6 7 8 9 # import import random # let's pick one random sample and set the index index = random . randint ( 0 , len ( dataset )) # extract the audio and sampling rate audio = dataset [ index ][ 'audio' ][ 'array' ] sampling_rate = dataset [ index ][ 'audio' ][ 'sampling_rate' ] # play the audio, use idisplay to display the audio AudioPlayer ( audio , rate = sampling_rate ) Here is the audio (which has size of 182133 elements at 22050 Hz sampling rate) : Your browser does not support the audio element. Now let's convert the audio to SNAC codes. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # import torch and SNAC codec import torch from snac import SNAC # load the model snac_model = SNAC . from_pretrained ( \"hubertsiuzdak/snac_24khz\" ) # as we are loading a 24Hz model, let's convert all the audio to 24000 Hz dataset = dataset . cast_column ( \"audio\" , Audio ( sampling_rate = 24000 )) # now let's pick the sample audio again audio = dataset [ index ][ 'audio' ][ 'array' ] sampling_rate = dataset [ index ][ 'audio' ][ 'sampling_rate' ] # this time it will be 24000 Hz # convert the audio to tensor audio_tensor = torch . tensor ( audio , dtype = torch . float32 ) # For single audio file: [1, 1, time_samples] audio_tensor = audio_tensor . unsqueeze ( 0 ) . unsqueeze ( 0 ) # Shape: ~[1, 1, 241664] # encode the audio using snac encoded = snac_model . encode ( audio_tensor ) # print the encoded shape print ( encoded [ 0 ] . shape ) print ( encoded [ 1 ] . shape ) print ( encoded [ 2 ] . shape ) # Output: # torch.Size([1, 97]) # torch.Size([1, 194]) # torch.Size([1, 388]) This returns a list 3 tensors denoting the SNAC codes for the 3 layers. This means we have transformed the audio from 180k samples to just 97 + 194 + 388 = 679 tokens. This is a significant reduction in the size of the data! To double check, we can decode the codec into audio and listen to match with the original audio. 1 2 3 4 # decode the audio using snac decoded = snac_model . decode ( encoded ) # play the audio AudioPlayer ( decoded . detach () . cpu () . numpy () . squeeze (), rate = sampling_rate ) Here is the decoded audio: Your browser does not support the audio element. Perfect! Now, as we can see, we already have a model that can convert any audio to significantly smaller number of tokens, i.e. Audio --> Code and then convert the codes back to audio i.e. Code --> Audio . But the requirement of TTS is that we need to convert text to audio, i.e. Text --> Audio . This is where we can leverage the power of pretrained language models to convert text to audio tokens, i.e. Text --> Code and then use the neural codec to go from Code --> Audio . This is the approach we will be taking in this guide. Code Walkthrough Let's walk through a complete implementation for training a TTS model using Gemma-3 and SNAC codec. We'll break down the code into logical sections and explain each component. I have created a complete implementation of this approach that you can use as a reference. Setup and Imports 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import os import logging import wandb import torch import numpy as np from typing import Dict , List , Optional , Tuple from dataclasses import dataclass , field from datasets import load_dataset , Dataset from transformers import ( AutoTokenizer , AutoModelForCausalLM , TrainingArguments , Trainer , DataCollatorForLanguageModeling , EarlyStoppingCallback , TrainerCallback ) from transformers.trainer_utils import get_last_checkpoint from trl import SFTTrainer The code imports necessary libraries. The SFTTrainer from the trl library is used for supervised fine-tuning, which is well-suited for causal language modeling tasks. Configuration Classes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 @dataclass class ModelArguments : \"\"\"Arguments pertaining to model configuration.\"\"\" model_name_or_path : str = field ( default = \"google/gemma-3-270m\" , metadata = { \"help\" : \"Path to pretrained model or model identifier from huggingface.co/models\" } ) cache_dir : Optional [ str ] = field ( default = None , metadata = { \"help\" : \"Where to store the pretrained models downloaded from huggingface.co/models\" } ) use_fast_tokenizer : bool = field ( default = True , metadata = { \"help\" : \"Whether to use one of the fast tokenizer (backed by the tokenizers library) or not.\" } ) torch_dtype : Optional [ str ] = field ( default = None , metadata = { \"help\" : \"Override the default `torch.dtype` and load the model under this dtype.\" } ) @dataclass class DataArguments : \"\"\"Arguments pertaining to data configuration.\"\"\" dataset_name : str = field ( default = \"mohitmayank/elise_text_snac_codes\" , metadata = { \"help\" : \"The name of the dataset to use (via the datasets library).\" } ) max_seq_length : int = field ( default = 900 , metadata = { \"help\" : \"The maximum total input sequence length after tokenization.\" } ) preprocessing_num_workers : Optional [ int ] = field ( default = None , metadata = { \"help\" : \"The number of processes to use for the preprocessing.\" } ) overwrite_cache : bool = field ( default = False , metadata = { \"help\" : \"Overwrite the cached training and evaluation sets\" } ) validation_split_percentage : int = field ( default = 10 , metadata = { \"help\" : \"Percentage of the dataset to use for validation\" } ) These dataclasses define configuration arguments for the model and data. The ModelArguments specifies which pretrained model to use (Gemma-3-270m), while DataArguments defines dataset parameters including the maximum sequence length (here, 900 tokens) and validation split percentage. SNAC Codec Configuration 1 2 3 4 5 6 7 8 9 10 11 12 SNAC_CONFIG = { \"num_layers\" : 3 , \"codes_per_layer\" : 4096 , # Each layer has codes 0-4095 \"total_snac_tokens\" : 4096 * 3 , # 12,288 additional tokens \"layer_names\" : [ \"snac_l1\" , \"snac_l2\" , \"snac_l3\" ], \"special_tokens\" : { \"audio_start\" : \"<audio_start>\" , \"audio_end\" : \"<audio_end>\" , \"layer_sep\" : \"<layer_sep>\" , \"pad_token\" : \"<snac_pad>\" } } SNAC uses a multi-scale quantization approach with 3 layers. Each layer has 4096 possible code values (0-4095), resulting in 12,288 total SNAC tokens. The configuration also defines special tokens to mark the start/end of audio sequences and layer separators. SNAC Multi-Scale Structure SNAC quantizes audio at different temporal resolutions: Layer 1 : Coarse temporal structure (lower frame rate) Layer 2 : Medium temporal structure Layer 3 : Fine acoustic details (higher frame rate) This hierarchical approach captures both long-term patterns (prosody, semantics) and short-term details (phonetic features). Dataset Loading 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def load_snac_dataset ( data_args : DataArguments ) -> Tuple [ Dataset , Dataset ]: \"\"\"Load and split the SNAC dataset.\"\"\" print ( f \"Loading dataset: { data_args . dataset_name } \" ) # Load the full dataset dataset = load_dataset ( data_args . dataset_name , split = \"train\" ) print ( f \"Loaded { len ( dataset ) } samples\" ) # Add special tokens to the SNAC_CONFIG special_words = [] for i in range ( len ( dataset )): text = dataset [ i ][ 'text' ] special_words . extend ([ word for word in text . split () if word . startswith ( '<' ) and word . endswith ( '>' )]) # Find the unique special words unique_special_words = list ( set ( special_words )) SNAC_CONFIG [ \"special_tokens\" ] . update ({ word : word for word in unique_special_words }) train_dataset = dataset eval_dataset = dataset print ( f \"Train samples: { len ( train_dataset ) } \" ) print ( f \"Eval samples: { len ( eval_dataset ) } \" ) return train_dataset , eval_dataset This function basically performs two things, loads the dataset from Hugging Face Hub. While you can start from a dataset with (audio, text) pairs like MrDragonFox/Elise , I have already transformed the dataset to (text, SNAC code) pairs that you can use here mohitmayank/elise_text_snac_codes . We will download and use this dataset for training. dynamically discovers any additional special tokens present in the dataset text and adds them to the configuration. This is important because the dataset may contain special tokens that are not part of the SNAC configuration, such as <giggling> , <laughter> , <sigh> , etc. SNAC Code to Token Conversion 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def convert_snac_codes_to_tokens ( snac_codes : List [ List [ List [ int ]]], tokenizer : AutoTokenizer ) -> List [ str ]: \"\"\"Convert SNAC codes to token strings.\"\"\" tokens = [ SNAC_CONFIG [ \"special_tokens\" ][ \"audio_start\" ]] # Iterate over the codes for i in range ( len ( snac_codes [ 0 ][ 0 ])): # Add the tokens from layer 1 (1 token) tokens . append ( f \"< { SNAC_CONFIG [ 'layer_names' ][ 0 ] } _ { snac_codes [ 0 ][ 0 ][ i ] } >\" ) # Add the tokens from layer 2 (2 tokens) tokens . extend ([ f \"< { SNAC_CONFIG [ 'layer_names' ][ 1 ] } _ { code_val } >\" for code_val in snac_codes [ 1 ][ 0 ][( i * 2 ):( i * 2 ) + 2 ]]) # Add the tokens from layer 3 (4 tokens) tokens . extend ([ f \"< { SNAC_CONFIG [ 'layer_names' ][ 2 ] } _ { code_val } >\" for code_val in snac_codes [ 2 ][ 0 ][( i * 4 ):( i * 4 ) + 4 ]]) tokens . append ( SNAC_CONFIG [ \"special_tokens\" ][ \"audio_end\" ]) return tokens This function converts SNAC codes (which are integers) into token strings that can be added to the language model vocabulary. In a way, we are transforming the audio tokens (which were 3 lists of tensors) into a single string of tokens. This is done by assuming the SNAC codec follow a time frame, where each frame consist of 7 elements. Each time frame will contain codes from all the 3 layers in following manner, First element of the frame is code from layer 1 Second and third elements of the frame are codes from layer 2 Fourth to seventh elements of the frame are codes from layer 3 One sample time frame will look like this: <snac_l1_123> <snac_l2_456> <snac_l2_478> <snac_l3_789><snac_l3_1123><snac_l3_100><snac_l3_54> We do it for the complete audio sequence till we exhaust all the time frames or the SNAC codes, and the encapsulate the audio within the special tokens <audio_start> and <audio_end> , so that the complete sequence looks like this: <audio_start> <snac_l1_123> ...<snac_l3_54> <audio_end> Why follow this complex format? This format is chosen because it is easy to parse and decode back to audio. It is also easy to train a language model on this format. On the plus side, this format can help with real-time streaming application in future, as we get generation output in timeframe manner. Data Preprocessing 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def preprocess_function ( examples : Dict [ str , List ], tokenizer : AutoTokenizer , max_length : int ): \"\"\"Preprocess examples for training.\"\"\" batch_size = len ( examples [ \"text\" ]) processed_texts = [] for i in range ( batch_size ): text = examples [ \"text\" ][ i ] snac_codes = examples [ \"snac_codes\" ][ i ] # Convert SNAC codes to tokens snac_tokens = convert_snac_codes_to_tokens_v2 ( snac_codes , tokenizer ) snac_text = \"\" . join ( snac_tokens ) # Create input in format: \"Text: {text} Audio: {snac_tokens}\" input_text = f \" { text } { snac_text } \" processed_texts . append ( input_text ) # Tokenize the processed texts tokenized = tokenizer ( processed_texts , truncation = True , padding = 'max_length' , max_length = max_length , return_tensors = None ) # Set labels equal to input_ids for causal language modeling tokenized [ \"labels\" ] = tokenized [ \"input_ids\" ] . copy () return tokenized The preprocessing function combines text and SNAC tokens into a single sequence. The format is: \"{text} {snac_tokens}\" , where the model learns to predict the SNAC tokens given the text. For causal language modeling, labels are set equal to input_ids , meaning the model learns to predict the next token in the sequence (including both text and audio tokens). One example of the output of the preprocessing function will look like this: Please have mercy on my dainty, frail body. Your coils are so strong and powerful, and I am powerless to resist <audio_start> <snac_l1_123> ... <snac_l3_54> <audio_end> This is the format that the model will learn to predict. Training Format The model is trained to predict the entire sequence autoregressively. During inference, you provide only the text, and the model generates the SNAC tokens that follow, which can then be decoded back to audio. Model and Tokenizer Setup 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def setup_model_and_tokenizer ( model_args : ModelArguments ) -> Tuple [ AutoModelForCausalLM , AutoTokenizer ]: \"\"\"Setup and extend the Gemma model and tokenizer for SNAC tokens.\"\"\" print ( f \"Loading model and tokenizer from { model_args . model_name_or_path } \" ) # Load tokenizer tokenizer = AutoTokenizer . from_pretrained ( model_args . model_name_or_path , cache_dir = model_args . cache_dir , use_fast = model_args . use_fast_tokenizer , trust_remote_code = True ) # Add padding token if not present if tokenizer . pad_token is None : tokenizer . pad_token = tokenizer . eos_token tokenizer . pad_token_id = tokenizer . eos_token_id tokenizer . padding_side = \"right\" # Store original vocab size original_vocab_size = len ( tokenizer ) print ( f \"Original vocabulary size: { original_vocab_size } \" ) # Add SNAC special tokens special_tokens_list = list ( SNAC_CONFIG [ \"special_tokens\" ] . values ()) num_added_special = tokenizer . add_special_tokens ({ \"additional_special_tokens\" : special_tokens_list }) print ( f \"Added { num_added_special } special tokens\" ) # Add SNAC code tokens snac_tokens = [] for layer_idx in range ( SNAC_CONFIG [ \"num_layers\" ]): layer_name = SNAC_CONFIG [ \"layer_names\" ][ layer_idx ] for code_val in range ( SNAC_CONFIG [ \"codes_per_layer\" ]): token = f \"< { layer_name } _ { code_val } >\" snac_tokens . append ( token ) # Add all SNAC tokens to the tokenizer num_added_snac = tokenizer . add_tokens ( snac_tokens ) print ( f \"Added { num_added_snac } SNAC code tokens\" ) # Verify total tokens added total_added = num_added_special + num_added_snac expected_total = len ( special_tokens_list ) + SNAC_CONFIG [ \"total_snac_tokens\" ] assert total_added == expected_total , f \"Expected { expected_total } tokens, got { total_added } \" print ( f \"New vocabulary size: { len ( tokenizer ) } \" ) # Load model model = AutoModelForCausalLM . from_pretrained ( model_args . model_name_or_path , cache_dir = model_args . cache_dir , torch_dtype = torch . bfloat16 , trust_remote_code = True , attn_implementation = 'eager' ) # Resize model embeddings to accommodate new tokens print ( f \"Resizing model embeddings to { len ( tokenizer ) } tokens\" ) model . resize_token_embeddings ( len ( tokenizer )) return model , tokenizer , original_vocab_size This is a critical function that extends the language model vocabulary to include SNAC tokens: Load Base Model : Loads the pretrained Gemma-3-270m model and tokenizer Add Special Tokens : Adds SNAC special tokens ( <audio_start> , <audio_end> , etc.) Add SNAC Code Tokens : Creates tokens for all possible SNAC codes (e.g., <snac_l1_0> through <snac_l1_4095> for each layer) Resize Embeddings : Expands the model's embedding layer to accommodate the new tokens Embedding Resizing When new tokens are added, the model's embedding matrix must be resized. The new token embeddings are typically initialized randomly or copied from similar existing tokens. This is crucial for the model to learn meaningful representations of the audio tokens. Training Configuration 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 @dataclass class TrainingArgumentsCustom ( TrainingArguments ): output_dir = \"output_dir\" overwrite_output_dir : bool = field ( default = False ) do_train : bool = field ( default = True ) do_eval : bool = field ( default = False ) # Logging & Verbosity logging_steps : int = field ( default = 10 ) logging_first_step : bool = field ( default = True ) disable_tqdm : bool = field ( default = False ) report_to : str = field ( default = \"wandb\" ) # Training params per_device_train_batch_size : int = field ( default = 2 ) per_device_eval_batch_size : int = field ( default = 1 ) gradient_accumulation_steps : int = field ( default = 4 ) learning_rate : float = field ( default = 2e-4 ) weight_decay : float = field ( default = 0.01 ) num_train_epochs : float = field ( default = 20 ) lr_scheduler_type : str = field ( default = \"cosine\" ) warmup_ratio : float = field ( default = 0.1 ) save_total_limit : int = field ( default = 5 ) save_strategy : str = field ( default = \"steps\" ) save_steps : int = field ( default = 10 ) # Dataloader dataloader_num_workers : int = field ( default = 0 ) dataloader_pin_memory : bool = field ( default = False ) # Mixed precision fp16 : bool = field ( default = False ) bf16 : bool = field ( default = False ) # Other remove_unused_columns : bool = field ( default = False ) include_inputs_for_metrics : bool = field ( default = True ) prediction_loss_only : bool = field ( default = False ) The training arguments configure the fine-tuning process: Batch Size : per_device_train_batch_size=2 with gradient_accumulation_steps=4 gives an effective batch size of 8 Learning Rate : 2e-4 is a common starting point for fine-tuning language models Scheduler : Cosine learning rate schedule with 10% warmup Mixed Precision : Can use bf16 or fp16 for faster training and lower memory usage Experimentation You are invited to experiment with different learning rates, batch sizes, gradient accumulation steps, number of training epochs, etc. to get the best performance. Training Execution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # Initialize configurations model_args = ModelArguments () data_args = DataArguments () training_args = TrainingArgumentsCustom () # Load datasets train_dataset , eval_dataset = load_snac_dataset ( data_args ) # Setup model and tokenizer model , tokenizer , original_vocab_size = setup_model_and_tokenizer ( model_args ) # Prepare datasets train_dataset , eval_dataset = prepare_datasets ( train_dataset , eval_dataset , tokenizer , data_args ) # Data collator for language modeling data_collator = DataCollatorForLanguageModeling ( tokenizer = tokenizer , mlm = False , # We're doing causal LM, not masked LM pad_to_multiple_of = 8 if training_args . fp16 or training_args . bf16 else None , return_tensors = \"pt\" ) # Initialize the SFTTrainer trainer = SFTTrainer ( model = model , train_dataset = train_dataset , args = training_args , data_collator = data_collator , ) # Start training print ( \"Starting model training...\" ) trainer . train () print ( \"Training finished.\" ) The training pipeline: Load Data : Loads text-SNAC code pairs from the dataset Setup Model : Extends the vocabulary and resizes embeddings Preprocess : Converts SNAC codes to tokens and formats training sequences Data Collator : Handles batching and padding for causal language modeling Train : Uses SFTTrainer to fine-tune the model The DataCollatorForLanguageModeling with mlm=False is configured for causal language modeling, where the model predicts the next token in the sequence. And we are done! Once you perform the training, you should see a training log like shown below: Training Log for LLM + Neural Codec TTS Model But Mohit, it's overfitting! Yes, sir! This is expected because we are using a very small dataset, and training for multiple epochs. This tutorial is meant to give you a starting point and a reference implementation. Head over to the conclusion section for next steps and my comments. We are just getting started. Inference After training, inference involves: Text Input : Provide text to the model Token Generation : Model generates SNAC tokens autoregressively Token Parsing : Extract SNAC codes from generated tokens Audio Decoding : Use SNAC decoder to convert codes back to audio waveform Here's a complete inference implementation: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 import torch from snac import SNAC # assuming the model and tokenizer are already loaded # Prepare text input text = \"Please have mercy on my dainty, frail body. Your coils are so strong and powerful, and I am powerless to resist. <audio_start>\" input_ids = tokenizer . encode ( text , return_tensors = \"pt\" ) # Generate SNAC tokens (model generates token IDs) with torch . no_grad (): outputs = model . generate ( ** inputs , max_new_tokens = 900 , temperature = 0.7 , top_k = 50 , top_p = 0.90 , num_return_sequences = 1 , eos_token_id = 262146 , # this is the end of audio token id use_cache = True ) # Parse SNAC codes from the generated token IDs def parse_snac_codes ( output ): \"\"\"Extract SNAC codes from model output token IDs.\"\"\" codes = [[], [], []] # Filter tokens that are SNAC tokens (token IDs >= 262173) # This threshold corresponds to the start of SNAC token vocabulary tokens = [ x for x in output if x >= 262173 ] # Process tokens in batches of 7 (1 from layer 1, 2 from layer 2, 4 from layer 3) for frame_i in range ( len ( tokens ) // 7 ): # Extract code for layer 1 (first token in frame) codes [ 0 ] . extend ([( tokens [ frame_i * 7 ] - 262173 ) % 4096 ]) # Extract codes for layer 2 (tokens 1-2 in frame) codes [ 1 ] . extend ([( tokens [( frame_i * 7 ) + x ] - 262173 ) % 4096 for x in range ( 1 , 3 )]) # Extract codes for layer 3 (tokens 3-6 in frame) codes [ 2 ] . extend ([( tokens [( frame_i * 7 ) + x ] - 262173 ) % 4096 for x in range ( 3 , 7 )]) # Convert to torch tensors with batch dimension encoded = [ torch . tensor ( codes [ 0 ]) . unsqueeze ( 0 ), torch . tensor ( codes [ 1 ]) . unsqueeze ( 0 ), torch . tensor ( codes [ 2 ]) . unsqueeze ( 0 ) ] return encoded # Parse the generated tokens to extract SNAC codes encoded = parse_snac_codes ( outputs [ 0 ] . cpu () . detach () . numpy ()) # Verify the shapes match expected SNAC format print ( f \"Layer 1 shape: { encoded [ 0 ] . shape } \" ) print ( f \"Layer 2 shape: { encoded [ 1 ] . shape } \" ) print ( f \"Layer 3 shape: { encoded [ 2 ] . shape } \" ) # Decode SNAC codes back to audio waveform decoded_audio = snac_model . decode ( encoded ) # The decoded audio is a tensor, convert to numpy for playback/saving audio_array = decoded_audio . detach () . cpu () . numpy () . squeeze () sampling_rate = 24000 # SNAC 24kHz model # Save or play the audio # from scipy.io import wavfile # wavfile.write(\"output.wav\", sampling_rate, audio_array) # PLay the audio # AudioPlayer(audio_array, rate=sampling_rate) Understanding the Parsing Function The parse_snac_codes function performs several key operations: Token Filtering : It filters tokens with IDs >= 262173, which corresponds to the start of the SNAC token vocabulary in the extended model. Frame Processing : The function processes tokens in batches of 7, matching the SNAC frame structure: 1 token from layer 1 (coarse structure) 2 tokens from layer 2 (medium detail) 4 tokens from layer 3 (fine detail) Code Extraction : For each token, it: Subtracts 262173 to get the relative token ID within SNAC vocabulary Takes modulo 4096 to extract the actual code value (since each layer has 4096 possible codes: 0-4095) Tensor Conversion : Converts the extracted codes into PyTorch tensors with the batch dimension, matching the format expected by the SNAC decoder. Token ID Threshold The threshold value 262173 is specific to this model configuration. It represents the starting token ID of SNAC tokens in the extended vocabulary. If you're using a different base model or have a different vocabulary size, you'll need to adjust this threshold accordingly. You can verify this by checking the tokenizer's vocabulary size before and after adding SNAC tokens. Best Practices Data Quality : Ensure high-quality text-audio pairs with accurate transcriptions Sequence Length : Balance max_seq_length between model capacity and training efficiency Learning Rate : Start with lower learning rates (1e-4 to 5e-4) for fine-tuning Gradient Accumulation : Use gradient accumulation to simulate larger batch sizes Checkpointing : Save checkpoints regularly to resume training if interrupted Evaluation : Monitor both training loss and audio quality metrics (e.g., MOS, SECS) Conclusion Training TTS models using LLM-based approaches with neural codecs represents a powerful paradigm that combines the strengths of modern language models with efficient audio representations. By treating audio generation as a sequence-to-sequence problem, we can leverage transfer learning and achieve high-quality speech synthesis. The key is understanding how to convert audio to discrete tokens, extend model vocabularies, and train the model to learn the text-to-audio mapping. As stated before, this tutorial is meant to give you a starting point and a reference implementation. We are just getting started with the journey of training TTS models. I think there are multiple ways to improve the performance of the model. Some ways are: Use a larger dataset (currently it is trained on ~1000 samples, we need to atleast 10x the size to get respectable results) Data Preprocessing (we can preprocess the data to handle the special tokens and to make sure the data is in the correct format. We can further break the audio into smaller and cleaner chunks, clean the audio by denoising, etc) Data Diversification (we need to diversify the data to improve the performance of the model. We can use data augmentation techniques or have audio from multiple speakers speaking in different speed, pitch, language, accent, etc) Use Reinforcement Learning to fine-tune the model (we can add explicit rewards like WER, SECS, etc to the training loop to improve the quality of the generated speech) and more... Maybe more on this in future guides! Do let me know if you have any questions or suggestions. If you want to contribute to this guide, please feel free to submit a pull request . If you want to discuss something, please feel free to reach out to me on LinkedIn .","title":"Training LLM-Based + Neural Codec TTS Models"},{"location":"audio_intelligence/training_tts/#training-llm-based-neural-codec-tts-models","text":"","title":"Training LLM-Based + Neural Codec TTS Models"},{"location":"audio_intelligence/training_tts/#introduction","text":"Training Text-to-Speech (TTS) models from scratch can be approached in multiple ways, each with its own advantages and trade-offs. The most common approaches include: End-to-End Neural TTS : Training models like VITS or FastSpeech 2s that directly generate mel-spectrograms or waveforms from text LLM-Based + Neural Codec : Leveraging pretrained language models to generate discrete audio tokens from neural codecs, then decoding them to audio In this guide, we'll focus on the LLM-based + Neural Codec approach, which has gained significant traction due to its ability to leverage powerful pretrained language models and achieve high-quality speech synthesis. This method treats audio generation as a sequence-to-sequence problem, where the model learns to predict discrete audio tokens (from neural codecs like SNAC or EnCodec ) given text input. Why LLM + Neural Codec? This approach benefits from: Transfer Learning : Leveraging knowledge from large pretrained language models Discrete Tokenization : Converting audio to discrete tokens makes it compatible with language model architectures Scalability : Can handle long audio sequences efficiently Flexibility : Easy to extend to multi-speaker or multilingual scenarios","title":"Introduction"},{"location":"audio_intelligence/training_tts/#overview-of-the-approach","text":"The LLM-based TTS training pipeline consists of several key steps: Audio Tokenization : Convert audio waveforms into discrete tokens using a neural codec (e.g., SNAC, EnCodec) Vocabulary Extension : Add audio tokens to the language model's vocabulary Data Preparation : Format training data as text-audio token pairs Model Training : Fine-tune the language model to predict audio tokens given text Inference : Generate audio tokens from text, then decode them back to audio using the neural codec flowchart TD subgraph Data Preparation direction LR A[Text Input] --> B[Audio Recording] B --> C[Neural Codec] end subgraph Model Training direction RL D[Extend LLM Vocabulary] --> E[Model Training] E --> F[Inference] end C -- \"Discrete Audio Tokens\" --> D F -- \"Decode\" --> H[Neural Codec Decoder] H -- \"Audio\" --> I[Audio Output]","title":"Overview of the Approach"},{"location":"audio_intelligence/training_tts/#main-concepts","text":"Let's understand the key concepts of this approach in detail. We will start with a dataset where we have (audio, text) pairs. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # import import os from datasets import load_dataset , Audio # load the dataset dataset = load_dataset ( \"MrDragonFox/Elise\" , split = \"train\" ) # print the dataset print ( dataset ) # Output: # Dataset({ # features: ['audio', 'text'], # num_rows: 1195 # }) # print one sample print ( dataset [ 0 ]) # Output: # {'audio': {'path': 'eaa31ab9.wav', # 'array': array([ 0. , 0. , 0. , ..., -0.00469971, # -0.00558472, -0.00915527]), # 'sampling_rate': 22050}, # 'text': 'Please have mercy on my dainty, frail body. Your coils are so strong and powerful, and I am powerless to resist.'} As you can see, we have MrDragonFox/Elise dataset 1195 samples with (audio, text) pairs along with metadata like sampling_rate . Now let's pick one random sample and play the audio. 1 2 3 4 5 6 7 8 9 # import import random # let's pick one random sample and set the index index = random . randint ( 0 , len ( dataset )) # extract the audio and sampling rate audio = dataset [ index ][ 'audio' ][ 'array' ] sampling_rate = dataset [ index ][ 'audio' ][ 'sampling_rate' ] # play the audio, use idisplay to display the audio AudioPlayer ( audio , rate = sampling_rate ) Here is the audio (which has size of 182133 elements at 22050 Hz sampling rate) : Your browser does not support the audio element. Now let's convert the audio to SNAC codes. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # import torch and SNAC codec import torch from snac import SNAC # load the model snac_model = SNAC . from_pretrained ( \"hubertsiuzdak/snac_24khz\" ) # as we are loading a 24Hz model, let's convert all the audio to 24000 Hz dataset = dataset . cast_column ( \"audio\" , Audio ( sampling_rate = 24000 )) # now let's pick the sample audio again audio = dataset [ index ][ 'audio' ][ 'array' ] sampling_rate = dataset [ index ][ 'audio' ][ 'sampling_rate' ] # this time it will be 24000 Hz # convert the audio to tensor audio_tensor = torch . tensor ( audio , dtype = torch . float32 ) # For single audio file: [1, 1, time_samples] audio_tensor = audio_tensor . unsqueeze ( 0 ) . unsqueeze ( 0 ) # Shape: ~[1, 1, 241664] # encode the audio using snac encoded = snac_model . encode ( audio_tensor ) # print the encoded shape print ( encoded [ 0 ] . shape ) print ( encoded [ 1 ] . shape ) print ( encoded [ 2 ] . shape ) # Output: # torch.Size([1, 97]) # torch.Size([1, 194]) # torch.Size([1, 388]) This returns a list 3 tensors denoting the SNAC codes for the 3 layers. This means we have transformed the audio from 180k samples to just 97 + 194 + 388 = 679 tokens. This is a significant reduction in the size of the data! To double check, we can decode the codec into audio and listen to match with the original audio. 1 2 3 4 # decode the audio using snac decoded = snac_model . decode ( encoded ) # play the audio AudioPlayer ( decoded . detach () . cpu () . numpy () . squeeze (), rate = sampling_rate ) Here is the decoded audio: Your browser does not support the audio element. Perfect! Now, as we can see, we already have a model that can convert any audio to significantly smaller number of tokens, i.e. Audio --> Code and then convert the codes back to audio i.e. Code --> Audio . But the requirement of TTS is that we need to convert text to audio, i.e. Text --> Audio . This is where we can leverage the power of pretrained language models to convert text to audio tokens, i.e. Text --> Code and then use the neural codec to go from Code --> Audio . This is the approach we will be taking in this guide.","title":"Main Concepts"},{"location":"audio_intelligence/training_tts/#code-walkthrough","text":"Let's walk through a complete implementation for training a TTS model using Gemma-3 and SNAC codec. We'll break down the code into logical sections and explain each component. I have created a complete implementation of this approach that you can use as a reference.","title":"Code Walkthrough"},{"location":"audio_intelligence/training_tts/#setup-and-imports","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import os import logging import wandb import torch import numpy as np from typing import Dict , List , Optional , Tuple from dataclasses import dataclass , field from datasets import load_dataset , Dataset from transformers import ( AutoTokenizer , AutoModelForCausalLM , TrainingArguments , Trainer , DataCollatorForLanguageModeling , EarlyStoppingCallback , TrainerCallback ) from transformers.trainer_utils import get_last_checkpoint from trl import SFTTrainer The code imports necessary libraries. The SFTTrainer from the trl library is used for supervised fine-tuning, which is well-suited for causal language modeling tasks.","title":"Setup and Imports"},{"location":"audio_intelligence/training_tts/#configuration-classes","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 @dataclass class ModelArguments : \"\"\"Arguments pertaining to model configuration.\"\"\" model_name_or_path : str = field ( default = \"google/gemma-3-270m\" , metadata = { \"help\" : \"Path to pretrained model or model identifier from huggingface.co/models\" } ) cache_dir : Optional [ str ] = field ( default = None , metadata = { \"help\" : \"Where to store the pretrained models downloaded from huggingface.co/models\" } ) use_fast_tokenizer : bool = field ( default = True , metadata = { \"help\" : \"Whether to use one of the fast tokenizer (backed by the tokenizers library) or not.\" } ) torch_dtype : Optional [ str ] = field ( default = None , metadata = { \"help\" : \"Override the default `torch.dtype` and load the model under this dtype.\" } ) @dataclass class DataArguments : \"\"\"Arguments pertaining to data configuration.\"\"\" dataset_name : str = field ( default = \"mohitmayank/elise_text_snac_codes\" , metadata = { \"help\" : \"The name of the dataset to use (via the datasets library).\" } ) max_seq_length : int = field ( default = 900 , metadata = { \"help\" : \"The maximum total input sequence length after tokenization.\" } ) preprocessing_num_workers : Optional [ int ] = field ( default = None , metadata = { \"help\" : \"The number of processes to use for the preprocessing.\" } ) overwrite_cache : bool = field ( default = False , metadata = { \"help\" : \"Overwrite the cached training and evaluation sets\" } ) validation_split_percentage : int = field ( default = 10 , metadata = { \"help\" : \"Percentage of the dataset to use for validation\" } ) These dataclasses define configuration arguments for the model and data. The ModelArguments specifies which pretrained model to use (Gemma-3-270m), while DataArguments defines dataset parameters including the maximum sequence length (here, 900 tokens) and validation split percentage.","title":"Configuration Classes"},{"location":"audio_intelligence/training_tts/#snac-codec-configuration","text":"1 2 3 4 5 6 7 8 9 10 11 12 SNAC_CONFIG = { \"num_layers\" : 3 , \"codes_per_layer\" : 4096 , # Each layer has codes 0-4095 \"total_snac_tokens\" : 4096 * 3 , # 12,288 additional tokens \"layer_names\" : [ \"snac_l1\" , \"snac_l2\" , \"snac_l3\" ], \"special_tokens\" : { \"audio_start\" : \"<audio_start>\" , \"audio_end\" : \"<audio_end>\" , \"layer_sep\" : \"<layer_sep>\" , \"pad_token\" : \"<snac_pad>\" } } SNAC uses a multi-scale quantization approach with 3 layers. Each layer has 4096 possible code values (0-4095), resulting in 12,288 total SNAC tokens. The configuration also defines special tokens to mark the start/end of audio sequences and layer separators. SNAC Multi-Scale Structure SNAC quantizes audio at different temporal resolutions: Layer 1 : Coarse temporal structure (lower frame rate) Layer 2 : Medium temporal structure Layer 3 : Fine acoustic details (higher frame rate) This hierarchical approach captures both long-term patterns (prosody, semantics) and short-term details (phonetic features).","title":"SNAC Codec Configuration"},{"location":"audio_intelligence/training_tts/#dataset-loading","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def load_snac_dataset ( data_args : DataArguments ) -> Tuple [ Dataset , Dataset ]: \"\"\"Load and split the SNAC dataset.\"\"\" print ( f \"Loading dataset: { data_args . dataset_name } \" ) # Load the full dataset dataset = load_dataset ( data_args . dataset_name , split = \"train\" ) print ( f \"Loaded { len ( dataset ) } samples\" ) # Add special tokens to the SNAC_CONFIG special_words = [] for i in range ( len ( dataset )): text = dataset [ i ][ 'text' ] special_words . extend ([ word for word in text . split () if word . startswith ( '<' ) and word . endswith ( '>' )]) # Find the unique special words unique_special_words = list ( set ( special_words )) SNAC_CONFIG [ \"special_tokens\" ] . update ({ word : word for word in unique_special_words }) train_dataset = dataset eval_dataset = dataset print ( f \"Train samples: { len ( train_dataset ) } \" ) print ( f \"Eval samples: { len ( eval_dataset ) } \" ) return train_dataset , eval_dataset This function basically performs two things, loads the dataset from Hugging Face Hub. While you can start from a dataset with (audio, text) pairs like MrDragonFox/Elise , I have already transformed the dataset to (text, SNAC code) pairs that you can use here mohitmayank/elise_text_snac_codes . We will download and use this dataset for training. dynamically discovers any additional special tokens present in the dataset text and adds them to the configuration. This is important because the dataset may contain special tokens that are not part of the SNAC configuration, such as <giggling> , <laughter> , <sigh> , etc.","title":"Dataset Loading"},{"location":"audio_intelligence/training_tts/#snac-code-to-token-conversion","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def convert_snac_codes_to_tokens ( snac_codes : List [ List [ List [ int ]]], tokenizer : AutoTokenizer ) -> List [ str ]: \"\"\"Convert SNAC codes to token strings.\"\"\" tokens = [ SNAC_CONFIG [ \"special_tokens\" ][ \"audio_start\" ]] # Iterate over the codes for i in range ( len ( snac_codes [ 0 ][ 0 ])): # Add the tokens from layer 1 (1 token) tokens . append ( f \"< { SNAC_CONFIG [ 'layer_names' ][ 0 ] } _ { snac_codes [ 0 ][ 0 ][ i ] } >\" ) # Add the tokens from layer 2 (2 tokens) tokens . extend ([ f \"< { SNAC_CONFIG [ 'layer_names' ][ 1 ] } _ { code_val } >\" for code_val in snac_codes [ 1 ][ 0 ][( i * 2 ):( i * 2 ) + 2 ]]) # Add the tokens from layer 3 (4 tokens) tokens . extend ([ f \"< { SNAC_CONFIG [ 'layer_names' ][ 2 ] } _ { code_val } >\" for code_val in snac_codes [ 2 ][ 0 ][( i * 4 ):( i * 4 ) + 4 ]]) tokens . append ( SNAC_CONFIG [ \"special_tokens\" ][ \"audio_end\" ]) return tokens This function converts SNAC codes (which are integers) into token strings that can be added to the language model vocabulary. In a way, we are transforming the audio tokens (which were 3 lists of tensors) into a single string of tokens. This is done by assuming the SNAC codec follow a time frame, where each frame consist of 7 elements. Each time frame will contain codes from all the 3 layers in following manner, First element of the frame is code from layer 1 Second and third elements of the frame are codes from layer 2 Fourth to seventh elements of the frame are codes from layer 3 One sample time frame will look like this: <snac_l1_123> <snac_l2_456> <snac_l2_478> <snac_l3_789><snac_l3_1123><snac_l3_100><snac_l3_54> We do it for the complete audio sequence till we exhaust all the time frames or the SNAC codes, and the encapsulate the audio within the special tokens <audio_start> and <audio_end> , so that the complete sequence looks like this: <audio_start> <snac_l1_123> ...<snac_l3_54> <audio_end> Why follow this complex format? This format is chosen because it is easy to parse and decode back to audio. It is also easy to train a language model on this format. On the plus side, this format can help with real-time streaming application in future, as we get generation output in timeframe manner.","title":"SNAC Code to Token Conversion"},{"location":"audio_intelligence/training_tts/#data-preprocessing","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 def preprocess_function ( examples : Dict [ str , List ], tokenizer : AutoTokenizer , max_length : int ): \"\"\"Preprocess examples for training.\"\"\" batch_size = len ( examples [ \"text\" ]) processed_texts = [] for i in range ( batch_size ): text = examples [ \"text\" ][ i ] snac_codes = examples [ \"snac_codes\" ][ i ] # Convert SNAC codes to tokens snac_tokens = convert_snac_codes_to_tokens_v2 ( snac_codes , tokenizer ) snac_text = \"\" . join ( snac_tokens ) # Create input in format: \"Text: {text} Audio: {snac_tokens}\" input_text = f \" { text } { snac_text } \" processed_texts . append ( input_text ) # Tokenize the processed texts tokenized = tokenizer ( processed_texts , truncation = True , padding = 'max_length' , max_length = max_length , return_tensors = None ) # Set labels equal to input_ids for causal language modeling tokenized [ \"labels\" ] = tokenized [ \"input_ids\" ] . copy () return tokenized The preprocessing function combines text and SNAC tokens into a single sequence. The format is: \"{text} {snac_tokens}\" , where the model learns to predict the SNAC tokens given the text. For causal language modeling, labels are set equal to input_ids , meaning the model learns to predict the next token in the sequence (including both text and audio tokens). One example of the output of the preprocessing function will look like this: Please have mercy on my dainty, frail body. Your coils are so strong and powerful, and I am powerless to resist <audio_start> <snac_l1_123> ... <snac_l3_54> <audio_end> This is the format that the model will learn to predict. Training Format The model is trained to predict the entire sequence autoregressively. During inference, you provide only the text, and the model generates the SNAC tokens that follow, which can then be decoded back to audio.","title":"Data Preprocessing"},{"location":"audio_intelligence/training_tts/#model-and-tokenizer-setup","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def setup_model_and_tokenizer ( model_args : ModelArguments ) -> Tuple [ AutoModelForCausalLM , AutoTokenizer ]: \"\"\"Setup and extend the Gemma model and tokenizer for SNAC tokens.\"\"\" print ( f \"Loading model and tokenizer from { model_args . model_name_or_path } \" ) # Load tokenizer tokenizer = AutoTokenizer . from_pretrained ( model_args . model_name_or_path , cache_dir = model_args . cache_dir , use_fast = model_args . use_fast_tokenizer , trust_remote_code = True ) # Add padding token if not present if tokenizer . pad_token is None : tokenizer . pad_token = tokenizer . eos_token tokenizer . pad_token_id = tokenizer . eos_token_id tokenizer . padding_side = \"right\" # Store original vocab size original_vocab_size = len ( tokenizer ) print ( f \"Original vocabulary size: { original_vocab_size } \" ) # Add SNAC special tokens special_tokens_list = list ( SNAC_CONFIG [ \"special_tokens\" ] . values ()) num_added_special = tokenizer . add_special_tokens ({ \"additional_special_tokens\" : special_tokens_list }) print ( f \"Added { num_added_special } special tokens\" ) # Add SNAC code tokens snac_tokens = [] for layer_idx in range ( SNAC_CONFIG [ \"num_layers\" ]): layer_name = SNAC_CONFIG [ \"layer_names\" ][ layer_idx ] for code_val in range ( SNAC_CONFIG [ \"codes_per_layer\" ]): token = f \"< { layer_name } _ { code_val } >\" snac_tokens . append ( token ) # Add all SNAC tokens to the tokenizer num_added_snac = tokenizer . add_tokens ( snac_tokens ) print ( f \"Added { num_added_snac } SNAC code tokens\" ) # Verify total tokens added total_added = num_added_special + num_added_snac expected_total = len ( special_tokens_list ) + SNAC_CONFIG [ \"total_snac_tokens\" ] assert total_added == expected_total , f \"Expected { expected_total } tokens, got { total_added } \" print ( f \"New vocabulary size: { len ( tokenizer ) } \" ) # Load model model = AutoModelForCausalLM . from_pretrained ( model_args . model_name_or_path , cache_dir = model_args . cache_dir , torch_dtype = torch . bfloat16 , trust_remote_code = True , attn_implementation = 'eager' ) # Resize model embeddings to accommodate new tokens print ( f \"Resizing model embeddings to { len ( tokenizer ) } tokens\" ) model . resize_token_embeddings ( len ( tokenizer )) return model , tokenizer , original_vocab_size This is a critical function that extends the language model vocabulary to include SNAC tokens: Load Base Model : Loads the pretrained Gemma-3-270m model and tokenizer Add Special Tokens : Adds SNAC special tokens ( <audio_start> , <audio_end> , etc.) Add SNAC Code Tokens : Creates tokens for all possible SNAC codes (e.g., <snac_l1_0> through <snac_l1_4095> for each layer) Resize Embeddings : Expands the model's embedding layer to accommodate the new tokens Embedding Resizing When new tokens are added, the model's embedding matrix must be resized. The new token embeddings are typically initialized randomly or copied from similar existing tokens. This is crucial for the model to learn meaningful representations of the audio tokens.","title":"Model and Tokenizer Setup"},{"location":"audio_intelligence/training_tts/#training-configuration","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 @dataclass class TrainingArgumentsCustom ( TrainingArguments ): output_dir = \"output_dir\" overwrite_output_dir : bool = field ( default = False ) do_train : bool = field ( default = True ) do_eval : bool = field ( default = False ) # Logging & Verbosity logging_steps : int = field ( default = 10 ) logging_first_step : bool = field ( default = True ) disable_tqdm : bool = field ( default = False ) report_to : str = field ( default = \"wandb\" ) # Training params per_device_train_batch_size : int = field ( default = 2 ) per_device_eval_batch_size : int = field ( default = 1 ) gradient_accumulation_steps : int = field ( default = 4 ) learning_rate : float = field ( default = 2e-4 ) weight_decay : float = field ( default = 0.01 ) num_train_epochs : float = field ( default = 20 ) lr_scheduler_type : str = field ( default = \"cosine\" ) warmup_ratio : float = field ( default = 0.1 ) save_total_limit : int = field ( default = 5 ) save_strategy : str = field ( default = \"steps\" ) save_steps : int = field ( default = 10 ) # Dataloader dataloader_num_workers : int = field ( default = 0 ) dataloader_pin_memory : bool = field ( default = False ) # Mixed precision fp16 : bool = field ( default = False ) bf16 : bool = field ( default = False ) # Other remove_unused_columns : bool = field ( default = False ) include_inputs_for_metrics : bool = field ( default = True ) prediction_loss_only : bool = field ( default = False ) The training arguments configure the fine-tuning process: Batch Size : per_device_train_batch_size=2 with gradient_accumulation_steps=4 gives an effective batch size of 8 Learning Rate : 2e-4 is a common starting point for fine-tuning language models Scheduler : Cosine learning rate schedule with 10% warmup Mixed Precision : Can use bf16 or fp16 for faster training and lower memory usage Experimentation You are invited to experiment with different learning rates, batch sizes, gradient accumulation steps, number of training epochs, etc. to get the best performance.","title":"Training Configuration"},{"location":"audio_intelligence/training_tts/#training-execution","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # Initialize configurations model_args = ModelArguments () data_args = DataArguments () training_args = TrainingArgumentsCustom () # Load datasets train_dataset , eval_dataset = load_snac_dataset ( data_args ) # Setup model and tokenizer model , tokenizer , original_vocab_size = setup_model_and_tokenizer ( model_args ) # Prepare datasets train_dataset , eval_dataset = prepare_datasets ( train_dataset , eval_dataset , tokenizer , data_args ) # Data collator for language modeling data_collator = DataCollatorForLanguageModeling ( tokenizer = tokenizer , mlm = False , # We're doing causal LM, not masked LM pad_to_multiple_of = 8 if training_args . fp16 or training_args . bf16 else None , return_tensors = \"pt\" ) # Initialize the SFTTrainer trainer = SFTTrainer ( model = model , train_dataset = train_dataset , args = training_args , data_collator = data_collator , ) # Start training print ( \"Starting model training...\" ) trainer . train () print ( \"Training finished.\" ) The training pipeline: Load Data : Loads text-SNAC code pairs from the dataset Setup Model : Extends the vocabulary and resizes embeddings Preprocess : Converts SNAC codes to tokens and formats training sequences Data Collator : Handles batching and padding for causal language modeling Train : Uses SFTTrainer to fine-tune the model The DataCollatorForLanguageModeling with mlm=False is configured for causal language modeling, where the model predicts the next token in the sequence. And we are done! Once you perform the training, you should see a training log like shown below: Training Log for LLM + Neural Codec TTS Model But Mohit, it's overfitting! Yes, sir! This is expected because we are using a very small dataset, and training for multiple epochs. This tutorial is meant to give you a starting point and a reference implementation. Head over to the conclusion section for next steps and my comments. We are just getting started.","title":"Training Execution"},{"location":"audio_intelligence/training_tts/#inference","text":"After training, inference involves: Text Input : Provide text to the model Token Generation : Model generates SNAC tokens autoregressively Token Parsing : Extract SNAC codes from generated tokens Audio Decoding : Use SNAC decoder to convert codes back to audio waveform Here's a complete inference implementation: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 import torch from snac import SNAC # assuming the model and tokenizer are already loaded # Prepare text input text = \"Please have mercy on my dainty, frail body. Your coils are so strong and powerful, and I am powerless to resist. <audio_start>\" input_ids = tokenizer . encode ( text , return_tensors = \"pt\" ) # Generate SNAC tokens (model generates token IDs) with torch . no_grad (): outputs = model . generate ( ** inputs , max_new_tokens = 900 , temperature = 0.7 , top_k = 50 , top_p = 0.90 , num_return_sequences = 1 , eos_token_id = 262146 , # this is the end of audio token id use_cache = True ) # Parse SNAC codes from the generated token IDs def parse_snac_codes ( output ): \"\"\"Extract SNAC codes from model output token IDs.\"\"\" codes = [[], [], []] # Filter tokens that are SNAC tokens (token IDs >= 262173) # This threshold corresponds to the start of SNAC token vocabulary tokens = [ x for x in output if x >= 262173 ] # Process tokens in batches of 7 (1 from layer 1, 2 from layer 2, 4 from layer 3) for frame_i in range ( len ( tokens ) // 7 ): # Extract code for layer 1 (first token in frame) codes [ 0 ] . extend ([( tokens [ frame_i * 7 ] - 262173 ) % 4096 ]) # Extract codes for layer 2 (tokens 1-2 in frame) codes [ 1 ] . extend ([( tokens [( frame_i * 7 ) + x ] - 262173 ) % 4096 for x in range ( 1 , 3 )]) # Extract codes for layer 3 (tokens 3-6 in frame) codes [ 2 ] . extend ([( tokens [( frame_i * 7 ) + x ] - 262173 ) % 4096 for x in range ( 3 , 7 )]) # Convert to torch tensors with batch dimension encoded = [ torch . tensor ( codes [ 0 ]) . unsqueeze ( 0 ), torch . tensor ( codes [ 1 ]) . unsqueeze ( 0 ), torch . tensor ( codes [ 2 ]) . unsqueeze ( 0 ) ] return encoded # Parse the generated tokens to extract SNAC codes encoded = parse_snac_codes ( outputs [ 0 ] . cpu () . detach () . numpy ()) # Verify the shapes match expected SNAC format print ( f \"Layer 1 shape: { encoded [ 0 ] . shape } \" ) print ( f \"Layer 2 shape: { encoded [ 1 ] . shape } \" ) print ( f \"Layer 3 shape: { encoded [ 2 ] . shape } \" ) # Decode SNAC codes back to audio waveform decoded_audio = snac_model . decode ( encoded ) # The decoded audio is a tensor, convert to numpy for playback/saving audio_array = decoded_audio . detach () . cpu () . numpy () . squeeze () sampling_rate = 24000 # SNAC 24kHz model # Save or play the audio # from scipy.io import wavfile # wavfile.write(\"output.wav\", sampling_rate, audio_array) # PLay the audio # AudioPlayer(audio_array, rate=sampling_rate)","title":"Inference"},{"location":"audio_intelligence/training_tts/#understanding-the-parsing-function","text":"The parse_snac_codes function performs several key operations: Token Filtering : It filters tokens with IDs >= 262173, which corresponds to the start of the SNAC token vocabulary in the extended model. Frame Processing : The function processes tokens in batches of 7, matching the SNAC frame structure: 1 token from layer 1 (coarse structure) 2 tokens from layer 2 (medium detail) 4 tokens from layer 3 (fine detail) Code Extraction : For each token, it: Subtracts 262173 to get the relative token ID within SNAC vocabulary Takes modulo 4096 to extract the actual code value (since each layer has 4096 possible codes: 0-4095) Tensor Conversion : Converts the extracted codes into PyTorch tensors with the batch dimension, matching the format expected by the SNAC decoder. Token ID Threshold The threshold value 262173 is specific to this model configuration. It represents the starting token ID of SNAC tokens in the extended vocabulary. If you're using a different base model or have a different vocabulary size, you'll need to adjust this threshold accordingly. You can verify this by checking the tokenizer's vocabulary size before and after adding SNAC tokens.","title":"Understanding the Parsing Function"},{"location":"audio_intelligence/training_tts/#best-practices","text":"Data Quality : Ensure high-quality text-audio pairs with accurate transcriptions Sequence Length : Balance max_seq_length between model capacity and training efficiency Learning Rate : Start with lower learning rates (1e-4 to 5e-4) for fine-tuning Gradient Accumulation : Use gradient accumulation to simulate larger batch sizes Checkpointing : Save checkpoints regularly to resume training if interrupted Evaluation : Monitor both training loss and audio quality metrics (e.g., MOS, SECS)","title":"Best Practices"},{"location":"audio_intelligence/training_tts/#conclusion","text":"Training TTS models using LLM-based approaches with neural codecs represents a powerful paradigm that combines the strengths of modern language models with efficient audio representations. By treating audio generation as a sequence-to-sequence problem, we can leverage transfer learning and achieve high-quality speech synthesis. The key is understanding how to convert audio to discrete tokens, extend model vocabularies, and train the model to learn the text-to-audio mapping. As stated before, this tutorial is meant to give you a starting point and a reference implementation. We are just getting started with the journey of training TTS models. I think there are multiple ways to improve the performance of the model. Some ways are: Use a larger dataset (currently it is trained on ~1000 samples, we need to atleast 10x the size to get respectable results) Data Preprocessing (we can preprocess the data to handle the special tokens and to make sure the data is in the correct format. We can further break the audio into smaller and cleaner chunks, clean the audio by denoising, etc) Data Diversification (we need to diversify the data to improve the performance of the model. We can use data augmentation techniques or have audio from multiple speakers speaking in different speed, pitch, language, accent, etc) Use Reinforcement Learning to fine-tune the model (we can add explicit rewards like WER, SECS, etc to the training loop to improve the quality of the generated speech) and more... Maybe more on this in future guides! Do let me know if you have any questions or suggestions. If you want to contribute to this guide, please feel free to submit a pull request . If you want to discuss something, please feel free to reach out to me on LinkedIn .","title":"Conclusion"},{"location":"audio_intelligence/tts/","text":"Introduction Text to Speech (TTS) is the process of generating synthesized speech for a given text input. This is a complicated task as the generating system has to consider context-based pronunciations, tone, rhythm, language, accent, etc. That said, recent research has achieved significant improvement in overall performance. Speech synthesis is quite old; in fact, Wolfgang von Kempelen, a Hungarian scientist, constructed a speaking machine with a series of bellows, springs, and bagpipes in the second half of the 18th century. Before moving forward, let\u2019s get accustomed to some basic terms related to speech, Phoneme: It is the smallest unit of speech. In English language there are a total of 44 phonemes. Grapheme: Group of letters that represent speech. Count is 250 Syllable: Combination of phonemes to create an intelligent pattern of speech. Count is ~15k Wolfgang von Kempelen ... second half of the 18th century (Created by Stable Diffusion 2.1) Types of TTS Let's start with a quick detour of different important types of TTS systems, [1] Concatenative Synthesis: Concatenative synthesis is based on combining pieces of speech stored in a database. This database usually contains speech units ranging from full sentences to individual syllables, all recorded by voice actors. There are two major problems with this approach, (a) we require a huge database of recordings (which is nearly impossible if you consider all combinations) , and (b) the generated voice is not that smooth. Statistical Parametric Speech Synthesis : SPSS usually consists of three components: a text analysis module, a parameter prediction module (acoustic model), and a vocoder analysis/synthesis module (vocoder). The text analysis module first processes the text, and then extracts the linguistic features, such as phonemes, duration and POS tags from different granularities. The acoustic model process the linguistic features to generate acoustic features which is then processed by the vocoder to generate the waveform. Neural Speech Synthesis: Recent enhancements in Neural Network (NN) based approaches have led to the use of NN in TTS. Usually, these models takes either of the two approaches, (a) replace one or many of the SPSS components with respective NN models, or (b) use an end-to-end NN based model that replaces all SPSS components with one NN. Components of TTS Next, let\u2019s discuss the components of the SPSS in more detail as they are the common denominator in TTS systems. We will go through them one by one. [1] Text analysis: It is used to extract linguistic features from the raw text data. Some common tasks are, Text normalization: We can start with converting non-standard words into spoken forms which can make the words easier to pronounce for the TTS models. Ex: year \u201c1989\u201d into \u201cnineteen eighty-nine\u201d Word Segmentation: Identifying different words in a text seems trivial in alphabet-based languages like English (use spaces) but it is quite tedious in character-based languages like Chinese. POS tagging: Identifying part of speech (like noun, adjective, etc) is important as different words have different pronunciations based on where and how they are used. Prosody prediction: Rhythm, stress, intonation corresponds to variations in syllable duration, loudness and pitch. This plays an important part on how human-like the speech is. Prosody prediction used tagging system to label each kind of prosody and ToBI (tagging and break indices) is a popular tagging system for English. Grapheme to Phoneme Conversion: Converting characters to pronunciation can greatly help with the speech synthesis process. Ex: \u201cspeech\u201d is converted to \u201cs p iy ch\u201d. Acoustic Models: They generate acoustic features from linguistics features or directly from phonemes or characters. While there are several models used in SPSS systems, let\u2019s focus on NN based approaches. RNN-based models: Tacotron leverages an encoder-decoder framework and takes characters as input and outputs linear-spectrograms, and uses Griffin Lim algorithm to generate waveform. Tacotron 2 generates mel-spectrograms and converts them into waveform using an additional WaveNet model. CNN-based models: DeepVoice utilises convolutional neural networks to obtain linguistic features. Then it leverages a WaveNet based vocoder to generate waveform. DeepVoice 2 introduced multi-speaker modeling. DeepVoice 3 leverages a fully-convolutional network structure for speech synthesis, which generates mel-spectrograms from characters and can scale up to real-word multi-speaker datasets. Transformers-based models: TransformerTTS leverage transformer based encoder-attention-decoder architecture to generate mel-spectrogram from phonemes. It tackles two flaws of RNN, (a) RNN based encoder and decoder cannot be trained in parallel due to their recurrent nature, and (b) RNN is not good for long generations. While the voice quality is on par with Tacotron, the generations are not that robust (ex: same word repeating multiple times or missing some words) . FastSpeech mitigated the issues by adopting fast-forward Transformer network and removing the attention mechanism between text and speech. (It is deployed in AzureTTS services) . FastSpeech 2 further improves the overall performance. Vocoder: Early neural vocoders such as WaveNet, Char2Wav, WaveRNN directly take linguistic features as input and generate waveform. Later versions take mel-spectrograms as input and generate waveform. Since speech waveform is very long, autoregressive waveform generation takes much inference time. Thus, generative models such as Flow, GAN, VAE, and DDPM (Denoising Diffusion Probabilistic Model, Diffusion for short) are used in waveform generation. Different TTS models and their classification in different types of TTS Systems. Source [1] Evaluating TTS Models Benchmarking TTS model is a challenging tasks as we have to consider various aspects of the generated speech like pronunciation, intonation, naturalness, clarity, similarity with speaker, etc. Hence it make sense to have combination of subjective and objective metrics to evaluate a TTS model. Let's discuss some of the metrics, Mean Opinion Score (MOS) : it is a subjective score where human evaluator are asked to score synthesized speech on a scale of 1 to 5 (higher the better) SECS : it stands for \"Speaker Encoder Cosine Similarity\" and it is used in voice cloning tasks to measure similarity between the generated speech and the reference speech of a target speaker. The idea is that if the generated speech is really good wrt voice cloning perspective, then the speaker encoders will give relatively similar embeddings to the output and reference speech and the SECS should be high. Word Error Rate (WER) : WER can also be used in TTS domain to make sure that the generated speech is coherent with the reference speech. Hint For any one project, make sure to use the same speaker encoder for SECS and transcription system for WER metric computation. Code There are lot of open source python package for TTS like Coqui TTS , Mozilla TTS , OpenTTS , ESPNet , PaddleSpeech , etc. Let's go through some of the most famous and easy to use ones, Coqui TTS For this tutorial, let's use Coqui TTS as it is one of the simplest package in terms of usability. In fact you just need to install the package with pip install TTS and then run the server with tts-server , and thats it! It will run a http dashboard on the localhost woth default model and vocoder like shown below, Coqui TTS server dashboard I tried it for \"my name is Mohit\" text and the result is shared below. Btw you can switch to different models or speakers to get different sounding speech. Your browser does not support the audio element. You can check out other models and vocoder available in the package with tts-server --list_models . Note, not all models and vocoder pairs are comparable. On top of this, Coqui TTS also provides the option to train and finetune the models further! OpenTTS Another good package is OpenTTS that unifies access to multiple open source text to speech systems and voices for many languages. One distinctive feature is the partial support to SSML i.e. Speech Synthesis Markup Language. It is a XML-based markup language for assisting the generation of synthetic speech in Web and other applications. One example as shared in their readme is shown below, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 <speak> The 1st thing to remember is that 27 languages are supported in Open TTS as of 10/13/2021 at 3pm. <voice name= \"glow-speak:en-us_mary_ann\" > <s> The current voice can be changed, even to a different text to speech system! </s> </voice> <voice name= \"coqui-tts:en_vctk#p228\" > <s> Breaks are possible </s> <break time= \"0.5s\" /> <s> between sentences. </s> </voice> <s lang= \"en\" > One language is never enough </s> <s lang= \"de\" > Eine Sprache ist niemals genug </s> <s lang= \"ja\" > \u8a00\u8a9e\u3092\u4e00\u3064\u306f\u6c7a\u3057\u3066\u8db3\u308a\u306a\u3044 </s> <s lang= \"sw\" > Lugha moja haitoshi </s> </speak> SSML support can lead to generation of complex and realistic sound as you can add sentence breaks, pauses, handle spelling out of numbers or date, change model or even languages for a single generation! The package is quite simple to run. First you need to install docker , and then download and run a docker image with docker run -it -p 5500:5500 synesthesiam/opentts:<LANGUAGE> , where <LANGUAGE> could be any of the 20 supported langauge. To begin with you can try en . The downloading will take some time (more than 5GB is downloaded!) but once done, you can access the dashboard on http://localhost:5500 or hit the HTTP APIs on http://localhost:5500/openapi/ . The endpoint details can be found here and the complete list of voices generated by the available models is shared here . Dashboard of OpenTTS I tried it for text \"Hello, how are you? My number is 7350.\" by selecting the coqui-tts: vctk model and ED (0) speaker. The output is quite good and shared below, Your browser does not support the audio element. Additional Materials [1] Paper - A Survey on Neural Speech Synthesis [2] Speech synthesis: A review of the best text to speech architectures with Deep Learning","title":"TTS Introduction"},{"location":"audio_intelligence/tts/#introduction","text":"Text to Speech (TTS) is the process of generating synthesized speech for a given text input. This is a complicated task as the generating system has to consider context-based pronunciations, tone, rhythm, language, accent, etc. That said, recent research has achieved significant improvement in overall performance. Speech synthesis is quite old; in fact, Wolfgang von Kempelen, a Hungarian scientist, constructed a speaking machine with a series of bellows, springs, and bagpipes in the second half of the 18th century. Before moving forward, let\u2019s get accustomed to some basic terms related to speech, Phoneme: It is the smallest unit of speech. In English language there are a total of 44 phonemes. Grapheme: Group of letters that represent speech. Count is 250 Syllable: Combination of phonemes to create an intelligent pattern of speech. Count is ~15k Wolfgang von Kempelen ... second half of the 18th century (Created by Stable Diffusion 2.1)","title":"Introduction"},{"location":"audio_intelligence/tts/#types-of-tts","text":"Let's start with a quick detour of different important types of TTS systems, [1] Concatenative Synthesis: Concatenative synthesis is based on combining pieces of speech stored in a database. This database usually contains speech units ranging from full sentences to individual syllables, all recorded by voice actors. There are two major problems with this approach, (a) we require a huge database of recordings (which is nearly impossible if you consider all combinations) , and (b) the generated voice is not that smooth. Statistical Parametric Speech Synthesis : SPSS usually consists of three components: a text analysis module, a parameter prediction module (acoustic model), and a vocoder analysis/synthesis module (vocoder). The text analysis module first processes the text, and then extracts the linguistic features, such as phonemes, duration and POS tags from different granularities. The acoustic model process the linguistic features to generate acoustic features which is then processed by the vocoder to generate the waveform. Neural Speech Synthesis: Recent enhancements in Neural Network (NN) based approaches have led to the use of NN in TTS. Usually, these models takes either of the two approaches, (a) replace one or many of the SPSS components with respective NN models, or (b) use an end-to-end NN based model that replaces all SPSS components with one NN.","title":"Types of TTS"},{"location":"audio_intelligence/tts/#components-of-tts","text":"Next, let\u2019s discuss the components of the SPSS in more detail as they are the common denominator in TTS systems. We will go through them one by one. [1] Text analysis: It is used to extract linguistic features from the raw text data. Some common tasks are, Text normalization: We can start with converting non-standard words into spoken forms which can make the words easier to pronounce for the TTS models. Ex: year \u201c1989\u201d into \u201cnineteen eighty-nine\u201d Word Segmentation: Identifying different words in a text seems trivial in alphabet-based languages like English (use spaces) but it is quite tedious in character-based languages like Chinese. POS tagging: Identifying part of speech (like noun, adjective, etc) is important as different words have different pronunciations based on where and how they are used. Prosody prediction: Rhythm, stress, intonation corresponds to variations in syllable duration, loudness and pitch. This plays an important part on how human-like the speech is. Prosody prediction used tagging system to label each kind of prosody and ToBI (tagging and break indices) is a popular tagging system for English. Grapheme to Phoneme Conversion: Converting characters to pronunciation can greatly help with the speech synthesis process. Ex: \u201cspeech\u201d is converted to \u201cs p iy ch\u201d. Acoustic Models: They generate acoustic features from linguistics features or directly from phonemes or characters. While there are several models used in SPSS systems, let\u2019s focus on NN based approaches. RNN-based models: Tacotron leverages an encoder-decoder framework and takes characters as input and outputs linear-spectrograms, and uses Griffin Lim algorithm to generate waveform. Tacotron 2 generates mel-spectrograms and converts them into waveform using an additional WaveNet model. CNN-based models: DeepVoice utilises convolutional neural networks to obtain linguistic features. Then it leverages a WaveNet based vocoder to generate waveform. DeepVoice 2 introduced multi-speaker modeling. DeepVoice 3 leverages a fully-convolutional network structure for speech synthesis, which generates mel-spectrograms from characters and can scale up to real-word multi-speaker datasets. Transformers-based models: TransformerTTS leverage transformer based encoder-attention-decoder architecture to generate mel-spectrogram from phonemes. It tackles two flaws of RNN, (a) RNN based encoder and decoder cannot be trained in parallel due to their recurrent nature, and (b) RNN is not good for long generations. While the voice quality is on par with Tacotron, the generations are not that robust (ex: same word repeating multiple times or missing some words) . FastSpeech mitigated the issues by adopting fast-forward Transformer network and removing the attention mechanism between text and speech. (It is deployed in AzureTTS services) . FastSpeech 2 further improves the overall performance. Vocoder: Early neural vocoders such as WaveNet, Char2Wav, WaveRNN directly take linguistic features as input and generate waveform. Later versions take mel-spectrograms as input and generate waveform. Since speech waveform is very long, autoregressive waveform generation takes much inference time. Thus, generative models such as Flow, GAN, VAE, and DDPM (Denoising Diffusion Probabilistic Model, Diffusion for short) are used in waveform generation. Different TTS models and their classification in different types of TTS Systems. Source [1]","title":"Components of TTS"},{"location":"audio_intelligence/tts/#evaluating-tts-models","text":"Benchmarking TTS model is a challenging tasks as we have to consider various aspects of the generated speech like pronunciation, intonation, naturalness, clarity, similarity with speaker, etc. Hence it make sense to have combination of subjective and objective metrics to evaluate a TTS model. Let's discuss some of the metrics, Mean Opinion Score (MOS) : it is a subjective score where human evaluator are asked to score synthesized speech on a scale of 1 to 5 (higher the better) SECS : it stands for \"Speaker Encoder Cosine Similarity\" and it is used in voice cloning tasks to measure similarity between the generated speech and the reference speech of a target speaker. The idea is that if the generated speech is really good wrt voice cloning perspective, then the speaker encoders will give relatively similar embeddings to the output and reference speech and the SECS should be high. Word Error Rate (WER) : WER can also be used in TTS domain to make sure that the generated speech is coherent with the reference speech. Hint For any one project, make sure to use the same speaker encoder for SECS and transcription system for WER metric computation.","title":"Evaluating TTS Models"},{"location":"audio_intelligence/tts/#code","text":"There are lot of open source python package for TTS like Coqui TTS , Mozilla TTS , OpenTTS , ESPNet , PaddleSpeech , etc. Let's go through some of the most famous and easy to use ones,","title":"Code"},{"location":"audio_intelligence/tts/#coqui-tts","text":"For this tutorial, let's use Coqui TTS as it is one of the simplest package in terms of usability. In fact you just need to install the package with pip install TTS and then run the server with tts-server , and thats it! It will run a http dashboard on the localhost woth default model and vocoder like shown below, Coqui TTS server dashboard I tried it for \"my name is Mohit\" text and the result is shared below. Btw you can switch to different models or speakers to get different sounding speech. Your browser does not support the audio element. You can check out other models and vocoder available in the package with tts-server --list_models . Note, not all models and vocoder pairs are comparable. On top of this, Coqui TTS also provides the option to train and finetune the models further!","title":"Coqui TTS"},{"location":"audio_intelligence/tts/#opentts","text":"Another good package is OpenTTS that unifies access to multiple open source text to speech systems and voices for many languages. One distinctive feature is the partial support to SSML i.e. Speech Synthesis Markup Language. It is a XML-based markup language for assisting the generation of synthetic speech in Web and other applications. One example as shared in their readme is shown below, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 <speak> The 1st thing to remember is that 27 languages are supported in Open TTS as of 10/13/2021 at 3pm. <voice name= \"glow-speak:en-us_mary_ann\" > <s> The current voice can be changed, even to a different text to speech system! </s> </voice> <voice name= \"coqui-tts:en_vctk#p228\" > <s> Breaks are possible </s> <break time= \"0.5s\" /> <s> between sentences. </s> </voice> <s lang= \"en\" > One language is never enough </s> <s lang= \"de\" > Eine Sprache ist niemals genug </s> <s lang= \"ja\" > \u8a00\u8a9e\u3092\u4e00\u3064\u306f\u6c7a\u3057\u3066\u8db3\u308a\u306a\u3044 </s> <s lang= \"sw\" > Lugha moja haitoshi </s> </speak> SSML support can lead to generation of complex and realistic sound as you can add sentence breaks, pauses, handle spelling out of numbers or date, change model or even languages for a single generation! The package is quite simple to run. First you need to install docker , and then download and run a docker image with docker run -it -p 5500:5500 synesthesiam/opentts:<LANGUAGE> , where <LANGUAGE> could be any of the 20 supported langauge. To begin with you can try en . The downloading will take some time (more than 5GB is downloaded!) but once done, you can access the dashboard on http://localhost:5500 or hit the HTTP APIs on http://localhost:5500/openapi/ . The endpoint details can be found here and the complete list of voices generated by the available models is shared here . Dashboard of OpenTTS I tried it for text \"Hello, how are you? My number is 7350.\" by selecting the coqui-tts: vctk model and ED (0) speaker. The output is quite good and shared below, Your browser does not support the audio element.","title":"OpenTTS"},{"location":"audio_intelligence/tts/#additional-materials","text":"[1] Paper - A Survey on Neural Speech Synthesis [2] Speech synthesis: A review of the best text to speech architectures with Deep Learning","title":"Additional Materials"},{"location":"audio_intelligence/voice_activity_detection/","text":"Introduction \ud83d\udde3 Voice activity detection (VAD) is the process of identifying the chunks or parts of an audio stream that contains certain \"voiced activities\". There could be different types of activity detection modules depending on the type of voice we want to identify. It could be human voice (in a conversation) or animal voice (in forest) or something else entirely! a drawing of head of human, dog and cat speaking something Created using DallE Steps in VAD The complete VAD process can be broken down to two simple steps, Step 1: we start with dividing the audio into multiple chunks of small sizes. Usually these chunks are quite small like 10ms , 20ms or 30ms . Step 2: we have a classifier or detector, that takes the chunk as input and predicts if the chunk has voice or not. The classifier could be a simple logic based algorithm or even neural network models. It depends on the acceptable tradeoff between accuracy and speed. Code Py-WebRTC VAD For practice, we will use Py-WebRTC VAD package that is a port to the WebRTC project by Google. It provides sufficiently good accuracy with lightening speed! \u26a1\ufe0f The complete code is shown below, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 # Python 3.8 on Macbook Pro M1 2020 # import import struct import librosa # librosa==0.9.1 import webrtcvad # webrtcvad==2.0.10 # load data file_path = 'hello_my_name_is_mohit.wav' # load wav file (librosa) y , sr = librosa . load ( file_path , sr = 16000 ) # convert the file to int if it is in float (Py-WebRTC requirement) if y . dtype . kind == 'f' : # convert to int16 y = np . array ([ int ( s * 32768 ) for s in y ]) # bound y [ y > 32767 ] = 32767 y [ y < - 32768 ] = - 32768 # create raw sample in bit raw_samples = struct . pack ( \" %d h\" % len ( y ), * y ) # define webrtcvad VAD vad = webrtcvad . Vad ( 3 ) # set aggressiveness from 0 to 3 window_duration = 0.03 # duration in seconds samples_per_window = int ( window_duration * sr + 0.5 ) bytes_per_sample = 2 # for int16 # Start classifying chunks of samples # var to hold segment wise report segments = [] # iterate over the audio samples for i , start in enumerate ( np . arange ( 0 , len ( y ), samples_per_window )): stop = min ( start + samples_per_window , len ( y )) loc_raw_sample = raw_samples [ start * bytes_per_sample : stop * bytes_per_sample ] try : is_speech = vad . is_speech ( loc_raw_sample , sample_rate = sr ) segments . append ( dict ( start = start , stop = stop , is_speech = is_speech )) except Exception as e : print ( f \"Failed for step { i } , reason: { e } \" ) # import pandas as pd # pd.DataFrame(segments) # result of classification Let's go through the code, Line 3-5 : we import the required packages. Make sure to install them using pip before starting. In case you are facing some issue, please install the specificed python and package versions (mentioned in the code) . Line 7- 18 : we read a sample wav file (use your own ) and then transform the bit depth of the audio into int16 . One point to note here is that webrtcvad only works for sample rate = 16000 and bit depth = int16 . And librosa loads an audio file in float. Because of all this requirement we need to perform the transformations. Line 21 : we transform the numpy array (format in which an audio file is loaded in librosa ) to byte string. This will be required for chunking and VAD analysis. Line 24-27 : we initialize an instance of webrtcvad with aggressiveness parameter. Note, the range is form 0 to 3, and higher the value, the more strict VAD is in classification chunks as voice. This means, you can miss some relevant voice chunks for higher aggressiveness and on the other hand get some false positives with lower aggressiveness. Line 31-45 : the code to first create chunks of the audio and then perform VAD classification at line 37-38 . The final results is stored in segments variable and a sample output is shown below, start stop is_speech 0 480 True 480 960 True 960 1440 False 1440 1920 False 1920 2400 False Here, each row denotes one chunk. The start and stop columns contain the begin and end details of each chunk. Finally the is_speech column contains True or False value depedening on if the chunk was detected as voice chunk or not. Here is the code's output visualized in form of waveform with vice chunks highlighted. Waveform of audio with webrtcvad detected voice chunks highlighted with yellow line on top. The aggressiveness parameter value was 0, hence lot's of false positive (chunks with no voice) are detected as well. Same as above, but with aggressiveness parameter value set to 3. Hence the detection is quite strict (some voice parts are missed) . Silero-VAD Hint Personal experience - Silerio-VAD is much more efficient and accurate than Py-WebRTC VAD. It is highly recommended even for production systems. Silero-VAD is another voice activity detection model that stands out for its stellar accuracy and speed. The model can process an audio chunk of over 30 milliseconds in less than 1 millisecond on a single CPU thread. This performance can be further enhanced through batching or GPU usage, with ONNX potentially offering a 4-5 times speed increase under certain conditions. Additionally, Silero VAD's lightweight nature is evident in its JIT model, which is approximately one megabyte in size, making it highly efficient and easy to integrate into various applications. Beyond its technical prowess, Silero VAD is notable for its general applicability and flexibility. It was trained on a vast corpus covering over 100 languages, enabling it to perform effectively across a range of audio types, from different domains to various background noise and quality levels. The model supports 8000 Hz and 16000 Hz sampling rates, accommodating different audio quality requirements. Furthermore, while it was trained on 30 ms chunks, it can handle longer chunks directly, and possibly even shorter ones. Its high portability is another advantage, benefiting from the robust ecosystems of PyTorch and ONNX, and it can run wherever these frameworks are available. Finally, Silero VAD is published under the permissive MIT license. Now, let's try it out ( Refer ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # import import torch # load the silerio vad model model , utils = torch . hub . load ( repo_or_dir = 'snakers4/silero-vad' , model = 'silero_vad' , force_reload = True , onnx = False ) # perform `pip install -q onnxruntime` and set this to True, if you want to use ONNX # get the helper functions out of util ( get_speech_timestamps , save_audio , read_audio , VADIterator , collect_chunks ) = utils # Option 1: Process complete audio wav = read_audio ( 'example.wav' , sampling_rate = SAMPLING_RATE ) speech_timestamps = get_speech_timestamps ( wav , model , sampling_rate = SAMPLING_RATE ) # Output: [{'end': 31200, 'start': 1568}, # {'end': 73696, 'start': 42528}, ..] # Option 2: Run on small chunks for chunk in chunk_list : speech_prob = model ( chunk , SAMPLING_RATE ) . item () print ( speech_prob ) ## Output: 0.06508486717939377 ## If the probability is more than a threshold, then it is speech. ## The threshold is an hyperparameter and can be experimented for each use case. Default value of 0.5 can be used here. model . reset_states () # reset state after every audio Warning For consistent results, use model.reset_states() after every audio chunk. Refer here for more details.","title":"Voice Activity Detection"},{"location":"audio_intelligence/voice_activity_detection/#introduction","text":"\ud83d\udde3 Voice activity detection (VAD) is the process of identifying the chunks or parts of an audio stream that contains certain \"voiced activities\". There could be different types of activity detection modules depending on the type of voice we want to identify. It could be human voice (in a conversation) or animal voice (in forest) or something else entirely! a drawing of head of human, dog and cat speaking something Created using DallE","title":"Introduction"},{"location":"audio_intelligence/voice_activity_detection/#steps-in-vad","text":"The complete VAD process can be broken down to two simple steps, Step 1: we start with dividing the audio into multiple chunks of small sizes. Usually these chunks are quite small like 10ms , 20ms or 30ms . Step 2: we have a classifier or detector, that takes the chunk as input and predicts if the chunk has voice or not. The classifier could be a simple logic based algorithm or even neural network models. It depends on the acceptable tradeoff between accuracy and speed.","title":"Steps in VAD"},{"location":"audio_intelligence/voice_activity_detection/#code","text":"","title":"Code"},{"location":"audio_intelligence/voice_activity_detection/#py-webrtc-vad","text":"For practice, we will use Py-WebRTC VAD package that is a port to the WebRTC project by Google. It provides sufficiently good accuracy with lightening speed! \u26a1\ufe0f The complete code is shown below, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 # Python 3.8 on Macbook Pro M1 2020 # import import struct import librosa # librosa==0.9.1 import webrtcvad # webrtcvad==2.0.10 # load data file_path = 'hello_my_name_is_mohit.wav' # load wav file (librosa) y , sr = librosa . load ( file_path , sr = 16000 ) # convert the file to int if it is in float (Py-WebRTC requirement) if y . dtype . kind == 'f' : # convert to int16 y = np . array ([ int ( s * 32768 ) for s in y ]) # bound y [ y > 32767 ] = 32767 y [ y < - 32768 ] = - 32768 # create raw sample in bit raw_samples = struct . pack ( \" %d h\" % len ( y ), * y ) # define webrtcvad VAD vad = webrtcvad . Vad ( 3 ) # set aggressiveness from 0 to 3 window_duration = 0.03 # duration in seconds samples_per_window = int ( window_duration * sr + 0.5 ) bytes_per_sample = 2 # for int16 # Start classifying chunks of samples # var to hold segment wise report segments = [] # iterate over the audio samples for i , start in enumerate ( np . arange ( 0 , len ( y ), samples_per_window )): stop = min ( start + samples_per_window , len ( y )) loc_raw_sample = raw_samples [ start * bytes_per_sample : stop * bytes_per_sample ] try : is_speech = vad . is_speech ( loc_raw_sample , sample_rate = sr ) segments . append ( dict ( start = start , stop = stop , is_speech = is_speech )) except Exception as e : print ( f \"Failed for step { i } , reason: { e } \" ) # import pandas as pd # pd.DataFrame(segments) # result of classification Let's go through the code, Line 3-5 : we import the required packages. Make sure to install them using pip before starting. In case you are facing some issue, please install the specificed python and package versions (mentioned in the code) . Line 7- 18 : we read a sample wav file (use your own ) and then transform the bit depth of the audio into int16 . One point to note here is that webrtcvad only works for sample rate = 16000 and bit depth = int16 . And librosa loads an audio file in float. Because of all this requirement we need to perform the transformations. Line 21 : we transform the numpy array (format in which an audio file is loaded in librosa ) to byte string. This will be required for chunking and VAD analysis. Line 24-27 : we initialize an instance of webrtcvad with aggressiveness parameter. Note, the range is form 0 to 3, and higher the value, the more strict VAD is in classification chunks as voice. This means, you can miss some relevant voice chunks for higher aggressiveness and on the other hand get some false positives with lower aggressiveness. Line 31-45 : the code to first create chunks of the audio and then perform VAD classification at line 37-38 . The final results is stored in segments variable and a sample output is shown below, start stop is_speech 0 480 True 480 960 True 960 1440 False 1440 1920 False 1920 2400 False Here, each row denotes one chunk. The start and stop columns contain the begin and end details of each chunk. Finally the is_speech column contains True or False value depedening on if the chunk was detected as voice chunk or not. Here is the code's output visualized in form of waveform with vice chunks highlighted. Waveform of audio with webrtcvad detected voice chunks highlighted with yellow line on top. The aggressiveness parameter value was 0, hence lot's of false positive (chunks with no voice) are detected as well. Same as above, but with aggressiveness parameter value set to 3. Hence the detection is quite strict (some voice parts are missed) .","title":"Py-WebRTC VAD"},{"location":"audio_intelligence/voice_activity_detection/#silero-vad","text":"Hint Personal experience - Silerio-VAD is much more efficient and accurate than Py-WebRTC VAD. It is highly recommended even for production systems. Silero-VAD is another voice activity detection model that stands out for its stellar accuracy and speed. The model can process an audio chunk of over 30 milliseconds in less than 1 millisecond on a single CPU thread. This performance can be further enhanced through batching or GPU usage, with ONNX potentially offering a 4-5 times speed increase under certain conditions. Additionally, Silero VAD's lightweight nature is evident in its JIT model, which is approximately one megabyte in size, making it highly efficient and easy to integrate into various applications. Beyond its technical prowess, Silero VAD is notable for its general applicability and flexibility. It was trained on a vast corpus covering over 100 languages, enabling it to perform effectively across a range of audio types, from different domains to various background noise and quality levels. The model supports 8000 Hz and 16000 Hz sampling rates, accommodating different audio quality requirements. Furthermore, while it was trained on 30 ms chunks, it can handle longer chunks directly, and possibly even shorter ones. Its high portability is another advantage, benefiting from the robust ecosystems of PyTorch and ONNX, and it can run wherever these frameworks are available. Finally, Silero VAD is published under the permissive MIT license. Now, let's try it out ( Refer ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # import import torch # load the silerio vad model model , utils = torch . hub . load ( repo_or_dir = 'snakers4/silero-vad' , model = 'silero_vad' , force_reload = True , onnx = False ) # perform `pip install -q onnxruntime` and set this to True, if you want to use ONNX # get the helper functions out of util ( get_speech_timestamps , save_audio , read_audio , VADIterator , collect_chunks ) = utils # Option 1: Process complete audio wav = read_audio ( 'example.wav' , sampling_rate = SAMPLING_RATE ) speech_timestamps = get_speech_timestamps ( wav , model , sampling_rate = SAMPLING_RATE ) # Output: [{'end': 31200, 'start': 1568}, # {'end': 73696, 'start': 42528}, ..] # Option 2: Run on small chunks for chunk in chunk_list : speech_prob = model ( chunk , SAMPLING_RATE ) . item () print ( speech_prob ) ## Output: 0.06508486717939377 ## If the probability is more than a threshold, then it is speech. ## The threshold is an hyperparameter and can be experimented for each use case. Default value of 0.5 can be used here. model . reset_states () # reset state after every audio Warning For consistent results, use model.reset_states() after every audio chunk. Refer here for more details.","title":"Silero-VAD"},{"location":"audio_intelligence/wav2vec2/","text":"Introduction Wav2Vec is a framework for self-supervised learning of representations from raw audio data. Basically it learns to efficiently represent the raw audio data as a vector space encoding. Illustration of the Wav2vec2 framework ( Wav2vec2 paper ) A major advantage of this approach is that we end up training a generic audio model that could be used for multiple downtream tasks! And because of the self-supervised learning, we don't need access to huge amount of labeled data. In the paper, after pre-training on unlabeled speech, the model is fine-tuned on small labeled data with a Connectionist Temporal Classification (CTC) loss for speech recognition task . Architecture The complete architecture of the framework can be divided into 3 components, they are Feature encoder : This is the encoder part of the model. It takes the raw audio data as input and outputs feature vectors. Input size is limited to 400 samples which is 20ms for 16kHz sample rate. The raw audio is first standardized to have zero mean and unit variance. Then it is passed to 1D convolutional neural network (temporal convolution) followed by layer normalization and GELU activation function. There could be 7 such convolution blocks with constant channel size (512), decreasing kernel width (10, 3x4, 2x2) and stride (5, 2x6). The output is list of feature vectors each with 512 dimensions. Transformers : The output of the feature encoder is passed on to a transformer layer. One differentiator is use of relative positional embedding by using convolution layers, rather than using fixed positional encoding as done in original Transformers paper. The block size differs, as 12 transformers block with model dimension of 768 is used in BASE model but 24 blocks with 1024 dimension in LARGE version. Quantization module : For self-supervised learning, we need to work with discrete outputs. For this, there is a quantization module that converts the continous vector output to discrete representations, and on top of it, it automatically learns the discrete speech units. This is done by maintaining multiple codebooks/groups (320 in size) and the units are sampled from each codebook are later concatenated (320x320=102400 possiblt speech units) . The sampling is done using Gumbel-Softmax which is like argmax but differentiable. Training To pre-train the model, Wav2Vec2 masks certain portions of time steps in the feature encoder which is similar to masked language model. The aim is to teach the model to predict the correct quantized latent audio representation in a set of distractors for each time step. The overall training objective is to minimize contrastive loss ( \\(L_m\\) ) and diversity loss ( \\(L_d\\) ) in \\(L = L_m + \\alpha L_d\\) . Contrastive loss is the performance on the self-supervised task. Diversity loss is designed to increase the use of the complete quantized codebook representations, and not only a select subset. For pretraining, the datasets used were (1) Librispeech corpus with 960 hours of audio data, (2) LibriVox 60k hours of audio data that was later subset to 53.2k hours. Only unlabeled data was used for pretraining. To make the model more robust to different tasks, we can finetune the model on a different task specific modifications and dataset. Here, the paper finetuned for ASR by adding a randomly initialized classification layer on top on Transformer layer with class size equal to the size of vocab. The model is optimized by minimizing the CTC loss. Adam was used as optimization algorithm and the learning rate is warmed up till 10% of the training duration, then kept constant for next 40% and finally linearly decayed for the remaining duration. Also, for the first 60k updates only output classifier was trained after which Transformer is also updated. The feature encoder is kept frozen (not trained at all). Results There are two interesting points to note from the results of the Wav2Vec2 model, The model is able to learn ASR with as minimum as 10 mins of labeled data! As shown below, \\(LARGE\\) model pre-trained on LV-60k and finetuned on Librispeech with CTC loss is giving 4.6/7.9 WER! This is a very good news incase you want to finetune the model for your domain or accent! The choice of decoder can lead to improvement in performance. As obvious from the results, Transformer decoder is giving best performance, followed by n-gram and then CTC decoding. But also note that the CTC decoding will gives the best inference speed. The suggested decoder could be 4-gram, as it provides huge improvement in performance by fixing the spellling mistakes and grammer issues of CTC and is still faster than Transformer decoders. WER on Librispeech dev/test data ( Wav2vec2 paper ) Code Offline transcription using Wav2Vec2 (CTC) Here is the code to perform offline transcription using Wav2Vec2 model with transformer package. Note the default decoder is CTC. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # import import torch import librosa from transformers import Wav2Vec2ForCTC , Wav2Vec2Tokenizer # load the tokenizer and model tokenizer = Wav2Vec2Tokenizer . from_pretrained ( \"facebook/wav2vec2-large-960h\" ) model = Wav2Vec2ForCTC . from_pretrained ( \"facebook/wav2vec2-large-960h\" ) # load the audio data (use your own wav file here!) input_audio , sr = librosa . load ( 'my_wav_file.wav' , sr = 16000 ) # tokenize input_values = tokenizer ( input_audio , return_tensors = \"pt\" , padding = \"longest\" ) . input_values # retrieve logits logits = model ( input_values ) . logits # take argmax and decode predicted_ids = torch . argmax ( logits , dim =- 1 ) transcription = tokenizer . batch_decode ( predicted_ids ) # print the output print ( transcription ) Offline transcription using Wav2Vec2 (N-gram) We can also use n-gram language model as decoder using a pre-trained model available in Huggingface. The usage is very similar to the CTC model, we just have to change the model name. Note, this downloads the Wav2Vec2 model plus the N-gram language model which will be around 3.2 GBs! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # install dependencies ! pip install pyctcdecode pypi - kenlm # import import librosa from transformers import Wav2Vec2ProcessorWithLM , Wav2Vec2ForCTC # load the processor processor = Wav2Vec2ProcessorWithLM . from_pretrained ( \"patrickvonplaten/wav2vec2-base-100h-with-lm\" ) model = Wav2Vec2ForCTC . from_pretrained ( \"facebook/wav2vec2-large-960h\" ) # load the audio data (use your own wav file here!) input_audio , sr = librosa . load ( 'my_wav_file.wav' , sr = 16000 ) # tokenize input_values = processor ( input_audio , return_tensors = \"pt\" , padding = \"longest\" ) . input_values # retrieve logits logits = model ( input_values ) . logits # decode using n-gram transcription = processor . batch_decode ( logits . detach () . numpy ()) . text # print the output print ( transcription ) Creating your own N-gram language model for Word2Vec2 To use n-gram model we can KenLM to create language model and then use pyctcdecode for decoding. This part is referenced from Huggingface blog on Wav2vec2 with n-gram . The steps are as follows, First, we will select one text dataset. This dataset can be the transcript of train data (part of labeled data we used to finetune Wav2Vec2 model) or a related (same domain like medical, telecom, etc) collection of documents. Next we can perform data cleaning like removing special characters and then combine the individual sentences to a free flow text and save that into text file. After this we can run KenLM to create a language model. kenlm/build/bin/lmplz -o 3 < \"text.txt\" > \"3-gram.arpa\" The .arpa file contains the n-gram language model that is ready to go with just two minor modifications. As per the Huggingface blog , we need to add </s> end of sentence token as 1 gram as well, so we open the arpa file, duplicate the existing <s> start of sentence token, and just replace the <s> with </s> . Next we also increment the count of 1-gram (present at the top of the .arpa file) by 1, because of what we just did. Then we save the file. Next, we load the a LM-less model and then we can use the pyctcdecode . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # Taken from Blog @ https://huggingface.co/blog/wav2vec2-with-ngram # import packages from transformers import AutoProcessor from pyctcdecode import build_ctcdecoder from transformers import Wav2Vec2ProcessorWithLM # load a LM-less model processor = AutoProcessor . from_pretrained ( \"hf-test/xls-r-300m-sv\" ) # get the vocabulary of the tokenizer vocab_dict = processor . tokenizer . get_vocab () sorted_vocab_dict = { k . lower (): v for k , v in sorted ( vocab_dict . items (), key = lambda item : item [ 1 ])} # build the decoder decoder = build_ctcdecoder ( labels = list ( sorted_vocab_dict . keys ()), kenlm_model_path = \"3-gram.arpa\" , ) # create a processor with the decoder processor_with_lm = Wav2Vec2ProcessorWithLM ( feature_extractor = processor . feature_extractor , tokenizer = processor . tokenizer , decoder = decoder ) # now the processor can be used for inference as shown in other above code sections. We can even reduce the size of the LM-model by converting it to a binary file. kenlm/build/bin/build_binary 3 -gram.arpa 3 -gram.bin Online transcription using Wav2Vec2 For live transcription using Wav2Vec2, we can utilize wav2vec2-live package. Once you have cloned the repo and installed the packages from requirements.txt , the live transcription can be started with (taken from the package readme and modified) , 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # import from live_asr import LiveWav2Vec2 # load model english_model = \"facebook/wav2vec2-large-960h-lv60-self\" asr = LiveWav2Vec2 ( english_model , device_name = \"default\" ) # start the live ASR asr . start () try : while True : text , sample_length , inference_time = asr . get_last_text () print ( f \"Duration: { sample_length : .3f } s \\t Speed: { inference_time : .3f } s \\t { text } \" ) except KeyboardInterrupt : asr . stop () This starts the Live ASR on your terminal. The code listen to the audio in your microphone, identifies the chunks with voice using VAD and then pass the voiced chunks to Wave2Vec2 for transcription. One sample output is shown below, listening to your voice Duration: 0 .780s Speed: 0 .205s hello Duration: 0 .780s Speed: 0 .190s hello Duration: 0 .960s Speed: 0 .223s my name .... Additional Materials An Illustrated Tour of Wav2vec 2.0 by Jonathan Bgn Boosting Wav2Vec2 with n-grams in \ud83e\udd17 Transformers","title":"Wav2Vec2 Model"},{"location":"audio_intelligence/wav2vec2/#introduction","text":"Wav2Vec is a framework for self-supervised learning of representations from raw audio data. Basically it learns to efficiently represent the raw audio data as a vector space encoding. Illustration of the Wav2vec2 framework ( Wav2vec2 paper ) A major advantage of this approach is that we end up training a generic audio model that could be used for multiple downtream tasks! And because of the self-supervised learning, we don't need access to huge amount of labeled data. In the paper, after pre-training on unlabeled speech, the model is fine-tuned on small labeled data with a Connectionist Temporal Classification (CTC) loss for speech recognition task .","title":"Introduction"},{"location":"audio_intelligence/wav2vec2/#architecture","text":"The complete architecture of the framework can be divided into 3 components, they are Feature encoder : This is the encoder part of the model. It takes the raw audio data as input and outputs feature vectors. Input size is limited to 400 samples which is 20ms for 16kHz sample rate. The raw audio is first standardized to have zero mean and unit variance. Then it is passed to 1D convolutional neural network (temporal convolution) followed by layer normalization and GELU activation function. There could be 7 such convolution blocks with constant channel size (512), decreasing kernel width (10, 3x4, 2x2) and stride (5, 2x6). The output is list of feature vectors each with 512 dimensions. Transformers : The output of the feature encoder is passed on to a transformer layer. One differentiator is use of relative positional embedding by using convolution layers, rather than using fixed positional encoding as done in original Transformers paper. The block size differs, as 12 transformers block with model dimension of 768 is used in BASE model but 24 blocks with 1024 dimension in LARGE version. Quantization module : For self-supervised learning, we need to work with discrete outputs. For this, there is a quantization module that converts the continous vector output to discrete representations, and on top of it, it automatically learns the discrete speech units. This is done by maintaining multiple codebooks/groups (320 in size) and the units are sampled from each codebook are later concatenated (320x320=102400 possiblt speech units) . The sampling is done using Gumbel-Softmax which is like argmax but differentiable.","title":"Architecture"},{"location":"audio_intelligence/wav2vec2/#training","text":"To pre-train the model, Wav2Vec2 masks certain portions of time steps in the feature encoder which is similar to masked language model. The aim is to teach the model to predict the correct quantized latent audio representation in a set of distractors for each time step. The overall training objective is to minimize contrastive loss ( \\(L_m\\) ) and diversity loss ( \\(L_d\\) ) in \\(L = L_m + \\alpha L_d\\) . Contrastive loss is the performance on the self-supervised task. Diversity loss is designed to increase the use of the complete quantized codebook representations, and not only a select subset. For pretraining, the datasets used were (1) Librispeech corpus with 960 hours of audio data, (2) LibriVox 60k hours of audio data that was later subset to 53.2k hours. Only unlabeled data was used for pretraining. To make the model more robust to different tasks, we can finetune the model on a different task specific modifications and dataset. Here, the paper finetuned for ASR by adding a randomly initialized classification layer on top on Transformer layer with class size equal to the size of vocab. The model is optimized by minimizing the CTC loss. Adam was used as optimization algorithm and the learning rate is warmed up till 10% of the training duration, then kept constant for next 40% and finally linearly decayed for the remaining duration. Also, for the first 60k updates only output classifier was trained after which Transformer is also updated. The feature encoder is kept frozen (not trained at all).","title":"Training"},{"location":"audio_intelligence/wav2vec2/#results","text":"There are two interesting points to note from the results of the Wav2Vec2 model, The model is able to learn ASR with as minimum as 10 mins of labeled data! As shown below, \\(LARGE\\) model pre-trained on LV-60k and finetuned on Librispeech with CTC loss is giving 4.6/7.9 WER! This is a very good news incase you want to finetune the model for your domain or accent! The choice of decoder can lead to improvement in performance. As obvious from the results, Transformer decoder is giving best performance, followed by n-gram and then CTC decoding. But also note that the CTC decoding will gives the best inference speed. The suggested decoder could be 4-gram, as it provides huge improvement in performance by fixing the spellling mistakes and grammer issues of CTC and is still faster than Transformer decoders. WER on Librispeech dev/test data ( Wav2vec2 paper )","title":"Results"},{"location":"audio_intelligence/wav2vec2/#code","text":"","title":"Code"},{"location":"audio_intelligence/wav2vec2/#offline-transcription-using-wav2vec2-ctc","text":"Here is the code to perform offline transcription using Wav2Vec2 model with transformer package. Note the default decoder is CTC. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # import import torch import librosa from transformers import Wav2Vec2ForCTC , Wav2Vec2Tokenizer # load the tokenizer and model tokenizer = Wav2Vec2Tokenizer . from_pretrained ( \"facebook/wav2vec2-large-960h\" ) model = Wav2Vec2ForCTC . from_pretrained ( \"facebook/wav2vec2-large-960h\" ) # load the audio data (use your own wav file here!) input_audio , sr = librosa . load ( 'my_wav_file.wav' , sr = 16000 ) # tokenize input_values = tokenizer ( input_audio , return_tensors = \"pt\" , padding = \"longest\" ) . input_values # retrieve logits logits = model ( input_values ) . logits # take argmax and decode predicted_ids = torch . argmax ( logits , dim =- 1 ) transcription = tokenizer . batch_decode ( predicted_ids ) # print the output print ( transcription )","title":"Offline transcription using Wav2Vec2 (CTC)"},{"location":"audio_intelligence/wav2vec2/#offline-transcription-using-wav2vec2-n-gram","text":"We can also use n-gram language model as decoder using a pre-trained model available in Huggingface. The usage is very similar to the CTC model, we just have to change the model name. Note, this downloads the Wav2Vec2 model plus the N-gram language model which will be around 3.2 GBs! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # install dependencies ! pip install pyctcdecode pypi - kenlm # import import librosa from transformers import Wav2Vec2ProcessorWithLM , Wav2Vec2ForCTC # load the processor processor = Wav2Vec2ProcessorWithLM . from_pretrained ( \"patrickvonplaten/wav2vec2-base-100h-with-lm\" ) model = Wav2Vec2ForCTC . from_pretrained ( \"facebook/wav2vec2-large-960h\" ) # load the audio data (use your own wav file here!) input_audio , sr = librosa . load ( 'my_wav_file.wav' , sr = 16000 ) # tokenize input_values = processor ( input_audio , return_tensors = \"pt\" , padding = \"longest\" ) . input_values # retrieve logits logits = model ( input_values ) . logits # decode using n-gram transcription = processor . batch_decode ( logits . detach () . numpy ()) . text # print the output print ( transcription )","title":"Offline transcription using Wav2Vec2 (N-gram)"},{"location":"audio_intelligence/wav2vec2/#creating-your-own-n-gram-language-model-for-word2vec2","text":"To use n-gram model we can KenLM to create language model and then use pyctcdecode for decoding. This part is referenced from Huggingface blog on Wav2vec2 with n-gram . The steps are as follows, First, we will select one text dataset. This dataset can be the transcript of train data (part of labeled data we used to finetune Wav2Vec2 model) or a related (same domain like medical, telecom, etc) collection of documents. Next we can perform data cleaning like removing special characters and then combine the individual sentences to a free flow text and save that into text file. After this we can run KenLM to create a language model. kenlm/build/bin/lmplz -o 3 < \"text.txt\" > \"3-gram.arpa\" The .arpa file contains the n-gram language model that is ready to go with just two minor modifications. As per the Huggingface blog , we need to add </s> end of sentence token as 1 gram as well, so we open the arpa file, duplicate the existing <s> start of sentence token, and just replace the <s> with </s> . Next we also increment the count of 1-gram (present at the top of the .arpa file) by 1, because of what we just did. Then we save the file. Next, we load the a LM-less model and then we can use the pyctcdecode . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # Taken from Blog @ https://huggingface.co/blog/wav2vec2-with-ngram # import packages from transformers import AutoProcessor from pyctcdecode import build_ctcdecoder from transformers import Wav2Vec2ProcessorWithLM # load a LM-less model processor = AutoProcessor . from_pretrained ( \"hf-test/xls-r-300m-sv\" ) # get the vocabulary of the tokenizer vocab_dict = processor . tokenizer . get_vocab () sorted_vocab_dict = { k . lower (): v for k , v in sorted ( vocab_dict . items (), key = lambda item : item [ 1 ])} # build the decoder decoder = build_ctcdecoder ( labels = list ( sorted_vocab_dict . keys ()), kenlm_model_path = \"3-gram.arpa\" , ) # create a processor with the decoder processor_with_lm = Wav2Vec2ProcessorWithLM ( feature_extractor = processor . feature_extractor , tokenizer = processor . tokenizer , decoder = decoder ) # now the processor can be used for inference as shown in other above code sections. We can even reduce the size of the LM-model by converting it to a binary file. kenlm/build/bin/build_binary 3 -gram.arpa 3 -gram.bin","title":"Creating your own N-gram language model for Word2Vec2"},{"location":"audio_intelligence/wav2vec2/#online-transcription-using-wav2vec2","text":"For live transcription using Wav2Vec2, we can utilize wav2vec2-live package. Once you have cloned the repo and installed the packages from requirements.txt , the live transcription can be started with (taken from the package readme and modified) , 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # import from live_asr import LiveWav2Vec2 # load model english_model = \"facebook/wav2vec2-large-960h-lv60-self\" asr = LiveWav2Vec2 ( english_model , device_name = \"default\" ) # start the live ASR asr . start () try : while True : text , sample_length , inference_time = asr . get_last_text () print ( f \"Duration: { sample_length : .3f } s \\t Speed: { inference_time : .3f } s \\t { text } \" ) except KeyboardInterrupt : asr . stop () This starts the Live ASR on your terminal. The code listen to the audio in your microphone, identifies the chunks with voice using VAD and then pass the voiced chunks to Wave2Vec2 for transcription. One sample output is shown below, listening to your voice Duration: 0 .780s Speed: 0 .205s hello Duration: 0 .780s Speed: 0 .190s hello Duration: 0 .960s Speed: 0 .223s my name ....","title":"Online transcription using Wav2Vec2"},{"location":"audio_intelligence/wav2vec2/#additional-materials","text":"An Illustrated Tour of Wav2vec 2.0 by Jonathan Bgn Boosting Wav2Vec2 with n-grams in \ud83e\udd17 Transformers","title":"Additional Materials"},{"location":"audio_intelligence/whisper/","text":"Introduction Whisper is an open source multi-task audio model released by OpenAI. It is an ASR system that works on 97 different languages (including english) and can even perform translation from other languages to english. The model was trained on 680,000 hours of multilingual and multitask data collected from the web. Whisper was trained using large scale weak supervision. Here is an interesting perspective for weak supervision training, There are 3 types of data and training strategies - (1) golden standard data for supervised training, (2) silver standard data for weakly supervised training, and (3) unlabelled data for unsupervised training. Now, it is difficult to get golden dataset due to human involvement which is costly and time consuming. And model trained on unlabelled datatset with unsupervised strategy lead to mediocre decoder part that needs further finetuning for downstream tasks. This gives the silver standard dataset a huge advantage, as it is the middle ground with large size and high accuracy. Note As huge portion of silver standard dataset might have had no humans verfication, there is always a room for faulty data. Hence the name - weak supervision. Dataset Author scraped the internet to collect huge and diverse transcription dataset. As this may also introduce noise, extra care was taken in pre-processing step to clean the data. The intention was to only consider human annotated data, for this any audio-text pair that \"seems\" like machine generated was removed. For this, they removed normalised transcriptions (only upper case, only lower case, lack of punctuations, etc) as they are most likely machine generated (no human writes like that) . They even trained language detection models to make sure that there is no mis-match in the audio and text pair's language. Finally, de-duplication was also done. With this, overall 680,000 hours was dataset was collected. The breakdown is as follows, 117,000 hours of non-english 96 different language data. 125,000 hours of X-->en translation data. 438,000 hours of english transcription data. Every audio files was resampled at 16,000 Hz and broken in 30 secs chunks to be passed to model for training. Transcription were also broken in the same chunk size respectively. Note The training dataset was not released by OpenAI. But they have open sourced the code and the pretrained models. Evaluation dataset details are shared here Architecture Authors picked the Transformer model as it has been widely used since its inception in 2017 and it scales reliably. The audio chunk is first converted into 80-channel log-magnitude Mel spectrogram with 25ms window and stride of 10ms. The features are scaled between -1 and 1 with zero mean across the dataset. Transformer inspired Whisper model [1] The input is first passed to two convolution layers with a filter width of 3 and GELU activation function. Sinusoidal position embeddings are added to the output and it is then passed to the encoder block of Transformer. The decoder block uses learned positional embedding and uses multiple cross-attention layers to apply encoder output. BPE text tokenizer was used like GPT-2. The decoder utilises multiple special tokens to facilitate the multi-task output generation. They are, <|startoftranscript|> to denote start of prediction <|nospeech|> to denote silence or even non-spoken voices (ex: background noise and music) <|transcribe|> to denote 'transcription' task <|translation|> to denote 'translation' task <|notimestamps|> to denote absence of timestamps <|endoftranscript|> to denote end of prediction Overview of Whisper [1] Results The performance of whisper model is very good. On comparing with wav2vec2 large 960h model, whisper large models makes 55% less errors on average. This is huge! In fact in some cases, even the tiny model performs better than older large models! Comparison of Whisper on various datasets [1] Warning Claims on bad performance of Whisper was made in this Twitter thread . Here, Ryan Hileman compared Whisper with NVIDIA and Talon model on several datasets to find Talon performing well against Whisper models. Also, he noted that Whisper models are quite slow in execution (even the tiny model) . Finally, he provided samples for \"catastrophic failures\" of Whisper of following types -- (1) generating complete paragraphs for single word audio input (like dec, car, two, snake, other) , (2) hallucinations and repetition in the output. Anyone thinking of using Whisper for their project should consider these concerns and test them out themselves before deployment. Released Models Authors released 5 variety of models based on size, going from 39M param tiny model to 1550M param large model. For each there are is an english only model {size}.en (ex: tiny.en ) and a multilingual model {size} (ex: tiny ). Size Parameters English-only model Multilingual model Required VRAM Relative speed tiny 39 M tiny.en tiny ~1 GB ~32x base 74 M base.en base ~1 GB ~16x small 244 M small.en small ~2 GB ~6x medium 769 M medium.en medium ~5 GB ~2x large 1550 M N/A large ~10 GB 1x Code We will go through two ways to use Whisper model. Authors have released a Python package called whisper [1] that makes using the pretrained models as easy as writing 3 lines of code. OpenAI recently released the API for Whisper model [2] While it a paid service (~$0.36 for 1 hour of audio transcription), they take care of constantly improving the model and hosting complexities. Python Package Inference Below is the inference code shared in the Readme of official Github repo [1], 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # Install ! brew install ffmpeg # for mac ! pip install git + https : // github . com / openai / whisper . git # Import import whisper # load the model model = whisper . load_model ( \"base\" ) # get transcription result = model . transcribe ( \"audio.mp3\" , language = \"english\" ) # result contains 3 output, # result['text'] --> complete transcription that with punctuations # result['segments'] --> segment wise transcription with timestamps and other details # result['langauge'] --> detected language of the audio # can be used for translation as well (here, Japanese to English) result = model . transcribe ( \"japanese.wav\" , language = \"Japanese\" , task = \"translate\" , beam_size = 5 , best_of = 5 ) Note Auto language detection only works if you don't specify it explicitly using language param in transcribe function. The package uses only the first 30 secs to detect the language. Also, whisper's translation is not that accurate hence an alternative approach could be to perform transcription using Whisper but use another package to translate the transcription. The package also provides CLI support, here is an example, whisper japanese.wav --language Japanese # generates -- # txt file (transcription), and # vtt file (segment wise transcription with timestamp) Finally for the brave souls, we can even play around with the individual modules and perform the transcription step by step, (from readme [1]) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # Install ! brew install ffmpeg # for mac ! pip install git + https : // github . com / openai / whisper . git # import import whisper model = whisper . load_model ( \"base\" ) # load audio and pad/trim it to fit 30 seconds audio = whisper . load_audio ( \"audio.mp3\" ) audio = whisper . pad_or_trim ( audio ) # make log-Mel spectrogram and move to the same device as the model mel = whisper . log_mel_spectrogram ( audio ) . to ( model . device ) # detect the spoken language _ , probs = model . detect_language ( mel ) print ( f \"Detected language: { max ( probs , key = probs . get ) } \" ) # decode the audio options = whisper . DecodingOptions () result = whisper . decode ( model , mel , options ) # print the recognized text print ( result . text ) OpenAI API Before we code, here are some important points to be aware of, OpenAI hosted Whisper model is recommended to be used for ~59 languages for which the WER rate is <50%, as for others the accuracy will not be good. Refer Whisper API only supports files that are less than 25 MB. For bigger files, we will have to split or used compressed audio. Finally, we can even use prompt engineering to further improve the accuracy of transcription. It can be used for word boosting, enforcing punctuations, styles and more. Refer Note Use of prompt engineering to enhance the transcription accuracy is a relatively newer approach and needs research for more clarity. With that out of the way, using OpenAI API for audio transcription using Whisper is quite easy as shown below, [1] 1 2 3 4 5 6 7 8 # Install ! pip install openai >= 0.27.0 # import import openai # load the audio file audio_file = open ( \"/path/to/file/audio.mp3\" , \"rb\" ) # pass for transcription transcript = openai . Audio . transcribe ( \"whisper-1\" , audio_file ) Note Apart from file and model , transcribe function supports multiple parameters like, ( Refer API doc ) prompt : for prompt engineering (more details below) response_format : to change the transcription output. We can use verbose_json to get timestamp and logits details. temperature : to introduce randomness in generation (default is 0) language : language of input audio For translation you can directly use 1 2 3 4 5 6 7 8 # Install ! pip install openai >= 0.27.0 # import import openai # load the audio file audio_file = open ( \"/path/to/file/german_audio.mp3\" , \"rb\" ) # pass for translation transcript = openai . Audio . translate ( \"whisper-1\" , audio_file ) Finally, we can use prompt engineering to enhance the accuracy by using prompt param. Below are some examples, 1 2 3 4 5 6 7 8 9 # Word Boosting name - 'Mohit' transcript = openai . Audio . translate ( \"whisper-1\" , audio_file , prompt = \"This transcript may contains people name like Mohit.\" ) # Enforce puntuations and special characters transcript = openai . Audio . translate ( \"whisper-1\" , audio_file , prompt = \"Hello, this transcript may contains people name like 'Mohit'.\" ) # Enforce filler words transcript = openai . Audio . translate ( \"whisper-1\" , audio_file , prompt = \"Hmm...this transcript may contains people name like Mohit.\" ) References [1] Whisper by OpenAI - Blog | Paper | Code | API Doc","title":"Whisper Model"},{"location":"audio_intelligence/whisper/#introduction","text":"Whisper is an open source multi-task audio model released by OpenAI. It is an ASR system that works on 97 different languages (including english) and can even perform translation from other languages to english. The model was trained on 680,000 hours of multilingual and multitask data collected from the web. Whisper was trained using large scale weak supervision. Here is an interesting perspective for weak supervision training, There are 3 types of data and training strategies - (1) golden standard data for supervised training, (2) silver standard data for weakly supervised training, and (3) unlabelled data for unsupervised training. Now, it is difficult to get golden dataset due to human involvement which is costly and time consuming. And model trained on unlabelled datatset with unsupervised strategy lead to mediocre decoder part that needs further finetuning for downstream tasks. This gives the silver standard dataset a huge advantage, as it is the middle ground with large size and high accuracy. Note As huge portion of silver standard dataset might have had no humans verfication, there is always a room for faulty data. Hence the name - weak supervision.","title":"Introduction"},{"location":"audio_intelligence/whisper/#dataset","text":"Author scraped the internet to collect huge and diverse transcription dataset. As this may also introduce noise, extra care was taken in pre-processing step to clean the data. The intention was to only consider human annotated data, for this any audio-text pair that \"seems\" like machine generated was removed. For this, they removed normalised transcriptions (only upper case, only lower case, lack of punctuations, etc) as they are most likely machine generated (no human writes like that) . They even trained language detection models to make sure that there is no mis-match in the audio and text pair's language. Finally, de-duplication was also done. With this, overall 680,000 hours was dataset was collected. The breakdown is as follows, 117,000 hours of non-english 96 different language data. 125,000 hours of X-->en translation data. 438,000 hours of english transcription data. Every audio files was resampled at 16,000 Hz and broken in 30 secs chunks to be passed to model for training. Transcription were also broken in the same chunk size respectively. Note The training dataset was not released by OpenAI. But they have open sourced the code and the pretrained models. Evaluation dataset details are shared here","title":"Dataset"},{"location":"audio_intelligence/whisper/#architecture","text":"Authors picked the Transformer model as it has been widely used since its inception in 2017 and it scales reliably. The audio chunk is first converted into 80-channel log-magnitude Mel spectrogram with 25ms window and stride of 10ms. The features are scaled between -1 and 1 with zero mean across the dataset. Transformer inspired Whisper model [1] The input is first passed to two convolution layers with a filter width of 3 and GELU activation function. Sinusoidal position embeddings are added to the output and it is then passed to the encoder block of Transformer. The decoder block uses learned positional embedding and uses multiple cross-attention layers to apply encoder output. BPE text tokenizer was used like GPT-2. The decoder utilises multiple special tokens to facilitate the multi-task output generation. They are, <|startoftranscript|> to denote start of prediction <|nospeech|> to denote silence or even non-spoken voices (ex: background noise and music) <|transcribe|> to denote 'transcription' task <|translation|> to denote 'translation' task <|notimestamps|> to denote absence of timestamps <|endoftranscript|> to denote end of prediction Overview of Whisper [1]","title":"Architecture"},{"location":"audio_intelligence/whisper/#results","text":"The performance of whisper model is very good. On comparing with wav2vec2 large 960h model, whisper large models makes 55% less errors on average. This is huge! In fact in some cases, even the tiny model performs better than older large models! Comparison of Whisper on various datasets [1] Warning Claims on bad performance of Whisper was made in this Twitter thread . Here, Ryan Hileman compared Whisper with NVIDIA and Talon model on several datasets to find Talon performing well against Whisper models. Also, he noted that Whisper models are quite slow in execution (even the tiny model) . Finally, he provided samples for \"catastrophic failures\" of Whisper of following types -- (1) generating complete paragraphs for single word audio input (like dec, car, two, snake, other) , (2) hallucinations and repetition in the output. Anyone thinking of using Whisper for their project should consider these concerns and test them out themselves before deployment.","title":"Results"},{"location":"audio_intelligence/whisper/#released-models","text":"Authors released 5 variety of models based on size, going from 39M param tiny model to 1550M param large model. For each there are is an english only model {size}.en (ex: tiny.en ) and a multilingual model {size} (ex: tiny ). Size Parameters English-only model Multilingual model Required VRAM Relative speed tiny 39 M tiny.en tiny ~1 GB ~32x base 74 M base.en base ~1 GB ~16x small 244 M small.en small ~2 GB ~6x medium 769 M medium.en medium ~5 GB ~2x large 1550 M N/A large ~10 GB 1x","title":"Released Models"},{"location":"audio_intelligence/whisper/#code","text":"We will go through two ways to use Whisper model. Authors have released a Python package called whisper [1] that makes using the pretrained models as easy as writing 3 lines of code. OpenAI recently released the API for Whisper model [2] While it a paid service (~$0.36 for 1 hour of audio transcription), they take care of constantly improving the model and hosting complexities.","title":"Code"},{"location":"audio_intelligence/whisper/#python-package-inference","text":"Below is the inference code shared in the Readme of official Github repo [1], 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # Install ! brew install ffmpeg # for mac ! pip install git + https : // github . com / openai / whisper . git # Import import whisper # load the model model = whisper . load_model ( \"base\" ) # get transcription result = model . transcribe ( \"audio.mp3\" , language = \"english\" ) # result contains 3 output, # result['text'] --> complete transcription that with punctuations # result['segments'] --> segment wise transcription with timestamps and other details # result['langauge'] --> detected language of the audio # can be used for translation as well (here, Japanese to English) result = model . transcribe ( \"japanese.wav\" , language = \"Japanese\" , task = \"translate\" , beam_size = 5 , best_of = 5 ) Note Auto language detection only works if you don't specify it explicitly using language param in transcribe function. The package uses only the first 30 secs to detect the language. Also, whisper's translation is not that accurate hence an alternative approach could be to perform transcription using Whisper but use another package to translate the transcription. The package also provides CLI support, here is an example, whisper japanese.wav --language Japanese # generates -- # txt file (transcription), and # vtt file (segment wise transcription with timestamp) Finally for the brave souls, we can even play around with the individual modules and perform the transcription step by step, (from readme [1]) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # Install ! brew install ffmpeg # for mac ! pip install git + https : // github . com / openai / whisper . git # import import whisper model = whisper . load_model ( \"base\" ) # load audio and pad/trim it to fit 30 seconds audio = whisper . load_audio ( \"audio.mp3\" ) audio = whisper . pad_or_trim ( audio ) # make log-Mel spectrogram and move to the same device as the model mel = whisper . log_mel_spectrogram ( audio ) . to ( model . device ) # detect the spoken language _ , probs = model . detect_language ( mel ) print ( f \"Detected language: { max ( probs , key = probs . get ) } \" ) # decode the audio options = whisper . DecodingOptions () result = whisper . decode ( model , mel , options ) # print the recognized text print ( result . text )","title":"Python Package Inference"},{"location":"audio_intelligence/whisper/#openai-api","text":"Before we code, here are some important points to be aware of, OpenAI hosted Whisper model is recommended to be used for ~59 languages for which the WER rate is <50%, as for others the accuracy will not be good. Refer Whisper API only supports files that are less than 25 MB. For bigger files, we will have to split or used compressed audio. Finally, we can even use prompt engineering to further improve the accuracy of transcription. It can be used for word boosting, enforcing punctuations, styles and more. Refer Note Use of prompt engineering to enhance the transcription accuracy is a relatively newer approach and needs research for more clarity. With that out of the way, using OpenAI API for audio transcription using Whisper is quite easy as shown below, [1] 1 2 3 4 5 6 7 8 # Install ! pip install openai >= 0.27.0 # import import openai # load the audio file audio_file = open ( \"/path/to/file/audio.mp3\" , \"rb\" ) # pass for transcription transcript = openai . Audio . transcribe ( \"whisper-1\" , audio_file ) Note Apart from file and model , transcribe function supports multiple parameters like, ( Refer API doc ) prompt : for prompt engineering (more details below) response_format : to change the transcription output. We can use verbose_json to get timestamp and logits details. temperature : to introduce randomness in generation (default is 0) language : language of input audio For translation you can directly use 1 2 3 4 5 6 7 8 # Install ! pip install openai >= 0.27.0 # import import openai # load the audio file audio_file = open ( \"/path/to/file/german_audio.mp3\" , \"rb\" ) # pass for translation transcript = openai . Audio . translate ( \"whisper-1\" , audio_file ) Finally, we can use prompt engineering to enhance the accuracy by using prompt param. Below are some examples, 1 2 3 4 5 6 7 8 9 # Word Boosting name - 'Mohit' transcript = openai . Audio . translate ( \"whisper-1\" , audio_file , prompt = \"This transcript may contains people name like Mohit.\" ) # Enforce puntuations and special characters transcript = openai . Audio . translate ( \"whisper-1\" , audio_file , prompt = \"Hello, this transcript may contains people name like 'Mohit'.\" ) # Enforce filler words transcript = openai . Audio . translate ( \"whisper-1\" , audio_file , prompt = \"Hmm...this transcript may contains people name like Mohit.\" )","title":"OpenAI API"},{"location":"audio_intelligence/whisper/#references","text":"[1] Whisper by OpenAI - Blog | Paper | Code | API Doc","title":"References"},{"location":"data_science_tools/compute_and_ai_services/","text":"Compute and AI Services Gone are the days when we needed to buy high end devices to do literally anything. Currently there are plethora of services available online (and many of them are free!) that provide not only compute to use as you feel, but also generic AI services. Let's look into some of the famous and widely used compute and AI services. CaaS: Compute as a Service In this section we will cover some of the famous (and with some hint of free) platforms that provide compute-as-a-service (CaaS). These CaaS sometimes could be plain simple virtual machines, sometime they can be a cluster of nodes, while in other cases they can also be jupyter like coding environment. Let's go through some of the examples. Google Colab Introduction Colaboratory or \"Colab\" in short, is a browser based jupyter notebook environment that is available for free. It requires no installation and even provides access to free GPU and TPU. The main disadvantages of Colab is that you cannot run long-running jobs (limit to max 12 hrs), GPU is subject to availability and in case of consistent usage of Colab, it might take longer to get GPU access. Google provides Pro and Pro+ options which are paid subscriptions to Colab (10$ and 50$ per month, respectively). While it provides longer background execution time and better compute (among others), they do not guarantee GPU and TPU access all the time. Remember, Colab is not an alternative to a full-blown cloud computing environment. It's just a place to test out some ideas quickly. Google Colab Snippets Run tensorboard to visualize embeddings Taken from: how-to-use-tensorboard-embedding-projector 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import numpy as np import tensorflow as tf import tensorboard as tb tf . io . gfile = tb . compat . tensorflow_stub . io . gfile from torch.utils.tensorboard import SummaryWriter vectors = np . array ([[ 0 , 0 , 1 ], [ 0 , 1 , 0 ], [ 1 , 0 , 0 ], [ 1 , 1 , 1 ]]) metadata = [ '001' , '010' , '100' , '111' ] # labels writer = SummaryWriter () writer . add_embedding ( vectors , metadata ) writer . close () % load_ext tensorboard % tensorboard -- logdir = runs Connect with Google Drive and access files This code will prompt you to provide authorization to access your Google Drive. 1 2 from google.colab import drive drive . mount ( '/content/drive' ) Kaggle Apart from being famous for hosting big AI/ML competitions, the next cool thing about the site is that it also provides free GPU/TPU computes! All you have to do is to sign up, create a new notebook and then you can start using it - import their datasets or your own, and start training you AI models! All of this ofcourse has a limit, you get minimum 30 hours of GPU usage per week, and at max 20 hours of TPU per week. Another catch is that you can only use GPU/TPU for 9 hours continuously. That said, Kaggle notebooks are a great place to perform your personal experiments or participate in new competitons to enhance your expertise. For more official work (industry or academics), do remember that you are putting your dataset in 3rd party's hands. Code/Notebook page of Kaggle . DeepNote DeepNote provides a highly customised jupyter like notebook. It's one of the richest service in terms of features. Here goes some examples - you can create projects with multiple notebooks, you can create teams and collaborate with your colleagues live, you can quickly visualize datasets from notebooks, you can schedule notebooks, you can host reports, and best of all - they have free tier There are multiple pricing based tiers. To begin with you can try out the free tier and get upto 750 hours of Standard compute hours per month, that's like keeping one project (that could consist of multiple notebooks) open for the complete month! ( offer subject to change; was valid at the time of writing ) Pricing tiers of Deepnote . Hint Planning to try DeepNote out? Use the refer link to get free 20 Pro compute hours (thats upto 16GB RAM and v4vCPU) MLaaS: Machine Learning as a Service In this section we will cover some of the famous platforms that provide Machine learning-as-a-Service (MLaaS). These MLaaS take care of infrastructure related aspect of data holding, data preparing, model training and model deployment. On top of this, they provide a repository of classical ML algorithms that can be leveraged to create data science solutions. The idea is to make data science as a plug and play solution creation activity, as they take care of most of the engineering aspect. Let's go through some of the examples. AWS Sagemaker (Amazon) AWS Sagemaker is a cloud-based servies that helps data scientists with the complete lifecycle of data science project. They have specialised tools that cover following stages of data science projects, Prepare : It's the pre-processing step of the project. Some of the important services are \" Gound Truth \" that is used for data labeling/annotation and \" Feature Store \" that is used to provide consistence data transformation across teams and services like training and deployment. Build : It's where an Data Scientists spends most of his time coding. \" Studio Notebooks \" provides jupyter notebooks that can be used to perform quick ideation check and build the model. Train & Tune : It's where you can efficiently train and debug your models. \" Automatic Model Training \" can be used for hyper-parameter tuning of the model i.e. finding the best parameters that provides highest accuracy. \" Experiments \" can be used to run and track multiple experiments, its an absolute must if your projects requires multiple runs to find the best architecture or parameters. Deploy & Manage : The final stage, where you deploy your model for the rest of the world to use. \" One-Click Deployment \" can be used to efficiently deploy your model to the cloud. \" Model Monitor \" can be used to manage your model, like deleting, updating, and so on. Services provided by AWS Sagemaker . AWS charges a premium for providing all of these features under a single umbrella. For a more detailed pricing information, you can estimate the cost using this . Hint As AWS Sagemaker is a costly affair, several DS teams try to find workarounds. Some of them are like using spot instances for training as they are cheaper & using AWS Lambda for deploying small models. Kubeflow Introduction Kubeflow is an open-source project that is dedicated to making development, tracking and deployments of machine learning (ML) workflows on Kubernetes simple, portable and scalable. As per their website, \"Anywhere you are running Kubernetes, you should be able to run Kubeflow.\" While there are many paid MLaaS like Sagemaker , Azure ML Services and Google AI Platform , Kubeflow is an outlier that provides most of the features present in the paid platforms, but for free! We can deploy Kubeflow on Kubernetes by following the guide on their website . Once done, you can boot it up and it should look as shown below, Main page of Kubeflow . Hint Go with Kubeflow if you are setting up a new AI team for your organziation or school, and don't want to commit to costly services like Sagemaker. But beware, it does require DevOps knowledge, as you will need to setup Kubernetes and manage it. While it is completly free, you will be charged for the compute you utilize. To cut down the cost, in case you are connecting Kubeflow with AWS, you can use Spot instances. Components Kubeflow provides several individual components that will help with the ML lifecycle. Note, we can even pick and choose the components you want while installation. Some of them are, Notebook: here we can create jupyter notebook servers and perform quick experimentations. Each server is assigned its own volume (hard memory). On booting up a server, a new compute is procured and you will see Jupyter Lab page where you can create mulitple notebooks, scripts or terminals. The compute could be EC2 instance or Spot instance, incase of AWS connection and based on your configuration. Pipeline: here we define one ML project. Kubeflow supports defining a pipeline in terms of a DAG (Directed Acyclic Graph), where each individual function or module is one node. Pipeline represents a graph of modules, where execution happens in a sequential or parallel manner while considering the inter-module dependencies , ex: module_2 requires output of module_1 . While this leads to modularization of the code, the real intention is to make the pipeline execution traceable and independent from each other. This is achieved by containerizing each module and running them on different instances, making the process truly independent. Experiments: On a single ML project, we may want to run multiple experiments, ex: (1) test_accuracy to try out a couple of parameters and compare accuracy, (2) test_performance to compare latency on different shape and size of data. This is where you define individual experiments. Runs: One execution of an experiment for a pipeline is captured here, ex: for test_accuracy experiment of MNIST pipeline, perform one run with learning_rate = 0.001 . Experiments (AutoML): we cannot try all the parameters for the test_accuracy one by one. The obvious question, why not automate it by doing hyperparameter tuning? AutoML is what you are looking for! Models: after all experimentations and model training, we would like to host/deploy the model. It can done using this component. Creating and running Pipeline Let's start the coding . So for this tutorial, we will create a simple Kubeflow pipeline with two steps, Step 1 - Download data: where we will download data from S3 bucket, pass the downloaded data to the next step for further analysis. Step 2 - Perform analysis: we will perform some rudimentary analysis on the data and log the metrics. We will try to go through some basic and advanced scenarios, so that you can refer the code to create your own pipeline, even if it is completely different. After creating the pipeline, we will register it, create an experiment and then execute a run. Lets start with importing the relevant packages. Make sure to install kfp with the latest version by using pip install kfp --upgrade 1 2 3 4 5 6 # imports import kfp import kfp.dsl as dsl from typing import NamedTuple import kfp.components as comp from kfp.components import InputPath , OutputPath Now we will create the first module that downloads data from S3 bucket. Note, Kubeflow takes care of the logistics of data availability between modules, but we need to share the path where data is downloaded. This is done by typecasing parameter with OutputPath(str) as done on line 2 . The process will be similar for ML models as well. We can download a model in the first module and perform training in another, and perform performance check in the third module. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 ## Step 1 def download_data ( data_path : OutputPath ( str )): # import the functions import os import boto3 # create the path if not exist if not os . path . exists ( data_path ): os . makedirs ( data_path ) # setup boto3 s3 = boto3 . resource ( 's3' ) s3_client = boto3 . client ( 's3' ) bucket_name = 'my-bucket' bucket = s3 . Bucket ( bucket_name ) # get list of all files at the s3 bucket prefix prefix = \"dataset/\" query = s3_client . list_objects ( Bucket = bucket_name , Prefix = prefix , Delimiter = '/' ) files = [] if 'Contents' in query : for obj in query [ 'Contents' ]: files . append ( obj [ 'Key' ]) # download each file into the folder for file_path in files : # get file name file_name = file_path . split ( '/' )[ - 1 ] # download and save the file s3_client . download_file ( bucket_name , file_path , f ' { data_path } / { file_name } ' ) print ( f \"Downloaded: ' { file_path } ' into ' { data_path } / { file_name } '\" ) # done! return print ( \"Done\" ) # download_data() # create kubeflow component download_data_comp = kfp . components . create_component_from_func ( func = download_data , base_image = 'python:3.7' , packages_to_install = [ 'boto3' ]) From line 40 to line 43 , we are converting the function to Kubeflow pipeline component. As the component will run on an independent instance, we need to provide the base_image and packages_to_install information as well. Next, we will create the second module that loads the data from first module and just returns some dummy metrics. In reality, you can do a lot of things like data preprocessing or data transformation or EDA. For now, we will just stick with a dummy example. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 ## Step 2 from typing import NamedTuple def data_analysis ( data_path : InputPath ( str )) -> NamedTuple ( 'Outputs' , [ ( 'mlpipeline_metrics' , 'Metrics' ), ]): # import import json from glob import glob from collections import namedtuple # load each json file for file_path in glob ( f \" { data_path } /*.json\" ): # load the call data file and perform some analysis data = json . load ( open ( file_path )) # print print ( f \"Loaded { file_path } \" ) # --- do something fancy here --- # create metrics that should be logged metrics = { 'metrics' : [ { 'name' : 'accuracy' , 'numberValue' : 89 }, { 'name' : 'f1' , 'numberValue' : 89 }]} return [ json . dumps ( metrics )] # create kubeflow component data_analysis_comp = kfp . components . create_component_from_func ( func = data_analysis , base_image = 'python:3.7' , packages_to_install = []) In the function we are defining the data_path as InputPath(str) and is later used directly on line 14 , without the need of manually sharing the data across instances. We define mlpipeline_metrics as output (by type casing) as this is mandatory if you want to log metrics. This is done on line 21 to line 29 , where we log dummy accuracy and f1 metrics. Next we return the metrics. Finally, we also create Kubeflow component. Next, we will combine all of the components together to create the pipeline. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 ## Create pipeline from kubernetes.client.models import ( V1Affinity , V1NodeAffinity , V1NodeSelector , V1NodeSelectorTerm , V1NodeSelectorRequirement ) # define pipeline @dsl . pipeline ( name = \"my_pipeline\" , description = \"A simple demo of kubeflow pipeline\" ) # Define parameters to be fed into pipeline def my_pipeline ( data_path = 'data/' ): # Step 1 download_data_container = download_data_comp () # Step 2 data_analysis_container = data_analysis_comp ( download_data_container . output ) # add affinity aff = V1Affinity ( node_affinity = V1NodeAffinity ( required_during_scheduling_ignored_during_execution = V1NodeSelector ( node_selector_terms = [ V1NodeSelectorTerm ( match_expressions = [ V1NodeSelectorRequirement ( key = \"xxxx\" , operator = \"In\" , values = [ 'yyy' ])])])) ) download_data_container . add_affinity ( aff ) data_analysis_container . add_affinity ( aff ) # create client that would enable communication with the Pipelines API server client = kfp . Client () experiment_name = 'my_pipeline' # Compile pipeline to generate compressed YAML definition of the pipeline. kfp . compiler . Compiler () . compile ( my_pipeline , ' {} .zip' . format ( experiment_name )) We start with importing relevant modules and creating the pipeline function where we define the name and description of the pipeline. Next we connect the components together. From line 20 to line 30 , we are defining and setting the node wide affinity so that we only use spot instances for the computation. This will keep our cost to the minimum. Finally we create a Kubeflow client and compile the complete pipeline. This will create a zip file of the compiled pipeline that we can upload from the pipeline tab in Kubeflow. Next, we can create an experiment and the perform a run from the respective Kubeflow tabs. The process is quite simple and can be easily done from the UI. Once we have executed a run and the process is completed, we can see the individual modules and the status in the run page as shown below. Run page after successful execution of a run of my_pipeline pipeline And we have done it","title":"Compute and AI Services"},{"location":"data_science_tools/compute_and_ai_services/#compute-and-ai-services","text":"Gone are the days when we needed to buy high end devices to do literally anything. Currently there are plethora of services available online (and many of them are free!) that provide not only compute to use as you feel, but also generic AI services. Let's look into some of the famous and widely used compute and AI services.","title":"Compute and AI Services"},{"location":"data_science_tools/compute_and_ai_services/#caas-compute-as-a-service","text":"In this section we will cover some of the famous (and with some hint of free) platforms that provide compute-as-a-service (CaaS). These CaaS sometimes could be plain simple virtual machines, sometime they can be a cluster of nodes, while in other cases they can also be jupyter like coding environment. Let's go through some of the examples.","title":"CaaS: Compute as a Service"},{"location":"data_science_tools/compute_and_ai_services/#google-colab","text":"","title":"Google Colab"},{"location":"data_science_tools/compute_and_ai_services/#introduction","text":"Colaboratory or \"Colab\" in short, is a browser based jupyter notebook environment that is available for free. It requires no installation and even provides access to free GPU and TPU. The main disadvantages of Colab is that you cannot run long-running jobs (limit to max 12 hrs), GPU is subject to availability and in case of consistent usage of Colab, it might take longer to get GPU access. Google provides Pro and Pro+ options which are paid subscriptions to Colab (10$ and 50$ per month, respectively). While it provides longer background execution time and better compute (among others), they do not guarantee GPU and TPU access all the time. Remember, Colab is not an alternative to a full-blown cloud computing environment. It's just a place to test out some ideas quickly.","title":"Introduction"},{"location":"data_science_tools/compute_and_ai_services/#google-colab-snippets","text":"","title":"Google Colab Snippets"},{"location":"data_science_tools/compute_and_ai_services/#run-tensorboard-to-visualize-embeddings","text":"Taken from: how-to-use-tensorboard-embedding-projector 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import numpy as np import tensorflow as tf import tensorboard as tb tf . io . gfile = tb . compat . tensorflow_stub . io . gfile from torch.utils.tensorboard import SummaryWriter vectors = np . array ([[ 0 , 0 , 1 ], [ 0 , 1 , 0 ], [ 1 , 0 , 0 ], [ 1 , 1 , 1 ]]) metadata = [ '001' , '010' , '100' , '111' ] # labels writer = SummaryWriter () writer . add_embedding ( vectors , metadata ) writer . close () % load_ext tensorboard % tensorboard -- logdir = runs","title":"Run tensorboard to visualize embeddings"},{"location":"data_science_tools/compute_and_ai_services/#connect-with-google-drive-and-access-files","text":"This code will prompt you to provide authorization to access your Google Drive. 1 2 from google.colab import drive drive . mount ( '/content/drive' )","title":"Connect with Google Drive and access files"},{"location":"data_science_tools/compute_and_ai_services/#kaggle","text":"Apart from being famous for hosting big AI/ML competitions, the next cool thing about the site is that it also provides free GPU/TPU computes! All you have to do is to sign up, create a new notebook and then you can start using it - import their datasets or your own, and start training you AI models! All of this ofcourse has a limit, you get minimum 30 hours of GPU usage per week, and at max 20 hours of TPU per week. Another catch is that you can only use GPU/TPU for 9 hours continuously. That said, Kaggle notebooks are a great place to perform your personal experiments or participate in new competitons to enhance your expertise. For more official work (industry or academics), do remember that you are putting your dataset in 3rd party's hands. Code/Notebook page of Kaggle .","title":"Kaggle"},{"location":"data_science_tools/compute_and_ai_services/#deepnote","text":"DeepNote provides a highly customised jupyter like notebook. It's one of the richest service in terms of features. Here goes some examples - you can create projects with multiple notebooks, you can create teams and collaborate with your colleagues live, you can quickly visualize datasets from notebooks, you can schedule notebooks, you can host reports, and best of all - they have free tier There are multiple pricing based tiers. To begin with you can try out the free tier and get upto 750 hours of Standard compute hours per month, that's like keeping one project (that could consist of multiple notebooks) open for the complete month! ( offer subject to change; was valid at the time of writing ) Pricing tiers of Deepnote . Hint Planning to try DeepNote out? Use the refer link to get free 20 Pro compute hours (thats upto 16GB RAM and v4vCPU)","title":"DeepNote"},{"location":"data_science_tools/compute_and_ai_services/#mlaas-machine-learning-as-a-service","text":"In this section we will cover some of the famous platforms that provide Machine learning-as-a-Service (MLaaS). These MLaaS take care of infrastructure related aspect of data holding, data preparing, model training and model deployment. On top of this, they provide a repository of classical ML algorithms that can be leveraged to create data science solutions. The idea is to make data science as a plug and play solution creation activity, as they take care of most of the engineering aspect. Let's go through some of the examples.","title":"MLaaS: Machine Learning as a Service"},{"location":"data_science_tools/compute_and_ai_services/#aws-sagemaker-amazon","text":"AWS Sagemaker is a cloud-based servies that helps data scientists with the complete lifecycle of data science project. They have specialised tools that cover following stages of data science projects, Prepare : It's the pre-processing step of the project. Some of the important services are \" Gound Truth \" that is used for data labeling/annotation and \" Feature Store \" that is used to provide consistence data transformation across teams and services like training and deployment. Build : It's where an Data Scientists spends most of his time coding. \" Studio Notebooks \" provides jupyter notebooks that can be used to perform quick ideation check and build the model. Train & Tune : It's where you can efficiently train and debug your models. \" Automatic Model Training \" can be used for hyper-parameter tuning of the model i.e. finding the best parameters that provides highest accuracy. \" Experiments \" can be used to run and track multiple experiments, its an absolute must if your projects requires multiple runs to find the best architecture or parameters. Deploy & Manage : The final stage, where you deploy your model for the rest of the world to use. \" One-Click Deployment \" can be used to efficiently deploy your model to the cloud. \" Model Monitor \" can be used to manage your model, like deleting, updating, and so on. Services provided by AWS Sagemaker . AWS charges a premium for providing all of these features under a single umbrella. For a more detailed pricing information, you can estimate the cost using this . Hint As AWS Sagemaker is a costly affair, several DS teams try to find workarounds. Some of them are like using spot instances for training as they are cheaper & using AWS Lambda for deploying small models.","title":"AWS Sagemaker (Amazon)"},{"location":"data_science_tools/compute_and_ai_services/#kubeflow","text":"","title":"Kubeflow"},{"location":"data_science_tools/compute_and_ai_services/#introduction_1","text":"Kubeflow is an open-source project that is dedicated to making development, tracking and deployments of machine learning (ML) workflows on Kubernetes simple, portable and scalable. As per their website, \"Anywhere you are running Kubernetes, you should be able to run Kubeflow.\" While there are many paid MLaaS like Sagemaker , Azure ML Services and Google AI Platform , Kubeflow is an outlier that provides most of the features present in the paid platforms, but for free! We can deploy Kubeflow on Kubernetes by following the guide on their website . Once done, you can boot it up and it should look as shown below, Main page of Kubeflow . Hint Go with Kubeflow if you are setting up a new AI team for your organziation or school, and don't want to commit to costly services like Sagemaker. But beware, it does require DevOps knowledge, as you will need to setup Kubernetes and manage it. While it is completly free, you will be charged for the compute you utilize. To cut down the cost, in case you are connecting Kubeflow with AWS, you can use Spot instances.","title":"Introduction"},{"location":"data_science_tools/compute_and_ai_services/#components","text":"Kubeflow provides several individual components that will help with the ML lifecycle. Note, we can even pick and choose the components you want while installation. Some of them are, Notebook: here we can create jupyter notebook servers and perform quick experimentations. Each server is assigned its own volume (hard memory). On booting up a server, a new compute is procured and you will see Jupyter Lab page where you can create mulitple notebooks, scripts or terminals. The compute could be EC2 instance or Spot instance, incase of AWS connection and based on your configuration. Pipeline: here we define one ML project. Kubeflow supports defining a pipeline in terms of a DAG (Directed Acyclic Graph), where each individual function or module is one node. Pipeline represents a graph of modules, where execution happens in a sequential or parallel manner while considering the inter-module dependencies , ex: module_2 requires output of module_1 . While this leads to modularization of the code, the real intention is to make the pipeline execution traceable and independent from each other. This is achieved by containerizing each module and running them on different instances, making the process truly independent. Experiments: On a single ML project, we may want to run multiple experiments, ex: (1) test_accuracy to try out a couple of parameters and compare accuracy, (2) test_performance to compare latency on different shape and size of data. This is where you define individual experiments. Runs: One execution of an experiment for a pipeline is captured here, ex: for test_accuracy experiment of MNIST pipeline, perform one run with learning_rate = 0.001 . Experiments (AutoML): we cannot try all the parameters for the test_accuracy one by one. The obvious question, why not automate it by doing hyperparameter tuning? AutoML is what you are looking for! Models: after all experimentations and model training, we would like to host/deploy the model. It can done using this component.","title":"Components"},{"location":"data_science_tools/compute_and_ai_services/#creating-and-running-pipeline","text":"Let's start the coding . So for this tutorial, we will create a simple Kubeflow pipeline with two steps, Step 1 - Download data: where we will download data from S3 bucket, pass the downloaded data to the next step for further analysis. Step 2 - Perform analysis: we will perform some rudimentary analysis on the data and log the metrics. We will try to go through some basic and advanced scenarios, so that you can refer the code to create your own pipeline, even if it is completely different. After creating the pipeline, we will register it, create an experiment and then execute a run. Lets start with importing the relevant packages. Make sure to install kfp with the latest version by using pip install kfp --upgrade 1 2 3 4 5 6 # imports import kfp import kfp.dsl as dsl from typing import NamedTuple import kfp.components as comp from kfp.components import InputPath , OutputPath Now we will create the first module that downloads data from S3 bucket. Note, Kubeflow takes care of the logistics of data availability between modules, but we need to share the path where data is downloaded. This is done by typecasing parameter with OutputPath(str) as done on line 2 . The process will be similar for ML models as well. We can download a model in the first module and perform training in another, and perform performance check in the third module. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 ## Step 1 def download_data ( data_path : OutputPath ( str )): # import the functions import os import boto3 # create the path if not exist if not os . path . exists ( data_path ): os . makedirs ( data_path ) # setup boto3 s3 = boto3 . resource ( 's3' ) s3_client = boto3 . client ( 's3' ) bucket_name = 'my-bucket' bucket = s3 . Bucket ( bucket_name ) # get list of all files at the s3 bucket prefix prefix = \"dataset/\" query = s3_client . list_objects ( Bucket = bucket_name , Prefix = prefix , Delimiter = '/' ) files = [] if 'Contents' in query : for obj in query [ 'Contents' ]: files . append ( obj [ 'Key' ]) # download each file into the folder for file_path in files : # get file name file_name = file_path . split ( '/' )[ - 1 ] # download and save the file s3_client . download_file ( bucket_name , file_path , f ' { data_path } / { file_name } ' ) print ( f \"Downloaded: ' { file_path } ' into ' { data_path } / { file_name } '\" ) # done! return print ( \"Done\" ) # download_data() # create kubeflow component download_data_comp = kfp . components . create_component_from_func ( func = download_data , base_image = 'python:3.7' , packages_to_install = [ 'boto3' ]) From line 40 to line 43 , we are converting the function to Kubeflow pipeline component. As the component will run on an independent instance, we need to provide the base_image and packages_to_install information as well. Next, we will create the second module that loads the data from first module and just returns some dummy metrics. In reality, you can do a lot of things like data preprocessing or data transformation or EDA. For now, we will just stick with a dummy example. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 ## Step 2 from typing import NamedTuple def data_analysis ( data_path : InputPath ( str )) -> NamedTuple ( 'Outputs' , [ ( 'mlpipeline_metrics' , 'Metrics' ), ]): # import import json from glob import glob from collections import namedtuple # load each json file for file_path in glob ( f \" { data_path } /*.json\" ): # load the call data file and perform some analysis data = json . load ( open ( file_path )) # print print ( f \"Loaded { file_path } \" ) # --- do something fancy here --- # create metrics that should be logged metrics = { 'metrics' : [ { 'name' : 'accuracy' , 'numberValue' : 89 }, { 'name' : 'f1' , 'numberValue' : 89 }]} return [ json . dumps ( metrics )] # create kubeflow component data_analysis_comp = kfp . components . create_component_from_func ( func = data_analysis , base_image = 'python:3.7' , packages_to_install = []) In the function we are defining the data_path as InputPath(str) and is later used directly on line 14 , without the need of manually sharing the data across instances. We define mlpipeline_metrics as output (by type casing) as this is mandatory if you want to log metrics. This is done on line 21 to line 29 , where we log dummy accuracy and f1 metrics. Next we return the metrics. Finally, we also create Kubeflow component. Next, we will combine all of the components together to create the pipeline. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 ## Create pipeline from kubernetes.client.models import ( V1Affinity , V1NodeAffinity , V1NodeSelector , V1NodeSelectorTerm , V1NodeSelectorRequirement ) # define pipeline @dsl . pipeline ( name = \"my_pipeline\" , description = \"A simple demo of kubeflow pipeline\" ) # Define parameters to be fed into pipeline def my_pipeline ( data_path = 'data/' ): # Step 1 download_data_container = download_data_comp () # Step 2 data_analysis_container = data_analysis_comp ( download_data_container . output ) # add affinity aff = V1Affinity ( node_affinity = V1NodeAffinity ( required_during_scheduling_ignored_during_execution = V1NodeSelector ( node_selector_terms = [ V1NodeSelectorTerm ( match_expressions = [ V1NodeSelectorRequirement ( key = \"xxxx\" , operator = \"In\" , values = [ 'yyy' ])])])) ) download_data_container . add_affinity ( aff ) data_analysis_container . add_affinity ( aff ) # create client that would enable communication with the Pipelines API server client = kfp . Client () experiment_name = 'my_pipeline' # Compile pipeline to generate compressed YAML definition of the pipeline. kfp . compiler . Compiler () . compile ( my_pipeline , ' {} .zip' . format ( experiment_name )) We start with importing relevant modules and creating the pipeline function where we define the name and description of the pipeline. Next we connect the components together. From line 20 to line 30 , we are defining and setting the node wide affinity so that we only use spot instances for the computation. This will keep our cost to the minimum. Finally we create a Kubeflow client and compile the complete pipeline. This will create a zip file of the compiled pipeline that we can upload from the pipeline tab in Kubeflow. Next, we can create an experiment and the perform a run from the respective Kubeflow tabs. The process is quite simple and can be easily done from the UI. Once we have executed a run and the process is completed, we can see the individual modules and the status in the run page as shown below. Run page after successful execution of a run of my_pipeline pipeline And we have done it","title":"Creating and running Pipeline"},{"location":"data_science_tools/database_postgresql/","text":"Introduction to PostgreSQL PostgreSQL, often simply called Postgres, is a powerful, open-source object-relational database management system (ORDBMS). It has a strong reputation for reliability, feature robustness, and performance. PostgreSQL was first developed in 1986 at the University of California, Berkeley as part of the POSTGRES project. It has since evolved into one of the most advanced and widely-used database systems, with a strong community supporting its development. PostgreSQL supports all major operating systems, including Linux, Mac OS, and Windows. Key Features of PostgreSQL PostgreSQL offers a wide range of features that make it a popular choice for many applications: Extensive data types : PostgreSQL supports a large variety of built-in data types and allows users to define their own custom data types. It can handle complex data types such as arrays, JSON, and geometric types. ACID compliance : PostgreSQL adheres to the ACID principles (Atomicity, Consistency, Isolation, Durability), ensuring reliable and trustworthy transactions. More details Concurrency control : PostgreSQL uses multi-version concurrency control (MVCC) to provide high concurrency without conflicts, allowing multiple transactions to access the same data simultaneously. Advanced querying capabilities : PostgreSQL supports complex SQL queries, subqueries, common table expressions (CTEs), recursive queries, and window functions. It also allows users to define their own functions, triggers, and stored procedures in various programming languages. Full-text search : PostgreSQL provides powerful full-text search capabilities, including stemming, ranking, and phrase-searching support. It uses indexes like B-tree, hash, and GiST to optimize search performance. Replication and high availability : PostgreSQL supports various replication strategies, such as asynchronous streaming, logical, and synchronous replication, providing data redundancy, fault tolerance, and high availability. Security and authentication : PostgreSQL offers robust security features, including SSL encryption, username/password authentication, LDAP authentication, Kerberos authentication, role-based access control (RBAC), and row-level security (RLS). Setting Up PostgreSQL To get PostgreSQL running on your local machine, you will need to have the following tools installed: PostgreSQL Server : You can follow the step-by-step instructions provided on the official website . Once the installation is complete, you can run the server by opening the application. PostgreSQL Query Tools : Once the PostgreSQL server is installed, you can install tools to manage and interact with PostgreSQL. There are multiple choices, each with its own set of unique features and all of them support the basic functionalities. Here are some famous ones - PgAdmin , DBeaver , or you can even use terminal tools like Psql . Hint Installation on Mac PostgreSQL can be installed on Mac by using homebrew . Run the command brew install postgresql . For more details and options, follow the official website . Learning the Basics Practice makes man perfect, so let's learn PostgreSQL through sample codes. Below are some sample code snippets in increasing order of complexity, designed to help you understand various aspects of PostgreSQL. Hint Before we begin, please note that to interact with the database, you need to use the PostgreSQL Query Language, which is a variant of the SQL language. If you are using terminal, then you can activate psql mode by running psql . Once inside you can connect to the database by running the following command: -- Connecting to a PostgreSQL database -- Use a client or terminal with appropriate access credentials \\ c my_database ; Or you can use any of the user-interface tools like PgAdmin for better user experience. 1. Creating a Database -- Creating a database. Replace `my_database` with your database name CREATE DATABASE my_database ; 2. Creating a Table -- Creating a simple table. Replace `employees` with your table name CREATE TABLE employees ( id SERIAL PRIMARY KEY , name VARCHAR ( 50 ), position VARCHAR ( 50 ), departmentid INT , salary DECIMAL ); Hint Here is a detailed list of all supported data types in PostgreSQL. Note, you can also create custom data types . 3. Inserting Data -- Inserting data into the table INSERT INTO employees ( name , position , salary ) VALUES ( 'John Doe' , 'Software Engineer' , 70000 ); 4. Basic Data Retrieval -- Retrieving all data from a table SELECT * FROM employees ; -- Limiting the number of rows returned SELECT * FROM employees LIMIT 10 ; -- Retrieving specific columns SELECT name , position FROM employees ; -- Retrieving data in descending order SELECT * FROM employees ORDER BY salary DESC ; 5. Data Retrieval with Conditions -- Retrieving specific data with a condition SELECT name , position FROM employees WHERE salary > 50000 ; -- Filtering on string columns SELECT * FROM employees WHERE name LIKE '%Doe%' ; -- Filtering on datetime columns SELECT * FROM orders WHERE order_date BETWEEN '2022-01-01' AND '2022-02-01' ; -- Filtering on datetime columns with interval (works same as above) SELECT * FROM orders WHERE order_date BETWEEN '2022-01-01' AND '2022-02-01' :: date + interval '1 month' ; -- To filter based on multiple conditions and values SELECT * FROM employees WHERE name LIKE '%Doe%' AND salary > 50000 AND position in ( 'Software Engineer' , 'Data Scientist' ); 6. Updating Data -- Updating data in the table UPDATE employees SET salary = 75000 WHERE name = 'John Doe' ; 7. Deleting Data -- Deleting data from the table DELETE FROM employees WHERE id = 1 ; -- Deleting all data from the table DELETE FROM employees ; -- Deleting the table DROP TABLE employees ; -- Deleting multiple tables DROP TABLE employees , departments ; 8. Joining Tables -- Creating another table CREATE TABLE departments ( id SERIAL PRIMARY KEY , name VARCHAR ( 50 ) ); -- Inserting data into the new table INSERT INTO departments ( name ) VALUES ( 'Engineering' ); -- Joining two tables SELECT employees . name , departments . name AS department_name FROM employees JOIN departments ON employees . departmentid = departments . id ; 9. Using Aggregate Functions -- Using an aggregate function to get the average salary SELECT AVG ( salary ) FROM employees ; -- Group by a column (ex: getting the average salary by department) SELECT department_name , AVG ( salary ) AS avg_salary FROM employees JOIN departments ON employees . id = departments . id GROUP BY department_name ; 10. Complex Query with Subquery and Grouping -- Finding the highest salary in each department SELECT department_name , MAX ( salary ) AS max_salary FROM ( SELECT employees . name , employees . salary , departments . name AS department_name FROM employees JOIN departments ON employees . id = departments . id ) AS department_salaries GROUP BY department_name ; These examples cover a range of basic to more complex tasks you can perform with PostgreSQL, from establishing a connection to executing advanced queries. As you become more comfortable with these operations, you'll be able to tackle more complex scenarios and optimize your database interactions. Python Sample Code There are multiple python packages available for PostgreSQL like, psycopg2 and asyncpg . For this section, we will use asyncpg package that provides support for asynchronous programming. A sample code to connect to the PostgreSQL server and fetch the result is shown below, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # import import asyncio import asyncpg # the main function that connect to the PostgreSQL server, # fetch the result and print the result async def run (): # connect to the PostgreSQL server conn = await asyncpg . connect ( user = 'postgres' , password = 'admin' , database = 'mydb' , host = 'localhost' ) # fetch the result result = await conn . fetch ( 'SELECT * FROM mytbl LIMIT 1' ) # print the result print ( dict ( result )) # close the connection await conn . close () if __name__ == '__main__' : # run the code loop = asyncio . get_event_loop () loop . run_until_complete ( run ()) Creating dynamic queries based on user input can be easily done by passing the variables to the fetch function. Below is the modification you need to do. If you notice, we have two variables in the query for id and limit denoted by $1 and $2 respectively. The respective values are passed in the fetch function. Rest of the code remains same. 1 2 3 4 5 # fetch the result result = await conn . fetch ( 'SELECT * FROM mytbl where id = $1 LIMIT $2' , 123 , 1 ) You can use conn.execute to run the query without fetching the result. Below is the modification needed. 1 2 3 4 5 # insertion example (one row) result = await conn . execute ( 'INSERT INTO mytbl (code, name) VALUES ($1, $2) where id = $3' , 123 , 'mohit' , 1 ) If you want to execute for multiple rows, you can use conn.executemany instead of conn.execute . Below is the modification to the code shown above. 1 2 3 4 5 # insertion example (multiple rows) result = await conn . executemany ( 'INSERT INTO mytbl (code, name) VALUES ($1, $2) where id = $3' , [( 123 , 'mohit' , 1 ), ( 124 , 'mayank' , 2 )] ) You might want to create a generic function to execute queries and retry in case of failure. Here is how you can do it using the tenacity library. The below code will retry 3 times if the query fails with exponential backoff. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 # import import asyncio import asyncpg import functools from tenacity import TryAgain , retry , stop_after_attempt , wait_exponential # custom retry logging function def custom_retry_log ( retry_state , msg ): if retry_state . attempt_number != 1 : print ( f \"Retrying { retry_state . attempt_number - 1 } for { msg } \" ) # main function async def execute_fetch_script ( script , values = (), msg = None , retry_on_failure = True ): # create connection conn = await asyncpg . connect ( user = 'postgres' , password = 'admin' , database = 'mydb' , host = 'localhost' ) try : # retry mechanism log_callback = functools . partial ( custom_retry_log , msg = msg ) # retry mechanism @retry ( wait = wait_exponential ( multiplier = 2 , min = 2 , max = 16 ), stop = stop_after_attempt ( 4 ), after = log_callback , reraise = True ) async def retry_wrapper (): try : # execute the select SQL script records = await conn . fetch ( script , * values ) project_records = [ dict ( record ) for record in records ] print ( project_records ) # remove this return project_records except Exception as e : if retry_on_failure : raise TryAgain ( e ) else : print ( f \"Failure in { msg } - { e } \" ) return # db call wrapper return await retry_wrapper () except Exception as e : raise Exception ( f \"Failure in { msg } - { e } \" ) finally : # close db connections await conn . close () if __name__ == '__main__' : loop = asyncio . get_event_loop () script = 'SELECT * FROM mytbl where projectid = $1 LIMIT $2' values = ( 2 , 1 ) loop . run_until_complete ( execute_fetch_script ( script , values , \"Testing Run\" )) If you noticed, all of the above examples are executing the query within a single transaction. In case you want to execute multiple queries in one transaction, you can do as shown below, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # import import asyncio import asyncpg import functools from tenacity import TryAgain , retry , stop_after_attempt , wait_exponential # create the connection conn = await asyncpg . connect ( user = 'postgres' , password = 'admin' , database = 'mydb' , host = 'localhost' ) # start the transaction async with conn . transaction (): try : # Query 1 - execute the select SQL script records = await conn . fetch ( 'SELECT * FROM mytbl where projectid = $1 LIMIT $2' , 2 , 1 ) # Query 2 - update the table await conn . execute ( 'UPDATE mytbl SET name = $1 where projectid = $2' , 'mohit' , 2 ) # handle exception except Exception as e : # in case of exception rollback the transaction await conn . execute ( 'ROLLBACK;' ) finally : # close db connections await conn . close () Snippets Real world problems will require much more than what we covered in the above sections. Lets cover some important queries in this section. Casting a column to a different data type -- Casting a column to a different data type SELECT CAST ( salary AS VARCHAR ) FROM employees ; Using JSONB column -- Extracting data from JSONB column -- Suppose data column contains {\"name\": \"John\", \"address\": {\"city\": \"New York\", \"state\": \"NY\"}} SELECT name , jsonb_extract_path ( data , 'address' , 'city' ) AS city FROM employees ; Extracting components from a DateTime column -- Extracting month from DATE column -- Suppose in a tbl, order_date col contains info like 2022-01-01 SELECT DATE_TRUNC ( 'month' , order_date ) AS month , COUNT ( * ) AS order_count FROM orders GROUP BY month ORDER BY month ; -- Extract year from DATE column, use: DATE_TRUNC('year', order_date) -- Extract quarter from DATE column, use: DATE_TRUNC('quarter', order_date) -- Extract week from DATE column, use: DATE_TRUNC('week', order_date) -- Extract day from DATE column, use: DATE_TRUNC('day', order_date) -- Extract hour from DATE column, use: DATE_TRUNC('hour', order_date) -- Extract minute from DATE column, use: DATE_TRUNC('minute', order_date) -- Extract second from DATE column, use: DATE_TRUNC('second', order_date) Conclusion PostgreSQL's combination of features, performance, and reliability makes it a popular choice for a wide range of applications, from small projects to large-scale enterprise systems. Its open-source nature, strong community support, and continuous development ensure that PostgreSQL will remain a leading database management system for years to come. Hope this article helped you understand the basics of PostgreSQL and piqued your interest in learning more. References [1] GeeksforGeeks - What is PostgreSQL? | PostgreSQL Tutorial [2] w3schools - PostgreSQL Tutorial [3] Tutorialspoint - PostgreSQL Tutorial","title":"PostgreSQL"},{"location":"data_science_tools/database_postgresql/#introduction-to-postgresql","text":"PostgreSQL, often simply called Postgres, is a powerful, open-source object-relational database management system (ORDBMS). It has a strong reputation for reliability, feature robustness, and performance. PostgreSQL was first developed in 1986 at the University of California, Berkeley as part of the POSTGRES project. It has since evolved into one of the most advanced and widely-used database systems, with a strong community supporting its development. PostgreSQL supports all major operating systems, including Linux, Mac OS, and Windows.","title":"Introduction to PostgreSQL"},{"location":"data_science_tools/database_postgresql/#key-features-of-postgresql","text":"PostgreSQL offers a wide range of features that make it a popular choice for many applications: Extensive data types : PostgreSQL supports a large variety of built-in data types and allows users to define their own custom data types. It can handle complex data types such as arrays, JSON, and geometric types. ACID compliance : PostgreSQL adheres to the ACID principles (Atomicity, Consistency, Isolation, Durability), ensuring reliable and trustworthy transactions. More details Concurrency control : PostgreSQL uses multi-version concurrency control (MVCC) to provide high concurrency without conflicts, allowing multiple transactions to access the same data simultaneously. Advanced querying capabilities : PostgreSQL supports complex SQL queries, subqueries, common table expressions (CTEs), recursive queries, and window functions. It also allows users to define their own functions, triggers, and stored procedures in various programming languages. Full-text search : PostgreSQL provides powerful full-text search capabilities, including stemming, ranking, and phrase-searching support. It uses indexes like B-tree, hash, and GiST to optimize search performance. Replication and high availability : PostgreSQL supports various replication strategies, such as asynchronous streaming, logical, and synchronous replication, providing data redundancy, fault tolerance, and high availability. Security and authentication : PostgreSQL offers robust security features, including SSL encryption, username/password authentication, LDAP authentication, Kerberos authentication, role-based access control (RBAC), and row-level security (RLS).","title":"Key Features of PostgreSQL"},{"location":"data_science_tools/database_postgresql/#setting-up-postgresql","text":"To get PostgreSQL running on your local machine, you will need to have the following tools installed: PostgreSQL Server : You can follow the step-by-step instructions provided on the official website . Once the installation is complete, you can run the server by opening the application. PostgreSQL Query Tools : Once the PostgreSQL server is installed, you can install tools to manage and interact with PostgreSQL. There are multiple choices, each with its own set of unique features and all of them support the basic functionalities. Here are some famous ones - PgAdmin , DBeaver , or you can even use terminal tools like Psql . Hint Installation on Mac PostgreSQL can be installed on Mac by using homebrew . Run the command brew install postgresql . For more details and options, follow the official website .","title":"Setting Up PostgreSQL"},{"location":"data_science_tools/database_postgresql/#learning-the-basics","text":"Practice makes man perfect, so let's learn PostgreSQL through sample codes. Below are some sample code snippets in increasing order of complexity, designed to help you understand various aspects of PostgreSQL. Hint Before we begin, please note that to interact with the database, you need to use the PostgreSQL Query Language, which is a variant of the SQL language. If you are using terminal, then you can activate psql mode by running psql . Once inside you can connect to the database by running the following command: -- Connecting to a PostgreSQL database -- Use a client or terminal with appropriate access credentials \\ c my_database ; Or you can use any of the user-interface tools like PgAdmin for better user experience. 1. Creating a Database -- Creating a database. Replace `my_database` with your database name CREATE DATABASE my_database ; 2. Creating a Table -- Creating a simple table. Replace `employees` with your table name CREATE TABLE employees ( id SERIAL PRIMARY KEY , name VARCHAR ( 50 ), position VARCHAR ( 50 ), departmentid INT , salary DECIMAL ); Hint Here is a detailed list of all supported data types in PostgreSQL. Note, you can also create custom data types . 3. Inserting Data -- Inserting data into the table INSERT INTO employees ( name , position , salary ) VALUES ( 'John Doe' , 'Software Engineer' , 70000 ); 4. Basic Data Retrieval -- Retrieving all data from a table SELECT * FROM employees ; -- Limiting the number of rows returned SELECT * FROM employees LIMIT 10 ; -- Retrieving specific columns SELECT name , position FROM employees ; -- Retrieving data in descending order SELECT * FROM employees ORDER BY salary DESC ; 5. Data Retrieval with Conditions -- Retrieving specific data with a condition SELECT name , position FROM employees WHERE salary > 50000 ; -- Filtering on string columns SELECT * FROM employees WHERE name LIKE '%Doe%' ; -- Filtering on datetime columns SELECT * FROM orders WHERE order_date BETWEEN '2022-01-01' AND '2022-02-01' ; -- Filtering on datetime columns with interval (works same as above) SELECT * FROM orders WHERE order_date BETWEEN '2022-01-01' AND '2022-02-01' :: date + interval '1 month' ; -- To filter based on multiple conditions and values SELECT * FROM employees WHERE name LIKE '%Doe%' AND salary > 50000 AND position in ( 'Software Engineer' , 'Data Scientist' ); 6. Updating Data -- Updating data in the table UPDATE employees SET salary = 75000 WHERE name = 'John Doe' ; 7. Deleting Data -- Deleting data from the table DELETE FROM employees WHERE id = 1 ; -- Deleting all data from the table DELETE FROM employees ; -- Deleting the table DROP TABLE employees ; -- Deleting multiple tables DROP TABLE employees , departments ; 8. Joining Tables -- Creating another table CREATE TABLE departments ( id SERIAL PRIMARY KEY , name VARCHAR ( 50 ) ); -- Inserting data into the new table INSERT INTO departments ( name ) VALUES ( 'Engineering' ); -- Joining two tables SELECT employees . name , departments . name AS department_name FROM employees JOIN departments ON employees . departmentid = departments . id ; 9. Using Aggregate Functions -- Using an aggregate function to get the average salary SELECT AVG ( salary ) FROM employees ; -- Group by a column (ex: getting the average salary by department) SELECT department_name , AVG ( salary ) AS avg_salary FROM employees JOIN departments ON employees . id = departments . id GROUP BY department_name ; 10. Complex Query with Subquery and Grouping -- Finding the highest salary in each department SELECT department_name , MAX ( salary ) AS max_salary FROM ( SELECT employees . name , employees . salary , departments . name AS department_name FROM employees JOIN departments ON employees . id = departments . id ) AS department_salaries GROUP BY department_name ; These examples cover a range of basic to more complex tasks you can perform with PostgreSQL, from establishing a connection to executing advanced queries. As you become more comfortable with these operations, you'll be able to tackle more complex scenarios and optimize your database interactions.","title":"Learning the Basics"},{"location":"data_science_tools/database_postgresql/#python-sample-code","text":"There are multiple python packages available for PostgreSQL like, psycopg2 and asyncpg . For this section, we will use asyncpg package that provides support for asynchronous programming. A sample code to connect to the PostgreSQL server and fetch the result is shown below, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # import import asyncio import asyncpg # the main function that connect to the PostgreSQL server, # fetch the result and print the result async def run (): # connect to the PostgreSQL server conn = await asyncpg . connect ( user = 'postgres' , password = 'admin' , database = 'mydb' , host = 'localhost' ) # fetch the result result = await conn . fetch ( 'SELECT * FROM mytbl LIMIT 1' ) # print the result print ( dict ( result )) # close the connection await conn . close () if __name__ == '__main__' : # run the code loop = asyncio . get_event_loop () loop . run_until_complete ( run ()) Creating dynamic queries based on user input can be easily done by passing the variables to the fetch function. Below is the modification you need to do. If you notice, we have two variables in the query for id and limit denoted by $1 and $2 respectively. The respective values are passed in the fetch function. Rest of the code remains same. 1 2 3 4 5 # fetch the result result = await conn . fetch ( 'SELECT * FROM mytbl where id = $1 LIMIT $2' , 123 , 1 ) You can use conn.execute to run the query without fetching the result. Below is the modification needed. 1 2 3 4 5 # insertion example (one row) result = await conn . execute ( 'INSERT INTO mytbl (code, name) VALUES ($1, $2) where id = $3' , 123 , 'mohit' , 1 ) If you want to execute for multiple rows, you can use conn.executemany instead of conn.execute . Below is the modification to the code shown above. 1 2 3 4 5 # insertion example (multiple rows) result = await conn . executemany ( 'INSERT INTO mytbl (code, name) VALUES ($1, $2) where id = $3' , [( 123 , 'mohit' , 1 ), ( 124 , 'mayank' , 2 )] ) You might want to create a generic function to execute queries and retry in case of failure. Here is how you can do it using the tenacity library. The below code will retry 3 times if the query fails with exponential backoff. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 # import import asyncio import asyncpg import functools from tenacity import TryAgain , retry , stop_after_attempt , wait_exponential # custom retry logging function def custom_retry_log ( retry_state , msg ): if retry_state . attempt_number != 1 : print ( f \"Retrying { retry_state . attempt_number - 1 } for { msg } \" ) # main function async def execute_fetch_script ( script , values = (), msg = None , retry_on_failure = True ): # create connection conn = await asyncpg . connect ( user = 'postgres' , password = 'admin' , database = 'mydb' , host = 'localhost' ) try : # retry mechanism log_callback = functools . partial ( custom_retry_log , msg = msg ) # retry mechanism @retry ( wait = wait_exponential ( multiplier = 2 , min = 2 , max = 16 ), stop = stop_after_attempt ( 4 ), after = log_callback , reraise = True ) async def retry_wrapper (): try : # execute the select SQL script records = await conn . fetch ( script , * values ) project_records = [ dict ( record ) for record in records ] print ( project_records ) # remove this return project_records except Exception as e : if retry_on_failure : raise TryAgain ( e ) else : print ( f \"Failure in { msg } - { e } \" ) return # db call wrapper return await retry_wrapper () except Exception as e : raise Exception ( f \"Failure in { msg } - { e } \" ) finally : # close db connections await conn . close () if __name__ == '__main__' : loop = asyncio . get_event_loop () script = 'SELECT * FROM mytbl where projectid = $1 LIMIT $2' values = ( 2 , 1 ) loop . run_until_complete ( execute_fetch_script ( script , values , \"Testing Run\" )) If you noticed, all of the above examples are executing the query within a single transaction. In case you want to execute multiple queries in one transaction, you can do as shown below, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # import import asyncio import asyncpg import functools from tenacity import TryAgain , retry , stop_after_attempt , wait_exponential # create the connection conn = await asyncpg . connect ( user = 'postgres' , password = 'admin' , database = 'mydb' , host = 'localhost' ) # start the transaction async with conn . transaction (): try : # Query 1 - execute the select SQL script records = await conn . fetch ( 'SELECT * FROM mytbl where projectid = $1 LIMIT $2' , 2 , 1 ) # Query 2 - update the table await conn . execute ( 'UPDATE mytbl SET name = $1 where projectid = $2' , 'mohit' , 2 ) # handle exception except Exception as e : # in case of exception rollback the transaction await conn . execute ( 'ROLLBACK;' ) finally : # close db connections await conn . close ()","title":"Python Sample Code"},{"location":"data_science_tools/database_postgresql/#snippets","text":"Real world problems will require much more than what we covered in the above sections. Lets cover some important queries in this section. Casting a column to a different data type -- Casting a column to a different data type SELECT CAST ( salary AS VARCHAR ) FROM employees ; Using JSONB column -- Extracting data from JSONB column -- Suppose data column contains {\"name\": \"John\", \"address\": {\"city\": \"New York\", \"state\": \"NY\"}} SELECT name , jsonb_extract_path ( data , 'address' , 'city' ) AS city FROM employees ; Extracting components from a DateTime column -- Extracting month from DATE column -- Suppose in a tbl, order_date col contains info like 2022-01-01 SELECT DATE_TRUNC ( 'month' , order_date ) AS month , COUNT ( * ) AS order_count FROM orders GROUP BY month ORDER BY month ; -- Extract year from DATE column, use: DATE_TRUNC('year', order_date) -- Extract quarter from DATE column, use: DATE_TRUNC('quarter', order_date) -- Extract week from DATE column, use: DATE_TRUNC('week', order_date) -- Extract day from DATE column, use: DATE_TRUNC('day', order_date) -- Extract hour from DATE column, use: DATE_TRUNC('hour', order_date) -- Extract minute from DATE column, use: DATE_TRUNC('minute', order_date) -- Extract second from DATE column, use: DATE_TRUNC('second', order_date)","title":"Snippets"},{"location":"data_science_tools/database_postgresql/#conclusion","text":"PostgreSQL's combination of features, performance, and reliability makes it a popular choice for a wide range of applications, from small projects to large-scale enterprise systems. Its open-source nature, strong community support, and continuous development ensure that PostgreSQL will remain a leading database management system for years to come. Hope this article helped you understand the basics of PostgreSQL and piqued your interest in learning more.","title":"Conclusion"},{"location":"data_science_tools/database_postgresql/#references","text":"[1] GeeksforGeeks - What is PostgreSQL? | PostgreSQL Tutorial [2] w3schools - PostgreSQL Tutorial [3] Tutorialspoint - PostgreSQL Tutorial","title":"References"},{"location":"data_science_tools/databases_introduction/","text":"Databases Introduction Databases are like a smart repository of data, where you can keep data in a structured, organized, and secure manner. While you might argue something like, \"Why can't I just keep them in a single txt file?\", remember things starts to get messy when you have a lot of data (millions of entries and more) and you still want to be fast (finding one entry in any modern database will be much faster than from a txt file) . In a way, databases allow for efficient retrieval, manipulation, and analysis of data. They also offer powerful querying and analysis capabilities, enabling data scientists and analysts to extract insights and make data-driven decisions. This makes them a powerful tool for data science projects. This article will briefly focus on the different types of databases, their features and some important generic concepts. You can also find separate articles for individual databases in this section. So without further delay, let's get started! Types of Databases Relational Databases Relational databases are the most common type of database. They are structured using tables, with each table containing rows and columns wherein each row represents a record, and each column contains a field. This simple structure makes it easier to query the database and find the information that is needed. Additionally, relational databases can be linked together using keys, allowing data to be shared between different tables. This makes it possible to link data from different sources and use it to generate meaningful insights. Hence the name \u201crelational\u201d database. Comparison of Relational Databases Feature / Database Oracle MySQL Microsoft SQL Server PostgreSQL MariaDB SQLite IBM Db2 SAP HANA License Commercial Open Source Commercial Open Source Open Source Open Source Commercial Commercial ACID Compliance Yes Yes Yes Yes Yes Yes Yes Yes Scalability Vertical/Horizontal Vertical Vertical/Horizontal Vertical/Horizontal Vertical/Horizontal Limited Vertical/Horizontal Horizontal Partitioning Yes Yes Yes Yes Yes No Yes Yes Replication Yes Yes Yes Yes Yes No Yes Yes JSON Support Yes Limited Yes Yes Yes No Yes Yes Geospatial Support Yes Limited No Yes (PostGIS) Yes No Yes Yes Stored Procedures Yes Yes Yes Yes Yes No Yes Yes User Base Large Enterprises Web Applications Enterprises Diverse Applications Web Applications Embedded Applications Enterprises Enterprises Popularity Rank 1 2 3 4 5 6 7 8 Warning Some details in the above table (like Popularity Rank) are as per the information aggregated from multiple sources at the time the article was written (August 2024) . This could change over time. This table summarizes the key features and characteristics of some of the top relational databases, highlighting their strengths and use cases. Oracle leads in enterprise environments, while MySQL and PostgreSQL are popular for web applications and diverse workloads. Microsoft SQL Server is favored in corporate settings, and MariaDB is recognized for its compatibility with MySQL. SQLite is widely used for lightweight applications, and IBM Db2 and SAP HANA cater to specific enterprise needs. Concepts ACID Compliance ACID compliance refers to a set of principles that ensure reliable processing of database transactions. The acronym ACID stands for Atomicity , Consistency , Isolation , and Durability . Each of these properties plays a crucial role in maintaining the integrity and reliability of data within database systems. [1] Atomicity: Atomicity guarantees that a transaction is treated as a single, indivisible unit. This means that either all operations within the transaction are completed successfully, or none are applied at all. If any part of the transaction fails, the entire transaction is rolled back, ensuring that the database remains unchanged in the event of an error or failure. Consistency: Consistency ensures that a transaction brings the database from one valid state to another, by adhering to all predefined rules and constraints (PRIMARY KEY, FOREIGN KEY, NOT NULL, CHECK, etc) . This property prevents illegal transactions that could corrupt the database, ensuring that all data remains valid and meaningful throughout the transaction process. Isolation: Isolation ensures that concurrent transactions do not interfere with each other. Each transaction is executed in such a way that it appears to be the only transaction being processed at that time, even if multiple transactions are occurring simultaneously. This prevents issues such as dirty reads, where one transaction reads data modified by another uncommitted transaction. Durability: Durability guarantees that once a transaction has been committed, it will remain so, even in the event of a system failure. This means that the changes made by the transaction are permanently recorded in the database, ensuring data persistence and reliability. ACID compliance is critical for applications that require high levels of data integrity, such as financial systems, healthcare databases, and any other systems where data accuracy is paramount. It helps prevent data loss, ensures consistent data states, and facilitates reliable transaction processing, which is essential for maintaining trust and accuracy in data-driven applications. References [1] PlanetScale.com - What does ACID compliance mean?","title":"Introduction"},{"location":"data_science_tools/databases_introduction/#databases","text":"","title":"Databases"},{"location":"data_science_tools/databases_introduction/#introduction","text":"Databases are like a smart repository of data, where you can keep data in a structured, organized, and secure manner. While you might argue something like, \"Why can't I just keep them in a single txt file?\", remember things starts to get messy when you have a lot of data (millions of entries and more) and you still want to be fast (finding one entry in any modern database will be much faster than from a txt file) . In a way, databases allow for efficient retrieval, manipulation, and analysis of data. They also offer powerful querying and analysis capabilities, enabling data scientists and analysts to extract insights and make data-driven decisions. This makes them a powerful tool for data science projects. This article will briefly focus on the different types of databases, their features and some important generic concepts. You can also find separate articles for individual databases in this section. So without further delay, let's get started!","title":"Introduction"},{"location":"data_science_tools/databases_introduction/#types-of-databases","text":"","title":"Types of Databases"},{"location":"data_science_tools/databases_introduction/#relational-databases","text":"Relational databases are the most common type of database. They are structured using tables, with each table containing rows and columns wherein each row represents a record, and each column contains a field. This simple structure makes it easier to query the database and find the information that is needed. Additionally, relational databases can be linked together using keys, allowing data to be shared between different tables. This makes it possible to link data from different sources and use it to generate meaningful insights. Hence the name \u201crelational\u201d database.","title":"Relational Databases"},{"location":"data_science_tools/databases_introduction/#comparison-of-relational-databases","text":"Feature / Database Oracle MySQL Microsoft SQL Server PostgreSQL MariaDB SQLite IBM Db2 SAP HANA License Commercial Open Source Commercial Open Source Open Source Open Source Commercial Commercial ACID Compliance Yes Yes Yes Yes Yes Yes Yes Yes Scalability Vertical/Horizontal Vertical Vertical/Horizontal Vertical/Horizontal Vertical/Horizontal Limited Vertical/Horizontal Horizontal Partitioning Yes Yes Yes Yes Yes No Yes Yes Replication Yes Yes Yes Yes Yes No Yes Yes JSON Support Yes Limited Yes Yes Yes No Yes Yes Geospatial Support Yes Limited No Yes (PostGIS) Yes No Yes Yes Stored Procedures Yes Yes Yes Yes Yes No Yes Yes User Base Large Enterprises Web Applications Enterprises Diverse Applications Web Applications Embedded Applications Enterprises Enterprises Popularity Rank 1 2 3 4 5 6 7 8 Warning Some details in the above table (like Popularity Rank) are as per the information aggregated from multiple sources at the time the article was written (August 2024) . This could change over time. This table summarizes the key features and characteristics of some of the top relational databases, highlighting their strengths and use cases. Oracle leads in enterprise environments, while MySQL and PostgreSQL are popular for web applications and diverse workloads. Microsoft SQL Server is favored in corporate settings, and MariaDB is recognized for its compatibility with MySQL. SQLite is widely used for lightweight applications, and IBM Db2 and SAP HANA cater to specific enterprise needs.","title":"Comparison of Relational Databases"},{"location":"data_science_tools/databases_introduction/#concepts","text":"","title":"Concepts"},{"location":"data_science_tools/databases_introduction/#acid-compliance","text":"ACID compliance refers to a set of principles that ensure reliable processing of database transactions. The acronym ACID stands for Atomicity , Consistency , Isolation , and Durability . Each of these properties plays a crucial role in maintaining the integrity and reliability of data within database systems. [1] Atomicity: Atomicity guarantees that a transaction is treated as a single, indivisible unit. This means that either all operations within the transaction are completed successfully, or none are applied at all. If any part of the transaction fails, the entire transaction is rolled back, ensuring that the database remains unchanged in the event of an error or failure. Consistency: Consistency ensures that a transaction brings the database from one valid state to another, by adhering to all predefined rules and constraints (PRIMARY KEY, FOREIGN KEY, NOT NULL, CHECK, etc) . This property prevents illegal transactions that could corrupt the database, ensuring that all data remains valid and meaningful throughout the transaction process. Isolation: Isolation ensures that concurrent transactions do not interfere with each other. Each transaction is executed in such a way that it appears to be the only transaction being processed at that time, even if multiple transactions are occurring simultaneously. This prevents issues such as dirty reads, where one transaction reads data modified by another uncommitted transaction. Durability: Durability guarantees that once a transaction has been committed, it will remain so, even in the event of a system failure. This means that the changes made by the transaction are permanently recorded in the database, ensuring data persistence and reliability. ACID compliance is critical for applications that require high levels of data integrity, such as financial systems, healthcare databases, and any other systems where data accuracy is paramount. It helps prevent data loss, ensures consistent data states, and facilitates reliable transaction processing, which is essential for maintaining trust and accuracy in data-driven applications.","title":"ACID Compliance"},{"location":"data_science_tools/databases_introduction/#references","text":"[1] PlanetScale.com - What does ACID compliance mean?","title":"References"},{"location":"data_science_tools/github_good_practices/","text":"Github Good Practices Introduction GitHub is a powerful tool for version control and collaboration. In this guide, we will cover essential practices for using GitHub effectively. Whether you are a beginner or an experienced developer, adhering to these practices will help you and your team work more efficiently and maintain a high standard of code quality. Practices Let's go through individual steps in the lifecycle of using Github to discuss good practices, Repositories Creating Repo: Create a new repository when starting a new project, developing a standalone feature, or creating a reusable component. That said, we should be careful about not creating separate projects if the individual modules are supposed to be used together. For example, if we are creating a dashboard (say, using React) that requires specific endpoints (say, using Python) , we can combine the into a single repo and run both applications. Project Owner : Each repo should have at least one Spock or owner who is responsible for new implementation or reviewing any changes made by others in form of PR. This helps with concentrating ownership and responsibility. Repo Structure: The organization of files and directories within a repository is crucial for maintainability and efficiency. It largely depends on the specific language or set of languages used in the project. A well-structured repository should have a logical hierarchy, clear separation of concerns, and follow established conventions for the chosen technology stack. Refer Python Good Practices for more details. Use Descriptive Names: Choose repository names that clearly indicate the project's purpose or content. A good practices is to name the repo with following nomenclature {team}.{projectname}.{service} . As an example, if AI team is developing a Content Classifier that will be exposed as APIs, then a suitable name would be ai.contentclassifer.api Include a README: Always create a comprehensive README file that explains the project's purpose, setup instructions, and usage guidelines. Branches Use Feature Branches: Create separate branches for each new feature or bug fix. This isolates changes and makes it easier to merge them into the main branch when they're ready. Properly naming a branch is crucial for effective and collaborative execution. Some examples are, Feature branch: feature/new-user-registration Bugfix branch: bugfix/login-error Hotfix branch: hotfix/critical-security-issue Release branch: release/v1.2.0 Individual branch : mohit/10-10-2024-updates Keep Branches Up-to-Date: Regularly merge or rebase your feature branches with the dev or main or master branch (whichever branch you intend to merge to later) to avoid merge conflicts and ensure your code is always compatible with the latest changes. Warning Do not push changes directly to main branches. Make sure to create a feature branch, make changes there, test them, and then raise a PR to merge the changes into the main branch. More on this below. Committing Changes Commit Frequently: Make small, focused commits that introduce a single change or feature. This makes it easier to review and revert changes if necessary. Write Clear Commit Messages: Use descriptive commit messages that accurately convey the purpose of the change. Some good practices are, Use the imperative mood: Start your commit message with a verb (e.g., \"Add,\" \"Fix,\" \"Improve\"). Refer to issues or pull requests: If your commit is related to a specific issue or pull request, include a reference to it in the commit message. Ex: Fixed #OB-101 Keep it short: Aim for a commit message that is no more than 50 characters long in general. Pull Requests Pre-PR: Before even raising a PR, make sure you Thoroughly Test Changes: Before creating a pull request, ensure your changes work as expected by running unit tests and/or manual testing. It is also important to perform a thorough test of other modules that might have been impacted due to the changes and perform a random check on other modules to make sure there is no sporadic impact on the overall project. Fix Issues Locally: Address any bugs or issues you discover during testing before submitting your pull request. Warning DO NOT raise a PR if the work is incomplete, or has not been tested. Remember, by raising a PR you should mean to convey that \u201cI have completed the development, and have performed proper tests\u201d. Ask yourself this question, before raising a PR. Draft PR: You can also raise an Draft PR incase you need an early review of the completed modules while you are still working on dependent modules. This helps to expedite the review process, and reduce reviewer\u2019s load by providing them with sufficient time. Creating a PR: Create Descriptive Pull Requests: Use clear and concise titles and descriptions that explain the purpose of the changes. Make sure the title highlight the most important aspects of the PR and the description contains individual changelogs. One example could be, ## Title Implement User Authentication Feature ## Description **Changelog:** - Added login and registration forms - Implemented backend API endpoints for authentication - Set up JWT token generation and validation Add reviewers: When creating a pull request, assign appropriate team members to review your code. Choose reviewers who are familiar with the project and can provide valuable feedback. Post-PR: Review Code Carefully: Reviewer should thoroughly go through the changelog in code and suggest improvements if any by adding comments. Do not approve the PR unless you are satisfied with the code\u2019s quality, impact and implementation. Address Feedback Promptly: Conversations to comments and suggestions from reviewers should be addressed in a timely manner. Conclusion By following these GitHub best practices, you can ensure a more organized, efficient, and collaborative workflow. These practices help maintain high code quality, reduce the likelihood of errors, and streamline the development process. Remember, consistency is key, and adopting these practices as a team will lead to better project outcomes and a more productive development environment. Happy coding!","title":"Github"},{"location":"data_science_tools/github_good_practices/#github-good-practices","text":"","title":"Github Good Practices"},{"location":"data_science_tools/github_good_practices/#introduction","text":"GitHub is a powerful tool for version control and collaboration. In this guide, we will cover essential practices for using GitHub effectively. Whether you are a beginner or an experienced developer, adhering to these practices will help you and your team work more efficiently and maintain a high standard of code quality.","title":"Introduction"},{"location":"data_science_tools/github_good_practices/#practices","text":"Let's go through individual steps in the lifecycle of using Github to discuss good practices,","title":"Practices"},{"location":"data_science_tools/github_good_practices/#repositories","text":"Creating Repo: Create a new repository when starting a new project, developing a standalone feature, or creating a reusable component. That said, we should be careful about not creating separate projects if the individual modules are supposed to be used together. For example, if we are creating a dashboard (say, using React) that requires specific endpoints (say, using Python) , we can combine the into a single repo and run both applications. Project Owner : Each repo should have at least one Spock or owner who is responsible for new implementation or reviewing any changes made by others in form of PR. This helps with concentrating ownership and responsibility. Repo Structure: The organization of files and directories within a repository is crucial for maintainability and efficiency. It largely depends on the specific language or set of languages used in the project. A well-structured repository should have a logical hierarchy, clear separation of concerns, and follow established conventions for the chosen technology stack. Refer Python Good Practices for more details. Use Descriptive Names: Choose repository names that clearly indicate the project's purpose or content. A good practices is to name the repo with following nomenclature {team}.{projectname}.{service} . As an example, if AI team is developing a Content Classifier that will be exposed as APIs, then a suitable name would be ai.contentclassifer.api Include a README: Always create a comprehensive README file that explains the project's purpose, setup instructions, and usage guidelines.","title":"Repositories"},{"location":"data_science_tools/github_good_practices/#branches","text":"Use Feature Branches: Create separate branches for each new feature or bug fix. This isolates changes and makes it easier to merge them into the main branch when they're ready. Properly naming a branch is crucial for effective and collaborative execution. Some examples are, Feature branch: feature/new-user-registration Bugfix branch: bugfix/login-error Hotfix branch: hotfix/critical-security-issue Release branch: release/v1.2.0 Individual branch : mohit/10-10-2024-updates Keep Branches Up-to-Date: Regularly merge or rebase your feature branches with the dev or main or master branch (whichever branch you intend to merge to later) to avoid merge conflicts and ensure your code is always compatible with the latest changes. Warning Do not push changes directly to main branches. Make sure to create a feature branch, make changes there, test them, and then raise a PR to merge the changes into the main branch. More on this below.","title":"Branches"},{"location":"data_science_tools/github_good_practices/#committing-changes","text":"Commit Frequently: Make small, focused commits that introduce a single change or feature. This makes it easier to review and revert changes if necessary. Write Clear Commit Messages: Use descriptive commit messages that accurately convey the purpose of the change. Some good practices are, Use the imperative mood: Start your commit message with a verb (e.g., \"Add,\" \"Fix,\" \"Improve\"). Refer to issues or pull requests: If your commit is related to a specific issue or pull request, include a reference to it in the commit message. Ex: Fixed #OB-101 Keep it short: Aim for a commit message that is no more than 50 characters long in general.","title":"Committing Changes"},{"location":"data_science_tools/github_good_practices/#pull-requests","text":"Pre-PR: Before even raising a PR, make sure you Thoroughly Test Changes: Before creating a pull request, ensure your changes work as expected by running unit tests and/or manual testing. It is also important to perform a thorough test of other modules that might have been impacted due to the changes and perform a random check on other modules to make sure there is no sporadic impact on the overall project. Fix Issues Locally: Address any bugs or issues you discover during testing before submitting your pull request. Warning DO NOT raise a PR if the work is incomplete, or has not been tested. Remember, by raising a PR you should mean to convey that \u201cI have completed the development, and have performed proper tests\u201d. Ask yourself this question, before raising a PR. Draft PR: You can also raise an Draft PR incase you need an early review of the completed modules while you are still working on dependent modules. This helps to expedite the review process, and reduce reviewer\u2019s load by providing them with sufficient time. Creating a PR: Create Descriptive Pull Requests: Use clear and concise titles and descriptions that explain the purpose of the changes. Make sure the title highlight the most important aspects of the PR and the description contains individual changelogs. One example could be, ## Title Implement User Authentication Feature ## Description **Changelog:** - Added login and registration forms - Implemented backend API endpoints for authentication - Set up JWT token generation and validation Add reviewers: When creating a pull request, assign appropriate team members to review your code. Choose reviewers who are familiar with the project and can provide valuable feedback. Post-PR: Review Code Carefully: Reviewer should thoroughly go through the changelog in code and suggest improvements if any by adding comments. Do not approve the PR unless you are satisfied with the code\u2019s quality, impact and implementation. Address Feedback Promptly: Conversations to comments and suggestions from reviewers should be addressed in a timely manner.","title":"Pull Requests"},{"location":"data_science_tools/github_good_practices/#conclusion","text":"By following these GitHub best practices, you can ensure a more organized, efficient, and collaborative workflow. These practices help maintain high code quality, reduce the likelihood of errors, and streamline the development process. Remember, consistency is key, and adopting these practices as a team will lead to better project outcomes and a more productive development environment. Happy coding!","title":"Conclusion"},{"location":"data_science_tools/introduction/","text":"Introduction Several aspiring data scientists think Data science is just about training fancy models. While it's part of the job, what we are missing here is the huge additional effort that is required to make sure that a model is trainable, executable and deployable. Add to it the complexity of working in a team and now we have to make sure the code is well formatted and structured as well. In all, life of a Data scientist is similar to any software engineer, just with a caveat of having the luxury to play with the state-of-the-art AI algorithms once in a while \ud83d\ude04 Now, the industry is trying (or realizing) the capabilities, limitations and responsibilities of professionals in AI or ML field. This is giving rise to increase in requirements for diverse job profiles like ML engineer, Data Engineer, Data Scientist, Research Scientist, etc. That said, Data scientist (DS) are reinventing themselves as well, giving rise to the interesting profile of \"Full stack Data scientists\" - who while researching and experiment with AI models, are not afraid to dabble into the old school engineering aspect of the project. This article is for such aspirants or practitioners. MLOps tools Just like a mechanic should know about all the tools at his disposal, a data scientist should be aware of different ready-made and possibly free services available. You can quote me on this, Quote Never pay for what you can do for free, and never build something which has already been built! With this fortune cookie quote in mind, let's look into different tools and their segregation based on the where and how they are used, Different MLOps tools covering Data, Training, Evaluation and Deployment. ( fullstackdeeplearning ) The rest of this section will cover some of these tools in detail.","title":"Introduction"},{"location":"data_science_tools/introduction/#introduction","text":"Several aspiring data scientists think Data science is just about training fancy models. While it's part of the job, what we are missing here is the huge additional effort that is required to make sure that a model is trainable, executable and deployable. Add to it the complexity of working in a team and now we have to make sure the code is well formatted and structured as well. In all, life of a Data scientist is similar to any software engineer, just with a caveat of having the luxury to play with the state-of-the-art AI algorithms once in a while \ud83d\ude04 Now, the industry is trying (or realizing) the capabilities, limitations and responsibilities of professionals in AI or ML field. This is giving rise to increase in requirements for diverse job profiles like ML engineer, Data Engineer, Data Scientist, Research Scientist, etc. That said, Data scientist (DS) are reinventing themselves as well, giving rise to the interesting profile of \"Full stack Data scientists\" - who while researching and experiment with AI models, are not afraid to dabble into the old school engineering aspect of the project. This article is for such aspirants or practitioners.","title":"Introduction"},{"location":"data_science_tools/introduction/#mlops-tools","text":"Just like a mechanic should know about all the tools at his disposal, a data scientist should be aware of different ready-made and possibly free services available. You can quote me on this, Quote Never pay for what you can do for free, and never build something which has already been built! With this fortune cookie quote in mind, let's look into different tools and their segregation based on the where and how they are used, Different MLOps tools covering Data, Training, Evaluation and Deployment. ( fullstackdeeplearning ) The rest of this section will cover some of these tools in detail.","title":"MLOps tools"},{"location":"data_science_tools/linux_snippets/","text":"Linux snippets A collection of useful Linux (and macOS) command-line snippets for data science workflows. All commands are compatible with zsh and bash shells. List files by size (descending) 1 ls -lhS Find files larger than 100MB 1 find . -type f -size +100M Count lines in all CSV files in a directory 1 wc -l *.csv Show top 10 memory-consuming processes 1 ps aux --sort = -%mem | head -n 11 Search for a pattern in all Python files 1 grep -rnw . -e 'pattern' --include = *.py Replace text in multiple files (in-place) 1 sed -i '' 's/oldtext/newtext/g' *.txt Download a file from the internet 1 curl -O https://example.com/file.csv Extract a tar.gz archive 1 tar -xzvf archive.tar.gz Monitor disk usage in current directory 1 du -sh * Show GPU usage (NVIDIA) 1 nvidia-smi Sample output: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 Wed Jun 11 12 :18:15 2025 +---------------------------------------------------------------------------------------+ | NVIDIA-SMI 535 .183.01 Driver Version: 535 .183.01 CUDA Version: 12 .2 | | -----------------------------------------+----------------------+----------------------+ | GPU Name Persistence-M | Bus-Id Disp.A | Volatile Uncorr. ECC | | Fan Temp Perf Pwr:Usage/Cap | Memory-Usage | GPU-Util Compute M. | | | | MIG M. | | ========================================= + ====================== + ====================== | | 0 NVIDIA H100 PCIe Off | 00000000 :00:08.0 Off | 0 | | N/A 37C P0 117W / 350W | 27085MiB / 81559MiB | 51 % Default | | | | Disabled | +-----------------------------------------+----------------------+----------------------+ | 1 NVIDIA H100 PCIe Off | 00000000 :00:09.0 Off | 0 | | N/A 38C P0 53W / 350W | 3MiB / 81559MiB | 0 % Default | | | | Disabled | +-----------------------------------------+----------------------+----------------------+ +---------------------------------------------------------------------------------------+ | Processes: | | GPU GI CI PID Type Process name GPU Memory | | ID ID Usage | | ======================================================================================= | | 0 N/A N/A 213705 C /usr/bin/python3 27076MiB | +---------------------------------------------------------------------------------------+ Check Python package versions in environment 1 pip freeze Create a virtual environment (Python 3) 1 2 python3 -m venv venv source venv/bin/activate Kill a process by name 1 pkill -f process_name Count unique values in a CSV column 1 cut -d, -f2 file.csv | sort | uniq -c | sort -nr Preview a CSV file (first 5 rows) 1 head -n 5 file.csv Check open ports 1 lsof -i -P -n | grep LISTEN Download all images from a webpage 1 wget -nd -r -P ./images -A jpg,jpeg,png,gif http://example.com Show the 10 largest files in a directory tree 1 find . -type f -exec du -h {} + | sort -rh | head -n 10 Remove all files except .csv in a directory 1 find . ! -name '*.csv' -type f -delete Split a large CSV into smaller files (1000 lines each) 1 split -l 1000 bigfile.csv smallfile_ Find the 10 largest directories in the current directory 1 du -h --max-depth = 1 | sort -hr | head -n 10 Feel free to copy, modify, and combine these snippets for your data science projects!","title":"Linux snippets"},{"location":"data_science_tools/linux_snippets/#linux-snippets","text":"A collection of useful Linux (and macOS) command-line snippets for data science workflows. All commands are compatible with zsh and bash shells.","title":"Linux snippets"},{"location":"data_science_tools/linux_snippets/#list-files-by-size-descending","text":"1 ls -lhS","title":"List files by size (descending)"},{"location":"data_science_tools/linux_snippets/#find-files-larger-than-100mb","text":"1 find . -type f -size +100M","title":"Find files larger than 100MB"},{"location":"data_science_tools/linux_snippets/#count-lines-in-all-csv-files-in-a-directory","text":"1 wc -l *.csv","title":"Count lines in all CSV files in a directory"},{"location":"data_science_tools/linux_snippets/#show-top-10-memory-consuming-processes","text":"1 ps aux --sort = -%mem | head -n 11","title":"Show top 10 memory-consuming processes"},{"location":"data_science_tools/linux_snippets/#search-for-a-pattern-in-all-python-files","text":"1 grep -rnw . -e 'pattern' --include = *.py","title":"Search for a pattern in all Python files"},{"location":"data_science_tools/linux_snippets/#replace-text-in-multiple-files-in-place","text":"1 sed -i '' 's/oldtext/newtext/g' *.txt","title":"Replace text in multiple files (in-place)"},{"location":"data_science_tools/linux_snippets/#download-a-file-from-the-internet","text":"1 curl -O https://example.com/file.csv","title":"Download a file from the internet"},{"location":"data_science_tools/linux_snippets/#extract-a-targz-archive","text":"1 tar -xzvf archive.tar.gz","title":"Extract a tar.gz archive"},{"location":"data_science_tools/linux_snippets/#monitor-disk-usage-in-current-directory","text":"1 du -sh *","title":"Monitor disk usage in current directory"},{"location":"data_science_tools/linux_snippets/#show-gpu-usage-nvidia","text":"1 nvidia-smi Sample output: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 Wed Jun 11 12 :18:15 2025 +---------------------------------------------------------------------------------------+ | NVIDIA-SMI 535 .183.01 Driver Version: 535 .183.01 CUDA Version: 12 .2 | | -----------------------------------------+----------------------+----------------------+ | GPU Name Persistence-M | Bus-Id Disp.A | Volatile Uncorr. ECC | | Fan Temp Perf Pwr:Usage/Cap | Memory-Usage | GPU-Util Compute M. | | | | MIG M. | | ========================================= + ====================== + ====================== | | 0 NVIDIA H100 PCIe Off | 00000000 :00:08.0 Off | 0 | | N/A 37C P0 117W / 350W | 27085MiB / 81559MiB | 51 % Default | | | | Disabled | +-----------------------------------------+----------------------+----------------------+ | 1 NVIDIA H100 PCIe Off | 00000000 :00:09.0 Off | 0 | | N/A 38C P0 53W / 350W | 3MiB / 81559MiB | 0 % Default | | | | Disabled | +-----------------------------------------+----------------------+----------------------+ +---------------------------------------------------------------------------------------+ | Processes: | | GPU GI CI PID Type Process name GPU Memory | | ID ID Usage | | ======================================================================================= | | 0 N/A N/A 213705 C /usr/bin/python3 27076MiB | +---------------------------------------------------------------------------------------+","title":"Show GPU usage (NVIDIA)"},{"location":"data_science_tools/linux_snippets/#check-python-package-versions-in-environment","text":"1 pip freeze","title":"Check Python package versions in environment"},{"location":"data_science_tools/linux_snippets/#create-a-virtual-environment-python-3","text":"1 2 python3 -m venv venv source venv/bin/activate","title":"Create a virtual environment (Python 3)"},{"location":"data_science_tools/linux_snippets/#kill-a-process-by-name","text":"1 pkill -f process_name","title":"Kill a process by name"},{"location":"data_science_tools/linux_snippets/#count-unique-values-in-a-csv-column","text":"1 cut -d, -f2 file.csv | sort | uniq -c | sort -nr","title":"Count unique values in a CSV column"},{"location":"data_science_tools/linux_snippets/#preview-a-csv-file-first-5-rows","text":"1 head -n 5 file.csv","title":"Preview a CSV file (first 5 rows)"},{"location":"data_science_tools/linux_snippets/#check-open-ports","text":"1 lsof -i -P -n | grep LISTEN","title":"Check open ports"},{"location":"data_science_tools/linux_snippets/#download-all-images-from-a-webpage","text":"1 wget -nd -r -P ./images -A jpg,jpeg,png,gif http://example.com","title":"Download all images from a webpage"},{"location":"data_science_tools/linux_snippets/#show-the-10-largest-files-in-a-directory-tree","text":"1 find . -type f -exec du -h {} + | sort -rh | head -n 10","title":"Show the 10 largest files in a directory tree"},{"location":"data_science_tools/linux_snippets/#remove-all-files-except-csv-in-a-directory","text":"1 find . ! -name '*.csv' -type f -delete","title":"Remove all files except .csv in a directory"},{"location":"data_science_tools/linux_snippets/#split-a-large-csv-into-smaller-files-1000-lines-each","text":"1 split -l 1000 bigfile.csv smallfile_","title":"Split a large CSV into smaller files (1000 lines each)"},{"location":"data_science_tools/linux_snippets/#find-the-10-largest-directories-in-the-current-directory","text":"1 du -h --max-depth = 1 | sort -hr | head -n 10 Feel free to copy, modify, and combine these snippets for your data science projects!","title":"Find the 10 largest directories in the current directory"},{"location":"data_science_tools/python_good_practices/","text":"Python Good Practices Introduction Writing code that works now is easy. Writing code that will work tomorrow is hard. Writing code that will work tomorrow and is intuitive enough for anyone to understand and follow\u200a\u2014\u200awell now we have hit the super hard stuff \ud83d\ude00. Observing several ML engineers and Data scientists working with me, I have noticed nearly all of them have their own unique style of coding. Well, don't get me wrong, subjectively is a good thing and I think it is what leads to innovations. That said while working in a team or even in open source collaboration, it helps to agree to a certain set of rules. And that's the idea behind this article, to provide python practitioners with a set of curated guidelines, from which they can pick and choose. With that, let's cover some of the good practices, which will not only help us to create a working but also a beautiful piece of code \ud83d\ude00 To cover this topic, we will go through three parts, Project structuring: ideas on how to organize your code Code formatting: ideas on how to make your code easy to follow Additional tips: a few things which will help you in the longer run Project Structuring In this part, we will basically talk about some good practices on how the complete python project can be structured. For this, we will look at two different possibilities, which anyone can choose based on how simple or complex their project is going to be. Type 1: The Classic This is the most basic format and yet gives the hint of organized structuring. This can be followed when our project consists of only a few scripts. The directory of a sample project could look something like this: 1 2 3 4 5 6 7 8 my_project # Root directory of the project \u251c\u2500\u2500 code # Source codes \u251c\u2500\u2500 input # Input files \u251c\u2500\u2500 output # Output files \u251c\u2500\u2500 config # Configuration files \u251c\u2500\u2500 notebooks # Project related Jupyter notebooks (for experimental code) \u251c\u2500\u2500 requirements . txt # List of external package which are project dependency \u2514\u2500\u2500 README . md # Project README As obvious from the names, folder code contains the individual modules ( .py files), input and output contains the input and output files respectively, and notebook contains the .ipynb notebooks files we use for experimentation. Finally, config folder could contain parameters within yaml or json or ini files and can be accessed by the code module files using configparser . requirements.txt contains a list of all external python packages needed by the project. One advantage of maintaining this file is that all of these packages can be easily installed using pip install -r requirements.txt command. (No need of manually installing each and every external packages!) . One example requirements.txt file is shown below (with package_name==package_version format) , 1 2 3 4 5 6 BeautifulSoup == 3.2.0 Django == 1.3 Fabric == 1.2.0 Jinja2 == 2.5.5 PyYAML == 3.09 Pygments == 1.4 Finally, README.MD contains the what, why and how of the project, with some dummy codes on how to run the project and sample use cases. Type 2: Kedro Kedro is not a project structuring strategy, it's a python tool released by QuantumBlack Labs , which does project structuring for you \ud83d\ude0e. On top of it, they provide a plethora of features to make our project organization and even code execution process super-easy, so that we can truly focus on what matters the most -- the experimentations and implementations! Their project structure is shown below. And btw, we can create a blank project by running kedro new command (don't forget to install kedro first by pip install kedro ) get-started # Parent directory of the template \u251c\u2500\u2500 conf # Project configuration files \u251c\u2500\u2500 data # Local project data (not committed to version control) \u251c\u2500\u2500 docs # Project documentation \u251c\u2500\u2500 logs # Project output logs (not committed to version control) \u251c\u2500\u2500 notebooks # Project related Jupyter notebooks (can be used for experimental code before moving the code to src) \u251c\u2500\u2500 README.md # Project README \u251c\u2500\u2500 setup.cfg # Configuration options for `pytest` when doing `kedro test` and for the `isort` utility when doing `kedro lint` \u2514\u2500\u2500 src # Project source code While most of the directories are similar to other types, a few points should be noted. Kedro's way of grouping different modules is by creating different \"pipelines\" . These pipelines are present within src folder, which in turn contains the module files. Furthermore, they have clear segregation of individual functions which are executed - these are stored within nodes.py file, and these functions are later connected with the input and output within pipeline.py file (all within the individual pipeline folder) . Kedro also segregates the code and the parameters, by storing the parameters within conf folder. Apart from just helping with organizing the project, they also provide options for sequential or parallel executions. We can execute individual functions (within nodes.py ) , or individual pipelines (which are a combination of functions) , or the complete project at one go. We can also create doc of the complete project or compile and package the project as a python .whl file, with just a single command run. For more details, and believe me we have just touched the surface, refer to their official documentation . Code formatting With a top-down approach, let's first have a look at a neat piece of code. We will discuss individual aspects of the code in more detail later. For now, just assume if someone asks you to do some scripting, what an ideal piece of code file should look like. Following code is take from csv_column_operations.py module file. It was generated for the prompt: \"write a function which takes csv file as input and returns the sum of a column\" . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 \"\"\"Return sum of a column from CSV file A module with \"perform_column_sum\" main function that computes and return sum of an user defined numerical column from an csv file passed as pandas dataframe Author: Mohit Mayank <mohitmayank1@gmail.com> Created: 4th August, 2021 \"\"\" # imports import sys # to exit execution import pandas as pd # to handle csv files # modules def perform_column_sum ( csv_file , column_to_perform_operation_on , operation_to_perform = 'sum' ): \"\"\"Performs numerical operation over a column of pandas dataframe Parameters ------------- csv_file: pandas.DataFrame the csv file which contains the column on which operation is to be performed column_to_perform_operation_on: string the column name (must be present in the csv file) operation_to_perform: string which operation to be performed on the column. Supported: ['sum'] Returns -------- column_operation_result: numeric the result after applying numeric operation on csv column \"\"\" # Step 1: data check and break # check 1: column should be present in the csv_file check_flag_col_presence = column_to_perform_operation_on in csv_file . columns # break the code if incorrect data is provided if not check_flag_col_presence : print ( f \"Column { column_to_perform_operation_on } is absent from the csv_file! Breaking code!\" ) sys . exit () # check 2: all values in the column should be of type numeric check_flag_data_type = pd . to_numeric ( csv_file [ column_to_perform_operation_on ], errors = 'coerce' ) . notnull () . all () # break the code if incorrect data is provided if not check_flag_data_type : print ( f \"One or more values in column { column_to_perform_operation_on } is not numeric! Breaking code!\" ) sys . exit () # Step 2: extract the column column_data = csv_file [ column_to_perform_operation_on ] # Step 3: Perform the operation column_operation_result = None if operation_to_perform == 'sum' : column_operation_result = sum ( column_data ) # Step 4: return the result return column_operation_result # run when file is directly executed if __name__ == '__main__' : # create a dummy dataframe df = pd . DataFrame ({ 'col1' : [ 1 , 2 , 3 ], 'col2' : [ 'a' , 'a' , 'a' ]}) # call the function answer = perform_column_sum ( df , 'col1' , 'sum' ) # match if the answer is correct assert ( answer == 6 ) Note Some might argue why do such an overkill for a simple piece of code. Note, it's a dummy example. In real life, you will develop more complex pieces of codes and hence it become quite important that we understand the gist. Now let's take a deeper dive into the individual aspect of the above code. Module structure A module is a python file with .py extension that contains the executable code or functions or classes, etc. Usually, we start the module with module definition, which is an area where we provide some basic details of the module. We can do so using the following template (and it can be easily compared to a real code shown above) 1 2 3 4 5 6 7 8 \"\"\"<Short description> <Long description> Author: <Name> <email> Created: <date> \"\"\" Next, we should clearly segregate the parts of the module such as imports, code area, etc using comment lines. Finally, at the bottom, we could include some examples on how to run the code. Including these scripts within if __name__ == '__main__': makes sure that they only run when the file is directly executed (like python csv_column_operations.py ) . So these pieces of code doesn't run when you say import the module in another script. Functions structure Functions are the basic block of code that performs a specific task. A module consists of several functions. To inform the user what a particular block of code does, we start the function with a function definition. A sample template is provided below, 1 2 3 4 5 6 7 8 9 10 11 12 \"\"\"Description Paramters --------- <parameter_1>: <data_type> <parameter_1_description> Returns --------- <output_1>: <data_type> <output_1_description> \"\"\" After this, we can start adding the relevant code lines. Make sure to separate different logical blocks of code within the functions using comments. One important thing to handle at the start of the coding section is to check the parameters and input data for some data type or data content related basic issues. A majority of code break happens due to silly mistakes like when someone provides wrong input, in which case we should print or log warning message and gracefully exit. The above same code contains two such preliminary but important checks inside the step 1 section. Naming convention There are several formatting conventions that we can follow, like Camel Case , Snake case , etc. It's quite subjective and depends on the developer. Below are some examples of naming different entities of a python code (taken from PIP8 conventions - with some modifications) \ud83d\ude07, Module name: Modules should have short, all-lowercase names (ex: csv_column_operations.py ) Function or method name: Function names should be lowercase, with words separated by underscores as necessary to improve readability. Also, don't forget to add your verbs! (ex: perform_column_sum() ) Variable name: Similar to function name but without the verbs! (ex: list_of_news ) Class name: Class names should normally use the CapWords convention. (ex: FindMax ) Constant name: Constants are usually defined on a module level and written in all capital letters with underscores separating words. (ex: MAX_OVERFLOW and TOTAL ). Add comments PEP-8 defines three types of comments, Block comments: which is written for a single or a collection of code lines. This can be done either when you want to explain a set of lines or just want to segregate code. In the above example, you can see # Step {1, 2, 3} used as segregation comment and # run when file is directly executed used to explain a set of code lines. Inline comments: which are added on the same line as the code. For example, see how # to handle csv files is used to justify the pandas package import. PEP-8 suggests using inline comments sparingly. Documentation Strings: these are used for documentation for module, functions or classes. PEP-257 suggests using multiline comment for docstring (using \"\"\") . An example of module and function docstrings (short for documentation strings) is provided in the sample code above. We should be as descriptive in our comments as possible. Try to separate functional sections of your code, provide explanations for complex code lines, provide details about the input/output of functions, etc. How do you know you have enough comments? - If you think someone with half your expertise can understand the code without calling you middle of the night! \ud83d\ude24 Indentations - Tabs vs Spaces Frankly, I am only going to touch this topic with a long stick \ud83e\uddf9. There are already several articles , reddit threads and even tv series (Silicon valley \ud83d\udcfa) where this topic has been discussed a lot! Want my 2 cents? Pick any modern IDE (like VSCode, Sublime, etc) , set indentations to tabs, and set 1 tab = 4 spaces. Done \ud83d\ude0f Linters Linters are tools that analyze your code to detect various types of errors. They can help you to maintain a consistent coding style and avoid common programming errors. Python has several linters available, like pylint , flake8 , pydocstyle , etc. Using them is super easy, say for pylint - you can install it using pip install pylint and run using pylint my_module.py . That's it! If you are using VSCode, you can install the Python extension by Microsoft, which comes with inbuilt linter support. Or you can install fast linters (using VSCode extension) like Ruff which is upto 10-100x faster than Flake8 and Black. Additional tips Till now we have discussed how to either structure the project or format the code. Next, we will cover a generic set of good practices which will save you some pain down the line \ud83d\ude2c Logging Instead of printing statements in the console which is temporary (do a cls and poof it's gone\ud83d\udca8), a better idea is to save these statements in a separate file, which you can always go back and refer to. This is logging \ud83d\udcdc Python provides an inbuilt function for logging. By referring to the official how to , logging to a file is super easy, 1 2 3 4 5 6 7 8 9 # import import logging # config the logging behavior logging . basicConfig ( filename = 'example.log' , level = logging . DEBUG ) # some sample log messages logging . debug ( 'This message should go to the log file' , exc_info = True ) logging . info ( 'So should this' , exc_info = True ) logging . warning ( 'And this, too' , exc_info = True ) # we add \"exc_info=True\" to capture the stack trace Note, there is a hierarchical levelling of logs to segregate different severity of logs. In the example shown above, the level parameter denotes the minimal level that is tracked and hence saved to the file. As per the official how to , these are the different logging levels with some details about when to use which (in increasing order of severity) , Level When it\u2019s used DEBUG Detailed information, typically of interest only when diagnosing problems. INFO Confirmation that things are working as expected. WARNING An indication that something unexpected happened, or indicative of some problem in the near future (e.g. \u2018disk space low\u2019). The software is still working as expected. ERROR Due to a more serious problem, the software has not been able to perform some function. CRITICAL A serious error, indicating that the program itself may be unable to continue running. While the above code is good for normal testing, for production you might want to have more control -- like formatting the output slightly differently (formatter) or have multiple places to publish logs (handlers) . One such use case is convered below, where we want to log to console as well as a file in a detailed json format. # import import sys import logging import json_log_formatter # create formatter (using json_log_formatter) formatter = json_log_formatter . VerboseJSONFormatter () # create two handlers (console and file) logger_sys_handler = logging . StreamHandler ( sys . stdout ) logger_file_handler = logging . FileHandler ( filename = 'log.json' ) # perform the same formatting for both handler logger_sys_handler . setFormatter ( formatter ) logger_file_handler . setFormatter ( formatter ) # get the logger and add handlers logger = logging . getLogger ( 'my_logger' ) logger . addHandler ( logger_sys_handler ) logger . addHandler ( logger_file_handler ) # set level logger . setLevel ( logging . INFO ) Documentation Documentation of the code is an absolute must, if you are planning to maintain the code or hand it over to someone else in the foreseeable future. Just ask any developer about their excitement on finding a ready-made and well curated documentation for a package they are planning to use! On the other hand, it looks quite difficult to create one yourself, isn't it? I mean, look at the beautiful docs of sklearn or pandas . \ud83d\ude2e Well, sorry for the scare there, but actually it's quite simple \ud83d\ude09. Remember all the function and module docstring and the formatting we followed before? As it turns out, we can leverage many open source tools like pydoc and sphinx to create full-fledged HTML documentations! Going into practical details is out of scope of this article, but it is fairly easy to follow the \"how to\" steps of both the packages and get your doc ready. One last thing, if you are using Kedro, this process is even simpler. All you have to do is run one command - kedro build-docs --open to create the documentation and automatically open it in your default browser! Virtual environment Virtual environments (VE) can be thought of as the local copy of python environment, created specifically for a project. This local copy is like a blank slate, as any required package can be installed here separately. It is extremely important to create a new virtual environment for any new project, because, each project has its own dependency tree (one package with a specific version needs another package to run, with its own specific version) while developing a project we may need to downgrade or upgrade a package, which if done on the base python environment, will affect your system! hence, a separate copy of python (VE), where you install whatever you want, seems to be the most logical solution. Using VE basically requires two steps, Create a VE: this can be done by running command python3 -m venv tutorial-env at the project root directory. (note, tutorial-env is the name of the VE, you can use rename it to anything) Activate VE: this can be done by running command tutorial-env\\Scripts\\activate.bat on Windows and source tutorial-env/bin/activate on Unix or MacOS. And that's it! Install, uninstall, upgrade or downgrade whatever you want! Note Remember to switch to another VE when you start working on another project or/and to deactivate the VE when you want to move to base VE. Handling Secrets and Keys While working on a project, we often need to use some secret keys or passwords, like API keys, database passwords, etc. It is a good practice to store these keys in a separate file, which is not committed to the version control system. This file is usually named .env and is stored at the root of the project directory. The .env file contains the keys in the form of KEY=VALUE pairs. For example, 1 2 API_KEY = 1234567890 DB_PASSWORD = abcd1234 To access these keys in the code, we can use the python-dotenv package to read the .env file and store the keys in the environment variables. Then we can use os module to read the environment variables. For example, 1 2 3 4 5 6 7 8 9 import os from dotenv import load_dotenv # load the .env file load_dotenv () # access the keys api_key = os . getenv ( 'API_KEY' ) db_password = os . getenv ( 'DB_PASSWORD' ) The .env file should be added to the .gitignore file to prevent it from being committed to the version control system. This ensures that the secret keys are not exposed to the public. Hint If you are using AI coding assistant like Github CoPilot, make sure to exclude the .env files in the settings so that it can't access the keys. Type Hints and Data Validation Python comes with dynamic variable type support, i.e. you can execute code x=1 and x='a' one after the another and the it will still work. This is in contrast with languages like Java and C++ where you have to specify the type explicitly, for example int a = 1 . While this feature makes Python easier to use and more dynamic, it comes at the cost of clarity and complexity. Now, let's talk about some good practices to mitigate this. Type Hints , as the name suggests, is an inbuilt functionality in Python to provide hints about the variable or parameter types in Python. One example is shown below, where name: str denotes that the function greeting expects a string input, and -> str denotes that it returns a string output. 1 2 def greeting ( name : str ) -> str : return 'Hello ' + name Note Python runtime does not enforce type checks by default, type hints are there for cleaner code and are used by 3rd party tools like IDEs and linters. For Data validation purpose, we can use Pydantic that provides multiple ready-made validation, custom validation and json serialization support. One example is shown below, where we define the model Delivery class (that inherits from BaseModel ) with timestamp , dimensions and enum fields and provide their respective type hints. Here, Pydantic enforces that timestamp should be of type datetime , dimensions should be of type tuple of two int and enum will be positive integer. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from datetime import datetime from typing import Tuple from pydantic import BaseModel , PositiveInt # class definition class Delivery ( BaseModel ): timestamp : datetime dimensions : Tuple [ int , int ] enum : PositiveInt m = Delivery ( timestamp = '2020-01-02T03:04:05Z' , dimensions = [ '10' , '20' ], enum = 1 ) print ( repr ( m . timestamp )) #> datetime.datetime(2020, 1, 2, 3, 4, 5, tzinfo=TzInfo(UTC)) print ( m . dimensions ) #> (10, 20) References PEP8 Style Guide for Python Code Kedro Python 3 documentation","title":"Python"},{"location":"data_science_tools/python_good_practices/#python-good-practices","text":"","title":"Python Good Practices"},{"location":"data_science_tools/python_good_practices/#introduction","text":"Writing code that works now is easy. Writing code that will work tomorrow is hard. Writing code that will work tomorrow and is intuitive enough for anyone to understand and follow\u200a\u2014\u200awell now we have hit the super hard stuff \ud83d\ude00. Observing several ML engineers and Data scientists working with me, I have noticed nearly all of them have their own unique style of coding. Well, don't get me wrong, subjectively is a good thing and I think it is what leads to innovations. That said while working in a team or even in open source collaboration, it helps to agree to a certain set of rules. And that's the idea behind this article, to provide python practitioners with a set of curated guidelines, from which they can pick and choose. With that, let's cover some of the good practices, which will not only help us to create a working but also a beautiful piece of code \ud83d\ude00 To cover this topic, we will go through three parts, Project structuring: ideas on how to organize your code Code formatting: ideas on how to make your code easy to follow Additional tips: a few things which will help you in the longer run","title":"Introduction"},{"location":"data_science_tools/python_good_practices/#project-structuring","text":"In this part, we will basically talk about some good practices on how the complete python project can be structured. For this, we will look at two different possibilities, which anyone can choose based on how simple or complex their project is going to be.","title":"Project Structuring"},{"location":"data_science_tools/python_good_practices/#type-1-the-classic","text":"This is the most basic format and yet gives the hint of organized structuring. This can be followed when our project consists of only a few scripts. The directory of a sample project could look something like this: 1 2 3 4 5 6 7 8 my_project # Root directory of the project \u251c\u2500\u2500 code # Source codes \u251c\u2500\u2500 input # Input files \u251c\u2500\u2500 output # Output files \u251c\u2500\u2500 config # Configuration files \u251c\u2500\u2500 notebooks # Project related Jupyter notebooks (for experimental code) \u251c\u2500\u2500 requirements . txt # List of external package which are project dependency \u2514\u2500\u2500 README . md # Project README As obvious from the names, folder code contains the individual modules ( .py files), input and output contains the input and output files respectively, and notebook contains the .ipynb notebooks files we use for experimentation. Finally, config folder could contain parameters within yaml or json or ini files and can be accessed by the code module files using configparser . requirements.txt contains a list of all external python packages needed by the project. One advantage of maintaining this file is that all of these packages can be easily installed using pip install -r requirements.txt command. (No need of manually installing each and every external packages!) . One example requirements.txt file is shown below (with package_name==package_version format) , 1 2 3 4 5 6 BeautifulSoup == 3.2.0 Django == 1.3 Fabric == 1.2.0 Jinja2 == 2.5.5 PyYAML == 3.09 Pygments == 1.4 Finally, README.MD contains the what, why and how of the project, with some dummy codes on how to run the project and sample use cases.","title":"Type 1: The Classic"},{"location":"data_science_tools/python_good_practices/#type-2-kedro","text":"Kedro is not a project structuring strategy, it's a python tool released by QuantumBlack Labs , which does project structuring for you \ud83d\ude0e. On top of it, they provide a plethora of features to make our project organization and even code execution process super-easy, so that we can truly focus on what matters the most -- the experimentations and implementations! Their project structure is shown below. And btw, we can create a blank project by running kedro new command (don't forget to install kedro first by pip install kedro ) get-started # Parent directory of the template \u251c\u2500\u2500 conf # Project configuration files \u251c\u2500\u2500 data # Local project data (not committed to version control) \u251c\u2500\u2500 docs # Project documentation \u251c\u2500\u2500 logs # Project output logs (not committed to version control) \u251c\u2500\u2500 notebooks # Project related Jupyter notebooks (can be used for experimental code before moving the code to src) \u251c\u2500\u2500 README.md # Project README \u251c\u2500\u2500 setup.cfg # Configuration options for `pytest` when doing `kedro test` and for the `isort` utility when doing `kedro lint` \u2514\u2500\u2500 src # Project source code While most of the directories are similar to other types, a few points should be noted. Kedro's way of grouping different modules is by creating different \"pipelines\" . These pipelines are present within src folder, which in turn contains the module files. Furthermore, they have clear segregation of individual functions which are executed - these are stored within nodes.py file, and these functions are later connected with the input and output within pipeline.py file (all within the individual pipeline folder) . Kedro also segregates the code and the parameters, by storing the parameters within conf folder. Apart from just helping with organizing the project, they also provide options for sequential or parallel executions. We can execute individual functions (within nodes.py ) , or individual pipelines (which are a combination of functions) , or the complete project at one go. We can also create doc of the complete project or compile and package the project as a python .whl file, with just a single command run. For more details, and believe me we have just touched the surface, refer to their official documentation .","title":"Type 2: Kedro"},{"location":"data_science_tools/python_good_practices/#code-formatting","text":"With a top-down approach, let's first have a look at a neat piece of code. We will discuss individual aspects of the code in more detail later. For now, just assume if someone asks you to do some scripting, what an ideal piece of code file should look like. Following code is take from csv_column_operations.py module file. It was generated for the prompt: \"write a function which takes csv file as input and returns the sum of a column\" . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 \"\"\"Return sum of a column from CSV file A module with \"perform_column_sum\" main function that computes and return sum of an user defined numerical column from an csv file passed as pandas dataframe Author: Mohit Mayank <mohitmayank1@gmail.com> Created: 4th August, 2021 \"\"\" # imports import sys # to exit execution import pandas as pd # to handle csv files # modules def perform_column_sum ( csv_file , column_to_perform_operation_on , operation_to_perform = 'sum' ): \"\"\"Performs numerical operation over a column of pandas dataframe Parameters ------------- csv_file: pandas.DataFrame the csv file which contains the column on which operation is to be performed column_to_perform_operation_on: string the column name (must be present in the csv file) operation_to_perform: string which operation to be performed on the column. Supported: ['sum'] Returns -------- column_operation_result: numeric the result after applying numeric operation on csv column \"\"\" # Step 1: data check and break # check 1: column should be present in the csv_file check_flag_col_presence = column_to_perform_operation_on in csv_file . columns # break the code if incorrect data is provided if not check_flag_col_presence : print ( f \"Column { column_to_perform_operation_on } is absent from the csv_file! Breaking code!\" ) sys . exit () # check 2: all values in the column should be of type numeric check_flag_data_type = pd . to_numeric ( csv_file [ column_to_perform_operation_on ], errors = 'coerce' ) . notnull () . all () # break the code if incorrect data is provided if not check_flag_data_type : print ( f \"One or more values in column { column_to_perform_operation_on } is not numeric! Breaking code!\" ) sys . exit () # Step 2: extract the column column_data = csv_file [ column_to_perform_operation_on ] # Step 3: Perform the operation column_operation_result = None if operation_to_perform == 'sum' : column_operation_result = sum ( column_data ) # Step 4: return the result return column_operation_result # run when file is directly executed if __name__ == '__main__' : # create a dummy dataframe df = pd . DataFrame ({ 'col1' : [ 1 , 2 , 3 ], 'col2' : [ 'a' , 'a' , 'a' ]}) # call the function answer = perform_column_sum ( df , 'col1' , 'sum' ) # match if the answer is correct assert ( answer == 6 ) Note Some might argue why do such an overkill for a simple piece of code. Note, it's a dummy example. In real life, you will develop more complex pieces of codes and hence it become quite important that we understand the gist. Now let's take a deeper dive into the individual aspect of the above code.","title":"Code formatting"},{"location":"data_science_tools/python_good_practices/#module-structure","text":"A module is a python file with .py extension that contains the executable code or functions or classes, etc. Usually, we start the module with module definition, which is an area where we provide some basic details of the module. We can do so using the following template (and it can be easily compared to a real code shown above) 1 2 3 4 5 6 7 8 \"\"\"<Short description> <Long description> Author: <Name> <email> Created: <date> \"\"\" Next, we should clearly segregate the parts of the module such as imports, code area, etc using comment lines. Finally, at the bottom, we could include some examples on how to run the code. Including these scripts within if __name__ == '__main__': makes sure that they only run when the file is directly executed (like python csv_column_operations.py ) . So these pieces of code doesn't run when you say import the module in another script.","title":"Module structure"},{"location":"data_science_tools/python_good_practices/#functions-structure","text":"Functions are the basic block of code that performs a specific task. A module consists of several functions. To inform the user what a particular block of code does, we start the function with a function definition. A sample template is provided below, 1 2 3 4 5 6 7 8 9 10 11 12 \"\"\"Description Paramters --------- <parameter_1>: <data_type> <parameter_1_description> Returns --------- <output_1>: <data_type> <output_1_description> \"\"\" After this, we can start adding the relevant code lines. Make sure to separate different logical blocks of code within the functions using comments. One important thing to handle at the start of the coding section is to check the parameters and input data for some data type or data content related basic issues. A majority of code break happens due to silly mistakes like when someone provides wrong input, in which case we should print or log warning message and gracefully exit. The above same code contains two such preliminary but important checks inside the step 1 section.","title":"Functions structure"},{"location":"data_science_tools/python_good_practices/#naming-convention","text":"There are several formatting conventions that we can follow, like Camel Case , Snake case , etc. It's quite subjective and depends on the developer. Below are some examples of naming different entities of a python code (taken from PIP8 conventions - with some modifications) \ud83d\ude07, Module name: Modules should have short, all-lowercase names (ex: csv_column_operations.py ) Function or method name: Function names should be lowercase, with words separated by underscores as necessary to improve readability. Also, don't forget to add your verbs! (ex: perform_column_sum() ) Variable name: Similar to function name but without the verbs! (ex: list_of_news ) Class name: Class names should normally use the CapWords convention. (ex: FindMax ) Constant name: Constants are usually defined on a module level and written in all capital letters with underscores separating words. (ex: MAX_OVERFLOW and TOTAL ).","title":"Naming convention"},{"location":"data_science_tools/python_good_practices/#add-comments","text":"PEP-8 defines three types of comments, Block comments: which is written for a single or a collection of code lines. This can be done either when you want to explain a set of lines or just want to segregate code. In the above example, you can see # Step {1, 2, 3} used as segregation comment and # run when file is directly executed used to explain a set of code lines. Inline comments: which are added on the same line as the code. For example, see how # to handle csv files is used to justify the pandas package import. PEP-8 suggests using inline comments sparingly. Documentation Strings: these are used for documentation for module, functions or classes. PEP-257 suggests using multiline comment for docstring (using \"\"\") . An example of module and function docstrings (short for documentation strings) is provided in the sample code above. We should be as descriptive in our comments as possible. Try to separate functional sections of your code, provide explanations for complex code lines, provide details about the input/output of functions, etc. How do you know you have enough comments? - If you think someone with half your expertise can understand the code without calling you middle of the night! \ud83d\ude24","title":"Add comments"},{"location":"data_science_tools/python_good_practices/#indentations-tabs-vs-spaces","text":"Frankly, I am only going to touch this topic with a long stick \ud83e\uddf9. There are already several articles , reddit threads and even tv series (Silicon valley \ud83d\udcfa) where this topic has been discussed a lot! Want my 2 cents? Pick any modern IDE (like VSCode, Sublime, etc) , set indentations to tabs, and set 1 tab = 4 spaces. Done \ud83d\ude0f","title":"Indentations - Tabs vs Spaces"},{"location":"data_science_tools/python_good_practices/#linters","text":"Linters are tools that analyze your code to detect various types of errors. They can help you to maintain a consistent coding style and avoid common programming errors. Python has several linters available, like pylint , flake8 , pydocstyle , etc. Using them is super easy, say for pylint - you can install it using pip install pylint and run using pylint my_module.py . That's it! If you are using VSCode, you can install the Python extension by Microsoft, which comes with inbuilt linter support. Or you can install fast linters (using VSCode extension) like Ruff which is upto 10-100x faster than Flake8 and Black.","title":"Linters"},{"location":"data_science_tools/python_good_practices/#additional-tips","text":"Till now we have discussed how to either structure the project or format the code. Next, we will cover a generic set of good practices which will save you some pain down the line \ud83d\ude2c","title":"Additional tips"},{"location":"data_science_tools/python_good_practices/#logging","text":"Instead of printing statements in the console which is temporary (do a cls and poof it's gone\ud83d\udca8), a better idea is to save these statements in a separate file, which you can always go back and refer to. This is logging \ud83d\udcdc Python provides an inbuilt function for logging. By referring to the official how to , logging to a file is super easy, 1 2 3 4 5 6 7 8 9 # import import logging # config the logging behavior logging . basicConfig ( filename = 'example.log' , level = logging . DEBUG ) # some sample log messages logging . debug ( 'This message should go to the log file' , exc_info = True ) logging . info ( 'So should this' , exc_info = True ) logging . warning ( 'And this, too' , exc_info = True ) # we add \"exc_info=True\" to capture the stack trace Note, there is a hierarchical levelling of logs to segregate different severity of logs. In the example shown above, the level parameter denotes the minimal level that is tracked and hence saved to the file. As per the official how to , these are the different logging levels with some details about when to use which (in increasing order of severity) , Level When it\u2019s used DEBUG Detailed information, typically of interest only when diagnosing problems. INFO Confirmation that things are working as expected. WARNING An indication that something unexpected happened, or indicative of some problem in the near future (e.g. \u2018disk space low\u2019). The software is still working as expected. ERROR Due to a more serious problem, the software has not been able to perform some function. CRITICAL A serious error, indicating that the program itself may be unable to continue running. While the above code is good for normal testing, for production you might want to have more control -- like formatting the output slightly differently (formatter) or have multiple places to publish logs (handlers) . One such use case is convered below, where we want to log to console as well as a file in a detailed json format. # import import sys import logging import json_log_formatter # create formatter (using json_log_formatter) formatter = json_log_formatter . VerboseJSONFormatter () # create two handlers (console and file) logger_sys_handler = logging . StreamHandler ( sys . stdout ) logger_file_handler = logging . FileHandler ( filename = 'log.json' ) # perform the same formatting for both handler logger_sys_handler . setFormatter ( formatter ) logger_file_handler . setFormatter ( formatter ) # get the logger and add handlers logger = logging . getLogger ( 'my_logger' ) logger . addHandler ( logger_sys_handler ) logger . addHandler ( logger_file_handler ) # set level logger . setLevel ( logging . INFO )","title":"Logging"},{"location":"data_science_tools/python_good_practices/#documentation","text":"Documentation of the code is an absolute must, if you are planning to maintain the code or hand it over to someone else in the foreseeable future. Just ask any developer about their excitement on finding a ready-made and well curated documentation for a package they are planning to use! On the other hand, it looks quite difficult to create one yourself, isn't it? I mean, look at the beautiful docs of sklearn or pandas . \ud83d\ude2e Well, sorry for the scare there, but actually it's quite simple \ud83d\ude09. Remember all the function and module docstring and the formatting we followed before? As it turns out, we can leverage many open source tools like pydoc and sphinx to create full-fledged HTML documentations! Going into practical details is out of scope of this article, but it is fairly easy to follow the \"how to\" steps of both the packages and get your doc ready. One last thing, if you are using Kedro, this process is even simpler. All you have to do is run one command - kedro build-docs --open to create the documentation and automatically open it in your default browser!","title":"Documentation"},{"location":"data_science_tools/python_good_practices/#virtual-environment","text":"Virtual environments (VE) can be thought of as the local copy of python environment, created specifically for a project. This local copy is like a blank slate, as any required package can be installed here separately. It is extremely important to create a new virtual environment for any new project, because, each project has its own dependency tree (one package with a specific version needs another package to run, with its own specific version) while developing a project we may need to downgrade or upgrade a package, which if done on the base python environment, will affect your system! hence, a separate copy of python (VE), where you install whatever you want, seems to be the most logical solution. Using VE basically requires two steps, Create a VE: this can be done by running command python3 -m venv tutorial-env at the project root directory. (note, tutorial-env is the name of the VE, you can use rename it to anything) Activate VE: this can be done by running command tutorial-env\\Scripts\\activate.bat on Windows and source tutorial-env/bin/activate on Unix or MacOS. And that's it! Install, uninstall, upgrade or downgrade whatever you want! Note Remember to switch to another VE when you start working on another project or/and to deactivate the VE when you want to move to base VE.","title":"Virtual environment"},{"location":"data_science_tools/python_good_practices/#handling-secrets-and-keys","text":"While working on a project, we often need to use some secret keys or passwords, like API keys, database passwords, etc. It is a good practice to store these keys in a separate file, which is not committed to the version control system. This file is usually named .env and is stored at the root of the project directory. The .env file contains the keys in the form of KEY=VALUE pairs. For example, 1 2 API_KEY = 1234567890 DB_PASSWORD = abcd1234 To access these keys in the code, we can use the python-dotenv package to read the .env file and store the keys in the environment variables. Then we can use os module to read the environment variables. For example, 1 2 3 4 5 6 7 8 9 import os from dotenv import load_dotenv # load the .env file load_dotenv () # access the keys api_key = os . getenv ( 'API_KEY' ) db_password = os . getenv ( 'DB_PASSWORD' ) The .env file should be added to the .gitignore file to prevent it from being committed to the version control system. This ensures that the secret keys are not exposed to the public. Hint If you are using AI coding assistant like Github CoPilot, make sure to exclude the .env files in the settings so that it can't access the keys.","title":"Handling Secrets and Keys"},{"location":"data_science_tools/python_good_practices/#type-hints-and-data-validation","text":"Python comes with dynamic variable type support, i.e. you can execute code x=1 and x='a' one after the another and the it will still work. This is in contrast with languages like Java and C++ where you have to specify the type explicitly, for example int a = 1 . While this feature makes Python easier to use and more dynamic, it comes at the cost of clarity and complexity. Now, let's talk about some good practices to mitigate this. Type Hints , as the name suggests, is an inbuilt functionality in Python to provide hints about the variable or parameter types in Python. One example is shown below, where name: str denotes that the function greeting expects a string input, and -> str denotes that it returns a string output. 1 2 def greeting ( name : str ) -> str : return 'Hello ' + name Note Python runtime does not enforce type checks by default, type hints are there for cleaner code and are used by 3rd party tools like IDEs and linters. For Data validation purpose, we can use Pydantic that provides multiple ready-made validation, custom validation and json serialization support. One example is shown below, where we define the model Delivery class (that inherits from BaseModel ) with timestamp , dimensions and enum fields and provide their respective type hints. Here, Pydantic enforces that timestamp should be of type datetime , dimensions should be of type tuple of two int and enum will be positive integer. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from datetime import datetime from typing import Tuple from pydantic import BaseModel , PositiveInt # class definition class Delivery ( BaseModel ): timestamp : datetime dimensions : Tuple [ int , int ] enum : PositiveInt m = Delivery ( timestamp = '2020-01-02T03:04:05Z' , dimensions = [ '10' , '20' ], enum = 1 ) print ( repr ( m . timestamp )) #> datetime.datetime(2020, 1, 2, 3, 4, 5, tzinfo=TzInfo(UTC)) print ( m . dimensions ) #> (10, 20)","title":"Type Hints and Data Validation"},{"location":"data_science_tools/python_good_practices/#references","text":"PEP8 Style Guide for Python Code Kedro Python 3 documentation","title":"References"},{"location":"data_science_tools/python_snippets/","text":"Python Snippets Add numpy array as Pandas column References from stackoverflow answer 1 2 3 4 5 6 7 8 import numpy as np import pandas as pd import scipy.sparse as sparse df = pd . DataFrame ( np . arange ( 1 , 10 ) . reshape ( 3 , 3 )) arr = sparse . coo_matrix (([ 1 , 1 , 1 ], ([ 0 , 1 , 2 ], [ 1 , 2 , 0 ])), shape = ( 3 , 3 )) df [ 'newcol' ] = arr . toarray () . tolist () print ( df ) Get members of python object 1 2 3 4 5 6 7 8 # import import networkx as nx from inspect import getmembers # Fetching the name of all drawing related members of NetworkX class. for x in getmembers ( nx ): if 'draw' in x [ 0 ]: print ( x ) Install packages using code References from here 1 2 3 4 5 6 7 8 9 10 # import import sys import subprocess # install package function def install ( package ): subprocess . check_call ([ sys . executable , \"-m\" , \"pip\" , \"install\" , package ]) # example # install(\"pathfinding\") Python packaging 1 2 3 4 5 6 # clean the previous build files python setup . py clean -- all # build the new distribution files python setup . py sdist bdist_wheel # upload the latest version to pypi twine upload -- skip - existing dist /* Python virtual environment 1 2 3 4 5 6 7 # Create the virtual environment in the current directory python - m venv projectnamevenv # pick one of the below based on your OS (default: Linux) # activate the virtual environment - Linux . projectnamevenv \\ Scripts \\ activate # activate the virtual environment - windows # .\\\\projectnamevenv\\\\Scripts\\\\activate.bat Where is my Python installed? To know the exact location of where the python distribution is installed, follow the steps as suggested here 1 2 3 import os import sys print ( os . path . dirname ( sys . executable )) Get list of installed Python packages To know exactly which packages are current installed (and their version) in your VE, try 1 pip list --format = freeze > reqirements.txt Unzipping files using Zipfile 1 2 3 4 5 # import import zipfile # unzipping with zipfile . ZipFile ( 'sample.zip' , 'r' ) as zip_ref : zip_ref . extractall () Find files or folders glob is a very efficient way to extract relevant files or folders using python. A few example are shown below. 1 2 3 4 5 6 7 8 9 10 11 12 # import from glob import glob # Ex 1: fetch all files within a directory glob ( \"../data/01_raw/CoAID/*\" ) # Ex 2: fetch all files within a directory with a pattern 'News*COVID-19.csv' glob ( \"../data/01_raw/CoAID/folder_1/News*COVID-19.csv\" ) # Ex 2: fetch all files within multiple directories which # follow a pattern 'News*COVID-19.csv' glob ( \"../data/01_raw/CoAID/**/News*COVID-19.csv\" ) Increase the pandas column width in jupyter lab or notebook Most of the times, we have text in a dataframe column, which while displaying gets truncated. One way to handle this to increase the max width of all columns in the dataframe (as shown below) 1 2 import pandas as pd pd . set_option ( 'max_colwidth' , 100 ) # increase 100 to add more space for bigger text Parse date and time from string There are basically 2 ways to do this, (1) Trust machine \ud83e\udd16: for majority of the 'famous' date writing styles, you can use dateparser package that automatically extracts the date and parse it into datetime format. 1 2 3 4 5 6 # import from dateparser import parse # parse text = 'October 05, 2021' dateparser . parse ( text ) # output - datetime.datetime(2021, 10, 5, 0, 0) which will return output ``. Another way is (2) DIY \ud83d\udcaa: if you can create the date time format ), you can use datetime package directly. 1 2 3 4 5 6 7 # import from datetime import datetime # parse text = 'October 05, 2021' date_format = '%B %d , %Y' datetime . strptime ( text , date_format ) # output - datetime.datetime(2021, 10, 5, 0, 0) Bulk document insert in MongoDB While pymongo provides insert_many function for bulk insert, it breaks in case of duplicate key. We can handle it with following function, which in its worse case is similar to insert_one , but shines otherwise. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # import import pymongo # function def insert_many_wrapper ( df , col ): \"\"\"bulk insert docs into the MongoDB while handling duplicate docs Parameters - df (pandas.dataframe): row as a doc with `_id` col - col (pymongo.db.col): pymongo collection object in which insertion is to be done \"\"\" # make a copy and reset index df = df . copy () . reset_index ( drop = True ) # vars all_not_inserted = True duplicate_count = 0 ttl_docs = df . shape [ 0 ] # iterate till all insertions are done (or passed in case of duplicates) while all_not_inserted : # try insertion try : col . insert_many ( df . to_dict ( orient = 'records' ), ordered = True ) all_not_inserted = False except pymongo . errors . BulkWriteError as e : id_till_inserted = e . details [ 'writeErrors' ][ 0 ][ 'keyValue' ][ '_id' ] index_in_df = df [ df [ '_id' ] == id_till_inserted ] . index [ 0 ] print ( f \"Duplicate id: { id_till_inserted } , Current index: { index_in_df } \" ) df = df . loc [ index_in_df + 1 :, :] duplicate_count += 1 # final status print ( f \"Total docs: { ttl_docs } , Inserted: { ttl_docs - len ( duplicate_count ) } , Duplicate found: { len ( duplicate_count ) } \" ) Search top StackExchange questions Stack Exchange exposes several API endpoints to process the questions, answers or posts from their website. A simple implementation to search and download the latest (from yesterday) and top voted questions is shown below. For more such API endpoints, consult their official doc . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \"\"\" Request StackExchange API to get the top 10 most voted questions and their answer from yesterday \"\"\" import requests import json import datetime import time # Get the current date today = datetime . date . today () yesterday = today - datetime . timedelta ( days = 1 ) # Get the current time now = datetime . datetime . now () # Get the time of yesterday yesterday_time = now . replace ( day = yesterday . day , month = yesterday . month , year = yesterday . year ) # Convert the time to epoch time yesterday_epoch = int ( time . mktime ( yesterday_time . timetuple ())) # Get the time of today today_time = now . replace ( day = today . day , month = today . month , year = today . year ) # Convert the time to epoch time today_epoch = int ( time . mktime ( today_time . timetuple ())) # Get the top 10 most voted questions and their answer from yesterday url = \"https://api.stackexchange.com/2.2/questions?pagesize=10&fromdate=\" + \\ str ( yesterday_epoch ) + \"&todate=\" + str ( today_epoch ) + \\ \"&order=desc&sort=votes&site=stackoverflow\" # Get the response from the API response = requests . get ( url ) # Convert the response to JSON data = response . json () # Print the data print ( json . dumps ( data , indent = 4 )) Export complete data from ElasticSearch Due to several memory and efficiency related limitations, it is non-trivial to export complete data from ElasticSearch database. That said, it is not impossible. PFB an scan based implementation that does the same for a dummy test_news index. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # import import pandas as pd from elasticsearch import Elasticsearch from elasticsearch.helpers import scan from tqdm import tqdm # config index_name = 'test_news' db_ip = 'http://localhost:9200' # connect to elasticsearch es = Elasticsearch ([ db_ip ]) # fetch all data from elasticsearch scroll = scan ( es , index = index_name , query = { \"query\" : { \"match_all\" : {}}}) data = [] for res in tqdm ( scroll ): data . append ( res [ '_source' ]) # convert to pandas dataframe and export as csv pd . DataFrame ( data ) . to_csv ( \"news_dump.csv\" , index = False ) Convert python literals from string While I/O from database or config files, we may get some literals (ex list) in form of string, wherein they maintain their structure but the type. We can use ast package to convert them back to their correct type. Quoting the documentation, \"With ast.literal_eval you can safely evaluate an expression node or a string containing a Python literal or container display. The string or node provided may only consist of the following Python literal structures: strings, bytes, numbers, tuples, lists, dicts, booleans, and None.\" 1 2 3 4 5 6 # import import ast # list literal in string format list_as_string = '[\"a\", \"b\"]' # convert list_as_list = ast . literal_eval ( list_as_string ) # Output: [\"a\", \"b\"] Plotly visualization on Pandas dataframe If you want to visualize your pandas dataframe using plotly package, there is no need to use the package explicitly. It can be done right from the pandas dataframe object, with just a couple of lines of code as shown below: 1 2 3 4 # set the backend plotting option pd . options . plotting . backend = \"plotly\" # do a normal plot! pd . DataFrame ( result ) . plot ( x = 'size' , y = 'mean' ) Conda cheat sheet Conda an open-source, cross-platform, language-agnostic package manager and environment management system. Therein again we have multiple varieties, Miniconda: it's a minimilistic package with python, conda and some base packages. Anaconda: it's a bigger package with all the things in Miniconda plus around 150 high quality packages. While the complete documentation can be accessed from here , some important snippets are: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # list all supported python versions conda search python # create a new global conda environment (with new python version) # note, py39 is the name of the env conda create - n py39 python = 3.9 # create a new local conda environment # (under venv folder in current directory and with new python version) conda create - p ./ venv - n py39 python = 3.9 # list all of the environments conda info -- envs # activate an environment conda activate py39 # where py39 is the name of the env # deactivate the current environment conda deactivate # delete an environment conda env remove - n py39 uv cheat sheet uv is an extremely fast Python package installer and resolver written in Rust. It serves as a drop-in replacement for pip, pip-tools, poetry, pyenv, twine, virtualenv, and more. Creating projects 1 2 3 4 5 6 7 8 # Initialize a project in the current directory uv init # Initialize a project in a specific directory uv init project_name # Specify Python version for the project uv init --python 3 .11 Virtual environments 1 2 3 4 5 6 7 8 # Create virtual environment uv venv .venv # Use uv as faster pip replacement uv pip install package_name # Create virtual environment with specific Python version uv venv --python 3 .11 Managing dependencies 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # Add a package as dependency uv add pandas # Add multiple packages at once uv add numpy scipy matplotlib # Add dependencies from requirements file uv add -r requirements.txt # Add development dependencies uv add --dev pytest black # Run a command from installed packages uv run pytest # Remove multiple dependencies uv remove numpy scipy # View dependency tree uv tree # Upgrade all dependencies uv lock --upgrade Version management 1 2 # Check current project version uv version Building and publishing 1 2 3 4 5 # Build your package uv build # Publish to PyPI uv publish Working with scripts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # Initialize a standalone script uv init --script script.py # Initialize script with specific Python version uv init --script script.py --python 3 .11 # Add dependency to a script uv add requests --script script.py # Run a script uv run script.py # Run script with specific Python version uv run --python 3 .11 script.py # Run script with specific Python version and dependencies uv run --python 3 .11 --with torch,peft == 0 .18.0rc0 test_model_size.py # Run Python interpreter with specific Python version and dependencies uv run --python 3 .11 --with torch,peft == 0 .18.0rc0 python -c \"import sys; print(sys.version)\" # Run script with specific Python version and dependencies from requirements file uv run --with-requirements requirements.txt crawl.py Python version management 1 2 3 4 5 6 7 8 9 10 11 # List available Python versions uv python list # Install a Python version uv python install 3 .11 # Run Python interpreter uv run python # Run specific Python version uv run --python 3 .11 python Code formatting 1 2 # Format code with Ruff uv format Requirement files Requirement file is a collection of packages you want to install for a Project. A sample file is shown below, # fine name requirements.txt package-one == 1 .9.4 git+https://github.com/path/to/package-two@41b95ec#egg = package-two package-three == 1 .0.1 package-four - Note three ways of defining packages, (1) with version number, (2) with github source and (3) without version number (installs the latest). Once done, you can install all these packages at one go by pip install -r requirements.txt Reading .numbers file .numbers file is a proprietary file format of Apple's Numbers application. It is a spreadsheet file format that is used to store data in a table format. To process and load the data from .numbers file, we can use numbers_parser package. Below is an example of how to read the data from multiple .numbers files and combine them into one file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # import import os import glob import pandas as pd from tqdm import tqdm from numbers_parser import Document # Get the list of files in the directory using glob numbers_files = glob . glob ( cwd + '/*.numbers' ) # Combine the .numbers files into one file combined_df = [] for file in tqdm ( numbers_files ): doc = Document ( file ) sheets = doc . sheets tables = sheets [ 0 ] . tables data = tables [ 0 ] . rows ( values_only = True ) df = pd . DataFrame ( data [ 1 :], columns = data [ 0 ]) df [ 'file' ] = file # Append the dataframe to the combined dataframe combined_df . append ( df ) # Save the combined file combined_df = pd . concat ( combined_df ) combined_df . to_csv ( 'combined_numbers_new.csv' , index = False ) Pandas Groupby Function Pandas can be utilised for fast analysis of categorical data using groupby. Let's have a look. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #import import numpy as np import pandas as pd # load a dummy df df = pd . Dataframe ( 'dummy.csv' ) # example below ## Name | Gender | Salary ## Ravi | Male | $20,000 ## Sita | Female | $40,000 ## Kito | Female | $11,000 # perform groupby to get average salary per gender ## Option 1 df . groupby ([ 'Gender' ]) . agg ({ 'Salary' : [ np . mean ]}) ## Option 2 df . groupby ([ 'Gender' ]) . mean () ## Option 3 df . groupby ([ 'Gender' ]) . apply ( lambda x : x [ 'Salary' ] . mean ()) Save and Load from Pickle Pickle can be used to efficiently store and load python objects and data. Refer StackOverflow 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # import import pickle # create data a = { 'a' : 1 , 'b' : [ 1 , 2 , 3 , 4 ]} # save pickle with open ( 'filename.pickle' , 'wb' ) as handle : pickle . dump ( a , handle , protocol = pickle . HIGHEST_PROTOCOL ) # load pickle with open ( 'filename.pickle' , 'rb' ) as handle : b = pickle . load ( handle ) # check assert print ( a == b ) Download Youtube video Youtube video can be downloaded using the pytube package. Here is an example. 1 2 3 4 5 6 7 8 9 10 11 12 # import from pytube import YouTube ## var: link to download video_url = \"https://www.youtube.com/watch?v=JP41nYZfekE\" # create instance yt = YouTube ( video_url ) # download abs_video_path = yt . streams . filter ( progressive = True , file_extension = 'mp4' ) . order_by ( 'resolution' ) . desc () . first () . download () ## print(f\"Video downloaded at {abs_video_path}\") Machine Translation EasyNMT lets you perform state-of-the-art machine translation with just 3 lines of python code! It supports translation between 150+ languages and automatic language detection for 170+ languages. Pre-trained machine translation models are auto-downloaded and can perform sentence and document translations! 1 2 3 4 5 6 7 8 9 # import from easynmt import EasyNMT # load model model = EasyNMT ( 'opus-mt' ) #Translate a single sentence to German print ( model . translate ( 'This is a sentence we want to translate to German' , target_lang = 'de' )) ## Output: Dies ist ein Satz, den wir ins Deutsche \u00fcbersetzen wollen Pandas read excel file While pandas is quite famous for CSV analysis, it can be used to read and process Excel files as well. Here are some snippets, 1 2 3 4 5 6 7 8 9 10 11 12 13 # import import pandas as pd # if you just want to read one sheet, by default it reads the first one. df = pd . read_excel ( \"file.xlsx\" , sheet_name = \"Page1\" ) # if you want to get the names of sheet and do more selective reading excel_data = pd . ExcelFile ( \"file.xlsx\" ) # get the sheet names print ( excel_data . sheet_names ) # read one sheet (decide using last print result) sheet_name = '..' df = excel_data . parse ( sheet_name ) Send Slack Messages One of the easiest way to send Slack message is via unique Incoming Webhook. Basically, you need to create a Slack App, register an incoming webhook with the app and whenever you want to post a message - just send a payload to the webhook. For more details on setup, you can refer the official page Once done, you just need to send the message like shown below, 1 2 3 4 5 6 7 8 9 10 11 12 # import requests (needed to connect with webhook) import requests # func def send_message_to_slack ( message ): # set the webhook webhook_url = \"...enter incoming webhook url here...\" # modify the message payload payload = '{\"text\": \" %s \"}' % message # send the message response = requests . post ( webhook_url , payload ) # test send_message_to_slack ( \"test\" ) Colab Snippets Google Colab is the go-to place for many data scientists and machine learning engineers who are looking to perform quick analysis or training for free. Below are some snippets that can be useful in Colab. If you are getting NotImplementedError: A UTF-8 locale is required. Got ANSI_X3.4-1968 or similar error when trying to run !pip install or similar CLI commands in Google Colab, you can fix it by running the following command before running !pip install . But note, this might break some imports. So make sure to import all the packages before running this command. 1 2 3 4 5 import locale locale . getpreferredencoding = lambda : \"UTF-8\" # now import # !import ... Asyncio Gather asyncio.gather is a powerful function in Python's asyncio module that allows you to run multiple coroutines concurrently and collect the results. Here is an example of how to use asyncio.gather to process a list of inputs concurrently and maintain order. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # import import asyncio import random # func to process input async def process_input ( input_value ): # Generate a random sleep time between 1 and 5 seconds sleep_time = random . uniform ( 1 , 5 ) print ( f \"Processing { input_value } . Will take { sleep_time : .2f } seconds.\" ) # Simulate some processing time await asyncio . sleep ( sleep_time ) return f \"Processed: { input_value } \" async def main (): # List of inputs to process inputs = [ \"A\" , \"B\" , \"C\" , \"D\" , \"E\" ] # Create a list of coroutines to run tasks = [ process_input ( input_value ) for input_value in inputs ] # Use asyncio.gather to run the coroutines concurrently and maintain order results = await asyncio . gather ( * tasks ) # Print the results for input_value , result in zip ( inputs , results ): print ( f \"Input: { input_value } -> { result } \" ) # Run the main function if __name__ == \"__main__\" : asyncio . run ( main ()) Once you run the above code, here is an example of the output you might see: Processing A. Will take 2 .45 seconds. Processing B. Will take 1 .47 seconds. Processing C. Will take 4 .47 seconds. Processing D. Will take 1 .68 seconds. Processing E. Will take 4 .47 seconds. Input: A -> Processed: A Input: B -> Processed: B Input: C -> Processed: C Input: D -> Processed: D Input: E -> Processed: E As you can see from the output, the inputs are processed concurrently, and the results are collected in the order of the inputs. This is true even if the processing times are different for each input.","title":"Python snippets"},{"location":"data_science_tools/python_snippets/#python-snippets","text":"","title":"Python Snippets"},{"location":"data_science_tools/python_snippets/#add-numpy-array-as-pandas-column","text":"References from stackoverflow answer 1 2 3 4 5 6 7 8 import numpy as np import pandas as pd import scipy.sparse as sparse df = pd . DataFrame ( np . arange ( 1 , 10 ) . reshape ( 3 , 3 )) arr = sparse . coo_matrix (([ 1 , 1 , 1 ], ([ 0 , 1 , 2 ], [ 1 , 2 , 0 ])), shape = ( 3 , 3 )) df [ 'newcol' ] = arr . toarray () . tolist () print ( df )","title":"Add numpy array as Pandas column"},{"location":"data_science_tools/python_snippets/#get-members-of-python-object","text":"1 2 3 4 5 6 7 8 # import import networkx as nx from inspect import getmembers # Fetching the name of all drawing related members of NetworkX class. for x in getmembers ( nx ): if 'draw' in x [ 0 ]: print ( x )","title":"Get members of python object"},{"location":"data_science_tools/python_snippets/#install-packages-using-code","text":"References from here 1 2 3 4 5 6 7 8 9 10 # import import sys import subprocess # install package function def install ( package ): subprocess . check_call ([ sys . executable , \"-m\" , \"pip\" , \"install\" , package ]) # example # install(\"pathfinding\")","title":"Install packages using code"},{"location":"data_science_tools/python_snippets/#python-packaging","text":"1 2 3 4 5 6 # clean the previous build files python setup . py clean -- all # build the new distribution files python setup . py sdist bdist_wheel # upload the latest version to pypi twine upload -- skip - existing dist /*","title":"Python packaging"},{"location":"data_science_tools/python_snippets/#python-virtual-environment","text":"1 2 3 4 5 6 7 # Create the virtual environment in the current directory python - m venv projectnamevenv # pick one of the below based on your OS (default: Linux) # activate the virtual environment - Linux . projectnamevenv \\ Scripts \\ activate # activate the virtual environment - windows # .\\\\projectnamevenv\\\\Scripts\\\\activate.bat","title":"Python virtual environment"},{"location":"data_science_tools/python_snippets/#where-is-my-python-installed","text":"To know the exact location of where the python distribution is installed, follow the steps as suggested here 1 2 3 import os import sys print ( os . path . dirname ( sys . executable ))","title":"Where is my Python installed?"},{"location":"data_science_tools/python_snippets/#get-list-of-installed-python-packages","text":"To know exactly which packages are current installed (and their version) in your VE, try 1 pip list --format = freeze > reqirements.txt","title":"Get list of installed Python packages"},{"location":"data_science_tools/python_snippets/#unzipping-files-using-zipfile","text":"1 2 3 4 5 # import import zipfile # unzipping with zipfile . ZipFile ( 'sample.zip' , 'r' ) as zip_ref : zip_ref . extractall ()","title":"Unzipping files using Zipfile"},{"location":"data_science_tools/python_snippets/#find-files-or-folders","text":"glob is a very efficient way to extract relevant files or folders using python. A few example are shown below. 1 2 3 4 5 6 7 8 9 10 11 12 # import from glob import glob # Ex 1: fetch all files within a directory glob ( \"../data/01_raw/CoAID/*\" ) # Ex 2: fetch all files within a directory with a pattern 'News*COVID-19.csv' glob ( \"../data/01_raw/CoAID/folder_1/News*COVID-19.csv\" ) # Ex 2: fetch all files within multiple directories which # follow a pattern 'News*COVID-19.csv' glob ( \"../data/01_raw/CoAID/**/News*COVID-19.csv\" )","title":"Find files or folders"},{"location":"data_science_tools/python_snippets/#increase-the-pandas-column-width-in-jupyter-lab-or-notebook","text":"Most of the times, we have text in a dataframe column, which while displaying gets truncated. One way to handle this to increase the max width of all columns in the dataframe (as shown below) 1 2 import pandas as pd pd . set_option ( 'max_colwidth' , 100 ) # increase 100 to add more space for bigger text","title":"Increase the pandas column width in jupyter lab or notebook"},{"location":"data_science_tools/python_snippets/#parse-date-and-time-from-string","text":"There are basically 2 ways to do this, (1) Trust machine \ud83e\udd16: for majority of the 'famous' date writing styles, you can use dateparser package that automatically extracts the date and parse it into datetime format. 1 2 3 4 5 6 # import from dateparser import parse # parse text = 'October 05, 2021' dateparser . parse ( text ) # output - datetime.datetime(2021, 10, 5, 0, 0) which will return output ``. Another way is (2) DIY \ud83d\udcaa: if you can create the date time format ), you can use datetime package directly. 1 2 3 4 5 6 7 # import from datetime import datetime # parse text = 'October 05, 2021' date_format = '%B %d , %Y' datetime . strptime ( text , date_format ) # output - datetime.datetime(2021, 10, 5, 0, 0)","title":"Parse date and time from string"},{"location":"data_science_tools/python_snippets/#bulk-document-insert-in-mongodb","text":"While pymongo provides insert_many function for bulk insert, it breaks in case of duplicate key. We can handle it with following function, which in its worse case is similar to insert_one , but shines otherwise. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # import import pymongo # function def insert_many_wrapper ( df , col ): \"\"\"bulk insert docs into the MongoDB while handling duplicate docs Parameters - df (pandas.dataframe): row as a doc with `_id` col - col (pymongo.db.col): pymongo collection object in which insertion is to be done \"\"\" # make a copy and reset index df = df . copy () . reset_index ( drop = True ) # vars all_not_inserted = True duplicate_count = 0 ttl_docs = df . shape [ 0 ] # iterate till all insertions are done (or passed in case of duplicates) while all_not_inserted : # try insertion try : col . insert_many ( df . to_dict ( orient = 'records' ), ordered = True ) all_not_inserted = False except pymongo . errors . BulkWriteError as e : id_till_inserted = e . details [ 'writeErrors' ][ 0 ][ 'keyValue' ][ '_id' ] index_in_df = df [ df [ '_id' ] == id_till_inserted ] . index [ 0 ] print ( f \"Duplicate id: { id_till_inserted } , Current index: { index_in_df } \" ) df = df . loc [ index_in_df + 1 :, :] duplicate_count += 1 # final status print ( f \"Total docs: { ttl_docs } , Inserted: { ttl_docs - len ( duplicate_count ) } , Duplicate found: { len ( duplicate_count ) } \" )","title":"Bulk document insert in MongoDB"},{"location":"data_science_tools/python_snippets/#search-top-stackexchange-questions","text":"Stack Exchange exposes several API endpoints to process the questions, answers or posts from their website. A simple implementation to search and download the latest (from yesterday) and top voted questions is shown below. For more such API endpoints, consult their official doc . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \"\"\" Request StackExchange API to get the top 10 most voted questions and their answer from yesterday \"\"\" import requests import json import datetime import time # Get the current date today = datetime . date . today () yesterday = today - datetime . timedelta ( days = 1 ) # Get the current time now = datetime . datetime . now () # Get the time of yesterday yesterday_time = now . replace ( day = yesterday . day , month = yesterday . month , year = yesterday . year ) # Convert the time to epoch time yesterday_epoch = int ( time . mktime ( yesterday_time . timetuple ())) # Get the time of today today_time = now . replace ( day = today . day , month = today . month , year = today . year ) # Convert the time to epoch time today_epoch = int ( time . mktime ( today_time . timetuple ())) # Get the top 10 most voted questions and their answer from yesterday url = \"https://api.stackexchange.com/2.2/questions?pagesize=10&fromdate=\" + \\ str ( yesterday_epoch ) + \"&todate=\" + str ( today_epoch ) + \\ \"&order=desc&sort=votes&site=stackoverflow\" # Get the response from the API response = requests . get ( url ) # Convert the response to JSON data = response . json () # Print the data print ( json . dumps ( data , indent = 4 ))","title":"Search top StackExchange questions"},{"location":"data_science_tools/python_snippets/#export-complete-data-from-elasticsearch","text":"Due to several memory and efficiency related limitations, it is non-trivial to export complete data from ElasticSearch database. That said, it is not impossible. PFB an scan based implementation that does the same for a dummy test_news index. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # import import pandas as pd from elasticsearch import Elasticsearch from elasticsearch.helpers import scan from tqdm import tqdm # config index_name = 'test_news' db_ip = 'http://localhost:9200' # connect to elasticsearch es = Elasticsearch ([ db_ip ]) # fetch all data from elasticsearch scroll = scan ( es , index = index_name , query = { \"query\" : { \"match_all\" : {}}}) data = [] for res in tqdm ( scroll ): data . append ( res [ '_source' ]) # convert to pandas dataframe and export as csv pd . DataFrame ( data ) . to_csv ( \"news_dump.csv\" , index = False )","title":"Export complete data from ElasticSearch"},{"location":"data_science_tools/python_snippets/#convert-python-literals-from-string","text":"While I/O from database or config files, we may get some literals (ex list) in form of string, wherein they maintain their structure but the type. We can use ast package to convert them back to their correct type. Quoting the documentation, \"With ast.literal_eval you can safely evaluate an expression node or a string containing a Python literal or container display. The string or node provided may only consist of the following Python literal structures: strings, bytes, numbers, tuples, lists, dicts, booleans, and None.\" 1 2 3 4 5 6 # import import ast # list literal in string format list_as_string = '[\"a\", \"b\"]' # convert list_as_list = ast . literal_eval ( list_as_string ) # Output: [\"a\", \"b\"]","title":"Convert python literals from string"},{"location":"data_science_tools/python_snippets/#plotly-visualization-on-pandas-dataframe","text":"If you want to visualize your pandas dataframe using plotly package, there is no need to use the package explicitly. It can be done right from the pandas dataframe object, with just a couple of lines of code as shown below: 1 2 3 4 # set the backend plotting option pd . options . plotting . backend = \"plotly\" # do a normal plot! pd . DataFrame ( result ) . plot ( x = 'size' , y = 'mean' )","title":"Plotly visualization on Pandas dataframe"},{"location":"data_science_tools/python_snippets/#conda-cheat-sheet","text":"Conda an open-source, cross-platform, language-agnostic package manager and environment management system. Therein again we have multiple varieties, Miniconda: it's a minimilistic package with python, conda and some base packages. Anaconda: it's a bigger package with all the things in Miniconda plus around 150 high quality packages. While the complete documentation can be accessed from here , some important snippets are: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # list all supported python versions conda search python # create a new global conda environment (with new python version) # note, py39 is the name of the env conda create - n py39 python = 3.9 # create a new local conda environment # (under venv folder in current directory and with new python version) conda create - p ./ venv - n py39 python = 3.9 # list all of the environments conda info -- envs # activate an environment conda activate py39 # where py39 is the name of the env # deactivate the current environment conda deactivate # delete an environment conda env remove - n py39","title":"Conda cheat sheet"},{"location":"data_science_tools/python_snippets/#uv-cheat-sheet","text":"uv is an extremely fast Python package installer and resolver written in Rust. It serves as a drop-in replacement for pip, pip-tools, poetry, pyenv, twine, virtualenv, and more.","title":"uv cheat sheet"},{"location":"data_science_tools/python_snippets/#creating-projects","text":"1 2 3 4 5 6 7 8 # Initialize a project in the current directory uv init # Initialize a project in a specific directory uv init project_name # Specify Python version for the project uv init --python 3 .11","title":"Creating projects"},{"location":"data_science_tools/python_snippets/#virtual-environments","text":"1 2 3 4 5 6 7 8 # Create virtual environment uv venv .venv # Use uv as faster pip replacement uv pip install package_name # Create virtual environment with specific Python version uv venv --python 3 .11","title":"Virtual environments"},{"location":"data_science_tools/python_snippets/#managing-dependencies","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # Add a package as dependency uv add pandas # Add multiple packages at once uv add numpy scipy matplotlib # Add dependencies from requirements file uv add -r requirements.txt # Add development dependencies uv add --dev pytest black # Run a command from installed packages uv run pytest # Remove multiple dependencies uv remove numpy scipy # View dependency tree uv tree # Upgrade all dependencies uv lock --upgrade","title":"Managing dependencies"},{"location":"data_science_tools/python_snippets/#version-management","text":"1 2 # Check current project version uv version","title":"Version management"},{"location":"data_science_tools/python_snippets/#building-and-publishing","text":"1 2 3 4 5 # Build your package uv build # Publish to PyPI uv publish","title":"Building and publishing"},{"location":"data_science_tools/python_snippets/#working-with-scripts","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # Initialize a standalone script uv init --script script.py # Initialize script with specific Python version uv init --script script.py --python 3 .11 # Add dependency to a script uv add requests --script script.py # Run a script uv run script.py # Run script with specific Python version uv run --python 3 .11 script.py # Run script with specific Python version and dependencies uv run --python 3 .11 --with torch,peft == 0 .18.0rc0 test_model_size.py # Run Python interpreter with specific Python version and dependencies uv run --python 3 .11 --with torch,peft == 0 .18.0rc0 python -c \"import sys; print(sys.version)\" # Run script with specific Python version and dependencies from requirements file uv run --with-requirements requirements.txt crawl.py","title":"Working with scripts"},{"location":"data_science_tools/python_snippets/#python-version-management","text":"1 2 3 4 5 6 7 8 9 10 11 # List available Python versions uv python list # Install a Python version uv python install 3 .11 # Run Python interpreter uv run python # Run specific Python version uv run --python 3 .11 python","title":"Python version management"},{"location":"data_science_tools/python_snippets/#code-formatting","text":"1 2 # Format code with Ruff uv format","title":"Code formatting"},{"location":"data_science_tools/python_snippets/#requirement-files","text":"Requirement file is a collection of packages you want to install for a Project. A sample file is shown below, # fine name requirements.txt package-one == 1 .9.4 git+https://github.com/path/to/package-two@41b95ec#egg = package-two package-three == 1 .0.1 package-four - Note three ways of defining packages, (1) with version number, (2) with github source and (3) without version number (installs the latest). Once done, you can install all these packages at one go by pip install -r requirements.txt","title":"Requirement files"},{"location":"data_science_tools/python_snippets/#reading-numbers-file","text":".numbers file is a proprietary file format of Apple's Numbers application. It is a spreadsheet file format that is used to store data in a table format. To process and load the data from .numbers file, we can use numbers_parser package. Below is an example of how to read the data from multiple .numbers files and combine them into one file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # import import os import glob import pandas as pd from tqdm import tqdm from numbers_parser import Document # Get the list of files in the directory using glob numbers_files = glob . glob ( cwd + '/*.numbers' ) # Combine the .numbers files into one file combined_df = [] for file in tqdm ( numbers_files ): doc = Document ( file ) sheets = doc . sheets tables = sheets [ 0 ] . tables data = tables [ 0 ] . rows ( values_only = True ) df = pd . DataFrame ( data [ 1 :], columns = data [ 0 ]) df [ 'file' ] = file # Append the dataframe to the combined dataframe combined_df . append ( df ) # Save the combined file combined_df = pd . concat ( combined_df ) combined_df . to_csv ( 'combined_numbers_new.csv' , index = False )","title":"Reading .numbers file"},{"location":"data_science_tools/python_snippets/#pandas-groupby-function","text":"Pandas can be utilised for fast analysis of categorical data using groupby. Let's have a look. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #import import numpy as np import pandas as pd # load a dummy df df = pd . Dataframe ( 'dummy.csv' ) # example below ## Name | Gender | Salary ## Ravi | Male | $20,000 ## Sita | Female | $40,000 ## Kito | Female | $11,000 # perform groupby to get average salary per gender ## Option 1 df . groupby ([ 'Gender' ]) . agg ({ 'Salary' : [ np . mean ]}) ## Option 2 df . groupby ([ 'Gender' ]) . mean () ## Option 3 df . groupby ([ 'Gender' ]) . apply ( lambda x : x [ 'Salary' ] . mean ())","title":"Pandas Groupby Function"},{"location":"data_science_tools/python_snippets/#save-and-load-from-pickle","text":"Pickle can be used to efficiently store and load python objects and data. Refer StackOverflow 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # import import pickle # create data a = { 'a' : 1 , 'b' : [ 1 , 2 , 3 , 4 ]} # save pickle with open ( 'filename.pickle' , 'wb' ) as handle : pickle . dump ( a , handle , protocol = pickle . HIGHEST_PROTOCOL ) # load pickle with open ( 'filename.pickle' , 'rb' ) as handle : b = pickle . load ( handle ) # check assert print ( a == b )","title":"Save and Load from Pickle"},{"location":"data_science_tools/python_snippets/#download-youtube-video","text":"Youtube video can be downloaded using the pytube package. Here is an example. 1 2 3 4 5 6 7 8 9 10 11 12 # import from pytube import YouTube ## var: link to download video_url = \"https://www.youtube.com/watch?v=JP41nYZfekE\" # create instance yt = YouTube ( video_url ) # download abs_video_path = yt . streams . filter ( progressive = True , file_extension = 'mp4' ) . order_by ( 'resolution' ) . desc () . first () . download () ## print(f\"Video downloaded at {abs_video_path}\")","title":"Download Youtube video"},{"location":"data_science_tools/python_snippets/#machine-translation","text":"EasyNMT lets you perform state-of-the-art machine translation with just 3 lines of python code! It supports translation between 150+ languages and automatic language detection for 170+ languages. Pre-trained machine translation models are auto-downloaded and can perform sentence and document translations! 1 2 3 4 5 6 7 8 9 # import from easynmt import EasyNMT # load model model = EasyNMT ( 'opus-mt' ) #Translate a single sentence to German print ( model . translate ( 'This is a sentence we want to translate to German' , target_lang = 'de' )) ## Output: Dies ist ein Satz, den wir ins Deutsche \u00fcbersetzen wollen","title":"Machine Translation"},{"location":"data_science_tools/python_snippets/#pandas-read-excel-file","text":"While pandas is quite famous for CSV analysis, it can be used to read and process Excel files as well. Here are some snippets, 1 2 3 4 5 6 7 8 9 10 11 12 13 # import import pandas as pd # if you just want to read one sheet, by default it reads the first one. df = pd . read_excel ( \"file.xlsx\" , sheet_name = \"Page1\" ) # if you want to get the names of sheet and do more selective reading excel_data = pd . ExcelFile ( \"file.xlsx\" ) # get the sheet names print ( excel_data . sheet_names ) # read one sheet (decide using last print result) sheet_name = '..' df = excel_data . parse ( sheet_name )","title":"Pandas read excel file"},{"location":"data_science_tools/python_snippets/#send-slack-messages","text":"One of the easiest way to send Slack message is via unique Incoming Webhook. Basically, you need to create a Slack App, register an incoming webhook with the app and whenever you want to post a message - just send a payload to the webhook. For more details on setup, you can refer the official page Once done, you just need to send the message like shown below, 1 2 3 4 5 6 7 8 9 10 11 12 # import requests (needed to connect with webhook) import requests # func def send_message_to_slack ( message ): # set the webhook webhook_url = \"...enter incoming webhook url here...\" # modify the message payload payload = '{\"text\": \" %s \"}' % message # send the message response = requests . post ( webhook_url , payload ) # test send_message_to_slack ( \"test\" )","title":"Send Slack Messages"},{"location":"data_science_tools/python_snippets/#colab-snippets","text":"Google Colab is the go-to place for many data scientists and machine learning engineers who are looking to perform quick analysis or training for free. Below are some snippets that can be useful in Colab. If you are getting NotImplementedError: A UTF-8 locale is required. Got ANSI_X3.4-1968 or similar error when trying to run !pip install or similar CLI commands in Google Colab, you can fix it by running the following command before running !pip install . But note, this might break some imports. So make sure to import all the packages before running this command. 1 2 3 4 5 import locale locale . getpreferredencoding = lambda : \"UTF-8\" # now import # !import ...","title":"Colab Snippets"},{"location":"data_science_tools/python_snippets/#asyncio-gather","text":"asyncio.gather is a powerful function in Python's asyncio module that allows you to run multiple coroutines concurrently and collect the results. Here is an example of how to use asyncio.gather to process a list of inputs concurrently and maintain order. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # import import asyncio import random # func to process input async def process_input ( input_value ): # Generate a random sleep time between 1 and 5 seconds sleep_time = random . uniform ( 1 , 5 ) print ( f \"Processing { input_value } . Will take { sleep_time : .2f } seconds.\" ) # Simulate some processing time await asyncio . sleep ( sleep_time ) return f \"Processed: { input_value } \" async def main (): # List of inputs to process inputs = [ \"A\" , \"B\" , \"C\" , \"D\" , \"E\" ] # Create a list of coroutines to run tasks = [ process_input ( input_value ) for input_value in inputs ] # Use asyncio.gather to run the coroutines concurrently and maintain order results = await asyncio . gather ( * tasks ) # Print the results for input_value , result in zip ( inputs , results ): print ( f \"Input: { input_value } -> { result } \" ) # Run the main function if __name__ == \"__main__\" : asyncio . run ( main ()) Once you run the above code, here is an example of the output you might see: Processing A. Will take 2 .45 seconds. Processing B. Will take 1 .47 seconds. Processing C. Will take 4 .47 seconds. Processing D. Will take 1 .68 seconds. Processing E. Will take 4 .47 seconds. Input: A -> Processed: A Input: B -> Processed: B Input: C -> Processed: C Input: D -> Processed: D Input: E -> Processed: E As you can see from the output, the inputs are processed concurrently, and the results are collected in the order of the inputs. This is true even if the processing times are different for each input.","title":"Asyncio Gather"},{"location":"data_science_tools/scraping_websites/","text":"Scraping Websites Introduction Scraping is the process of traversing and collecting data from the web pages. People scrape websites for many reasons -- to get information about companies or fetch latest news or get stock prices informations or just create a dataset for the next big AI model In this article, we will be focusing on two different techniques to scrape website. For static website, we can use Scrapy . As an example, we will scrape data from the Devgan website that hosts details of difference sections in Indian Penal Code (IPC). [Github Code] For dynamic website, we can use Selenium in combination with BeautifulSoup4 (BS4). As an example, we will scrape data from Google search results. In short, Selenium is an open-source tool for browser automation and it will be used to automate the process of opening the browser and loading the website (as dynamic websites populates the data once the website is completely loaded) . For extracting the data from the website, we will use BS4. Warning This article is purely for educational purpose. I would highly recommend considering website's Terms of Service (ToS) or getting website owner's permission before scraping. Static Website scrape using Scrapy Understanding the website Before we even start scraping, we need to understand the structure of the website. This is very important, as we want to (1) get an idea of what we want to scrapeand (2) where those data are located. The flow of scraping section descriptions from Devgan website Our goal is to scrapethe description for each section in IPC. As per the website flow above, the complete process can be divided into two parts, First, we need to traverse to the main page and extract the link of each sections. Next, we need to traverse to each individual section page and extract the description details present there. Data extraction methods Now, let's also look into different methods exposed by Scrapy to extract data from the web pages. The basic idea is that scrapy downloads the web page source code in HTML and parse it using different parsers. For this, we can either use XPaths or CSS selectors. The choice is purely up to us. We can begin with the main page and try to find the link of each section. For this, you can open inspect option from your browser by right clicking on any of the sections and select inspect . This should show you the source code. Next, try to find the position of the tag where each section is defined. Refer the image below, and you can see that each section is within <a> tag inside the <div id=\"content\"> tag. The href component will give you the link of the section and the <span> tag inside gives the section name. Inspecting the source code of the first relevant page in Devgan website To try out the extraction, we can utilize the interpreter functionality of Scapy. For that just activate your Scrapy VM and type scrapy shell '{website-link}' , here it will be scrapy shell http://devgan.in/all_sections_ipc.php . This opens a playground where we can play around with response variable to experiment with different extraction queries. To extract the individual sections we can use CSS query - response.css('div#content').css('a') . Note, here we define the {tag_type}#{id} as the first CSS query and then use another CSS query - a . This will give us a list of all the <a> tags inside the <div id=\"content\"> tag. Now from within section, to extract the title, we can use CSS query - section.css('span.sectionlink::text').extract() . For this to work, you should save the last query as section variable. Similar approach can be applied to extract the description from the next page. Just re-run the shell with one of the section's link and try out building CSS query. Once you have all the queries ready, we can move on to the main coding part Note You can refer the Scrapy official doc for more details on creating CSS or XPath queries. Setup Scrapy project First, let us install the Scapy package using pip. It can be easily done by running the following command in the terminal: pip install scrapy . Do make sure to create your own virtual environment (VE), activate it and then install the package in that environment. For confusion regarding VE, refer my snippets on the same topic. Next, let us setup the Scrapy project. Go to your directory of choice and run the command scrapy startproject tutorial . This will create a project with folder structure as shown below. We can ignore most of the files created here, our main focus will be on the spiders/ directory. tutorial/ scrapy.cfg # deploy configuration file tutorial/ # project's Python module, you'll import your code from here __init__.py items.py # project items definition file middlewares.py # project middlewares file pipelines.py # project pipelines file settings.py # project settings file spiders/ # a directory where you'll later put your spiders __init__.py Note The above folder structure is taken from the Scrapy Official Tutorial Create your Spider Usually we create one spider to scrapeone website. For this example we will do exactly the same for Devgan website. So let's create a spider spiders/devgan.py . The code is shown below, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # import import scrapy # function class DevganSpider ( scrapy . Spider ): name = \"devgan\" allowed_domains = [ \"devgan.in\" ] def start_requests ( self ): urls = [ 'http://devgan.in/all_sections_ipc.php' , ] for url in urls : yield scrapy . Request ( url = url , callback = self . parse_mainpage ) def parse_mainpage ( self , response ): # identify the links to the individual section pages sections = response . css ( 'div#content' ) . css ( 'a' ) #.getall() # for each section for section in sections : # loc var loc = { 'title' : section . xpath ( '@title' ) . extract (), 'link' : 'http://devgan.in' + section . xpath ( '@href' ) . extract ()[ 0 ], 'section' : section . css ( 'span.sectionlink::text' ) . extract (), } # traverse again and extract the description yield scrapy . Request ( loc [ 'link' ], callback = self . parse_section , cb_kwargs = dict ( meta = loc )) def parse_section ( self , response , meta ): # extract the description meta [ 'description' ] = \" \" . join ( response . css ( 'tr.mys-desc' ) . css ( '::text' ) . extract ()) # return return meta Now lets us try to understand the code line by line, Line 2: Importing the scrapy package. Line 5: Defining the spider class that inherits the scrapy.Spider class. Line 6-7: We define the name of the spider and allow the spider to crawl the domain devgan.in . Line 9-14: We define the start_requests method. This method is called when the spider is executed. It calls the scraping function for each url to scrap, it is done using scrapy.Request function call. For each url, the scraping function set within callback parameter is called. Line 16: We define the scraping function parse_mainpage for the main page. Note, this function receives response as an argument, that contains the source code from the server for the main page url. Line 18-29: We start with identifying the links to the individual section pages, store them in sections , and call the scraping function parse_section for each section. Before that, we also extract the title, link and section name from the main page using the queries we created before. One point to remember, this particular example is little complex as we want to traverse further inside into the section pages. For this, we again call the scrapy.Request for the individual section links. Finally, we want to pass the data collected form this page to the section page, as we will consolidate all data for individual section there and return it. For this, we use cb_kwargs parameter to pass the meta data to the next function. Line 31-35: We extract the description from the section page using the CSS query. We add description detail to the metadata and return the complete data that is to be persisted. Executing the spider To run the spider, traverse to the root directory and execure the following command, scrapy crawl devgan -O sections_details.csv -t csv . Here, devgan is the name of the spider we created earlier, -O is used to set the output file name as sections_details.csv . -t is used to define the output format as csv . This will create the csv file with all details of the sections as separate columns as shown below (only 2 rows) title link section description IPC Section 1... http://... Section 1 This Act shall be called the Indian Penal Code... IPC Section 2... http://... Section 2 Every person shall be liable to punishment un.... And that's it! Cheers! Dynamic Website scrape using Selenium and BS4 Understanding the website Well, everyone knows and has used Google atleast once in their life. Nevertheless, for an example, if we want to find all of the latest news from TechCrunch, this is how the google search will look like. Google search result shows the news for the 14th of Nov, 2023 On looking at the page source of the above screen, you will only see javascript code that does not contain any data as shown above. This is because Google is a dynamic website which is event-driven and created with server-side languages. Because of this, we cannot use Scrapy alone as it cannot run Javascript, what we we need is a browser to run the code. That's where Selenium and BS4 comes in. Selenium and BS4 Automation We will code a generic function to automate the process of opening Chrome browser, loading the website and extracting the data from the website. To run it for our example of TechCrunch, we just need to change the input param. Note Before starting make sure to install the Selenium package and drivers as explained here . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 from selenium import webdriver from selenium.webdriver.chrome.service import Service from selenium.webdriver.chrome.options import Options from bs4 import BeautifulSoup import csv import time # Set up the Selenium driver (make sure you have the Chrome WebDriver installed) options = Options () options . add_argument ( \"--window-size=1920,1200\" ) driver = webdriver . Chrome ( options = options ) # Function to scrape Google using Selenium and BeautifulSoup def scrape_google ( search_query , num_pages , start_page = 0 ): results = [] for page in range ( 0 , num_pages ): start = ( page * 10 ) + start_page * 10 url = f \"https://www.google.com/search?q= { search_query } &start= { start } \" driver . get ( url ) time . sleep ( 2 ) # Sleep to ensure all scripts are loaded properly # loading and processing the page source in BS4 soup = BeautifulSoup ( driver . page_source , 'html.parser' ) search_items = soup . find_all ( 'div' , class_ = 'g' ) # iterate over all items (search results) for item in search_items : title = item . find ( 'h3' ) link = item . find ( 'a' , href = True ) description = item . get_text () . split ( ' \u203a ' )[ 2 ] if title and link : results . append ({ 'title' : title . get_text (), 'link' : link [ 'href' ], 'description' : description if description else \"\" }) save_results_to_csv ( results , f 'google_search_results_ { page } .csv' ) driver . quit () return results # Save results to CSV def save_results_to_csv ( results , filename ): with open ( filename , 'w' , newline = '' , encoding = 'utf-8' ) as csvfile : fieldnames = [ 'title' , 'link' , 'description' ] writer = csv . DictWriter ( csvfile , fieldnames = fieldnames ) writer . writeheader () for result in results : writer . writerow ( result ) # Use the function to scrape and save results search_results = scrape_google ( \"site:https://techcrunch.com/2023/11/14/\" , 10 ) Let's understand the code in detail, Line 1-6 : Importing the required packages. Line 8-11 : Initializes the Chrome WebDriver with the specified options. Line 14-40 : Defines a function to scrape Google. It takes a search query, the number of pages to scrape, and an optional starting page. Inside the function, we iterate over the number of pages specified, constructing a URL for each page of Google search results based on the query and the current page. The WebDriver is used to navigate to the URL. Then, we use BS4 to parse the page source and extracts the title, link, and description of each search result and appends it to the results list. At each iteration, we save the result to a CSV. Finally, we close the driver and return the results . Line 42-49 : Defines save_results_to_csv function to save the scraped results to a CSV file. It uses Python's csv module to write the title, link, and description of each search result to a CSV file. Line 52 : We call the scrape_google function to scrape first 10 pages of Google search results for the specified query. And we are done!","title":"Scraping Websites"},{"location":"data_science_tools/scraping_websites/#scraping-websites","text":"","title":"Scraping Websites"},{"location":"data_science_tools/scraping_websites/#introduction","text":"Scraping is the process of traversing and collecting data from the web pages. People scrape websites for many reasons -- to get information about companies or fetch latest news or get stock prices informations or just create a dataset for the next big AI model In this article, we will be focusing on two different techniques to scrape website. For static website, we can use Scrapy . As an example, we will scrape data from the Devgan website that hosts details of difference sections in Indian Penal Code (IPC). [Github Code] For dynamic website, we can use Selenium in combination with BeautifulSoup4 (BS4). As an example, we will scrape data from Google search results. In short, Selenium is an open-source tool for browser automation and it will be used to automate the process of opening the browser and loading the website (as dynamic websites populates the data once the website is completely loaded) . For extracting the data from the website, we will use BS4. Warning This article is purely for educational purpose. I would highly recommend considering website's Terms of Service (ToS) or getting website owner's permission before scraping.","title":"Introduction"},{"location":"data_science_tools/scraping_websites/#static-website-scrape-using-scrapy","text":"","title":"Static Website scrape using Scrapy"},{"location":"data_science_tools/scraping_websites/#understanding-the-website","text":"Before we even start scraping, we need to understand the structure of the website. This is very important, as we want to (1) get an idea of what we want to scrapeand (2) where those data are located. The flow of scraping section descriptions from Devgan website Our goal is to scrapethe description for each section in IPC. As per the website flow above, the complete process can be divided into two parts, First, we need to traverse to the main page and extract the link of each sections. Next, we need to traverse to each individual section page and extract the description details present there.","title":"Understanding the website"},{"location":"data_science_tools/scraping_websites/#data-extraction-methods","text":"Now, let's also look into different methods exposed by Scrapy to extract data from the web pages. The basic idea is that scrapy downloads the web page source code in HTML and parse it using different parsers. For this, we can either use XPaths or CSS selectors. The choice is purely up to us. We can begin with the main page and try to find the link of each section. For this, you can open inspect option from your browser by right clicking on any of the sections and select inspect . This should show you the source code. Next, try to find the position of the tag where each section is defined. Refer the image below, and you can see that each section is within <a> tag inside the <div id=\"content\"> tag. The href component will give you the link of the section and the <span> tag inside gives the section name. Inspecting the source code of the first relevant page in Devgan website To try out the extraction, we can utilize the interpreter functionality of Scapy. For that just activate your Scrapy VM and type scrapy shell '{website-link}' , here it will be scrapy shell http://devgan.in/all_sections_ipc.php . This opens a playground where we can play around with response variable to experiment with different extraction queries. To extract the individual sections we can use CSS query - response.css('div#content').css('a') . Note, here we define the {tag_type}#{id} as the first CSS query and then use another CSS query - a . This will give us a list of all the <a> tags inside the <div id=\"content\"> tag. Now from within section, to extract the title, we can use CSS query - section.css('span.sectionlink::text').extract() . For this to work, you should save the last query as section variable. Similar approach can be applied to extract the description from the next page. Just re-run the shell with one of the section's link and try out building CSS query. Once you have all the queries ready, we can move on to the main coding part Note You can refer the Scrapy official doc for more details on creating CSS or XPath queries.","title":"Data extraction methods"},{"location":"data_science_tools/scraping_websites/#setup-scrapy-project","text":"First, let us install the Scapy package using pip. It can be easily done by running the following command in the terminal: pip install scrapy . Do make sure to create your own virtual environment (VE), activate it and then install the package in that environment. For confusion regarding VE, refer my snippets on the same topic. Next, let us setup the Scrapy project. Go to your directory of choice and run the command scrapy startproject tutorial . This will create a project with folder structure as shown below. We can ignore most of the files created here, our main focus will be on the spiders/ directory. tutorial/ scrapy.cfg # deploy configuration file tutorial/ # project's Python module, you'll import your code from here __init__.py items.py # project items definition file middlewares.py # project middlewares file pipelines.py # project pipelines file settings.py # project settings file spiders/ # a directory where you'll later put your spiders __init__.py Note The above folder structure is taken from the Scrapy Official Tutorial","title":"Setup Scrapy project"},{"location":"data_science_tools/scraping_websites/#create-your-spider","text":"Usually we create one spider to scrapeone website. For this example we will do exactly the same for Devgan website. So let's create a spider spiders/devgan.py . The code is shown below, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # import import scrapy # function class DevganSpider ( scrapy . Spider ): name = \"devgan\" allowed_domains = [ \"devgan.in\" ] def start_requests ( self ): urls = [ 'http://devgan.in/all_sections_ipc.php' , ] for url in urls : yield scrapy . Request ( url = url , callback = self . parse_mainpage ) def parse_mainpage ( self , response ): # identify the links to the individual section pages sections = response . css ( 'div#content' ) . css ( 'a' ) #.getall() # for each section for section in sections : # loc var loc = { 'title' : section . xpath ( '@title' ) . extract (), 'link' : 'http://devgan.in' + section . xpath ( '@href' ) . extract ()[ 0 ], 'section' : section . css ( 'span.sectionlink::text' ) . extract (), } # traverse again and extract the description yield scrapy . Request ( loc [ 'link' ], callback = self . parse_section , cb_kwargs = dict ( meta = loc )) def parse_section ( self , response , meta ): # extract the description meta [ 'description' ] = \" \" . join ( response . css ( 'tr.mys-desc' ) . css ( '::text' ) . extract ()) # return return meta Now lets us try to understand the code line by line, Line 2: Importing the scrapy package. Line 5: Defining the spider class that inherits the scrapy.Spider class. Line 6-7: We define the name of the spider and allow the spider to crawl the domain devgan.in . Line 9-14: We define the start_requests method. This method is called when the spider is executed. It calls the scraping function for each url to scrap, it is done using scrapy.Request function call. For each url, the scraping function set within callback parameter is called. Line 16: We define the scraping function parse_mainpage for the main page. Note, this function receives response as an argument, that contains the source code from the server for the main page url. Line 18-29: We start with identifying the links to the individual section pages, store them in sections , and call the scraping function parse_section for each section. Before that, we also extract the title, link and section name from the main page using the queries we created before. One point to remember, this particular example is little complex as we want to traverse further inside into the section pages. For this, we again call the scrapy.Request for the individual section links. Finally, we want to pass the data collected form this page to the section page, as we will consolidate all data for individual section there and return it. For this, we use cb_kwargs parameter to pass the meta data to the next function. Line 31-35: We extract the description from the section page using the CSS query. We add description detail to the metadata and return the complete data that is to be persisted.","title":"Create your Spider"},{"location":"data_science_tools/scraping_websites/#executing-the-spider","text":"To run the spider, traverse to the root directory and execure the following command, scrapy crawl devgan -O sections_details.csv -t csv . Here, devgan is the name of the spider we created earlier, -O is used to set the output file name as sections_details.csv . -t is used to define the output format as csv . This will create the csv file with all details of the sections as separate columns as shown below (only 2 rows) title link section description IPC Section 1... http://... Section 1 This Act shall be called the Indian Penal Code... IPC Section 2... http://... Section 2 Every person shall be liable to punishment un.... And that's it! Cheers!","title":"Executing the spider"},{"location":"data_science_tools/scraping_websites/#dynamic-website-scrape-using-selenium-and-bs4","text":"","title":"Dynamic Website scrape using Selenium and BS4"},{"location":"data_science_tools/scraping_websites/#understanding-the-website_1","text":"Well, everyone knows and has used Google atleast once in their life. Nevertheless, for an example, if we want to find all of the latest news from TechCrunch, this is how the google search will look like. Google search result shows the news for the 14th of Nov, 2023 On looking at the page source of the above screen, you will only see javascript code that does not contain any data as shown above. This is because Google is a dynamic website which is event-driven and created with server-side languages. Because of this, we cannot use Scrapy alone as it cannot run Javascript, what we we need is a browser to run the code. That's where Selenium and BS4 comes in.","title":"Understanding the website"},{"location":"data_science_tools/scraping_websites/#selenium-and-bs4-automation","text":"We will code a generic function to automate the process of opening Chrome browser, loading the website and extracting the data from the website. To run it for our example of TechCrunch, we just need to change the input param. Note Before starting make sure to install the Selenium package and drivers as explained here . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 from selenium import webdriver from selenium.webdriver.chrome.service import Service from selenium.webdriver.chrome.options import Options from bs4 import BeautifulSoup import csv import time # Set up the Selenium driver (make sure you have the Chrome WebDriver installed) options = Options () options . add_argument ( \"--window-size=1920,1200\" ) driver = webdriver . Chrome ( options = options ) # Function to scrape Google using Selenium and BeautifulSoup def scrape_google ( search_query , num_pages , start_page = 0 ): results = [] for page in range ( 0 , num_pages ): start = ( page * 10 ) + start_page * 10 url = f \"https://www.google.com/search?q= { search_query } &start= { start } \" driver . get ( url ) time . sleep ( 2 ) # Sleep to ensure all scripts are loaded properly # loading and processing the page source in BS4 soup = BeautifulSoup ( driver . page_source , 'html.parser' ) search_items = soup . find_all ( 'div' , class_ = 'g' ) # iterate over all items (search results) for item in search_items : title = item . find ( 'h3' ) link = item . find ( 'a' , href = True ) description = item . get_text () . split ( ' \u203a ' )[ 2 ] if title and link : results . append ({ 'title' : title . get_text (), 'link' : link [ 'href' ], 'description' : description if description else \"\" }) save_results_to_csv ( results , f 'google_search_results_ { page } .csv' ) driver . quit () return results # Save results to CSV def save_results_to_csv ( results , filename ): with open ( filename , 'w' , newline = '' , encoding = 'utf-8' ) as csvfile : fieldnames = [ 'title' , 'link' , 'description' ] writer = csv . DictWriter ( csvfile , fieldnames = fieldnames ) writer . writeheader () for result in results : writer . writerow ( result ) # Use the function to scrape and save results search_results = scrape_google ( \"site:https://techcrunch.com/2023/11/14/\" , 10 ) Let's understand the code in detail, Line 1-6 : Importing the required packages. Line 8-11 : Initializes the Chrome WebDriver with the specified options. Line 14-40 : Defines a function to scrape Google. It takes a search query, the number of pages to scrape, and an optional starting page. Inside the function, we iterate over the number of pages specified, constructing a URL for each page of Google search results based on the query and the current page. The WebDriver is used to navigate to the URL. Then, we use BS4 to parse the page source and extracts the title, link, and description of each search result and appends it to the results list. At each iteration, we save the result to a CSV. Finally, we close the driver and return the results . Line 42-49 : Defines save_results_to_csv function to save the scraped results to a CSV file. It uses Python's csv module to write the title, link, and description of each search result to a CSV file. Line 52 : We call the scrape_google function to scrape first 10 pages of Google search results for the specified query. And we are done!","title":"Selenium and BS4 Automation"},{"location":"data_science_tools/version_control/","text":"Version control (VC) is basically needed for any file(s) that will be maintained for a long time (read, multiple editing process) and/or accessed by multiple people (in collaboration) . If you have such a file or a set of files (as a project) , you will agree the necessity to track the changes. VC tries to help us with the same \ud83c\udd92 Now comes the question of what can be tracked and how? A very simple distinction of different tools available for VC can be introduced efficiently, if we look at them from the lens of what type of data they can \"version control\". Such as, Code: if you want to maintain just the code files, GIT is the defacto answer. There are several GIT based service providers, such as GitHub , whose platform can be used (for free) to maintain a git repository. Data and ML Model: in contrast to GIT, that was developed to maintain relatively small sized files, we need something different if we want to handle big files like datasets or ML/DL models. Enter DVC (Data Version Control), an GIT extension that directly connects the data storages (cloud or local) with the git to maintain data, model and code at the same time! We will now go through some of the tools/services for version control in detail. GIT Introduction In simple words, GIT is a system designed to track changes in your file. True story, it was developed by none other but the creator of Linux, yes, Linus Torvalds in 2005! The story goes something like this -- while he was developing the linux kernel along with other kernel developers, he found it troublesome to maintain, track and handle conflicting (overlapping) pieces of codes. So he ended up coding the GIT system as a side project, just to help him and his fellow developers maintain linux kernel in a more efficient manner! Now, isn't that a cool side project \ud83d\ude0e. You can read more about GIT and the history here . Some of the popular and free services are GitHub , Gitlab and BitBucket . While they differ by UI and add-on functionalities, the core system (Git) used by all of them is the same. Hence if you learn the basic Git commands once, you can use any of the services mentioned above. That is why we will limit ourselves to learn Git the old school way i.e. via GIT bash commands, and leave the fancy UI or tool based operation as an exploration activity for the interested audience. Before we go into the command and syntax, we need to be clear about certain topics to better appreciate Git. These are, Where to download Git? Git is free and available here . Download the latest stable version as per your OS. How do we use Git? After downloading Git (and specifically in Windows) , from any directory in file explorer, on right click, you should get the option to open either \"Git bash\" or \"Git GUI\". For this article, we will use Git bash, as that's how real developers roll \ud83d\ude24 (jk) What is Git Bash? It is something similar to command prompt in windows or terminal in linux, but something specifically designed for Git. To perform any Git related operation, we will use the Git bash. What is the life cycle in Git? Basically any file in a git repository typically goes through three states. These are, (1) working state: the initial stage, where you have created a git repository and git is just looking at the files to note what has changed. (2) staging state: the second state where you mark certain files that should be commited, and (3) commit state: where you finalize the changes made to the files and commit them to the Git's history. Basically, this will create a version of your code and persist it for future reference. What is local vs remote instances? Local instance is a git repository present in your local computer, and on the other hand, remote instance is the common server used to upload the modifications of the local instance. This is done so that there is a centralised repository from where everyone in the team can pull or push the latest code. What are branches in Git? Branches are like parallel universes in Git. We can spawn off new branches anytime and from any other branch. By doing so we create a fork within that branch, where the developer can do whatever they want to do. Finally, after relevant commits/changes, the forked branch is merged back to their original branch using merge request. What is a merge request and merge conflict in Git? Merge request is a request raised by the developer to the maintainer of the Git remote repository, asking them to merge the two branches. The maintainer may want to perform final set of validations before accepting the merge request. It may also happen that the same lines in the same file has been modified in both the branches, this will then lead to a merge conflict. Resolving merge conflict can range from easy to highly complex based on how many files has been affected. To resolve a merge conflict, we will modify the affected lines and then create a new commit. Now, let's take a practical approach of learning Git by role-playing an example to learn the basics. Suppose you are working on a big project that requires mulitple modifications per day. TO efficiently maintain the project, you are looking for a tool that will help to keep track of the changes made in the project, by recording the line wise modification made in the files in the project. For this you want to explore GIT and test if it will make your life easier or not. So, let's get stated with the exploration! \ud83d\ude00 Initializing the Git repository: As we discussed, Git helps in tracking the changes made in a file. On top of it, it's easy to scale it up and track a complete folder that contains hundreds of files! For reference, suppose you have already created a python project and want to track the changes in any of the files present there. To do so, just go to the main directory of the project and initialize git by using command git init . This will mark that directory as a git repository. Next, if you run git status , it will show you an overview of the project and all of files. Note, by default Git keeps a look out at all of the files within the directory and show when any of the files have changed. Staging files: You are going through the project file by file, making modifications as needed. Once you are happy with any file (or think that it is done), you can add that file to the staging area by command git add <file_name> , or if you want to stage all of the files at one go, do git add . . Now if you run git status again, you can see the files names are in green. This means these files are staged! Example for initializing the git repository to tracking the files. Commit: Now, suppose we just completed one small task. It would be a good idea to take a snapshot of our current code and save it. This can be done by git commit -m \"your message\" , wherein you are asking git to commit all of the changes added in the staging area. This commit can be thought of as a unique snapshot of your code with the commit message as your description. Note, Git also generates hex code that is unique to each commit, that acts as the commit identifier. Your description is just a human readable piece of informance for us mere mortals \ud83d\ude00 Push: Note, all of these modifications has been done on your local instance, and to publish these to the world, we need to push the code to the remote instance. We can push our latest commits to the remote server by git push origin master . Note, here git push signifies we want to push the code, origin denotes the remote server and master denotes the branch of origin on which we want to push. And that's it! We have covered most of the fundamental aspects of using git! One important aspect to remember is that, we should refrain from committing directly to the master branch. Instead whenever we are planning to do some modifications, we should checkout to a new git branch (by using git checkout -b <branch_name> ), do the modifications there, push that particular branch to remote and then create a merge request. This is just a good practice followed when working with a team! Note It may so happens that you only want to certain few files and not all of them. This can be done by creating a .gitignore file and placing it in the root directory. Within the file, add the relative (from root directory) path of all the files or folders you want the Git to ignore. For example, data/input.csv or data/* are respectively the examples to exclude one file or the complete folder from Git's tracking system. GIT Snippets A consolidation of some of the most helper code snippets for GIT. The basic git commands Listing down some of the most basic GIT commands, that you should definitely know about. Most of them are references from the above theory part. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # list all local branches git branch # list all remote branches git branch - r # create a local copy of a remote branch git checkout -- track origin / branch_name # show the remote links git remote - v # add a new remote git remote add new_remote git @github . com : User / UserRepo . git # pull the latest code from \"master\" branch of \"origin\" remote server git pull origin master # checkout to an existing branch git checkout main # checkout to a new branch git checkout - b use_bert_model # after performing some changes, add files to staging state git add . # commit git commit - m \"added bert model\" # push the branch to remote git push origin use_bert_model Modify config to add email and name 1 2 3 4 5 6 7 8 9 10 11 # Check the value of the config git config -- get user . email git config -- get user . name # Add username git config -- global user . name \"FIRST_NAME LAST_NAME\" # Add email git config -- global user . email \"MY_NAME@example.com\" # For local modification (for a git within a directory), use --local instead of --global # mode details: https://support.atlassian.com/bitbucket-cloud/docs/configure-your-dvcs-username-for-commits/ Publishing to Github using APIs (Python) Publishing (adding files for instance) to Git is quite easy using the local CLI tool and/or Github tools or UI. We have already discussed how to do this using CLI. But what if you are creating your own application and need to do the same using Github APIs? This snippet is a python based function that adds a new file to your git repo, commits and publishes it! Note, this is not as simple as single API call, for detailed information on what happens behind the scene when you commit and push, I will suggest this article . You will need to create a personal token from github using this link . Store that as config['Github']['personal_token'] for this function to work. Note, the function takes config as parameter input. This snippet is inspired from this article and this stackoverflow answer . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 # function to publish new content to Github def publish_to_github ( config , content , remote_path , commit_message , repo = 'test' , user = 'imohitmayank' , branch = 'main' , name = \"Mohit Mayank\" , email = \"mohitmayank1@gmail.com\" ): \"\"\" Function to publish new content to Github Parameters ----------- config: dict with `config['Github']['personal_token']` containing your Github personal token content: string content you want to push to Github remote_path: path wrt to remote, where you want to save the content to; include the file name commit_message: message for commit \"\"\" # Step 1: Get the SHA of the branch url = f \"https://api.github.com/repos/ { user } / { repo } /branches/ { branch } \" header = { 'Authorization' : f 'token { config [ \"Github\" ][ \"personal_token\" ] } ' } r = requests . get ( url , headers = header ) last_commit_sha = r . json ()[ 'commit' ][ 'sha' ] print ( \"Step 1 Done: SHA fetched.\" ) # Step 2: Create a blob url = f \"https://api.github.com/repos/ { user } / { repo } /git/blobs\" header = { 'Authorization' : f 'token { config [ \"Github\" ][ \"personal_token\" ] } ' } body = { \"content\" : content , \"encoding\" : \"utf-8\" } r = requests . post ( url , json = body , headers = header ) utf8_blob_sha = r . json ()[ 'sha' ] print ( \"Step 2 Done: Blob created.\" ) # Step 3: Create a tree url = f \"https://api.github.com/repos/ { user } / { repo } /git/trees\" header = { 'Authorization' : f 'token { config [ \"Github\" ][ \"personal_token\" ] } ' } body = { \"base_tree\" : last_commit_sha , \"tree\" : [ { \"path\" : remote_path , \"mode\" : \"100644\" , \"type\" : \"blob\" , \"sha\" : utf8_blob_sha } ] } r = requests . post ( url , json = body , headers = header ) tree_sha = r . json ()[ 'sha' ] print ( \"Step 3 Done: Tree created.\" ) ## Step 4: Commit the changes url = f \"https://api.github.com/repos/ { user } / { repo } /git/commits\" header = { 'Authorization' : f 'token { config [ \"Github\" ][ \"personal_token\" ] } ' } body = { \"message\" : commit_message , \"author\" : { \"name\" : name , \"email\" : email }, \"parents\" : [ last_commit_sha ], \"tree\" : tree_sha } r = requests . post ( url , json = body , headers = header ) new_commit_sha = r . json ()[ 'sha' ] print ( \"Step 4 Done: Changes commited\" ) ## Step 5: update the HEAD url = f \"https://api.github.com/repos/ { user } / { repo } /git/refs/heads/ { branch } \" header = { 'Authorization' : f 'token { config [ \"Github\" ][ \"personal_token\" ] } ' } body = { \"ref\" : \"refs/heads/ {branch} \" , \"sha\" : new_commit_sha } r = requests . post ( url , json = body , headers = header ) print ( \"Step 5 Done: HEAD updated\" ) print ( \"------ ALL DONE! ------\" ) Ignore files/folders .gitignore file in the root directory, contains the name of files and folders which should not be tracked by GIT. 1 2 3 4 5 6 7 8 9 # ignore personal.txt personal # ignore everything within \"pic\" folder pic /* # ignore everything except a specific file within a folder ! pic / logo . png pic /* Untrack file/folder and delete them from GIT To untrack the files or folders, we can create .gitignore file and add respective info. To delete the files or folders form GIT (and not from local system), we can delete them from the cache as suggested here , 1 2 3 4 5 # for a single file: git rm -- cached mylogfile . log # for a single directory: git rm -- cached - r mydirectory Stash partial changes Suppose you have made some partial changes and the remote is updated with a new commit. Now you cannot commit your local change (as its partial) and you need to pull the latest code from remote (as its update). git stash comes to the rescue, example below. 1 2 3 4 5 6 7 8 # stash away the current partial changes git stash # pull the latest code (or any other operation) git pull origin master # pop the stashed partial changes git stash pop Reset to the last commit You may want to revert back to the very last commit, discarding every modification from then. This could be because you were playing around with the code or doing some minor experiments. In either cases, you can do this by, 1 git reset -- hard HEAD Otherwise, to just unstage the files which were staged by git add , 1 git reset Refer this stackoverflow QA for more details. Using large files Several VC platform have a maximum file size limit, for example Github has 100MB file size limit. That said, there are ways to bypass such limitations, once of those are Git LFS i.e. Large file system. Using Git LFS we can track large files and it internally takes care of storing them as LFS objects. This way we can store our dataset or models in the git repositories as well. Below is an example track a model in a repository using Git LFS. # install git lfs git lfs install # track a file git lfs track \"model/model.pkl\" # or track a folder git lfs track \"model/**\" # add the git attribute to reflect changes git add .gitattribute # migrate the changes i.e. replace files with pointers (for current branch) git lfs migrate import --include=='model/**' --verbose # or for all branches git lfs migrate import --everything --include=='model/**' --verbose # show the files which are tracked git lfs ls-files Setting up multiple Github accounts on a single machine using SSH It is possible to setup multiple Github account on a single machine using SSH. This is useful when you want to work on multiple projects which are hosted on different Github accounts. For example, you might have one personal and one work account that you want to use on your machine. You can refer this for more details, and I will also summarize the steps below. The process is quite simple, first we will generate two SSH keys (for two accounts) and save them on our machine. Next, we will create a global ssh config file to map the two keys with github. Then, we will add the public keys to the respective github account. Finally, we will create a git config file for each local project and add the user details. Let's get started. Create SSH keys using the command shared below, make sure to replace the email address with your own. You will be prompted to enter a file name, you can enter any name you want. For example, if you want to create a key for your personal account, you can enter id_rsa_personal . Repeat this process twice to generate two keys for two different accounts. ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\" Next, create a config file in .ssh folder to map the two accounts with their keys. If the file is not present, you can create it using the following command. touch ~/.ssh/config After this, open the file and add the following content. # Personal account Host github.com-personal HostName github.com User git IdentityFile ~/.ssh/id_rsa_personal IdentitiesOnly yes # Work account Host github.com-work HostName github.com User git IdentityFile ~/.ssh/id_rsa_work IdentitiesOnly yes Now, we will add the public keys to the respective Github account. You can find the public key in the following location, ~/.ssh/id_rsa_personal.pub and ~/.ssh/id_rsa_work.pub . Copy the content of the file and add it to the respective Github account. You can refer this official doc for more details. Finally go to the local project directory and create a config file in the .git folder. Add the following content to the file. [ user ] name = personal # use work if this is for work account email = { email-address } # add the respective email address [ remote \"origin\" ] url = git@github.com-personal:imohitmayank/my-repo.git # use git@github.com-personal:.. for work fetch = +refs/heads/*:refs/remotes/origin/* And that's it, now for any git related interactions initiated from this directory, personal github account will be used. Note Step a to c is only needed to be done once. After that, you can follow step d for any new project. DVC ( Lazy Data Scientist at work - \ud83d\ude34) Additional Tips Semantic Versioning The Semantic Versioning (SemVer) is a methodology that advocates for a structured approach to versioning software to solve the common issues encountered in software management, often referred to as \"dependency hell\" [3]. SemVer provides a set of rules for how version numbers are assigned and incremented. A normal version number is in the form of X.Y.Z, with X for major, Y for minor, and Z for patch releases. The details of the rules are as follows: MAJOR version is incremented for incompatible API changes. MINOR version is incremented for the addition of backward-compatible functionality. PATCH version is incremented for backward-compatible bug fixes. SemVers also suggests that pre-release versions can be indicated by labels such as alpha, beta, rc (release candidate), etc., with possible numerical identifiers. The pre-release versions have a lower precedence than the associated normal version. This allows developers to release new features or bug fixes for testing before the official version is finalized. By using this system, developers can make iterative improvements and signal to users that the version is not yet meant for production use. Below we have some versioning examples following the lifecycle of a product, Pre - release Versio ns : - 1.0.0- alpha : A n alpha pre - release o f t he f irs t major versio n , i n dica t i n g i t is n o t s ta ble a n d is f or test i n g. - 1.0.0- alpha. 1 : A subseque nt pre - release , could be a n i terat io n wi t h mi n or cha n ges or f ixes fr om t he previous alpha. - 1.0.0- be ta : A be ta pre - release which is closer t o t he f i nal produc t bu t may s t ill u n dergo cha n ges. - 1.0.0- rc. 1 : Release ca n dida te 1 , i n dica t i n g t he so ft ware is po tent ially shippable , wi t h all features comple te d a n d bug f ixes applied , bu t s t ill migh t have k n ow n issues. - 1.0.0- rc. 2 : Release ca n dida te 2 , a n i terat io n a fter rc. 1 , wi t h furt her f ixes or mi n or cha n ges. Pos t - release Versio ns : - 1.0.0 : The o ff icial release o f t he so ft ware , co ns idered s ta ble a n d sui ta ble f or produc t io n . - 1.0.1 : A pa t ch release i n dica t i n g backward - compa t ible bug f ixes have bee n applied. - 1.1.0 : A mi n or release which adds backward - compa t ible features or improveme nts . - 2.0.0 : A major release i n dica t i n g t here are cha n ges t ha t are n o t backward - compa t ible. References GIT DVC Semnantic Versioning 2.0 - Blog","title":"Version control"},{"location":"data_science_tools/version_control/#git","text":"","title":"GIT"},{"location":"data_science_tools/version_control/#introduction","text":"In simple words, GIT is a system designed to track changes in your file. True story, it was developed by none other but the creator of Linux, yes, Linus Torvalds in 2005! The story goes something like this -- while he was developing the linux kernel along with other kernel developers, he found it troublesome to maintain, track and handle conflicting (overlapping) pieces of codes. So he ended up coding the GIT system as a side project, just to help him and his fellow developers maintain linux kernel in a more efficient manner! Now, isn't that a cool side project \ud83d\ude0e. You can read more about GIT and the history here . Some of the popular and free services are GitHub , Gitlab and BitBucket . While they differ by UI and add-on functionalities, the core system (Git) used by all of them is the same. Hence if you learn the basic Git commands once, you can use any of the services mentioned above. That is why we will limit ourselves to learn Git the old school way i.e. via GIT bash commands, and leave the fancy UI or tool based operation as an exploration activity for the interested audience. Before we go into the command and syntax, we need to be clear about certain topics to better appreciate Git. These are, Where to download Git? Git is free and available here . Download the latest stable version as per your OS. How do we use Git? After downloading Git (and specifically in Windows) , from any directory in file explorer, on right click, you should get the option to open either \"Git bash\" or \"Git GUI\". For this article, we will use Git bash, as that's how real developers roll \ud83d\ude24 (jk) What is Git Bash? It is something similar to command prompt in windows or terminal in linux, but something specifically designed for Git. To perform any Git related operation, we will use the Git bash. What is the life cycle in Git? Basically any file in a git repository typically goes through three states. These are, (1) working state: the initial stage, where you have created a git repository and git is just looking at the files to note what has changed. (2) staging state: the second state where you mark certain files that should be commited, and (3) commit state: where you finalize the changes made to the files and commit them to the Git's history. Basically, this will create a version of your code and persist it for future reference. What is local vs remote instances? Local instance is a git repository present in your local computer, and on the other hand, remote instance is the common server used to upload the modifications of the local instance. This is done so that there is a centralised repository from where everyone in the team can pull or push the latest code. What are branches in Git? Branches are like parallel universes in Git. We can spawn off new branches anytime and from any other branch. By doing so we create a fork within that branch, where the developer can do whatever they want to do. Finally, after relevant commits/changes, the forked branch is merged back to their original branch using merge request. What is a merge request and merge conflict in Git? Merge request is a request raised by the developer to the maintainer of the Git remote repository, asking them to merge the two branches. The maintainer may want to perform final set of validations before accepting the merge request. It may also happen that the same lines in the same file has been modified in both the branches, this will then lead to a merge conflict. Resolving merge conflict can range from easy to highly complex based on how many files has been affected. To resolve a merge conflict, we will modify the affected lines and then create a new commit. Now, let's take a practical approach of learning Git by role-playing an example to learn the basics. Suppose you are working on a big project that requires mulitple modifications per day. TO efficiently maintain the project, you are looking for a tool that will help to keep track of the changes made in the project, by recording the line wise modification made in the files in the project. For this you want to explore GIT and test if it will make your life easier or not. So, let's get stated with the exploration! \ud83d\ude00 Initializing the Git repository: As we discussed, Git helps in tracking the changes made in a file. On top of it, it's easy to scale it up and track a complete folder that contains hundreds of files! For reference, suppose you have already created a python project and want to track the changes in any of the files present there. To do so, just go to the main directory of the project and initialize git by using command git init . This will mark that directory as a git repository. Next, if you run git status , it will show you an overview of the project and all of files. Note, by default Git keeps a look out at all of the files within the directory and show when any of the files have changed. Staging files: You are going through the project file by file, making modifications as needed. Once you are happy with any file (or think that it is done), you can add that file to the staging area by command git add <file_name> , or if you want to stage all of the files at one go, do git add . . Now if you run git status again, you can see the files names are in green. This means these files are staged! Example for initializing the git repository to tracking the files. Commit: Now, suppose we just completed one small task. It would be a good idea to take a snapshot of our current code and save it. This can be done by git commit -m \"your message\" , wherein you are asking git to commit all of the changes added in the staging area. This commit can be thought of as a unique snapshot of your code with the commit message as your description. Note, Git also generates hex code that is unique to each commit, that acts as the commit identifier. Your description is just a human readable piece of informance for us mere mortals \ud83d\ude00 Push: Note, all of these modifications has been done on your local instance, and to publish these to the world, we need to push the code to the remote instance. We can push our latest commits to the remote server by git push origin master . Note, here git push signifies we want to push the code, origin denotes the remote server and master denotes the branch of origin on which we want to push. And that's it! We have covered most of the fundamental aspects of using git! One important aspect to remember is that, we should refrain from committing directly to the master branch. Instead whenever we are planning to do some modifications, we should checkout to a new git branch (by using git checkout -b <branch_name> ), do the modifications there, push that particular branch to remote and then create a merge request. This is just a good practice followed when working with a team! Note It may so happens that you only want to certain few files and not all of them. This can be done by creating a .gitignore file and placing it in the root directory. Within the file, add the relative (from root directory) path of all the files or folders you want the Git to ignore. For example, data/input.csv or data/* are respectively the examples to exclude one file or the complete folder from Git's tracking system.","title":"Introduction"},{"location":"data_science_tools/version_control/#git-snippets","text":"A consolidation of some of the most helper code snippets for GIT.","title":"GIT Snippets"},{"location":"data_science_tools/version_control/#the-basic-git-commands","text":"Listing down some of the most basic GIT commands, that you should definitely know about. Most of them are references from the above theory part. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # list all local branches git branch # list all remote branches git branch - r # create a local copy of a remote branch git checkout -- track origin / branch_name # show the remote links git remote - v # add a new remote git remote add new_remote git @github . com : User / UserRepo . git # pull the latest code from \"master\" branch of \"origin\" remote server git pull origin master # checkout to an existing branch git checkout main # checkout to a new branch git checkout - b use_bert_model # after performing some changes, add files to staging state git add . # commit git commit - m \"added bert model\" # push the branch to remote git push origin use_bert_model","title":"The basic git commands"},{"location":"data_science_tools/version_control/#modify-config-to-add-email-and-name","text":"1 2 3 4 5 6 7 8 9 10 11 # Check the value of the config git config -- get user . email git config -- get user . name # Add username git config -- global user . name \"FIRST_NAME LAST_NAME\" # Add email git config -- global user . email \"MY_NAME@example.com\" # For local modification (for a git within a directory), use --local instead of --global # mode details: https://support.atlassian.com/bitbucket-cloud/docs/configure-your-dvcs-username-for-commits/","title":"Modify config to add email and name"},{"location":"data_science_tools/version_control/#publishing-to-github-using-apis-python","text":"Publishing (adding files for instance) to Git is quite easy using the local CLI tool and/or Github tools or UI. We have already discussed how to do this using CLI. But what if you are creating your own application and need to do the same using Github APIs? This snippet is a python based function that adds a new file to your git repo, commits and publishes it! Note, this is not as simple as single API call, for detailed information on what happens behind the scene when you commit and push, I will suggest this article . You will need to create a personal token from github using this link . Store that as config['Github']['personal_token'] for this function to work. Note, the function takes config as parameter input. This snippet is inspired from this article and this stackoverflow answer . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 # function to publish new content to Github def publish_to_github ( config , content , remote_path , commit_message , repo = 'test' , user = 'imohitmayank' , branch = 'main' , name = \"Mohit Mayank\" , email = \"mohitmayank1@gmail.com\" ): \"\"\" Function to publish new content to Github Parameters ----------- config: dict with `config['Github']['personal_token']` containing your Github personal token content: string content you want to push to Github remote_path: path wrt to remote, where you want to save the content to; include the file name commit_message: message for commit \"\"\" # Step 1: Get the SHA of the branch url = f \"https://api.github.com/repos/ { user } / { repo } /branches/ { branch } \" header = { 'Authorization' : f 'token { config [ \"Github\" ][ \"personal_token\" ] } ' } r = requests . get ( url , headers = header ) last_commit_sha = r . json ()[ 'commit' ][ 'sha' ] print ( \"Step 1 Done: SHA fetched.\" ) # Step 2: Create a blob url = f \"https://api.github.com/repos/ { user } / { repo } /git/blobs\" header = { 'Authorization' : f 'token { config [ \"Github\" ][ \"personal_token\" ] } ' } body = { \"content\" : content , \"encoding\" : \"utf-8\" } r = requests . post ( url , json = body , headers = header ) utf8_blob_sha = r . json ()[ 'sha' ] print ( \"Step 2 Done: Blob created.\" ) # Step 3: Create a tree url = f \"https://api.github.com/repos/ { user } / { repo } /git/trees\" header = { 'Authorization' : f 'token { config [ \"Github\" ][ \"personal_token\" ] } ' } body = { \"base_tree\" : last_commit_sha , \"tree\" : [ { \"path\" : remote_path , \"mode\" : \"100644\" , \"type\" : \"blob\" , \"sha\" : utf8_blob_sha } ] } r = requests . post ( url , json = body , headers = header ) tree_sha = r . json ()[ 'sha' ] print ( \"Step 3 Done: Tree created.\" ) ## Step 4: Commit the changes url = f \"https://api.github.com/repos/ { user } / { repo } /git/commits\" header = { 'Authorization' : f 'token { config [ \"Github\" ][ \"personal_token\" ] } ' } body = { \"message\" : commit_message , \"author\" : { \"name\" : name , \"email\" : email }, \"parents\" : [ last_commit_sha ], \"tree\" : tree_sha } r = requests . post ( url , json = body , headers = header ) new_commit_sha = r . json ()[ 'sha' ] print ( \"Step 4 Done: Changes commited\" ) ## Step 5: update the HEAD url = f \"https://api.github.com/repos/ { user } / { repo } /git/refs/heads/ { branch } \" header = { 'Authorization' : f 'token { config [ \"Github\" ][ \"personal_token\" ] } ' } body = { \"ref\" : \"refs/heads/ {branch} \" , \"sha\" : new_commit_sha } r = requests . post ( url , json = body , headers = header ) print ( \"Step 5 Done: HEAD updated\" ) print ( \"------ ALL DONE! ------\" )","title":"Publishing to Github using APIs (Python)"},{"location":"data_science_tools/version_control/#ignore-filesfolders","text":".gitignore file in the root directory, contains the name of files and folders which should not be tracked by GIT. 1 2 3 4 5 6 7 8 9 # ignore personal.txt personal # ignore everything within \"pic\" folder pic /* # ignore everything except a specific file within a folder ! pic / logo . png pic /*","title":"Ignore files/folders"},{"location":"data_science_tools/version_control/#untrack-filefolder-and-delete-them-from-git","text":"To untrack the files or folders, we can create .gitignore file and add respective info. To delete the files or folders form GIT (and not from local system), we can delete them from the cache as suggested here , 1 2 3 4 5 # for a single file: git rm -- cached mylogfile . log # for a single directory: git rm -- cached - r mydirectory","title":"Untrack file/folder and delete them from GIT"},{"location":"data_science_tools/version_control/#stash-partial-changes","text":"Suppose you have made some partial changes and the remote is updated with a new commit. Now you cannot commit your local change (as its partial) and you need to pull the latest code from remote (as its update). git stash comes to the rescue, example below. 1 2 3 4 5 6 7 8 # stash away the current partial changes git stash # pull the latest code (or any other operation) git pull origin master # pop the stashed partial changes git stash pop","title":"Stash partial changes"},{"location":"data_science_tools/version_control/#reset-to-the-last-commit","text":"You may want to revert back to the very last commit, discarding every modification from then. This could be because you were playing around with the code or doing some minor experiments. In either cases, you can do this by, 1 git reset -- hard HEAD Otherwise, to just unstage the files which were staged by git add , 1 git reset Refer this stackoverflow QA for more details.","title":"Reset to the last commit"},{"location":"data_science_tools/version_control/#using-large-files","text":"Several VC platform have a maximum file size limit, for example Github has 100MB file size limit. That said, there are ways to bypass such limitations, once of those are Git LFS i.e. Large file system. Using Git LFS we can track large files and it internally takes care of storing them as LFS objects. This way we can store our dataset or models in the git repositories as well. Below is an example track a model in a repository using Git LFS. # install git lfs git lfs install # track a file git lfs track \"model/model.pkl\" # or track a folder git lfs track \"model/**\" # add the git attribute to reflect changes git add .gitattribute # migrate the changes i.e. replace files with pointers (for current branch) git lfs migrate import --include=='model/**' --verbose # or for all branches git lfs migrate import --everything --include=='model/**' --verbose # show the files which are tracked git lfs ls-files","title":"Using large files"},{"location":"data_science_tools/version_control/#setting-up-multiple-github-accounts-on-a-single-machine-using-ssh","text":"It is possible to setup multiple Github account on a single machine using SSH. This is useful when you want to work on multiple projects which are hosted on different Github accounts. For example, you might have one personal and one work account that you want to use on your machine. You can refer this for more details, and I will also summarize the steps below. The process is quite simple, first we will generate two SSH keys (for two accounts) and save them on our machine. Next, we will create a global ssh config file to map the two keys with github. Then, we will add the public keys to the respective github account. Finally, we will create a git config file for each local project and add the user details. Let's get started. Create SSH keys using the command shared below, make sure to replace the email address with your own. You will be prompted to enter a file name, you can enter any name you want. For example, if you want to create a key for your personal account, you can enter id_rsa_personal . Repeat this process twice to generate two keys for two different accounts. ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\" Next, create a config file in .ssh folder to map the two accounts with their keys. If the file is not present, you can create it using the following command. touch ~/.ssh/config After this, open the file and add the following content. # Personal account Host github.com-personal HostName github.com User git IdentityFile ~/.ssh/id_rsa_personal IdentitiesOnly yes # Work account Host github.com-work HostName github.com User git IdentityFile ~/.ssh/id_rsa_work IdentitiesOnly yes Now, we will add the public keys to the respective Github account. You can find the public key in the following location, ~/.ssh/id_rsa_personal.pub and ~/.ssh/id_rsa_work.pub . Copy the content of the file and add it to the respective Github account. You can refer this official doc for more details. Finally go to the local project directory and create a config file in the .git folder. Add the following content to the file. [ user ] name = personal # use work if this is for work account email = { email-address } # add the respective email address [ remote \"origin\" ] url = git@github.com-personal:imohitmayank/my-repo.git # use git@github.com-personal:.. for work fetch = +refs/heads/*:refs/remotes/origin/* And that's it, now for any git related interactions initiated from this directory, personal github account will be used. Note Step a to c is only needed to be done once. After that, you can follow step d for any new project.","title":"Setting up multiple Github accounts on a single machine using SSH"},{"location":"data_science_tools/version_control/#dvc","text":"( Lazy Data Scientist at work - \ud83d\ude34)","title":"DVC"},{"location":"data_science_tools/version_control/#additional-tips","text":"","title":"Additional Tips"},{"location":"data_science_tools/version_control/#semantic-versioning","text":"The Semantic Versioning (SemVer) is a methodology that advocates for a structured approach to versioning software to solve the common issues encountered in software management, often referred to as \"dependency hell\" [3]. SemVer provides a set of rules for how version numbers are assigned and incremented. A normal version number is in the form of X.Y.Z, with X for major, Y for minor, and Z for patch releases. The details of the rules are as follows: MAJOR version is incremented for incompatible API changes. MINOR version is incremented for the addition of backward-compatible functionality. PATCH version is incremented for backward-compatible bug fixes. SemVers also suggests that pre-release versions can be indicated by labels such as alpha, beta, rc (release candidate), etc., with possible numerical identifiers. The pre-release versions have a lower precedence than the associated normal version. This allows developers to release new features or bug fixes for testing before the official version is finalized. By using this system, developers can make iterative improvements and signal to users that the version is not yet meant for production use. Below we have some versioning examples following the lifecycle of a product, Pre - release Versio ns : - 1.0.0- alpha : A n alpha pre - release o f t he f irs t major versio n , i n dica t i n g i t is n o t s ta ble a n d is f or test i n g. - 1.0.0- alpha. 1 : A subseque nt pre - release , could be a n i terat io n wi t h mi n or cha n ges or f ixes fr om t he previous alpha. - 1.0.0- be ta : A be ta pre - release which is closer t o t he f i nal produc t bu t may s t ill u n dergo cha n ges. - 1.0.0- rc. 1 : Release ca n dida te 1 , i n dica t i n g t he so ft ware is po tent ially shippable , wi t h all features comple te d a n d bug f ixes applied , bu t s t ill migh t have k n ow n issues. - 1.0.0- rc. 2 : Release ca n dida te 2 , a n i terat io n a fter rc. 1 , wi t h furt her f ixes or mi n or cha n ges. Pos t - release Versio ns : - 1.0.0 : The o ff icial release o f t he so ft ware , co ns idered s ta ble a n d sui ta ble f or produc t io n . - 1.0.1 : A pa t ch release i n dica t i n g backward - compa t ible bug f ixes have bee n applied. - 1.1.0 : A mi n or release which adds backward - compa t ible features or improveme nts . - 2.0.0 : A major release i n dica t i n g t here are cha n ges t ha t are n o t backward - compa t ible.","title":"Semantic Versioning"},{"location":"data_science_tools/version_control/#references","text":"GIT DVC Semnantic Versioning 2.0 - Blog","title":"References"},{"location":"introduction/getting_started/","text":"Introduction Did you recently decide to become a Data Scientist? But you don't know what to do next or how can you get started? -- Well it's common to be confused about these things and specially on how to begin your journey in this amazing world of Data Science \ud83c\udf0e Just like learning any other technique, it's better to approach learning Data Science from scratch and in multiple phases. Remember, this is by no means a magic formula to make you a Data Science expert overnight - we also don't provide any certifications \ud83d\udcc4 . The intention of this guide is to provide the essential knowledge and skills to get you started in the Data Science field. And most importantly, to help you plan your journey in the right direction. One more thing, the field of Data Science is quite vast. The learning approach could vary based on what you want to become -- Data Engineer, Data Scientist, Research Scientist, ML Engineer, etc. In this guide, we will focus on Data Scientist designation while also touching some peripheral topics. But before we get started, let's have a look at the different designations in the Data Science field and what they are all about. Data Engineer: Data Engineer handles data i.e. they are responsible for the data processing and data analysis. Data Scientist: Data Scientist handles model training i.e. they are responsible to leverage the data to generate predictive and actionable models. ML Engineer: ML Engineer deploys models i.e. they are responsible to take the model and perform accessible and scalable deployment. Note Research Scientist is another Data Science related designation that is usually more research and academics oriented, when compared to Data Scientist , which is more practical and industry oriented. Now, let's get started by dividing the herculean task of masting Data Science into three levels, namely L1, L2, and L3. L1 is the most basic level, and L3 is the most advanced level. Note Advancing from one level to another is subject to your own understanding and progress. There is no time related or checkpoint related explicit grading system that I will recommend. I believe, that if it seems you are not learning anything new by following the steps of a certain level, you are qualified enough to move on to the next level. \"To learn is to read, understand and apply.\" -- with this in mind, each level is further divided into two subtasks of theory and practice . The idea is to have at least one action item for each subtask in each level. More details are below, Levels Theory Practice L1 Beginner Online Courses Course Assignments and Code replication L2 Domain Specialization Courses Projects and Competitions L3 Research Papers and Books Create Products and Publish Papers L1: the absolute beginners \ud83d\udc66 This is the starting point of our journey. Here we want to get a basic understanding of the Data Science field and start getting our hands dirty with the basics. Let's try to go through the individual subtasks in detail. Theory: We will limit our scope to going through online courses that provide high level understanding. Here is a list of some free online courses or materials for you to go through. Python for Everybody Specialization and Python docs Machine Learning by Andrew Ng Intro to Deep Learning by MIT Data Engineering Foundations Specialization Practice: it can start with any assignments mentioned in the theory courses or materials. On top of it, we can also perform code replication i.e. to look into basic code snippets and try to replicate them. Pick any existing EDA script or ML code or any other code snippet and try to replicate it on your own. This provides the opportunity to perform guided practice as you can always refer back to the original code if you are stuck! L2: the intermediate level \ud83d\udc68 Now we have moved on to the intermediate level. Data Science in itself is a very vast field and includes multiple sub-domain like NLP, CV, RL, etc. By now, you should have some inclination towards one or more of these fields. It's time to get some domain-specific specializations. Let's go through the individual subtasks in detail. Theory: Based on different fields and generic topics, here is a list of introductory materials that you can refer to, Natural Language Processing Specialization CS224U: Natural Language Understanding CS231n: Deep Learning for Computer Vision Introduction to Reinforcement Learning with David Silver Full Stack Deeplearning Awesome MLOps Github Practice: in terms of practices, code assignment is mandatory. But another piece of advice is to participate in competitions and hackathons published on platforms like Kaggle . The plan could be to first participate in old competitions and get a feel of coding and solving problems. And then to participate in live competitions and compete with some of the best Data Science enthusiasts out there! Another thing that you can do is to create a simple AI/ML project from scratch, this will give you a much-needed practical experience. Here is an article I wrote on how to ideate and publish your projects. You can also refer to this Github repo to get some inspirations or AI project ideas. Note Please be aware that the intention of participation should be to learn. If you enter any competition without proper preparation and practice, you might not be able to get the best results. But that should never demotivate you. Your intention should be to learn, if it's that, I am sure you will come out of any competition with learning something new. Winning or Lossing is just the by-product. L3: the to be experts \ud83d\ude0e We have reached the final and an never-ending level . By now you have already mastered the basics of Data Science and even some advanced topics. But learning is a never-ending process, as the knowledge is not constant. Every day there is new research that takes the cumulative knowledge one step forward. This progress is quite fast in AI/ML field, so while learning all the existing stuff is quite important, it is necessary that you keep learning the new things and not get left behind! With this in mind, let's look into the individual subtasks in detail. Theory: here you should read about the latest trends in the field. The intention is to be up-to-date and even to be ahead of the curve. For this you can refer cited papers, trending blogs, and famous books. Lots of researchers publish their work on Arxiv which is free for all and with sites like Arxiv Sanity you can find the trending papers. Several top AI labs have their own website where they frequently publish their latest research like - Google AI , Meta AI , DeepMind AI , OpenAI , Uber AI , etc. Apart from this, people also follow influencers and groups to get the latest news. People even subscribe to AI newsletters for the same. Note If this sounds like a challenge, then you are not alone. It's quite a task to follow a lot of these sites and people to get the latest news in the field of AI and ML. That is why I created The ML Dojo . ML Dojo is a daily report on the latest and upcoming research, experiments, topics, articles, papers, \u2026 (you name it), in the field of Artificial Intelligence and Machine learning. Give it a try, it's completly free Practice: instead of just reading research papers, the intention should be to find your topic of interest, research, and publish your own work. For this, you can even collaborate with your colleagues or friends. Writing a paper of your own is a challenging but educating process, as you get to ideate, experiment, and write (to defend) the work. It gives you the ability to look at a problem from multiple perspectives and then solve it! Another thing to do is to take the project to the next level -- by creating (and maybe open-sourcing) your own products. While projects were created for the purpose of learning and your own usage, products are created for the sake of other people's usage. This will teach you to look at the problem from someone else's perspective.","title":"Getting started with Data Science"},{"location":"introduction/getting_started/#introduction","text":"Did you recently decide to become a Data Scientist? But you don't know what to do next or how can you get started? -- Well it's common to be confused about these things and specially on how to begin your journey in this amazing world of Data Science \ud83c\udf0e Just like learning any other technique, it's better to approach learning Data Science from scratch and in multiple phases. Remember, this is by no means a magic formula to make you a Data Science expert overnight - we also don't provide any certifications \ud83d\udcc4 . The intention of this guide is to provide the essential knowledge and skills to get you started in the Data Science field. And most importantly, to help you plan your journey in the right direction. One more thing, the field of Data Science is quite vast. The learning approach could vary based on what you want to become -- Data Engineer, Data Scientist, Research Scientist, ML Engineer, etc. In this guide, we will focus on Data Scientist designation while also touching some peripheral topics. But before we get started, let's have a look at the different designations in the Data Science field and what they are all about. Data Engineer: Data Engineer handles data i.e. they are responsible for the data processing and data analysis. Data Scientist: Data Scientist handles model training i.e. they are responsible to leverage the data to generate predictive and actionable models. ML Engineer: ML Engineer deploys models i.e. they are responsible to take the model and perform accessible and scalable deployment. Note Research Scientist is another Data Science related designation that is usually more research and academics oriented, when compared to Data Scientist , which is more practical and industry oriented. Now, let's get started by dividing the herculean task of masting Data Science into three levels, namely L1, L2, and L3. L1 is the most basic level, and L3 is the most advanced level. Note Advancing from one level to another is subject to your own understanding and progress. There is no time related or checkpoint related explicit grading system that I will recommend. I believe, that if it seems you are not learning anything new by following the steps of a certain level, you are qualified enough to move on to the next level. \"To learn is to read, understand and apply.\" -- with this in mind, each level is further divided into two subtasks of theory and practice . The idea is to have at least one action item for each subtask in each level. More details are below, Levels Theory Practice L1 Beginner Online Courses Course Assignments and Code replication L2 Domain Specialization Courses Projects and Competitions L3 Research Papers and Books Create Products and Publish Papers","title":"Introduction"},{"location":"introduction/getting_started/#l1-the-absolute-beginners","text":"This is the starting point of our journey. Here we want to get a basic understanding of the Data Science field and start getting our hands dirty with the basics. Let's try to go through the individual subtasks in detail. Theory: We will limit our scope to going through online courses that provide high level understanding. Here is a list of some free online courses or materials for you to go through. Python for Everybody Specialization and Python docs Machine Learning by Andrew Ng Intro to Deep Learning by MIT Data Engineering Foundations Specialization Practice: it can start with any assignments mentioned in the theory courses or materials. On top of it, we can also perform code replication i.e. to look into basic code snippets and try to replicate them. Pick any existing EDA script or ML code or any other code snippet and try to replicate it on your own. This provides the opportunity to perform guided practice as you can always refer back to the original code if you are stuck!","title":"L1: the absolute beginners \ud83d\udc66"},{"location":"introduction/getting_started/#l2-the-intermediate-level","text":"Now we have moved on to the intermediate level. Data Science in itself is a very vast field and includes multiple sub-domain like NLP, CV, RL, etc. By now, you should have some inclination towards one or more of these fields. It's time to get some domain-specific specializations. Let's go through the individual subtasks in detail. Theory: Based on different fields and generic topics, here is a list of introductory materials that you can refer to, Natural Language Processing Specialization CS224U: Natural Language Understanding CS231n: Deep Learning for Computer Vision Introduction to Reinforcement Learning with David Silver Full Stack Deeplearning Awesome MLOps Github Practice: in terms of practices, code assignment is mandatory. But another piece of advice is to participate in competitions and hackathons published on platforms like Kaggle . The plan could be to first participate in old competitions and get a feel of coding and solving problems. And then to participate in live competitions and compete with some of the best Data Science enthusiasts out there! Another thing that you can do is to create a simple AI/ML project from scratch, this will give you a much-needed practical experience. Here is an article I wrote on how to ideate and publish your projects. You can also refer to this Github repo to get some inspirations or AI project ideas. Note Please be aware that the intention of participation should be to learn. If you enter any competition without proper preparation and practice, you might not be able to get the best results. But that should never demotivate you. Your intention should be to learn, if it's that, I am sure you will come out of any competition with learning something new. Winning or Lossing is just the by-product.","title":"L2: the intermediate level \ud83d\udc68"},{"location":"introduction/getting_started/#l3-the-to-be-experts","text":"We have reached the final and an never-ending level . By now you have already mastered the basics of Data Science and even some advanced topics. But learning is a never-ending process, as the knowledge is not constant. Every day there is new research that takes the cumulative knowledge one step forward. This progress is quite fast in AI/ML field, so while learning all the existing stuff is quite important, it is necessary that you keep learning the new things and not get left behind! With this in mind, let's look into the individual subtasks in detail. Theory: here you should read about the latest trends in the field. The intention is to be up-to-date and even to be ahead of the curve. For this you can refer cited papers, trending blogs, and famous books. Lots of researchers publish their work on Arxiv which is free for all and with sites like Arxiv Sanity you can find the trending papers. Several top AI labs have their own website where they frequently publish their latest research like - Google AI , Meta AI , DeepMind AI , OpenAI , Uber AI , etc. Apart from this, people also follow influencers and groups to get the latest news. People even subscribe to AI newsletters for the same. Note If this sounds like a challenge, then you are not alone. It's quite a task to follow a lot of these sites and people to get the latest news in the field of AI and ML. That is why I created The ML Dojo . ML Dojo is a daily report on the latest and upcoming research, experiments, topics, articles, papers, \u2026 (you name it), in the field of Artificial Intelligence and Machine learning. Give it a try, it's completly free Practice: instead of just reading research papers, the intention should be to find your topic of interest, research, and publish your own work. For this, you can even collaborate with your colleagues or friends. Writing a paper of your own is a challenging but educating process, as you get to ideate, experiment, and write (to defend) the work. It gives you the ability to look at a problem from multiple perspectives and then solve it! Another thing to do is to take the project to the next level -- by creating (and maybe open-sourcing) your own products. While projects were created for the purpose of learning and your own usage, products are created for the sake of other people's usage. This will teach you to look at the problem from someone else's perspective.","title":"L3: the to be experts \ud83d\ude0e"},{"location":"machine_learning/ML_snippets/","text":"AI/ML Snippets Sharing some of the most widely used and arguably not so famous Machine Learning snippets \ud83d\ude09 Feature importance Feature importance calculation is an important technique to identify the features which \"helps\" with the downstream classification or regression tasks. Sklearn provides several options to infer the importance of a feature. Most importantly, many model automatically computed the importane and store it in model.feature_importances_ , after you call .fit() As an example, lets take the text based classification task and try to infer the following, Part 1: First use CountVectorizer for feature engineering and ExtraTreesClassifier for classification. Part 2: Show the top N features. Part 3: Show evidence of a feature (by value count over different class labels) Following dataset based assumtions have been made, We assume x_train and y_train contains the a list of sentences and labels repectively. We assume a pandas dataframe of name train_df is present which contains x_train and y_train as columns with name title and label respectively. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # import import random import pandas as pd from sklearn.ensemble import ExtraTreesClassifier from sklearn.feature_extraction.text import CountVectorizer # PART 1: Train the model # ----------------------- # variables max_features = 10000 # get features vectorizer = CountVectorizer ( max_features = max_features ) features = vectorizer . fit_transform ( x_train ) # model model = ExtraTreesClassifier ( random_state = 1 ) model . fit ( features , y_train ) # PART 2: View top features # ----------------------- top_n = 10 # no of top features to extract feature_imp_indices = model . feature_importances_ . argsort ()[ - top_n :][:: - 1 ] feature_importance = pd . DataFrame ({ 'score' : model . feature_importances_ [ feature_imp_indices ], 'feature' : np . array ( vectorizer . get_feature_names ())[ feature_imp_indices ], 'indices' : feature_imp_indices }) feature_importance # a pandas dataframe of top_n features # PART 3: View individual feature's evidence # ----------------------- index = 2282 # the feature's index # the label's distribution if this word is present in sentence x_train . iloc [ np . where ( features [:, index ] . todense () >= 1 )[ 0 ]][ 'label' ] . value_counts () Cross validation Cross validation is a technique in which at each iteration you create different split of train and dev data. At each such iteration, we train he model on the train split and validate on the remaining split. This way, event with small training data, we can perform multiple fold of validation. If you repeat this operation (for \\(N\\) iterations) over the complete data such that (1) each data point belonged to the dev split at most once, (2) each data point belonged to train split \\(N-1\\) times - its cross-validation. I have used Stratified K-Folds cross-validator, you can use any function from the complete list mentioned here - Sklearn Model selection 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # import ======= from sklearn.model_selection import StratifiedKFold # code ============= # split the dataset into K fold test def split_dataset ( dataset , return_fold = 0 , n_splits = 3 , shuffle = True , random_state = 1 ): \"\"\" dataset: pandas dataframe return_fold: the fold out of `n_split` fold, which is to be returned n_splits: # cross fold \"\"\" # defined the KFOld function skf = StratifiedKFold ( n_splits = n_splits , shuffle = shuffle , random_state = random_state ) # defined the dataset X = dataset y = dataset [ 'class' ] # label/class for i , ( train_index , test_index ) in enumerate ( skf . split ( X , y )): if return_fold == i : return dataset . loc [ train_index ], dataset . loc [ test_index ] # example call if __name__ == '__main__' : # read the dataset df = pd . read_csv ( \"....\" ) # get one specific fold out of train , test = split_dataset ( dataset = df , return_fold = 0 , n_splits = 3 ) # run for all folds for fold in range ( n_splits ): train , test = split_dataset ( dataset = df , return_fold = fold , n_splits = n_splits ) # <perform actions here...> Hyper-parameter tuning Below is an example of hyperparameter tuning for SVR regression algorithm. There we specify the search space i.e. the list of algorithm parameters to try, and for each parameter combination perform a 5 fold CV test. Refer for more details - Sklearn Hyperparameter tuning and Sklearn SVR Algorithm 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 # import ======= from sklearn.model_selection import GridSearchCV from sklearn.metrics import make_scorer from sklearn.metrics import mean_squared_error # DATA LOAD ============ train_data = ... # load the features and target on which to train # SEARCH SPACE ============ search_space = [{ 'kernel' : [ 'poly' , 'rbf' , 'sigmoid' ], 'C' : [ 1 , 10 , 100 ], 'epsilon' : [ 10 , 1 , 0.1 , 0.2 , 0.01 ]}] # TUNING ============ scorer = make_scorer ( mean_squared_error , greater_is_better = False ) svr_gs = GridSearchCV ( SVR (), search_space , cv = 5 , scoring = scorer , verbose = 10 , n_jobs = None ) svr_gs . fit ( train_data [ 'features' ], train_data [ 'target' ]) # PRINT RESULT ============ parameter_result = [] print ( \"Grid scores on training set:\" ) means = svr_gs . cv_results_ [ 'mean_test_score' ] stds = svr_gs . cv_results_ [ 'std_test_score' ] for mean , std , params in zip ( means , stds , svr_gs . cv_results_ [ 'params' ]): print ( \" %0.3f (+/- %0.03f ) for %r \" % ( mean , std * 2 , params )) parameter_result . append ({ 'mean' : abs ( mean ), 'std' : std , ** params }) # SELECT BEST PARAMETERS ============ # select the settings with smallest loss parameter_result = pd . DataFrame ( parameter_result ) parameter_result = parameter_result . sort_values ( by = [ 'mean' ]) best_settings = parameter_result . head ( 1 ) . to_dict ( orient = 'records' )[ 0 ] # FIT WITH BEST PARAMETERS ============ SVRModel = SVR ( C = best_settings [ 'C' ], epsilon = best_settings [ 'epsilon' ], kernel = best_settings [ 'kernel' ]) SVRModel . fit ( train_data [ 'features' ], train_data [ 'target' ]) Callbacks Callbacks are the hooks that you can attach to your deep learning training or validation process. It can be used to affect the training process from simple logging metric to even terminating the training in case special conditions are met. Below is an example of EarlyStopping and ModelCheckpoint callbacks. Keras 1 2 3 4 5 # fit the model history = model . fit ( train_data_gen , # training data generator # .... # put usual code here callbacks = [ checkpoint , earlystopping ] ) Mean pooling References this stackoverflow answer . Keras 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # import import numpy as np import keras # create sample data A = np . array ([[ 1 , 2 , 3 ],[ 4 , 5 , 6 ],[ 0 , 0 , 0 ],[ 0 , 0 , 0 ],[ 0 , 0 , 0 ]]) B = np . array ([[ 1 , 3 , 0 ],[ 4 , 0 , 0 ],[ 0 , 0 , 1 ],[ 0 , 0 , 0 ],[ 0 , 0 , 0 ]]) C = np . array ([ A , B ]) . astype ( \"float32\" ) # expected answer (for temporal mean) np . mean ( C , axis = 1 ) \"\"\" The output is array([[1. , 1.4, 1.8], [1. , 0.6, 0.2]], dtype=float32) Now using AveragePooling1D, \"\"\" model = keras . models . Sequential ( tf . keras . layers . AveragePooling1D ( pool_size = 5 ) ) model . predict ( C ) \"\"\" The output is, array([[[1. , 1.4, 1.8]], [[1. , 0.6, 0.2]]], dtype=float32) \"\"\" Some points to consider, The pool_size should be equal to the step/timesteps size of the recurrent layer. The shape of the output is ( batch_size , downsampled_steps , features ), which contains one additional downsampled_steps dimension. This will be always 1 if you set the pool_size equal to timestep size in recurrent layer. Dataset and Dataloader Dataset can be downloaded from Kaggle . PyTorch 1 2 3 4 5 6 # init the train and test dataset train_dataset = IMDBDataset ( X_train , y_train ) test_dataset = IMDBDataset ( X_test , y_test ) # create the dataloader train_dataloader = DataLoader ( train_dataset , batch_size = 64 , shuffle = True ) test_dataloader = DataLoader ( test_dataset , batch_size = 64 , shuffle = True ) Freeze Layers Example on how to freeze certain layers while training PyTorch lightning 1 2 3 4 5 6 7 8 9 10 11 12 # Before defining the optimizer, we need to freeze the layers # In pytorch lightning, as optimizer is defined in configure_optimizers, we freeze layers there. def configure_optimizers ( self ): # iterate through the layers and freeze the one with certain name (here all BERT models) # note: the name of layer depends on the varibale name for name , param in self . named_parameters (): if 'BERTModel' in name : param . requires_grad = False # only pass the non-frozen paramters to optimizer optimizer = torch . optim . Adam ( filter ( lambda p : p . requires_grad , self . parameters ()), lr = 1e-3 ) # return optimizer return optimizer LoRA with Selective Token Training It is possible to apply LoRA (Low-Rank Adaptation) on the embedding layer while training only specific tokens (such as newly added tokens) and freezing other tokens (older ones). The Hugging Face PEFT (Parameter-Efficient Fine-Tuning) library supports this kind of selective fine-tuning via the trainable_token_indices parameter in the LoraConfig . This allows you to: Freeze the majority of the embedding tokens (old tokens). Unfreeze and fine-tune only a subset of tokens (e.g., newly added tokens) by specifying their token IDs. Apply LoRA adapters on other target modules as usual. This approach saves memory and preserves learned token contexts, as only the embeddings corresponding to the new tokens are trainable while the others remain frozen. The token weights are saved as part of the adapter's state dict, enabling selective fine-tuning without large overhead. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from transformers import AutoTokenizer , AutoModelForCausalLM from peft import get_peft_model , LoraConfig # Load model and tokenizer base_model = AutoModelForCausalLM . from_pretrained ( \"mistralai/Mistral-7B-v0.1\" ) tokenizer = AutoTokenizer . from_pretrained ( \"mistralai/Mistral-7B-v0.1\" ) # Add new special tokens special_tokens = [ '<|start_think|>' , '<|stop_think|>' ] tokenizer . add_special_tokens ({ 'additional_special_tokens' : special_tokens }) # Resize model embedding matrix base_model . resize_token_embeddings ( len ( tokenizer )) # Setup LoRA config with trainable tokens and LoRA for other modules lora_config = LoraConfig ( target_modules = 'all-linear' , trainable_token_indices = { 'embed_tokens' : tokenizer . convert_tokens_to_ids ( special_tokens ) }, ) # Apply LoRA peft_model = get_peft_model ( base_model , lora_config ) # Proceed with training Note References: PEFT GitHub Issues , PEFT Documentation Get PEFT Model Sizes Utility function to calculate the total parameters, adapter parameters, and base parameters of a PEFT model, along with their memory sizes in MB. This is useful for understanding the memory footprint and parameter efficiency of your PEFT/LoRA models. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 def get_peft_model_sizes ( model ): total_params = sum ( p . numel () for p in model . parameters ()) total_size_mb = total_params * 4 / ( 1024 ** 2 ) # float32 size adapter_params = 0 adapter_param_names = [] for name , param in model . named_parameters (): if 'adapter' in name . lower () and param . requires_grad : adapter_params += param . numel () adapter_param_names . append ( name ) adapter_size_mb = adapter_params * 4 / ( 1024 ** 2 ) base_params = total_params - adapter_params base_size_mb = base_params * 4 / ( 1024 ** 2 ) return { 'total_params' : total_params , 'total_size_mb' : total_size_mb , 'adapter_params' : adapter_params , 'adapter_size_mb' : adapter_size_mb , 'base_params' : base_params , 'base_size_mb' : base_size_mb , 'adapter_param_names' : adapter_param_names } # Usage example model_sizes = get_peft_model_sizes ( model ) print ( model_sizes ) Example output: { 'total_params' : 284600576 , 'total_size_mb' : 1085.6650390625 , 'adapter_params' : 183537280 , 'adapter_size_mb' : 700.13916015625 , 'base_params' : 101063296 , 'base_size_mb' : 385.52587890625 , 'adapter_param_names' : [ 'base_model.model.model.embed_tokens.token_adapter.base_layer.weight' , 'base_model.model.model.embed_tokens.token_adapter.trainable_tokens_delta.default' ] } Check Trainable Parameters You can use the following code to check the trainable and frozen parameters in a model. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 trainable_params = 0 frozen_params = 0 for name , param in model . named_parameters (): if param . requires_grad : trainable_params += param . numel () print ( f \"Trainable: { name } | shape: { param . shape } \" ) else : frozen_params += param . numel () print ( f \"Frozen: { name } | shape: { param . shape } \" ) total_params = trainable_params + frozen_params print ( \"Total trainable parameters:\" , trainable_params ) print ( \"Total frozen parameters:\" , frozen_params ) print ( \"Total parameters:\" , total_params ) print ( \"Ratio of trained params to total params:\" , trainable_params / total_params ) Check for GPU availability We need GPUs for deep learning, and before we start training or inference it's a good idea to check if GPU is available on the system or not. The most basic way to check for GPUs (if it's a NVIDIA one) is to run nvidia-smi command. It will return a detailed output with driver's version, cuda version and the processes using GPU. Refer this for more details on individual components. +-----------------------------------------------------------------------------+ | NVIDIA-SMI 435 .21 Driver Version: 435 .21 CUDA Version: 10 .1 | | -------------------------------+----------------------+----------------------+ | GPU Name Persistence-M | Bus-Id Disp.A | Volatile Uncorr. ECC | | Fan Temp Perf Pwr:Usage/Cap | Memory-Usage | GPU-Util Compute M. | | =============================== + ====================== + ====================== | | 0 GeForce MX110 Off | 00000000 :01:00.0 Off | N/A | | N/A 43C P0 N/A / N/A | 164MiB / 2004MiB | 0 % Default | +-------------------------------+----------------------+----------------------+ +-----------------------------------------------------------------------------+ | Processes: GPU Memory | | GPU PID Type Process name Usage | | ============================================================================= | | 0 6348 G /usr/lib/xorg 53MiB | | 0 13360 G ...BBBBBaxsxsuxbssxsxs --shared-files 28MiB | +-----------------------------------------------------------------------------+ You can even use deep learning frameworks like Pytorch to check for the GPU availability. In fact, this is where you will most probably use them. 1 2 3 4 5 6 7 8 9 10 11 12 13 # import import torch # checks torch . cuda . is_available () ## Output: True torch . cuda . device_count () ## Output: 1 torch . cuda . current_device () ## Output: 0 torch . cuda . device ( 0 ) ## Output: <torch.cuda.device at 0x7efce0b03be0> torch . cuda . get_device_name ( 0 ) ## Output: 'GeForce MX110' Monitor GPU usage If you want to continuously monitor the GPU usage, you can use watch -n 2 nvidia-smi --id=0 command. This will refresh the nvidia-smi output every 2 second. HuggingFace Tokenizer Tokenizer is a pre-processing step that converts the text into a sequence of tokens. HuggingFace tokenizer is a wrapper around the tokenizers library , that contains multiple base algorithms for fast tokenization. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # import from transformers import AutoTokenizer # load a tokenizer (use the model of your choice) tokenizer = AutoTokenizer . from_pretrained ( 'sentence-transformers/all-MiniLM-L6-v2' ) # create an dummy text text = \"Hello my Name is Mohit\" # this will tokenize the text and return a list of tokens tokenizer . tokenize ( text ) # Output: ['hello', 'my', 'name', 'is', 'mo', '##hit'] # this will tokenize the text and return a list of token ids tokenizer . encode ( text ) # Output: [101, 7592, 2026, 2171, 2003, 9587, 16584, 102] # this will return the decoded text (from token ids) tokenizer . decode ( tokenizer . encode ( text )) # Output: [CLS] hello my name is mohit [SEP] # get the token and id details in key value pair vocabulary = tokenizer . get_vocab () # length of vocab here is 30522 # vocabulary['hello'] returns 7592 Explore Model You can use the summary method to check the model's architecture. This will show the layers, their output shape and the number of parameters in each layer. Keras PyTorch 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # import from keras.models import Sequential from keras.layers import Dense , Conv2D , MaxPooling2D , Flatten # create a model model = Sequential () model . add ( Conv2D ( 32 , ( 3 , 3 ), activation = 'relu' , input_shape = ( 28 , 28 , 1 ))) model . add ( MaxPooling2D (( 2 , 2 ))) model . add ( Conv2D ( 64 , ( 3 , 3 ), activation = 'relu' )) model . add ( MaxPooling2D (( 2 , 2 ))) model . add ( Conv2D ( 64 , ( 3 , 3 ), activation = 'relu' )) model . add ( Flatten ()) model . add ( Dense ( 64 , activation = 'relu' )) model . add ( Dense ( 10 , activation = 'softmax)) # print the model summary model . summary () 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # import import torch import torch.nn as nn # create a model class Net ( nn . Module ): def __init__ ( self ): super ( Net , self ) . __init__ () self . conv1 = nn . Conv2d ( 1 , 32 , 3 , 1 ) self . conv2 = nn . Conv2d ( 32 , 64 , 3 , 1 ) self . conv3 = nn . Conv2d ( 64 , 64 , 3 , 1 ) self . fc1 = nn . Linear ( 1024 , 64 ) self . fc2 = nn . Linear ( 64 , 10 ) def forward ( self , x ): x = F . relu ( self . conv1 ( x )) x = F . max_pool2d ( x , 2 , 2 ) x = F . relu ( self . conv2 ( x )) x = F . max_pool2d ( x , 2 , 2 ) x = F . relu ( self . conv3 ( x )) x = x . view ( - 1 , 1024 ) x = F . relu ( self . fc1 ( x )) x = self . fc2 ( x ) return F . log_softmax ( x , dim = 1 ) # create an instance of the model model = Net () # print the model summary print ( model ) To check the named parameters of the model and their dtypes, you can use the following code, PyTorch 1 2 3 4 print ( f \"Total number of names params: { len ( list ( model . named_parameters ())) } \" ) print ( \"They are - \" ) for name , param in model . named_parameters (): print ( name , param . dtype )","title":"ML snippets"},{"location":"machine_learning/ML_snippets/#aiml-snippets","text":"Sharing some of the most widely used and arguably not so famous Machine Learning snippets \ud83d\ude09","title":"AI/ML Snippets"},{"location":"machine_learning/ML_snippets/#feature-importance","text":"Feature importance calculation is an important technique to identify the features which \"helps\" with the downstream classification or regression tasks. Sklearn provides several options to infer the importance of a feature. Most importantly, many model automatically computed the importane and store it in model.feature_importances_ , after you call .fit() As an example, lets take the text based classification task and try to infer the following, Part 1: First use CountVectorizer for feature engineering and ExtraTreesClassifier for classification. Part 2: Show the top N features. Part 3: Show evidence of a feature (by value count over different class labels) Following dataset based assumtions have been made, We assume x_train and y_train contains the a list of sentences and labels repectively. We assume a pandas dataframe of name train_df is present which contains x_train and y_train as columns with name title and label respectively. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # import import random import pandas as pd from sklearn.ensemble import ExtraTreesClassifier from sklearn.feature_extraction.text import CountVectorizer # PART 1: Train the model # ----------------------- # variables max_features = 10000 # get features vectorizer = CountVectorizer ( max_features = max_features ) features = vectorizer . fit_transform ( x_train ) # model model = ExtraTreesClassifier ( random_state = 1 ) model . fit ( features , y_train ) # PART 2: View top features # ----------------------- top_n = 10 # no of top features to extract feature_imp_indices = model . feature_importances_ . argsort ()[ - top_n :][:: - 1 ] feature_importance = pd . DataFrame ({ 'score' : model . feature_importances_ [ feature_imp_indices ], 'feature' : np . array ( vectorizer . get_feature_names ())[ feature_imp_indices ], 'indices' : feature_imp_indices }) feature_importance # a pandas dataframe of top_n features # PART 3: View individual feature's evidence # ----------------------- index = 2282 # the feature's index # the label's distribution if this word is present in sentence x_train . iloc [ np . where ( features [:, index ] . todense () >= 1 )[ 0 ]][ 'label' ] . value_counts ()","title":"Feature importance"},{"location":"machine_learning/ML_snippets/#cross-validation","text":"Cross validation is a technique in which at each iteration you create different split of train and dev data. At each such iteration, we train he model on the train split and validate on the remaining split. This way, event with small training data, we can perform multiple fold of validation. If you repeat this operation (for \\(N\\) iterations) over the complete data such that (1) each data point belonged to the dev split at most once, (2) each data point belonged to train split \\(N-1\\) times - its cross-validation. I have used Stratified K-Folds cross-validator, you can use any function from the complete list mentioned here - Sklearn Model selection 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # import ======= from sklearn.model_selection import StratifiedKFold # code ============= # split the dataset into K fold test def split_dataset ( dataset , return_fold = 0 , n_splits = 3 , shuffle = True , random_state = 1 ): \"\"\" dataset: pandas dataframe return_fold: the fold out of `n_split` fold, which is to be returned n_splits: # cross fold \"\"\" # defined the KFOld function skf = StratifiedKFold ( n_splits = n_splits , shuffle = shuffle , random_state = random_state ) # defined the dataset X = dataset y = dataset [ 'class' ] # label/class for i , ( train_index , test_index ) in enumerate ( skf . split ( X , y )): if return_fold == i : return dataset . loc [ train_index ], dataset . loc [ test_index ] # example call if __name__ == '__main__' : # read the dataset df = pd . read_csv ( \"....\" ) # get one specific fold out of train , test = split_dataset ( dataset = df , return_fold = 0 , n_splits = 3 ) # run for all folds for fold in range ( n_splits ): train , test = split_dataset ( dataset = df , return_fold = fold , n_splits = n_splits ) # <perform actions here...>","title":"Cross validation"},{"location":"machine_learning/ML_snippets/#hyper-parameter-tuning","text":"Below is an example of hyperparameter tuning for SVR regression algorithm. There we specify the search space i.e. the list of algorithm parameters to try, and for each parameter combination perform a 5 fold CV test. Refer for more details - Sklearn Hyperparameter tuning and Sklearn SVR Algorithm 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 # import ======= from sklearn.model_selection import GridSearchCV from sklearn.metrics import make_scorer from sklearn.metrics import mean_squared_error # DATA LOAD ============ train_data = ... # load the features and target on which to train # SEARCH SPACE ============ search_space = [{ 'kernel' : [ 'poly' , 'rbf' , 'sigmoid' ], 'C' : [ 1 , 10 , 100 ], 'epsilon' : [ 10 , 1 , 0.1 , 0.2 , 0.01 ]}] # TUNING ============ scorer = make_scorer ( mean_squared_error , greater_is_better = False ) svr_gs = GridSearchCV ( SVR (), search_space , cv = 5 , scoring = scorer , verbose = 10 , n_jobs = None ) svr_gs . fit ( train_data [ 'features' ], train_data [ 'target' ]) # PRINT RESULT ============ parameter_result = [] print ( \"Grid scores on training set:\" ) means = svr_gs . cv_results_ [ 'mean_test_score' ] stds = svr_gs . cv_results_ [ 'std_test_score' ] for mean , std , params in zip ( means , stds , svr_gs . cv_results_ [ 'params' ]): print ( \" %0.3f (+/- %0.03f ) for %r \" % ( mean , std * 2 , params )) parameter_result . append ({ 'mean' : abs ( mean ), 'std' : std , ** params }) # SELECT BEST PARAMETERS ============ # select the settings with smallest loss parameter_result = pd . DataFrame ( parameter_result ) parameter_result = parameter_result . sort_values ( by = [ 'mean' ]) best_settings = parameter_result . head ( 1 ) . to_dict ( orient = 'records' )[ 0 ] # FIT WITH BEST PARAMETERS ============ SVRModel = SVR ( C = best_settings [ 'C' ], epsilon = best_settings [ 'epsilon' ], kernel = best_settings [ 'kernel' ]) SVRModel . fit ( train_data [ 'features' ], train_data [ 'target' ])","title":"Hyper-parameter tuning"},{"location":"machine_learning/ML_snippets/#callbacks","text":"Callbacks are the hooks that you can attach to your deep learning training or validation process. It can be used to affect the training process from simple logging metric to even terminating the training in case special conditions are met. Below is an example of EarlyStopping and ModelCheckpoint callbacks. Keras 1 2 3 4 5 # fit the model history = model . fit ( train_data_gen , # training data generator # .... # put usual code here callbacks = [ checkpoint , earlystopping ] )","title":"Callbacks"},{"location":"machine_learning/ML_snippets/#mean-pooling","text":"References this stackoverflow answer . Keras 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # import import numpy as np import keras # create sample data A = np . array ([[ 1 , 2 , 3 ],[ 4 , 5 , 6 ],[ 0 , 0 , 0 ],[ 0 , 0 , 0 ],[ 0 , 0 , 0 ]]) B = np . array ([[ 1 , 3 , 0 ],[ 4 , 0 , 0 ],[ 0 , 0 , 1 ],[ 0 , 0 , 0 ],[ 0 , 0 , 0 ]]) C = np . array ([ A , B ]) . astype ( \"float32\" ) # expected answer (for temporal mean) np . mean ( C , axis = 1 ) \"\"\" The output is array([[1. , 1.4, 1.8], [1. , 0.6, 0.2]], dtype=float32) Now using AveragePooling1D, \"\"\" model = keras . models . Sequential ( tf . keras . layers . AveragePooling1D ( pool_size = 5 ) ) model . predict ( C ) \"\"\" The output is, array([[[1. , 1.4, 1.8]], [[1. , 0.6, 0.2]]], dtype=float32) \"\"\" Some points to consider, The pool_size should be equal to the step/timesteps size of the recurrent layer. The shape of the output is ( batch_size , downsampled_steps , features ), which contains one additional downsampled_steps dimension. This will be always 1 if you set the pool_size equal to timestep size in recurrent layer.","title":"Mean pooling"},{"location":"machine_learning/ML_snippets/#dataset-and-dataloader","text":"Dataset can be downloaded from Kaggle . PyTorch 1 2 3 4 5 6 # init the train and test dataset train_dataset = IMDBDataset ( X_train , y_train ) test_dataset = IMDBDataset ( X_test , y_test ) # create the dataloader train_dataloader = DataLoader ( train_dataset , batch_size = 64 , shuffle = True ) test_dataloader = DataLoader ( test_dataset , batch_size = 64 , shuffle = True )","title":"Dataset and Dataloader"},{"location":"machine_learning/ML_snippets/#freeze-layers","text":"Example on how to freeze certain layers while training PyTorch lightning 1 2 3 4 5 6 7 8 9 10 11 12 # Before defining the optimizer, we need to freeze the layers # In pytorch lightning, as optimizer is defined in configure_optimizers, we freeze layers there. def configure_optimizers ( self ): # iterate through the layers and freeze the one with certain name (here all BERT models) # note: the name of layer depends on the varibale name for name , param in self . named_parameters (): if 'BERTModel' in name : param . requires_grad = False # only pass the non-frozen paramters to optimizer optimizer = torch . optim . Adam ( filter ( lambda p : p . requires_grad , self . parameters ()), lr = 1e-3 ) # return optimizer return optimizer","title":"Freeze Layers"},{"location":"machine_learning/ML_snippets/#lora-with-selective-token-training","text":"It is possible to apply LoRA (Low-Rank Adaptation) on the embedding layer while training only specific tokens (such as newly added tokens) and freezing other tokens (older ones). The Hugging Face PEFT (Parameter-Efficient Fine-Tuning) library supports this kind of selective fine-tuning via the trainable_token_indices parameter in the LoraConfig . This allows you to: Freeze the majority of the embedding tokens (old tokens). Unfreeze and fine-tune only a subset of tokens (e.g., newly added tokens) by specifying their token IDs. Apply LoRA adapters on other target modules as usual. This approach saves memory and preserves learned token contexts, as only the embeddings corresponding to the new tokens are trainable while the others remain frozen. The token weights are saved as part of the adapter's state dict, enabling selective fine-tuning without large overhead. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from transformers import AutoTokenizer , AutoModelForCausalLM from peft import get_peft_model , LoraConfig # Load model and tokenizer base_model = AutoModelForCausalLM . from_pretrained ( \"mistralai/Mistral-7B-v0.1\" ) tokenizer = AutoTokenizer . from_pretrained ( \"mistralai/Mistral-7B-v0.1\" ) # Add new special tokens special_tokens = [ '<|start_think|>' , '<|stop_think|>' ] tokenizer . add_special_tokens ({ 'additional_special_tokens' : special_tokens }) # Resize model embedding matrix base_model . resize_token_embeddings ( len ( tokenizer )) # Setup LoRA config with trainable tokens and LoRA for other modules lora_config = LoraConfig ( target_modules = 'all-linear' , trainable_token_indices = { 'embed_tokens' : tokenizer . convert_tokens_to_ids ( special_tokens ) }, ) # Apply LoRA peft_model = get_peft_model ( base_model , lora_config ) # Proceed with training Note References: PEFT GitHub Issues , PEFT Documentation","title":"LoRA with Selective Token Training"},{"location":"machine_learning/ML_snippets/#get-peft-model-sizes","text":"Utility function to calculate the total parameters, adapter parameters, and base parameters of a PEFT model, along with their memory sizes in MB. This is useful for understanding the memory footprint and parameter efficiency of your PEFT/LoRA models. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 def get_peft_model_sizes ( model ): total_params = sum ( p . numel () for p in model . parameters ()) total_size_mb = total_params * 4 / ( 1024 ** 2 ) # float32 size adapter_params = 0 adapter_param_names = [] for name , param in model . named_parameters (): if 'adapter' in name . lower () and param . requires_grad : adapter_params += param . numel () adapter_param_names . append ( name ) adapter_size_mb = adapter_params * 4 / ( 1024 ** 2 ) base_params = total_params - adapter_params base_size_mb = base_params * 4 / ( 1024 ** 2 ) return { 'total_params' : total_params , 'total_size_mb' : total_size_mb , 'adapter_params' : adapter_params , 'adapter_size_mb' : adapter_size_mb , 'base_params' : base_params , 'base_size_mb' : base_size_mb , 'adapter_param_names' : adapter_param_names } # Usage example model_sizes = get_peft_model_sizes ( model ) print ( model_sizes ) Example output: { 'total_params' : 284600576 , 'total_size_mb' : 1085.6650390625 , 'adapter_params' : 183537280 , 'adapter_size_mb' : 700.13916015625 , 'base_params' : 101063296 , 'base_size_mb' : 385.52587890625 , 'adapter_param_names' : [ 'base_model.model.model.embed_tokens.token_adapter.base_layer.weight' , 'base_model.model.model.embed_tokens.token_adapter.trainable_tokens_delta.default' ] }","title":"Get PEFT Model Sizes"},{"location":"machine_learning/ML_snippets/#check-trainable-parameters","text":"You can use the following code to check the trainable and frozen parameters in a model. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 trainable_params = 0 frozen_params = 0 for name , param in model . named_parameters (): if param . requires_grad : trainable_params += param . numel () print ( f \"Trainable: { name } | shape: { param . shape } \" ) else : frozen_params += param . numel () print ( f \"Frozen: { name } | shape: { param . shape } \" ) total_params = trainable_params + frozen_params print ( \"Total trainable parameters:\" , trainable_params ) print ( \"Total frozen parameters:\" , frozen_params ) print ( \"Total parameters:\" , total_params ) print ( \"Ratio of trained params to total params:\" , trainable_params / total_params )","title":"Check Trainable Parameters"},{"location":"machine_learning/ML_snippets/#check-for-gpu-availability","text":"We need GPUs for deep learning, and before we start training or inference it's a good idea to check if GPU is available on the system or not. The most basic way to check for GPUs (if it's a NVIDIA one) is to run nvidia-smi command. It will return a detailed output with driver's version, cuda version and the processes using GPU. Refer this for more details on individual components. +-----------------------------------------------------------------------------+ | NVIDIA-SMI 435 .21 Driver Version: 435 .21 CUDA Version: 10 .1 | | -------------------------------+----------------------+----------------------+ | GPU Name Persistence-M | Bus-Id Disp.A | Volatile Uncorr. ECC | | Fan Temp Perf Pwr:Usage/Cap | Memory-Usage | GPU-Util Compute M. | | =============================== + ====================== + ====================== | | 0 GeForce MX110 Off | 00000000 :01:00.0 Off | N/A | | N/A 43C P0 N/A / N/A | 164MiB / 2004MiB | 0 % Default | +-------------------------------+----------------------+----------------------+ +-----------------------------------------------------------------------------+ | Processes: GPU Memory | | GPU PID Type Process name Usage | | ============================================================================= | | 0 6348 G /usr/lib/xorg 53MiB | | 0 13360 G ...BBBBBaxsxsuxbssxsxs --shared-files 28MiB | +-----------------------------------------------------------------------------+ You can even use deep learning frameworks like Pytorch to check for the GPU availability. In fact, this is where you will most probably use them. 1 2 3 4 5 6 7 8 9 10 11 12 13 # import import torch # checks torch . cuda . is_available () ## Output: True torch . cuda . device_count () ## Output: 1 torch . cuda . current_device () ## Output: 0 torch . cuda . device ( 0 ) ## Output: <torch.cuda.device at 0x7efce0b03be0> torch . cuda . get_device_name ( 0 ) ## Output: 'GeForce MX110'","title":"Check for GPU availability"},{"location":"machine_learning/ML_snippets/#monitor-gpu-usage","text":"If you want to continuously monitor the GPU usage, you can use watch -n 2 nvidia-smi --id=0 command. This will refresh the nvidia-smi output every 2 second.","title":"Monitor GPU usage"},{"location":"machine_learning/ML_snippets/#huggingface-tokenizer","text":"Tokenizer is a pre-processing step that converts the text into a sequence of tokens. HuggingFace tokenizer is a wrapper around the tokenizers library , that contains multiple base algorithms for fast tokenization. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # import from transformers import AutoTokenizer # load a tokenizer (use the model of your choice) tokenizer = AutoTokenizer . from_pretrained ( 'sentence-transformers/all-MiniLM-L6-v2' ) # create an dummy text text = \"Hello my Name is Mohit\" # this will tokenize the text and return a list of tokens tokenizer . tokenize ( text ) # Output: ['hello', 'my', 'name', 'is', 'mo', '##hit'] # this will tokenize the text and return a list of token ids tokenizer . encode ( text ) # Output: [101, 7592, 2026, 2171, 2003, 9587, 16584, 102] # this will return the decoded text (from token ids) tokenizer . decode ( tokenizer . encode ( text )) # Output: [CLS] hello my name is mohit [SEP] # get the token and id details in key value pair vocabulary = tokenizer . get_vocab () # length of vocab here is 30522 # vocabulary['hello'] returns 7592","title":"HuggingFace Tokenizer"},{"location":"machine_learning/ML_snippets/#explore-model","text":"You can use the summary method to check the model's architecture. This will show the layers, their output shape and the number of parameters in each layer. Keras PyTorch 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # import from keras.models import Sequential from keras.layers import Dense , Conv2D , MaxPooling2D , Flatten # create a model model = Sequential () model . add ( Conv2D ( 32 , ( 3 , 3 ), activation = 'relu' , input_shape = ( 28 , 28 , 1 ))) model . add ( MaxPooling2D (( 2 , 2 ))) model . add ( Conv2D ( 64 , ( 3 , 3 ), activation = 'relu' )) model . add ( MaxPooling2D (( 2 , 2 ))) model . add ( Conv2D ( 64 , ( 3 , 3 ), activation = 'relu' )) model . add ( Flatten ()) model . add ( Dense ( 64 , activation = 'relu' )) model . add ( Dense ( 10 , activation = 'softmax)) # print the model summary model . summary () 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # import import torch import torch.nn as nn # create a model class Net ( nn . Module ): def __init__ ( self ): super ( Net , self ) . __init__ () self . conv1 = nn . Conv2d ( 1 , 32 , 3 , 1 ) self . conv2 = nn . Conv2d ( 32 , 64 , 3 , 1 ) self . conv3 = nn . Conv2d ( 64 , 64 , 3 , 1 ) self . fc1 = nn . Linear ( 1024 , 64 ) self . fc2 = nn . Linear ( 64 , 10 ) def forward ( self , x ): x = F . relu ( self . conv1 ( x )) x = F . max_pool2d ( x , 2 , 2 ) x = F . relu ( self . conv2 ( x )) x = F . max_pool2d ( x , 2 , 2 ) x = F . relu ( self . conv3 ( x )) x = x . view ( - 1 , 1024 ) x = F . relu ( self . fc1 ( x )) x = self . fc2 ( x ) return F . log_softmax ( x , dim = 1 ) # create an instance of the model model = Net () # print the model summary print ( model ) To check the named parameters of the model and their dtypes, you can use the following code, PyTorch 1 2 3 4 print ( f \"Total number of names params: { len ( list ( model . named_parameters ())) } \" ) print ( \"They are - \" ) for name , param in model . named_parameters (): print ( name , param . dtype )","title":"Explore Model"},{"location":"machine_learning/classification/","text":"Note This page is still not complete and new sections might get added later. That said, the existing content is ready to be consumed. \ud83c\udf54 Introduction Classification is a fundamental task in supervised machine learning , where the goal is to assign predefined labels or categories to input data points based on their features. Unlike clustering , which deals with unsupervised learning and aims to discover inherent patterns or groupings in data, classification relies on a labeled dataset to learn a model that can make predictions on new, unseen data. The primary objective of classification is to create a decision boundary or model that can accurately differentiate between different classes or categories within the data. Some use cases of classification could be bank loan defaulter prediction, spam email detection, image recognition, medical diagnosis, sentiment analysis, etc. Metrics Classification metrics are used to evaluate the performance of a classification model by comparing its predictions to the actual ground truth labels. Here are some common classification metrics, An extensive view of Confusion Matrix and different metrics. Source: Wikipedia Accuracy : Accuracy is the most basic classification metric, measuring the ratio of correctly predicted instances to the total number of instances. It provides an overall measure of the model's correctness. However, it may not be suitable for imbalanced datasets, where one class significantly outnumbers the others. \\[{\\displaystyle \\mathrm {Accuracy} ={\\frac {TP+TN}{TP+TN+FP+FN}}}\\] Precision : Precision is the ratio of true positive predictions to the total number of positive predictions made by the model. High precision indicates that when the model predicts a positive class, it is likely to be correct. \\[{\\displaystyle \\mathrm {Precision} ={\\frac {TP}{TP+FP}}}\\] Recall (Sensitivity or True Positive Rate) : Recall is the ratio of true positive predictions to the total number of actual positive instances in the dataset. It measures the model's ability to capture all positive instances. High recall means that the model can find most of the positive cases. \\[{\\displaystyle \\mathrm {Recall} ={\\frac {TP}{TP+FN}}}\\] F1-Score : The F1-Score is the harmonic mean of precision and recall. It balances both metrics and is particularly useful when you need to consider the trade-off between precision and recall. It's a good overall measure of a model's performance. Note Please be aware of average params in the Sklearn implementation . Set the param to macro in case of imbalanced dataset, as it will compute the score for each class and then perform unweighted average i.e. giving each class equal importance, no matter their frequency. Setting it to weighted is similar to macro , but now the average will be weighted. Setting to micro will lead to computing the numbers for complete data without considering any class. \\[{\\displaystyle \\mathrm {F1}_{score} ={\\frac {2}{\\frac {1}{\\mathrm {Precision}}+\\frac {1}{\\mathrm {Recall}}}}}\\] Specificity (True Negative Rate) : Specificity measures the model's ability to correctly identify negative instances. It is the ratio of true negative predictions to the total number of actual negative instances. It is particularly relevant when false negatives are costly. \\[{\\displaystyle \\mathrm {Specificity} ={\\frac {TN}{TN+FP}}}\\] ROC Curve and AUC : The Receiver Operating Characteristic (ROC) curve is a graphical representation of the model's performance across different thresholds. The Area Under the ROC Curve (AUC) quantifies the overall performance of the model, with a higher AUC indicating better discrimination between classes. Confusion Matrix : A confusion matrix is a table that summarizes the model's predictions compared to the actual labels, breaking down true positives, true negatives, false positives, and false negatives. It provides detailed insights into the model's performance. The choice of which metric to use depends on the specific problem, the nature of the dataset, and the business or application requirements. It's essential to consider the context and goals when selecting the appropriate classification metrics for evaluating a machine learning model. Classification Algorithms While there are many classification algorithms, here are some of the most common and widely used ones, Logistic Regression Logistic Regression is a widely used classification model that is particularly effective for binary classification problems. It works by modeling the relationship between the input features and the probability of belonging to a particular class. It does this by fitting a logistic curve to the data, which allows it to output probabilities that an instance belongs to a specific class. Logistic Regression is a linear model , which means it assumes a linear relationship between the input features and the log-odds of the class probabilities. It's simple, interpretable, and computationally efficient, making it a good choice for problems with a large number of features. The formula for Logistic Regression is shown below, \\[{\\displaystyle \\mathrm {LogisticRegression_loss}(i) = -(y_i \\log(\\hat{y_i})+(1-y_i) \\log(1-\\hat{y_i}))}\\] where, \\(y_i\\) is the actual class and \\(\\hat{y_i}\\) is the predicted class Decision Tree A Decision Tree is a versatile and interpretable machine learning model used for both classification and regression tasks. It is a tree-like structure where each internal node represents a feature, each branch represents a decision rule based on that feature, and each leaf node represents the predicted outcome or value. Decision Trees are particularly well-suited for tasks where the decision-making process can be represented as a series of logical if-then-else conditions. One of the significant advantages of Decision Trees is their transparency and interpretability. The model's decision rules can be easily visualized, understood, and explained to non-technical stakeholders, making it a valuable tool in domains where interpretability is crucial, such as healthcare and finance. However, Decision Trees can be prone to overfitting, especially when they are deep and the dataset is small. To mitigate this issue, techniques like pruning, limiting tree depth, and using ensemble methods like Random Forests or Gradient Boosting Trees are often employed. Decision Trees also provide feature importance scores, helping analysts identify the most critical factors driving the model's predictions, which can inform feature selection and data exploration efforts in a broader context.","title":"Classification"},{"location":"machine_learning/classification/#introduction","text":"Classification is a fundamental task in supervised machine learning , where the goal is to assign predefined labels or categories to input data points based on their features. Unlike clustering , which deals with unsupervised learning and aims to discover inherent patterns or groupings in data, classification relies on a labeled dataset to learn a model that can make predictions on new, unseen data. The primary objective of classification is to create a decision boundary or model that can accurately differentiate between different classes or categories within the data. Some use cases of classification could be bank loan defaulter prediction, spam email detection, image recognition, medical diagnosis, sentiment analysis, etc.","title":"Introduction"},{"location":"machine_learning/classification/#metrics","text":"Classification metrics are used to evaluate the performance of a classification model by comparing its predictions to the actual ground truth labels. Here are some common classification metrics, An extensive view of Confusion Matrix and different metrics. Source: Wikipedia Accuracy : Accuracy is the most basic classification metric, measuring the ratio of correctly predicted instances to the total number of instances. It provides an overall measure of the model's correctness. However, it may not be suitable for imbalanced datasets, where one class significantly outnumbers the others. \\[{\\displaystyle \\mathrm {Accuracy} ={\\frac {TP+TN}{TP+TN+FP+FN}}}\\] Precision : Precision is the ratio of true positive predictions to the total number of positive predictions made by the model. High precision indicates that when the model predicts a positive class, it is likely to be correct. \\[{\\displaystyle \\mathrm {Precision} ={\\frac {TP}{TP+FP}}}\\] Recall (Sensitivity or True Positive Rate) : Recall is the ratio of true positive predictions to the total number of actual positive instances in the dataset. It measures the model's ability to capture all positive instances. High recall means that the model can find most of the positive cases. \\[{\\displaystyle \\mathrm {Recall} ={\\frac {TP}{TP+FN}}}\\] F1-Score : The F1-Score is the harmonic mean of precision and recall. It balances both metrics and is particularly useful when you need to consider the trade-off between precision and recall. It's a good overall measure of a model's performance. Note Please be aware of average params in the Sklearn implementation . Set the param to macro in case of imbalanced dataset, as it will compute the score for each class and then perform unweighted average i.e. giving each class equal importance, no matter their frequency. Setting it to weighted is similar to macro , but now the average will be weighted. Setting to micro will lead to computing the numbers for complete data without considering any class. \\[{\\displaystyle \\mathrm {F1}_{score} ={\\frac {2}{\\frac {1}{\\mathrm {Precision}}+\\frac {1}{\\mathrm {Recall}}}}}\\] Specificity (True Negative Rate) : Specificity measures the model's ability to correctly identify negative instances. It is the ratio of true negative predictions to the total number of actual negative instances. It is particularly relevant when false negatives are costly. \\[{\\displaystyle \\mathrm {Specificity} ={\\frac {TN}{TN+FP}}}\\] ROC Curve and AUC : The Receiver Operating Characteristic (ROC) curve is a graphical representation of the model's performance across different thresholds. The Area Under the ROC Curve (AUC) quantifies the overall performance of the model, with a higher AUC indicating better discrimination between classes. Confusion Matrix : A confusion matrix is a table that summarizes the model's predictions compared to the actual labels, breaking down true positives, true negatives, false positives, and false negatives. It provides detailed insights into the model's performance. The choice of which metric to use depends on the specific problem, the nature of the dataset, and the business or application requirements. It's essential to consider the context and goals when selecting the appropriate classification metrics for evaluating a machine learning model.","title":"Metrics"},{"location":"machine_learning/classification/#classification-algorithms","text":"While there are many classification algorithms, here are some of the most common and widely used ones,","title":"Classification Algorithms"},{"location":"machine_learning/classification/#logistic-regression","text":"Logistic Regression is a widely used classification model that is particularly effective for binary classification problems. It works by modeling the relationship between the input features and the probability of belonging to a particular class. It does this by fitting a logistic curve to the data, which allows it to output probabilities that an instance belongs to a specific class. Logistic Regression is a linear model , which means it assumes a linear relationship between the input features and the log-odds of the class probabilities. It's simple, interpretable, and computationally efficient, making it a good choice for problems with a large number of features. The formula for Logistic Regression is shown below, \\[{\\displaystyle \\mathrm {LogisticRegression_loss}(i) = -(y_i \\log(\\hat{y_i})+(1-y_i) \\log(1-\\hat{y_i}))}\\] where, \\(y_i\\) is the actual class and \\(\\hat{y_i}\\) is the predicted class","title":"Logistic Regression"},{"location":"machine_learning/classification/#decision-tree","text":"A Decision Tree is a versatile and interpretable machine learning model used for both classification and regression tasks. It is a tree-like structure where each internal node represents a feature, each branch represents a decision rule based on that feature, and each leaf node represents the predicted outcome or value. Decision Trees are particularly well-suited for tasks where the decision-making process can be represented as a series of logical if-then-else conditions. One of the significant advantages of Decision Trees is their transparency and interpretability. The model's decision rules can be easily visualized, understood, and explained to non-technical stakeholders, making it a valuable tool in domains where interpretability is crucial, such as healthcare and finance. However, Decision Trees can be prone to overfitting, especially when they are deep and the dataset is small. To mitigate this issue, techniques like pruning, limiting tree depth, and using ensemble methods like Random Forests or Gradient Boosting Trees are often employed. Decision Trees also provide feature importance scores, helping analysts identify the most critical factors driving the model's predictions, which can inform feature selection and data exploration efforts in a broader context.","title":"Decision Tree"},{"location":"machine_learning/clustering/","text":"Note This page is still not complete and new sections might get added later. That said, the existing content is ready to be consumed. \ud83c\udf54 Introduction Clustering is an unsupervised task of grouping a set of items based on item\u2019s features where the final grouping should minimize certain cost function. While finding optimum grouping is very hard, there are several algorithms that can help us find sub-optimal solutions. Also note that as the data is not labeled, the grouping could be completely different from the user\u2019s expectation. Each clustering algorithm has its own internal similarity function and grouping strategy by which the clusters are formed. Clustering algorithms can be categorised based on different perspectives. Below are some examples (not a complete list) , Considering time of application, we can have online (streaming data) vs offline (all data present) clustering algorithms. Considering input data type, we have algorithms that consider item's features while others that considers item-item similarity matrix. Considering input parameter, there are algorithms that require no of clusters as input while others do not. Metrics Before starting with Clustering algorithms, let's understand the metrics that can be used to compare the clustering performance. Silhouette Score Silhouette score considers the intra-cluster \\(a(i)\\) and inter-cluster \\(b(i)\\) distances to generate a performance metric for the clustering of a dataset. The score can range between -1 (bad clustering) and 1 (good clustering) , with higher number denoting better clustering. We can choose different distance functions (euclidean, manhattan, cosine, etc) based on the data. The formulation wrt each data point is shown below, where we can average the value to get dataset level scores. \\[ {\\displaystyle a(i)={\\frac {1}{|C_{I}|-1}}\\sum _{j\\in C_{I},i\\neq j}d(i,j)} \\] \\[ {\\displaystyle b(i)=\\min _{J\\neq I}{\\frac {1}{|C_{J}|}}\\sum _{j\\in C_{J}}d(i,j)} \\] \\[ {\\displaystyle s(i)={\\frac {b(i)-a(i)}{\\max\\{a(i),b(i)\\}}}} \\] In \\(a(i)\\) formulation, we compare each data point against all the other points in the same cluster. We use \\(\\frac {1}{|C_{I}|-1}\\) as we ignore the \\(d(i, i)\\) computation. In \\(b(i)\\) formulation, we compare one data point against all data points from other clusters one at a time, and pick the value for the cluster with members having minimum average distance from the data point (think of it like the next best cluster for the data point) . Finally, the silhouette score for that data point is computed in \\(s(i)\\) . It is further simplified below, \\[ s(i) = \\begin{cases} 1-a(i)/b(i), & \\mbox{if } a(i) < b(i) \\\\ 0, & \\mbox{if } a(i) = b(i) \\\\ b(i)/a(i)-1, & \\mbox{if } a(i) > b(i) \\\\ \\end{cases} \\] Sklearn package provides a function to compute silhouette score. The inputs are data point features, the cluster labels and the distance metric. Example call is shown below, 1 2 3 4 5 # import from sklearn.metrics import silhouette_score # compute the score score = silhouette_score ( X , labels , metric = 'cosine' ) Homogeneity, Completeness and V measure For a given set of datapoints, the original labels are called \"Class\" and the output of clustering algorithms is called \"Clusters\". To measure performance of the algorithm, we can check how well the cluster and class align. This alignment can be captured by creating a contingency table that contains distribution of data points falling under different combinations of class and clusters. For example, consider 6 datapoints for which we have the class label [1, 1, 1, 2, 2, 2] and cluster label [1, 1, 2, 2, 3, 3] . The contingency table will contains \\(a_{ck}\\) elements where \\(c\\) denotes the class and \\(k\\) the clusters. It will look as follows, class/cluster 1 2 3 1 2 1 0 2 0 1 2 3 0 0 0 Note As clear from the table above, the alignment could be directional in nature i.e. the metrics using the contingency table will generate different score if we compare (class, cluster) and (cluster, class) . With this context, let's understand the metrics in detail, [5] Homogeneity: it describes the \"purity\" of the cluster i.e. it measures whether or not the same class is assigned to all points within a cluster. The formulation is as follows, \\[ h = 1 - \\frac {H(C|K)}{H(C)}, where \\] \\[ H (C | K) = - \\sum_{k=1}^{|K|} \\sum_{c=1}^{|C|} \\frac{a_{ck}}{N} \\log_{}{\\frac{a_{ck}}{\\sum_{c=1}^{|C|} a_{ck}}} \\] \\[ H (C) = - \\sum_{c=1}^{|C|} \\frac{\\sum_{k=1}^{|K|} a_{ck}}{n} \\log_{}{\\frac{\\sum_{k=1}^{|K|} a_{ck}}{n}} \\] Completeness: it describes the \"purity\" of the class i.e. it measures if all points belonging to a given class are assigned to the same cluster. The formulation is as follows, \\[ c = 1 - \\frac {H(K|C)}{H(K)}, where \\] \\[ H (K | C) = - \\sum_{c=1}^{|C|} \\sum_{k=1}^{|K|} \\frac{a_{ck}}{N} \\log_{}{\\frac{a_{ck}}{\\sum_{k=1}^{|K|} a_{ck}}} \\] \\[ H (K) = - \\sum_{k=1}^{|K|} \\frac{\\sum_{c=1}^{|C|} a_{ck}}{n} \\log_{}{\\frac{\\sum_{c=1}^{|C|} a_{ck}}{n}} \\] V measure: it is a combination of the above scores and is used to measure the overall performance of a clustering algorithm. To be exact, it is the harmoic mean of the Homogeneity and Completeness scores. The formulation is given below, where beta is the ratio of weight attributed to homogeneity vs completeness. If beta is greater than 1, completeness is weighted more strongly in the calculation. If beta is less than 1, homogeneity is weighted more strongly. By default, beta is 1. \\[ v = \\frac{(1 + beta) * homogeneity * completeness}{(beta * homogeneity + completeness)} \\] Hint Sklearn provides individual and combined implementations for these metrics. Refer sklearn.metrics.homogeneity_completeness_v_measure Clustering Algorithms K-Means K-means is the swiss army knife of the clustering algorithms, the forever baseline - the first clustering algorithm anyone tries . It can be easily understood by considering the steps mentioned below. The step (a) is a one time activity done during the initialization part, while steps (b) and (c) are repeated until the convergence i.e. there is no more change in cluster membership even if we continue the process or there is no more noticable centroid movement. Centroid Assignment: Assign K centroids. There are three points to remember here, How to decide the value of K? --> here it is an input parameter. In practice we can analyze the cluster results with different k (2 to N) and pick the one with best metric score like silhouette score. Are centroids choosen from data points? --> during initialization they may be selected from data points but over iterations they become their own special points that are part of the same feature space How are the centroids choosen? --> the assignment strategy can be random (pick any random K data points) , or follow 'furthest' heuristic ( \\(i^{th}\\) centroid is choosen such that its minimum distance to the preceding centroids is largest) or follow k-mean++ heuristic (selects a point with probability proportional to the square of its distance to the nearest preceding centroid) . Note Random initialization is not preferred, as it is possible to get all centroid assigned to data points from only one true cluster. The 'furthest' heuristic is also not preferred as it select data points at the edges for centroid. K-means++ heuristic is more suitable as the centroid selection is more natural. Cluster Assignment: assign all data points to one of the centroids (forming a cluster) based on the closeness of the points to the centroid. The closeness is computed by a similarity function that could be equilidean distance. Centroid Adjustment: adjust the centroids such that it minimises the intra-cluster distance among the cluster member. This is called inertia and its formulation is \\(\\sum_{i=0}^n \\text{min}(||x_i-\\mu_{j}||^2)\\) , where \\(\\mu_{j}\\) is the mean of the respective cluster. The adjustment is done by moving the centroids to the mean position of the cluster members. Remember, K-means algorithm is guaranteed to converge but the final result may vary based on the centroid initialisation. This is why it is suggested to try multiple runs with different initialization and pick the one with best clustering or use smarter initialization technique like k-means++. Refer ML Interview Questions and [2] for more details. Many clustering algorithms have improved k-means over time, they are: K-Medians: It is a variation of k-means clustering where instead of calculating the mean for each cluster to determine its centroid, we calculates the median. As it uses Manhattan distance (L1-norm distance) , the algorithm becomes more reliable for discrete or binary data sets. K-Medoids: In contrast to the k-means algorithm, k-medoids chooses actual data points as centers instead. Furthermore, k-medoids can be used with arbitrary dissimilarity measures, whereas k-means generally requires Euclidean distance. Because k-medoids minimizes a sum of pairwise dissimilarities instead of a sum of squared Euclidean distances, it is more robust to noise and outliers than k-means. Refer [3] for an intuitive solved example. K-means++: It is the standard K-means algorithm but with a smarter initialization of the centroids. We start with choosing one center randomly from the data points. Then for each data point \\(x\\) not chosen yet, we find the distance \\(D(x)\\) between \\(x\\) and the nearest center that has already been chosen. The new center is choosen again at random but this time using a weighted probability distribution where a point \\(x\\) is chosen with probability proportional to \\(D(x)^2\\) . We repeat these steps until k centers have been chosen. Mini Batch K-means: It is an optimized version of k-means for faster execution with only slighly worse results. Here, at each iteration a set of random data points are selected to form a mini-batch and they are assigned to the nearest centroids. The centroid adjustment happens for each sample by taking streaming average of the sample and all previous samples assigned to that centroid. Mini Batch K-means converges faster than K-means. Hint K-Means works best in datasets with clusters that are roughly equally-sized and shaped roughly regularly. Also the data points should be in euclidean space as the K-means uses euclidean distance measure. It is not recommended for clustering neural network embeddings as they capture semantic meanings which is more suitably captured by cosine similarity. The best that can be done with K-means is to run multiple iterations on embeddings and pick the one with highest cosine silhouette score. Here is the code to perform Kmeans clustering and find the silhouette score [1], 1 2 3 4 5 6 7 8 9 10 11 12 13 # import from sklearn.cluster import KMeans from sklearn.metrics import silhouette_score # load the data X = np . load ( 'data/embeddings.npy' ) # dummy # create the model model = KMeans ( n_clusters = 2 , init = 'k-means++' , max_iter = 100 , n_init = 1 ) # get the label labels = model . fit_predict ( X ) # compute silhouette_score sil_score = silhouette_score ( X , labels , metric = 'cosine' ) Hierarchical Clustering It is a clustering technique that seeks to build a hierarchy of clusters i.e. we start with the dataset divided into N clusters and then some clusters are either merged or split based on their similarity. There are two major strategies to perform hierarchical clustering, Agglomerative: Bottom-up approach where we start with each sample as a separate cluster and then clusters are merged. Divisive: Top-down approach where we start with all samples part of a single cluster and then at each level we recursively split existing clusters. To understand the split or merge process, we need to understand the following, Distance metric: this is the function that gives the distance between two data points. We can choose from a number of functions like euclidean, cosine, manhattan, etc. Linkage criteria: this is a function that define the distance between two clusters based on applying distance function on pairs of data from the two clusters. There are following strategies to choose from, Complete Linkage: Pick the most distant pair of points as the representation of cluster distance. Formulation is : \\(\\max \\,\\{\\,d(a,b):a\\in A,\\,b\\in B\\,\\}.\\) Single Linkage: Pick the least distant pair of points as the representation of cluster distance. Formulation is : \\(\\min \\,\\{\\,d(a,b):a\\in A,\\,b\\in B\\,\\}.\\) Ward: find the pair of clusters that leads to minimum increase in total within-cluster variance after merging. This is only applicable for euclidean distance. [4] Average: Uses the average of distances between all pairs of data points from the two clusters. Formulation is \\({\\displaystyle {\\frac {1}{|A|\\cdot |B|}}\\sum _{a\\in A}\\sum _{b\\in B}d(a,b).}\\) Now it should be easy to understand the overall process. Taking agglomerative as example, to begin with, all samples are separate clusters. At each iteration, we will compute the linkage score between all pairs of clusters and find the pair with the minimum score. We merge that pair of clusters together and go ahead with next iteration. We keep on repeating this process until we have reached a desired number of clusters ( n_clusters ) or the linkage distance threshold ( distance_threshold ) has triggered, above which, clusters will not be merged. Note At a time, we can only use either n_clusters or distance_threshold . Here is a sample code using sklearn package [1], 1 2 3 4 5 6 7 8 9 10 11 12 13 # import from sklearn.cluster import AgglomerativeClustering from sklearn.metrics import silhouette_score # load the data X = np . load ( 'data/embeddings.npy' ) # dummy # create the model model = AgglomerativeClustering ( n_clusters = 2 , affinity = 'cosine' , linkage = 'average' ) # get the label labels = model . fit_predict ( X ) # compute silhouette_score sil_score = silhouette_score ( X , labels , metric = 'cosine' ) References [1] Sklearn - Clustering [2] Visualizing K Means Clustering - Naftali Harris [3] K-Medoids clustering with solved example [4] Wikipedia - Hierarchical clustering | Ward's method [5] V-Measure: A Conditional Entropy-Based External Cluster Evaluation Measure","title":"Clustering"},{"location":"machine_learning/clustering/#introduction","text":"Clustering is an unsupervised task of grouping a set of items based on item\u2019s features where the final grouping should minimize certain cost function. While finding optimum grouping is very hard, there are several algorithms that can help us find sub-optimal solutions. Also note that as the data is not labeled, the grouping could be completely different from the user\u2019s expectation. Each clustering algorithm has its own internal similarity function and grouping strategy by which the clusters are formed. Clustering algorithms can be categorised based on different perspectives. Below are some examples (not a complete list) , Considering time of application, we can have online (streaming data) vs offline (all data present) clustering algorithms. Considering input data type, we have algorithms that consider item's features while others that considers item-item similarity matrix. Considering input parameter, there are algorithms that require no of clusters as input while others do not.","title":"Introduction"},{"location":"machine_learning/clustering/#metrics","text":"Before starting with Clustering algorithms, let's understand the metrics that can be used to compare the clustering performance.","title":"Metrics"},{"location":"machine_learning/clustering/#silhouette-score","text":"Silhouette score considers the intra-cluster \\(a(i)\\) and inter-cluster \\(b(i)\\) distances to generate a performance metric for the clustering of a dataset. The score can range between -1 (bad clustering) and 1 (good clustering) , with higher number denoting better clustering. We can choose different distance functions (euclidean, manhattan, cosine, etc) based on the data. The formulation wrt each data point is shown below, where we can average the value to get dataset level scores. \\[ {\\displaystyle a(i)={\\frac {1}{|C_{I}|-1}}\\sum _{j\\in C_{I},i\\neq j}d(i,j)} \\] \\[ {\\displaystyle b(i)=\\min _{J\\neq I}{\\frac {1}{|C_{J}|}}\\sum _{j\\in C_{J}}d(i,j)} \\] \\[ {\\displaystyle s(i)={\\frac {b(i)-a(i)}{\\max\\{a(i),b(i)\\}}}} \\] In \\(a(i)\\) formulation, we compare each data point against all the other points in the same cluster. We use \\(\\frac {1}{|C_{I}|-1}\\) as we ignore the \\(d(i, i)\\) computation. In \\(b(i)\\) formulation, we compare one data point against all data points from other clusters one at a time, and pick the value for the cluster with members having minimum average distance from the data point (think of it like the next best cluster for the data point) . Finally, the silhouette score for that data point is computed in \\(s(i)\\) . It is further simplified below, \\[ s(i) = \\begin{cases} 1-a(i)/b(i), & \\mbox{if } a(i) < b(i) \\\\ 0, & \\mbox{if } a(i) = b(i) \\\\ b(i)/a(i)-1, & \\mbox{if } a(i) > b(i) \\\\ \\end{cases} \\] Sklearn package provides a function to compute silhouette score. The inputs are data point features, the cluster labels and the distance metric. Example call is shown below, 1 2 3 4 5 # import from sklearn.metrics import silhouette_score # compute the score score = silhouette_score ( X , labels , metric = 'cosine' )","title":"Silhouette Score"},{"location":"machine_learning/clustering/#homogeneity-completeness-and-v-measure","text":"For a given set of datapoints, the original labels are called \"Class\" and the output of clustering algorithms is called \"Clusters\". To measure performance of the algorithm, we can check how well the cluster and class align. This alignment can be captured by creating a contingency table that contains distribution of data points falling under different combinations of class and clusters. For example, consider 6 datapoints for which we have the class label [1, 1, 1, 2, 2, 2] and cluster label [1, 1, 2, 2, 3, 3] . The contingency table will contains \\(a_{ck}\\) elements where \\(c\\) denotes the class and \\(k\\) the clusters. It will look as follows, class/cluster 1 2 3 1 2 1 0 2 0 1 2 3 0 0 0 Note As clear from the table above, the alignment could be directional in nature i.e. the metrics using the contingency table will generate different score if we compare (class, cluster) and (cluster, class) . With this context, let's understand the metrics in detail, [5] Homogeneity: it describes the \"purity\" of the cluster i.e. it measures whether or not the same class is assigned to all points within a cluster. The formulation is as follows, \\[ h = 1 - \\frac {H(C|K)}{H(C)}, where \\] \\[ H (C | K) = - \\sum_{k=1}^{|K|} \\sum_{c=1}^{|C|} \\frac{a_{ck}}{N} \\log_{}{\\frac{a_{ck}}{\\sum_{c=1}^{|C|} a_{ck}}} \\] \\[ H (C) = - \\sum_{c=1}^{|C|} \\frac{\\sum_{k=1}^{|K|} a_{ck}}{n} \\log_{}{\\frac{\\sum_{k=1}^{|K|} a_{ck}}{n}} \\] Completeness: it describes the \"purity\" of the class i.e. it measures if all points belonging to a given class are assigned to the same cluster. The formulation is as follows, \\[ c = 1 - \\frac {H(K|C)}{H(K)}, where \\] \\[ H (K | C) = - \\sum_{c=1}^{|C|} \\sum_{k=1}^{|K|} \\frac{a_{ck}}{N} \\log_{}{\\frac{a_{ck}}{\\sum_{k=1}^{|K|} a_{ck}}} \\] \\[ H (K) = - \\sum_{k=1}^{|K|} \\frac{\\sum_{c=1}^{|C|} a_{ck}}{n} \\log_{}{\\frac{\\sum_{c=1}^{|C|} a_{ck}}{n}} \\] V measure: it is a combination of the above scores and is used to measure the overall performance of a clustering algorithm. To be exact, it is the harmoic mean of the Homogeneity and Completeness scores. The formulation is given below, where beta is the ratio of weight attributed to homogeneity vs completeness. If beta is greater than 1, completeness is weighted more strongly in the calculation. If beta is less than 1, homogeneity is weighted more strongly. By default, beta is 1. \\[ v = \\frac{(1 + beta) * homogeneity * completeness}{(beta * homogeneity + completeness)} \\] Hint Sklearn provides individual and combined implementations for these metrics. Refer sklearn.metrics.homogeneity_completeness_v_measure","title":"Homogeneity, Completeness and V measure"},{"location":"machine_learning/clustering/#clustering-algorithms","text":"","title":"Clustering Algorithms"},{"location":"machine_learning/clustering/#k-means","text":"K-means is the swiss army knife of the clustering algorithms, the forever baseline - the first clustering algorithm anyone tries . It can be easily understood by considering the steps mentioned below. The step (a) is a one time activity done during the initialization part, while steps (b) and (c) are repeated until the convergence i.e. there is no more change in cluster membership even if we continue the process or there is no more noticable centroid movement. Centroid Assignment: Assign K centroids. There are three points to remember here, How to decide the value of K? --> here it is an input parameter. In practice we can analyze the cluster results with different k (2 to N) and pick the one with best metric score like silhouette score. Are centroids choosen from data points? --> during initialization they may be selected from data points but over iterations they become their own special points that are part of the same feature space How are the centroids choosen? --> the assignment strategy can be random (pick any random K data points) , or follow 'furthest' heuristic ( \\(i^{th}\\) centroid is choosen such that its minimum distance to the preceding centroids is largest) or follow k-mean++ heuristic (selects a point with probability proportional to the square of its distance to the nearest preceding centroid) . Note Random initialization is not preferred, as it is possible to get all centroid assigned to data points from only one true cluster. The 'furthest' heuristic is also not preferred as it select data points at the edges for centroid. K-means++ heuristic is more suitable as the centroid selection is more natural. Cluster Assignment: assign all data points to one of the centroids (forming a cluster) based on the closeness of the points to the centroid. The closeness is computed by a similarity function that could be equilidean distance. Centroid Adjustment: adjust the centroids such that it minimises the intra-cluster distance among the cluster member. This is called inertia and its formulation is \\(\\sum_{i=0}^n \\text{min}(||x_i-\\mu_{j}||^2)\\) , where \\(\\mu_{j}\\) is the mean of the respective cluster. The adjustment is done by moving the centroids to the mean position of the cluster members. Remember, K-means algorithm is guaranteed to converge but the final result may vary based on the centroid initialisation. This is why it is suggested to try multiple runs with different initialization and pick the one with best clustering or use smarter initialization technique like k-means++. Refer ML Interview Questions and [2] for more details. Many clustering algorithms have improved k-means over time, they are: K-Medians: It is a variation of k-means clustering where instead of calculating the mean for each cluster to determine its centroid, we calculates the median. As it uses Manhattan distance (L1-norm distance) , the algorithm becomes more reliable for discrete or binary data sets. K-Medoids: In contrast to the k-means algorithm, k-medoids chooses actual data points as centers instead. Furthermore, k-medoids can be used with arbitrary dissimilarity measures, whereas k-means generally requires Euclidean distance. Because k-medoids minimizes a sum of pairwise dissimilarities instead of a sum of squared Euclidean distances, it is more robust to noise and outliers than k-means. Refer [3] for an intuitive solved example. K-means++: It is the standard K-means algorithm but with a smarter initialization of the centroids. We start with choosing one center randomly from the data points. Then for each data point \\(x\\) not chosen yet, we find the distance \\(D(x)\\) between \\(x\\) and the nearest center that has already been chosen. The new center is choosen again at random but this time using a weighted probability distribution where a point \\(x\\) is chosen with probability proportional to \\(D(x)^2\\) . We repeat these steps until k centers have been chosen. Mini Batch K-means: It is an optimized version of k-means for faster execution with only slighly worse results. Here, at each iteration a set of random data points are selected to form a mini-batch and they are assigned to the nearest centroids. The centroid adjustment happens for each sample by taking streaming average of the sample and all previous samples assigned to that centroid. Mini Batch K-means converges faster than K-means. Hint K-Means works best in datasets with clusters that are roughly equally-sized and shaped roughly regularly. Also the data points should be in euclidean space as the K-means uses euclidean distance measure. It is not recommended for clustering neural network embeddings as they capture semantic meanings which is more suitably captured by cosine similarity. The best that can be done with K-means is to run multiple iterations on embeddings and pick the one with highest cosine silhouette score. Here is the code to perform Kmeans clustering and find the silhouette score [1], 1 2 3 4 5 6 7 8 9 10 11 12 13 # import from sklearn.cluster import KMeans from sklearn.metrics import silhouette_score # load the data X = np . load ( 'data/embeddings.npy' ) # dummy # create the model model = KMeans ( n_clusters = 2 , init = 'k-means++' , max_iter = 100 , n_init = 1 ) # get the label labels = model . fit_predict ( X ) # compute silhouette_score sil_score = silhouette_score ( X , labels , metric = 'cosine' )","title":"K-Means"},{"location":"machine_learning/clustering/#hierarchical-clustering","text":"It is a clustering technique that seeks to build a hierarchy of clusters i.e. we start with the dataset divided into N clusters and then some clusters are either merged or split based on their similarity. There are two major strategies to perform hierarchical clustering, Agglomerative: Bottom-up approach where we start with each sample as a separate cluster and then clusters are merged. Divisive: Top-down approach where we start with all samples part of a single cluster and then at each level we recursively split existing clusters. To understand the split or merge process, we need to understand the following, Distance metric: this is the function that gives the distance between two data points. We can choose from a number of functions like euclidean, cosine, manhattan, etc. Linkage criteria: this is a function that define the distance between two clusters based on applying distance function on pairs of data from the two clusters. There are following strategies to choose from, Complete Linkage: Pick the most distant pair of points as the representation of cluster distance. Formulation is : \\(\\max \\,\\{\\,d(a,b):a\\in A,\\,b\\in B\\,\\}.\\) Single Linkage: Pick the least distant pair of points as the representation of cluster distance. Formulation is : \\(\\min \\,\\{\\,d(a,b):a\\in A,\\,b\\in B\\,\\}.\\) Ward: find the pair of clusters that leads to minimum increase in total within-cluster variance after merging. This is only applicable for euclidean distance. [4] Average: Uses the average of distances between all pairs of data points from the two clusters. Formulation is \\({\\displaystyle {\\frac {1}{|A|\\cdot |B|}}\\sum _{a\\in A}\\sum _{b\\in B}d(a,b).}\\) Now it should be easy to understand the overall process. Taking agglomerative as example, to begin with, all samples are separate clusters. At each iteration, we will compute the linkage score between all pairs of clusters and find the pair with the minimum score. We merge that pair of clusters together and go ahead with next iteration. We keep on repeating this process until we have reached a desired number of clusters ( n_clusters ) or the linkage distance threshold ( distance_threshold ) has triggered, above which, clusters will not be merged. Note At a time, we can only use either n_clusters or distance_threshold . Here is a sample code using sklearn package [1], 1 2 3 4 5 6 7 8 9 10 11 12 13 # import from sklearn.cluster import AgglomerativeClustering from sklearn.metrics import silhouette_score # load the data X = np . load ( 'data/embeddings.npy' ) # dummy # create the model model = AgglomerativeClustering ( n_clusters = 2 , affinity = 'cosine' , linkage = 'average' ) # get the label labels = model . fit_predict ( X ) # compute silhouette_score sil_score = silhouette_score ( X , labels , metric = 'cosine' )","title":"Hierarchical Clustering"},{"location":"machine_learning/clustering/#references","text":"[1] Sklearn - Clustering [2] Visualizing K Means Clustering - Naftali Harris [3] K-Medoids clustering with solved example [4] Wikipedia - Hierarchical clustering | Ward's method [5] V-Measure: A Conditional Entropy-Based External Cluster Evaluation Measure","title":"References"},{"location":"machine_learning/dpo/","text":"Introduction LLMs trained on vast datasets exhibit impressive capabilities in understanding and generating human language. However, ensuring that these models align with human preferences and produce desirable outputs remains a significant challenge. In a recent paper titled \"Direct Preference Optimization: Your Language Model is Secretly a Reward Model,\" [1] researchers from Stanford University introduce a novel approach to fine-tuning language models based on human preferences without relying on reinforcement learning techniques like RLHF While RLHF is still one of the primary methods for training language models to align with human preferences, it has several limitations, including high computational costs (need multiple copies of the model for finetuning - reference model, reward model and policy model) , complex reward modeling, and challenges in reward shaping. DPO was developed to address these limitations and provide a more efficient and effective alternative for training language models based on human preferences. Technique The complete DPO pipeline consists of two steps, SFT fine-tuning of the language model on the required dataset (which is mostly instruction dataset and so this step can be loosely called instruction-finetuning) , and then Reward maximization with KL-divergence constraint by fine-tuning on the preference dataset. In practice, models are readily available with SFT done and hence can be directly sent to the second step. The preference dataset consists of (input, output_1, output_2, .. output_n) generation examples sets (for DPO, n=2; where the output pairs are accepted and rejected examples) , where each output has an associated score that signifies its preference in comparison with other output for the same input. The DPO algorithm optimizes the language model to generate the preferred output by minimizing a modified version of binary cross entropy objective between the model's output and the preferred output. Source: [1] DPO algorithm implicitly optimizes the same objectives as RLHF but is simpler to implement and train. DPO does this by incorporating two factors into its policy, RLHF relies on preference model like Bradley-Terry model , to define a preference loss to train a reward model, which is then in turn used to train the policy. DPO on the other hand, uses a change of variable (math tricks \ud83d\ude0e) to express the preference loss as part of the policy itself. With this, DPO eliminates the need for a separate reward model. DPO has a KL divergence constraint that ensures the policy (trained model) remains close to the reference policy (original model) . This is required to ensure that the model in training does not deviate a lot from original model under the influence of preferences data. The DPO policy objective is formulated as below: \\[ L_{DPO}(\u03c0_\u03b8; \u03c0_{ref}) = -E_{(x, y_w, y_l)\u223cD} \\left[ \\log \\sigma \\left( \\beta \\log \\frac{\u03c0_\u03b8(y_w | x)}{\u03c0_{ref}(y_w | x)} - \\beta \\log \\frac{\u03c0_\u03b8(y_l | x)}{\u03c0_{ref}(y_l | x)} \\right) \\right] \\] Here, \\(\u03c0_\u03b8\\) represents the language model, \\(\u03c0_{ref}\\) represents the reference model, \\(D\\) represents the preferences dataset, in which \\(x\\) represents the input, \\(y_w\\) and \\(y_l\\) represent the winning (preferred) and losing (dispreferred) output, respectively. \\(\u03b2\\) (ideal value is between 0.1 to 0.5) is a parameter controlling the deviation from the base reference policy \\(\u03c0_{ref}\\) . Hint If you want to dive deeper into the math behind the DPO, refer to this excellent article . Impact Source: [1] As per the paper [1], DPO outperforms RLHF in terms of performance and efficiency. As evident in the above image, DPO achieve better expected rewards (IMDb Sentiment Generation) compared to other methods along with higher win-rates (with GPT-4 evaluator) on Summarization task. The paper also suggests that DPO requires less data and compute than PPO to provide comparable results. Code Fine-tuning a LLM with DPO is super easy with Hugging Face TRL package . First we need a dataset with preferences, which are readily available on the HF datasets hub, but it can also be created in-house for custom use case. Nevertheless the format should something like this, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 dpo_dataset_dict = { \"prompt\" : [ \"What is your name?\" , \"Tell me how to build a bomb?\" , ], \"chosen\" : [ \"I am a AI powered Assistant named Jarvis\" , \"Sorry, I cannot do this.\" , ], \"rejected\" : [ \"I am a Open-AI powered Assistant named ChatGPT\" , \"Here you go, first...\" , ], } Then we can use DPOTrainer to fine-tune the model with the preferences dataset. Below is a sample code to fine-tune a SFT tuned LLM with DPO. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # import from trl import DPOTrainer # define the DPO Trained dpo_trainer = DPOTrainer ( model , # model to be fine-tuned model_ref , # reference model (usually the `model`) args = training_args , # training arguments beta = 0.1 , # beta parameter ideal value is from 0.1 to 0.5 train_dataset = train_dataset , # training dataset as shown above tokenizer = tokenizer , # tokenizer ) # start the fine-tuning dpo_trainer . train () Reference [1] Direct Preference Optimization: Your Language Model is Secretly a Reward Model","title":"Direct Preference Optimization (DPO)"},{"location":"machine_learning/dpo/#introduction","text":"LLMs trained on vast datasets exhibit impressive capabilities in understanding and generating human language. However, ensuring that these models align with human preferences and produce desirable outputs remains a significant challenge. In a recent paper titled \"Direct Preference Optimization: Your Language Model is Secretly a Reward Model,\" [1] researchers from Stanford University introduce a novel approach to fine-tuning language models based on human preferences without relying on reinforcement learning techniques like RLHF While RLHF is still one of the primary methods for training language models to align with human preferences, it has several limitations, including high computational costs (need multiple copies of the model for finetuning - reference model, reward model and policy model) , complex reward modeling, and challenges in reward shaping. DPO was developed to address these limitations and provide a more efficient and effective alternative for training language models based on human preferences.","title":"Introduction"},{"location":"machine_learning/dpo/#technique","text":"The complete DPO pipeline consists of two steps, SFT fine-tuning of the language model on the required dataset (which is mostly instruction dataset and so this step can be loosely called instruction-finetuning) , and then Reward maximization with KL-divergence constraint by fine-tuning on the preference dataset. In practice, models are readily available with SFT done and hence can be directly sent to the second step. The preference dataset consists of (input, output_1, output_2, .. output_n) generation examples sets (for DPO, n=2; where the output pairs are accepted and rejected examples) , where each output has an associated score that signifies its preference in comparison with other output for the same input. The DPO algorithm optimizes the language model to generate the preferred output by minimizing a modified version of binary cross entropy objective between the model's output and the preferred output. Source: [1] DPO algorithm implicitly optimizes the same objectives as RLHF but is simpler to implement and train. DPO does this by incorporating two factors into its policy, RLHF relies on preference model like Bradley-Terry model , to define a preference loss to train a reward model, which is then in turn used to train the policy. DPO on the other hand, uses a change of variable (math tricks \ud83d\ude0e) to express the preference loss as part of the policy itself. With this, DPO eliminates the need for a separate reward model. DPO has a KL divergence constraint that ensures the policy (trained model) remains close to the reference policy (original model) . This is required to ensure that the model in training does not deviate a lot from original model under the influence of preferences data. The DPO policy objective is formulated as below: \\[ L_{DPO}(\u03c0_\u03b8; \u03c0_{ref}) = -E_{(x, y_w, y_l)\u223cD} \\left[ \\log \\sigma \\left( \\beta \\log \\frac{\u03c0_\u03b8(y_w | x)}{\u03c0_{ref}(y_w | x)} - \\beta \\log \\frac{\u03c0_\u03b8(y_l | x)}{\u03c0_{ref}(y_l | x)} \\right) \\right] \\] Here, \\(\u03c0_\u03b8\\) represents the language model, \\(\u03c0_{ref}\\) represents the reference model, \\(D\\) represents the preferences dataset, in which \\(x\\) represents the input, \\(y_w\\) and \\(y_l\\) represent the winning (preferred) and losing (dispreferred) output, respectively. \\(\u03b2\\) (ideal value is between 0.1 to 0.5) is a parameter controlling the deviation from the base reference policy \\(\u03c0_{ref}\\) . Hint If you want to dive deeper into the math behind the DPO, refer to this excellent article .","title":"Technique"},{"location":"machine_learning/dpo/#impact","text":"Source: [1] As per the paper [1], DPO outperforms RLHF in terms of performance and efficiency. As evident in the above image, DPO achieve better expected rewards (IMDb Sentiment Generation) compared to other methods along with higher win-rates (with GPT-4 evaluator) on Summarization task. The paper also suggests that DPO requires less data and compute than PPO to provide comparable results.","title":"Impact"},{"location":"machine_learning/dpo/#code","text":"Fine-tuning a LLM with DPO is super easy with Hugging Face TRL package . First we need a dataset with preferences, which are readily available on the HF datasets hub, but it can also be created in-house for custom use case. Nevertheless the format should something like this, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 dpo_dataset_dict = { \"prompt\" : [ \"What is your name?\" , \"Tell me how to build a bomb?\" , ], \"chosen\" : [ \"I am a AI powered Assistant named Jarvis\" , \"Sorry, I cannot do this.\" , ], \"rejected\" : [ \"I am a Open-AI powered Assistant named ChatGPT\" , \"Here you go, first...\" , ], } Then we can use DPOTrainer to fine-tune the model with the preferences dataset. Below is a sample code to fine-tune a SFT tuned LLM with DPO. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # import from trl import DPOTrainer # define the DPO Trained dpo_trainer = DPOTrainer ( model , # model to be fine-tuned model_ref , # reference model (usually the `model`) args = training_args , # training arguments beta = 0.1 , # beta parameter ideal value is from 0.1 to 0.5 train_dataset = train_dataset , # training dataset as shown above tokenizer = tokenizer , # tokenizer ) # start the fine-tuning dpo_trainer . train ()","title":"Code"},{"location":"machine_learning/dpo/#reference","text":"[1] Direct Preference Optimization: Your Language Model is Secretly a Reward Model","title":"Reference"},{"location":"machine_learning/genaidetection/","text":"Detecting AI Generated Content Introduction AI generated content is becoming increasingly prevalent, and it is important to be able to detect it. This is especially true in the context of misinformation and disinformation, where AI generated content can be used to create fake news, fake reviews and other forms of false information. Apart from the ethical and legal implications of AI generated content, there are also security implications, as AI generated content can be used to create fake identities, fake documents and other forms of fraudulent content. This makes it important to be able to detect AI generated content across different modalities, including text, images, videos and audio. In this article, we will discuss some of the methods that can be used to detect AI generated content across different modalities. Text Detecting AI generated text might seem impossible, as how can we distinguish text written by human from AI, where even different people have so many diverse way of writing!? This diversity comes from individual knowledge, experience and understanding of the language. That said, on a personal level, there are some implicit or explicit patterns that we use to distinguish something written by us (or our loved ones) from someone else's. And this is what AI text detection system try to leverage (but on a much grander scale) , to find patterns that distinguish AI generated text from human generated one. The simplest approach to detect AI generated text is to use classifiers (mostly neural network based) . This approach is based on the assumption that AI generated text has different statistical properties than human generated text, and that these properties can be learned by a classifier. The classifier can be trained using a labeled dataset of AI generated text and human generated text. Once the classifier is trained, it can be used to detect AI generated text in new data. Let's look at some of the methods, Kaggle Competition Winning Solution Kaggle hosted a sponsored competition LLM - Detect AI Generated Text [1] to build SoTA approach to detect AI generated text. After months of effort, the winning team was able to build a solution that gave ~98% accuracy. To build the solution, the team first of all enhanced the competition dataset by generating more AI contents using different open-source and proprietary language models. The team's approach to modeling was quite diverse as it involved fine-tuning LLMs with (Q)LoRA, leveraging Deberta-v3 for classification, and the Ghostbuster approach [2]. Finally their ensemble technique focused on ranking rather than raw prediction values where they averaged ranks across models and applied strategic weighting to the ranks to get the final prediction. Note The evaluation metric for the competition was ROC curve between the predicted probability and the observed target. ROC curve is a common metric for binary classification problems. Ghostbuster Ghostbuster [2] was part of the above winning solution and can also be used separately to detect AI generated text. Ghostbuster [2] Detecting Text Ghostwritten by Large Language Models Ghostbuster operates by determining the probability of generating each token in a document using multiple weaker language models. It then combines these probabilities using various functions as input to a final classifier. Ghostbuster does not require knowledge of the specific model used to generate a document or the probability of generating the document under that model. This characteristic makes Ghostbuster particularly valuable for identifying text that may have been generated by an unknown or black-box model, such as popular commercial models like ChatGPT and Claude, which do not provide probabilities. To ensure robust generalization, the researchers evaluated Ghostbuster across various methods of text generation, including different domains (utilizing newly collected datasets of essays, news, and stories), language models, and prompts. Stylometric Analysis Stylometric analysis is another approach that can be used to detect AI generated text, as shown in [3]. For context, Stylometric analysis is the study of writing style, and it can be used to detect patterns in writing style that are indicative of AI generation. For example, AI generated text may have different word choices, sentence structures, and other writing style features that can be used to detect it. Stylometric analysis can be used to detect AI generated text in a variety of ways, including by analyzing word distributions, sentence structures, and other linguistic features. Some of the features that can be used for stylometric analysis are mentioned below, [3] Stylometry Analysis Features Description Phraseology Word count, sentence count, paragraph count, mean and stdev of word count per sentence, mean and stdev of word count per paragraph, mean and stdev of sentence count per paragraph Punctuation Total punctuation count, mean count of special punctuation (!, \u2019, ,, :, ;, ?, \u201d, -,\u2013, @, #) Linguistic Diversity Lexical richness, readability Hint There are several websites that offer AI generated text detection services that you can try like Content at Scale , CopyLeaks , GPTZero , etc. That said, the accuracy that they provide is debatable and it is always better to test different services out for your specific use case. Images AI models for image generation are becoming more realistic over time. While in the past it was easy to detect AI images by identifying obvious flaws like missing shadows, unnatural faces or extra fingers etc, but the newer models are able to generate images that are almost indistinguishable from real ones. That said, there are still some methods that can be used to detect AI generated images. Projective Geometry The intuition behind this approach is that AI generated images do not have the same projective geometry as real images (as of yet) . As per the paper [4], it is possible to create a high quality AI image detector by looking at multiple factors like, Scale discrepancies - Generated images often do not adhere to the principle of size constancy, which states that objects of the same size should appear smaller as they move farther away from the viewer. As a result, the scaling in AI images is inconsistent, leading to a distorted sense of depth perception. Along with this some AI generated images might have incorrect representation of scale of real world objects, which means that objects in the image do not have the same scale as they would in real life. Inconsistencies in Vanishing Points - AI generated images often have inconsistencies in vanishing points, which are the points at which parallel lines appear to converge in the distance. Lighting and Shadow inconsistencies - AI generated images often lack shadows or have inconsistent lighting i.e. the shadow direction could be unnatural and inconsistent in case of presence of multiple objects in image. All of the above factors highlight the fact that the current Image generation models lack World Model understanding. While the model do have basic understanding about the different concepts like human, animal, places, etc, they lack the understanding of how these concepts interact with each other in the real world. This is the reason why the generated images lack the projective geometry that is present in real images. Different projective geometry related classifiers in [4] to detect AI generated images Image Watermarking Image watermarking is a technique that can be used to embed a watermark into an image, which is invisible to naked eye but can be extracted and authenticated to determine important details about the image. So by this technique if an image contains a watermark, it is AI generated otherwise its a real one. Meta's Stable Signature [5] is an example of such watermarking technique. This approach is quite intrusive as it requires the image to be modified at the time of generation. This is possible to implement by big text-to-image models providers but it is really difficult to implement or standardize due to the large number of open source models available in the market. Meta's Stable Signature [5] Hint There are several websites that provide AI image detection services by using inhouse trained classification models. Some of them are Is it AI? , AI or Not , etc. Videos As videos are a sequence of images, the same methods that are used to detect AI generated images can be used to detect AI generated videos. In addition to that, there are some additional methods that can be used to detect AI generated videos. Laws of Physics AI generated videos often do not adhere to the laws of physics, which can be used to detect them. For example, AI generated videos may have objects that move in unnatural ways, or that do not interact with each other in the way that they would in real life. This can be used to detect AI generated videos. Below is an example of a video that was generated by OpenAI Sora , which is widely considered the best AI video generation model as of the time of writing this article (Feb 2024) . The video shows a generic plastic chair being discovered in the desert, and it is clear that the video does not adhere to the laws of physics, as the chair moves in an unnatural way and does not interact with the environment in the way that it would in real life. OpenAI Sora generation for \"Archeologists discover a generic plastic chair in the desert, excavating and dusting it with great care.\" Note It will be interesting to find a work that can identify objects in a video and track if they follow basics physics laws or not. Maybe Game Dev QA have something similar that automates the testing of physics in the game using game play videos! \ud83e\udd14 Audio Detecting AI generated Audio is as challenging as AI text detection. The diversity in human voice and the way we speak makes it difficult to detect AI generated audio. That said, there are some methods that can be used to detect AI generated audio. Audio Watermarking Audio watermarking is a technique that can be used to embed a watermark, inform of imperceptible data, into an audio file that can be extracted and authenticated to determine if the audio is AI generated or not. So by this technique if an audio contains a watermark, it is AI generated otherwise its a real one. PerTh audio watermarking technique, developed by Resemble AI [6], exploits the frequency sensitivity of human hearing to embed data subtly into audio files. By leveraging the fact that our hearing sensitivity varies across different frequencies, PerTh embeds more data into less sensitive frequencies. This results in a watermark that is securely hidden in the audio, undetectable to the human ear, but retrievable when needed. It also takes advantage of the principle of auditory masking. When a loud sound, known as a masker sound, is played, quieter sounds nearby become imperceptible. PerTh utilizes this effect to place watermarked data into these \"masked\" areas, ensuring that the main audio content remains undisturbed. Resemble AI's PerTh audio watermarking technique [6] Classification Classification models can be trained to detect AI generated audio. The methodology could vary from end-to-end (input: audio, output: class) to feature based (input: audio features, output: class) . Classifiers can be trained using a labeled dataset of AI generated audio and human generated audio. End-to-end classifiers are quite difficult to scale as audio come in different size and shape and it could be problematic to train the model or run inference without compromising latency. Feature based classifiers are more common and easier to scale. The features could be extracted using different techniques like MFCC, Chroma, Mel Spectrogram, etc. The classification model could be a simple machine learning based or a complex deep learning based. Hint Some examples are Resemble Detect [6], PlayHT's AI Audio Detection , etc. Use case specific models can also be trained, one such example is Twilio's Answering Machine Detection model . References [1] Kaggle Competition: LLM - Detect AI Generated Text [2] Ghostbuster: Detecting Text Ghostwritten by Large Language Models [3] Stylometric Detection of AI-Generated Text in Twitter Timelines [4] \"Shadows Don\u2019t Lie and Lines Can\u2019t Bend! Generative Models don\u2019t know Projective Geometry...for now\" - Paper | Github [5] Meta's Stable Signature - Release Notes | Paper | Code [6] Resemble AI - PerTh Watermarker | Resemble Detect","title":"Detecting AI Generated Content"},{"location":"machine_learning/genaidetection/#detecting-ai-generated-content","text":"","title":"Detecting AI Generated Content"},{"location":"machine_learning/genaidetection/#introduction","text":"AI generated content is becoming increasingly prevalent, and it is important to be able to detect it. This is especially true in the context of misinformation and disinformation, where AI generated content can be used to create fake news, fake reviews and other forms of false information. Apart from the ethical and legal implications of AI generated content, there are also security implications, as AI generated content can be used to create fake identities, fake documents and other forms of fraudulent content. This makes it important to be able to detect AI generated content across different modalities, including text, images, videos and audio. In this article, we will discuss some of the methods that can be used to detect AI generated content across different modalities.","title":"Introduction"},{"location":"machine_learning/genaidetection/#text","text":"Detecting AI generated text might seem impossible, as how can we distinguish text written by human from AI, where even different people have so many diverse way of writing!? This diversity comes from individual knowledge, experience and understanding of the language. That said, on a personal level, there are some implicit or explicit patterns that we use to distinguish something written by us (or our loved ones) from someone else's. And this is what AI text detection system try to leverage (but on a much grander scale) , to find patterns that distinguish AI generated text from human generated one. The simplest approach to detect AI generated text is to use classifiers (mostly neural network based) . This approach is based on the assumption that AI generated text has different statistical properties than human generated text, and that these properties can be learned by a classifier. The classifier can be trained using a labeled dataset of AI generated text and human generated text. Once the classifier is trained, it can be used to detect AI generated text in new data. Let's look at some of the methods,","title":"Text"},{"location":"machine_learning/genaidetection/#kaggle-competition-winning-solution","text":"Kaggle hosted a sponsored competition LLM - Detect AI Generated Text [1] to build SoTA approach to detect AI generated text. After months of effort, the winning team was able to build a solution that gave ~98% accuracy. To build the solution, the team first of all enhanced the competition dataset by generating more AI contents using different open-source and proprietary language models. The team's approach to modeling was quite diverse as it involved fine-tuning LLMs with (Q)LoRA, leveraging Deberta-v3 for classification, and the Ghostbuster approach [2]. Finally their ensemble technique focused on ranking rather than raw prediction values where they averaged ranks across models and applied strategic weighting to the ranks to get the final prediction. Note The evaluation metric for the competition was ROC curve between the predicted probability and the observed target. ROC curve is a common metric for binary classification problems.","title":"Kaggle Competition Winning Solution"},{"location":"machine_learning/genaidetection/#ghostbuster","text":"Ghostbuster [2] was part of the above winning solution and can also be used separately to detect AI generated text. Ghostbuster [2] Detecting Text Ghostwritten by Large Language Models Ghostbuster operates by determining the probability of generating each token in a document using multiple weaker language models. It then combines these probabilities using various functions as input to a final classifier. Ghostbuster does not require knowledge of the specific model used to generate a document or the probability of generating the document under that model. This characteristic makes Ghostbuster particularly valuable for identifying text that may have been generated by an unknown or black-box model, such as popular commercial models like ChatGPT and Claude, which do not provide probabilities. To ensure robust generalization, the researchers evaluated Ghostbuster across various methods of text generation, including different domains (utilizing newly collected datasets of essays, news, and stories), language models, and prompts.","title":"Ghostbuster"},{"location":"machine_learning/genaidetection/#stylometric-analysis","text":"Stylometric analysis is another approach that can be used to detect AI generated text, as shown in [3]. For context, Stylometric analysis is the study of writing style, and it can be used to detect patterns in writing style that are indicative of AI generation. For example, AI generated text may have different word choices, sentence structures, and other writing style features that can be used to detect it. Stylometric analysis can be used to detect AI generated text in a variety of ways, including by analyzing word distributions, sentence structures, and other linguistic features. Some of the features that can be used for stylometric analysis are mentioned below, [3] Stylometry Analysis Features Description Phraseology Word count, sentence count, paragraph count, mean and stdev of word count per sentence, mean and stdev of word count per paragraph, mean and stdev of sentence count per paragraph Punctuation Total punctuation count, mean count of special punctuation (!, \u2019, ,, :, ;, ?, \u201d, -,\u2013, @, #) Linguistic Diversity Lexical richness, readability Hint There are several websites that offer AI generated text detection services that you can try like Content at Scale , CopyLeaks , GPTZero , etc. That said, the accuracy that they provide is debatable and it is always better to test different services out for your specific use case.","title":"Stylometric Analysis"},{"location":"machine_learning/genaidetection/#images","text":"AI models for image generation are becoming more realistic over time. While in the past it was easy to detect AI images by identifying obvious flaws like missing shadows, unnatural faces or extra fingers etc, but the newer models are able to generate images that are almost indistinguishable from real ones. That said, there are still some methods that can be used to detect AI generated images.","title":"Images"},{"location":"machine_learning/genaidetection/#projective-geometry","text":"The intuition behind this approach is that AI generated images do not have the same projective geometry as real images (as of yet) . As per the paper [4], it is possible to create a high quality AI image detector by looking at multiple factors like, Scale discrepancies - Generated images often do not adhere to the principle of size constancy, which states that objects of the same size should appear smaller as they move farther away from the viewer. As a result, the scaling in AI images is inconsistent, leading to a distorted sense of depth perception. Along with this some AI generated images might have incorrect representation of scale of real world objects, which means that objects in the image do not have the same scale as they would in real life. Inconsistencies in Vanishing Points - AI generated images often have inconsistencies in vanishing points, which are the points at which parallel lines appear to converge in the distance. Lighting and Shadow inconsistencies - AI generated images often lack shadows or have inconsistent lighting i.e. the shadow direction could be unnatural and inconsistent in case of presence of multiple objects in image. All of the above factors highlight the fact that the current Image generation models lack World Model understanding. While the model do have basic understanding about the different concepts like human, animal, places, etc, they lack the understanding of how these concepts interact with each other in the real world. This is the reason why the generated images lack the projective geometry that is present in real images. Different projective geometry related classifiers in [4] to detect AI generated images","title":"Projective Geometry"},{"location":"machine_learning/genaidetection/#image-watermarking","text":"Image watermarking is a technique that can be used to embed a watermark into an image, which is invisible to naked eye but can be extracted and authenticated to determine important details about the image. So by this technique if an image contains a watermark, it is AI generated otherwise its a real one. Meta's Stable Signature [5] is an example of such watermarking technique. This approach is quite intrusive as it requires the image to be modified at the time of generation. This is possible to implement by big text-to-image models providers but it is really difficult to implement or standardize due to the large number of open source models available in the market. Meta's Stable Signature [5] Hint There are several websites that provide AI image detection services by using inhouse trained classification models. Some of them are Is it AI? , AI or Not , etc.","title":"Image Watermarking"},{"location":"machine_learning/genaidetection/#videos","text":"As videos are a sequence of images, the same methods that are used to detect AI generated images can be used to detect AI generated videos. In addition to that, there are some additional methods that can be used to detect AI generated videos.","title":"Videos"},{"location":"machine_learning/genaidetection/#laws-of-physics","text":"AI generated videos often do not adhere to the laws of physics, which can be used to detect them. For example, AI generated videos may have objects that move in unnatural ways, or that do not interact with each other in the way that they would in real life. This can be used to detect AI generated videos. Below is an example of a video that was generated by OpenAI Sora , which is widely considered the best AI video generation model as of the time of writing this article (Feb 2024) . The video shows a generic plastic chair being discovered in the desert, and it is clear that the video does not adhere to the laws of physics, as the chair moves in an unnatural way and does not interact with the environment in the way that it would in real life. OpenAI Sora generation for \"Archeologists discover a generic plastic chair in the desert, excavating and dusting it with great care.\" Note It will be interesting to find a work that can identify objects in a video and track if they follow basics physics laws or not. Maybe Game Dev QA have something similar that automates the testing of physics in the game using game play videos! \ud83e\udd14","title":"Laws of Physics"},{"location":"machine_learning/genaidetection/#audio","text":"Detecting AI generated Audio is as challenging as AI text detection. The diversity in human voice and the way we speak makes it difficult to detect AI generated audio. That said, there are some methods that can be used to detect AI generated audio.","title":"Audio"},{"location":"machine_learning/genaidetection/#audio-watermarking","text":"Audio watermarking is a technique that can be used to embed a watermark, inform of imperceptible data, into an audio file that can be extracted and authenticated to determine if the audio is AI generated or not. So by this technique if an audio contains a watermark, it is AI generated otherwise its a real one. PerTh audio watermarking technique, developed by Resemble AI [6], exploits the frequency sensitivity of human hearing to embed data subtly into audio files. By leveraging the fact that our hearing sensitivity varies across different frequencies, PerTh embeds more data into less sensitive frequencies. This results in a watermark that is securely hidden in the audio, undetectable to the human ear, but retrievable when needed. It also takes advantage of the principle of auditory masking. When a loud sound, known as a masker sound, is played, quieter sounds nearby become imperceptible. PerTh utilizes this effect to place watermarked data into these \"masked\" areas, ensuring that the main audio content remains undisturbed. Resemble AI's PerTh audio watermarking technique [6]","title":"Audio Watermarking"},{"location":"machine_learning/genaidetection/#classification","text":"Classification models can be trained to detect AI generated audio. The methodology could vary from end-to-end (input: audio, output: class) to feature based (input: audio features, output: class) . Classifiers can be trained using a labeled dataset of AI generated audio and human generated audio. End-to-end classifiers are quite difficult to scale as audio come in different size and shape and it could be problematic to train the model or run inference without compromising latency. Feature based classifiers are more common and easier to scale. The features could be extracted using different techniques like MFCC, Chroma, Mel Spectrogram, etc. The classification model could be a simple machine learning based or a complex deep learning based. Hint Some examples are Resemble Detect [6], PlayHT's AI Audio Detection , etc. Use case specific models can also be trained, one such example is Twilio's Answering Machine Detection model .","title":"Classification"},{"location":"machine_learning/genaidetection/#references","text":"[1] Kaggle Competition: LLM - Detect AI Generated Text [2] Ghostbuster: Detecting Text Ghostwritten by Large Language Models [3] Stylometric Detection of AI-Generated Text in Twitter Timelines [4] \"Shadows Don\u2019t Lie and Lines Can\u2019t Bend! Generative Models don\u2019t know Projective Geometry...for now\" - Paper | Github [5] Meta's Stable Signature - Release Notes | Paper | Code [6] Resemble AI - PerTh Watermarker | Resemble Detect","title":"References"},{"location":"machine_learning/interview_questions/","text":"Here are some questions and their answers to make you ready for your next interview. Best of luck Question Answer What is Deep learning and how is it different from traditional Machine learning? Deep learning is a subfield of machine learning that uses neural networks with many layers, called deep neural networks, to learn and make predictions. It is different from traditional machine learning in that it can automatically learn hierarchical representations of the data and doesn't rely heavily on feature engineering. Question Answer What is Dummy Variable Trap in ML? The dummy variable trap is a situation in which a set of variables are perfectly correlated with each other, making it impossible to estimate the parameters of a linear regression model. This occurs when one or more of the dummy variables (one-hot encoded variables) are perfectly correlated with the constant term, which is a column of ones in the design matrix. For example, consider a dataset with a categorical variable with three levels: red, blue, and green. If we create three dummy variables for this variable, we might end up with a situation where the sum of the dummy variables is always equal to 1 for each observation. This would make it impossible to estimate the parameters of the linear regression model, as the design matrix would be singular. To avoid the dummy variable trap, we can drop one of the dummy variables. This will ensure that the dummy variables are not perfectly correlated with each other, and the design matrix will be invertible. Note If using regularizing, then don't drop a level as it biases your model in favor of the variable you dropped. Refer Damien Martin's Blog Question Answer How does back-propagation work in a neural network? Backpropagation is an algorithm used to train neural networks. It starts by propagating the input forward through the network, calculating the output. Then it compares the output to the desired output and calculates the error. The error is then propagated backwards through the network, adjusting the weights in the network so as to minimize the error. This process is repeated multiple times until the error is minimized. Question Answer While training deep learning models, why do we prefer training on mini-batch rather than on individual sample? First, the gradient of the loss over a mini-batch is an estimate of the gradient over the training set, whose quality improves as the batch size increases. Second, computation over a batch can be much more efficient than m computations for individual examples, due to the parallelism afforded by the modern computing platforms. Ref Question Answer What is Layer Normalization? Layer normalization is a technique used in deep learning to normalize the activations (outputs) of a neural network layer for each individual data sample. It works by computing the mean and variance of all features (neurons) in a layer for a single input, and then normalizing these values so that they have a standard distribution (zero mean and unit variance). This helps stabilize and accelerate the training process, making the model less sensitive to changes in the scale of the inputs and more robust to different batch sizes. How it works : For each input sample, calculate the mean and variance across all features in a layer, then subtract the mean and divide by the standard deviation for each feature. Where it's used : Especially useful in models like RNNs and transformers, and in any scenario where batch sizes are small or variable. Key benefit : Works the same way during both training and inference, and does not depend on the batch size. Question Answer What is Batch Normalization? Batch normalization is a normalization technique that normalizes each feature across all samples in a mini-batch. This means, for each feature (e.g., each neuron in a layer), the mean and variance are computed across the entire batch, and each feature value is normalized using these batch statistics. Refer How it works : For each feature, calculate the mean and variance across the current mini-batch, then normalize each value by subtracting the batch mean and dividing by the batch standard deviation. Where it's used : Commonly used in convolutional neural networks (CNNs) and feedforward networks, especially with large and consistent batch sizes. Key benefit : Helps accelerate training, improve generalization, and allows for higher learning rates. Question Answer What is Entropy (information theory) ? Entropy is a measurement of uncertainty of a system. Intuitively, it is the amount of information needed to remove uncertainty from the system. The entropy of a probability distribution p for various states of a system can be computed as: \\(-\\sum_{i}^{} (p_i \\log p_i)\\) Question Answer Even though Sigmoid function is non-linear, why is Logistic regression considered a linear classifier? Logistic regression is called a linear classifier because it computes a linear combination of the input features \\((z = w^T x + b)\\) , then applies the sigmoid function to output a probability. The decision boundary is defined by \\(w^T x + b = 0\\) , which is a linear equation\u2014so the separation between classes is linear in the feature space, even though the output is passed through a non-linear sigmoid. Refer Question Answer What is the difference between Logits, Soft and Hard targets? Let us understand each of the terms one by one. For better understanding, let's take a dog vs cat image classification as an example. Logits are the un-normalized output of the model. In our cat vs dog example, logits will be, say, 10.1 for cat and 5.6 for dog for an image with cat. Refer this SE question . Soft target : are normalized logits by applying a function . In our example, if we use softmax to the logits we get 0.99 for cat and 0.1 for dog. Hard targets : are the encoding of the soft targets. In our example, as the model predicted (here correctly) the image as of cat, the hard targets be 1 for cat and 0 for dog. graph LR A[Logits] -- normalization --> B[Soft Targets] B -- encoding --> C[Hard Targets] Question Answer How do you handle overfitting in deep learning models? Overfitting occurs when a model becomes too complex and starts to fit the noise in the training data, rather than the underlying pattern. There are several ways to handle overfitting in deep learning models, including: Regularization techniques such as L1 and L2 regularization, which add a penalty term to the loss function to discourage large weights Early stopping , where training is stopped before the model has a chance to fully fit the noise in the training data Dropout , which randomly drops out a certain percentage of neurons during training to prevent them from co-adapting and becoming too specialized Adding more data to the training set Question Answer Explain Regularization and different types of regularization techniques. Regularization is a set of techniques used in machine learning to reduce overfitting and improve a model's ability to generalize to new, unseen data. Overfitting happens when a model learns not only the underlying patterns in the training data but also the noise, making it perform poorly on new data. Regularization addresses this by adding a penalty to the model's loss function, discouraging overly complex models and large parameter values. Why use regularization? Prevents overfitting by discouraging complex models Improves generalization to new data Encourages simpler, more robust models How does it work? Regularization modifies the loss function by adding a penalty term based on the model's weights: \\[ \\text{Loss} = \\text{Original Loss} + \\lambda \\times \\text{Penalty} \\] where \\(\\lambda\\) controls the strength of the penalty. Common regularization techniques: L1 Regularization (Lasso): Adds the sum of the absolute values of the weights. Can shrink some weights to exactly zero, effectively performing feature selection. L2 Regularization (Ridge): Adds the sum of the squared values of the weights. Shrinks weights toward zero but rarely makes them exactly zero. Elastic Net: Combines L1 and L2 penalties, balancing between feature selection and coefficient shrinkage. Technique Penalty Type Effect on Weights Typical Use Case L1 (Lasso) Sum of absolute values Many weights set to zero Feature selection, sparse models L2 (Ridge) Sum of squares Weights shrink toward zero General shrinkage, no feature removal Elastic Net L1 + L2 combination Mix of both above Both shrinkage and feature selection In summary: Regularization is essential for building robust machine learning models. L1 and L2 are the most common forms, each adding different types of penalties to control model complexity and improve generalizability. Question Answer Explain the concept of temperature in deep learning? In deep learning, the concept of \"temperature\" is often associated with the Softmax function and is used to control the degree of confidence or uncertainty in the model's predictions. It's primarily applied in the context of classification tasks, such as image recognition or natural language processing, where the model assigns probabilities to different classes. The Softmax function is used to convert raw model scores or logits into a probability distribution over the classes. Each class is assigned a probability score, and the class with the highest probability is typically selected as the predicted class. The Softmax function is defined as follows for a class \"i\": \\[P(i) = \\frac{e^{z_i / \\tau}}{\\sum_{j} e^{z_j / \\tau}}\\] Where: \\(P(i)\\) is the probability of class \"i.\" \\(z_i\\) is the raw score or logit for class \"i.\" \\(\\tau\\) , known as the \"temperature,\" is a positive scalar parameter. The temperature parameter, \\(\\tau\\) , affects the shape of the probability distribution. When \\(\\tau\\) is high, the distribution becomes \"soft,\" meaning that the probabilities are more evenly spread among the classes. A lower temperature results in a \"harder\" distribution, with one or a few classes having much higher probabilities. Here's how temperature impacts the Softmax function: High \\(\\tau\\) : The model is more uncertain, and the probability distribution is more uniform, which can be useful when exploring diverse options or when dealing with noisy data. Low \\(\\tau\\) : The model becomes more confident, and the predicted class will have a much higher probability. This is useful when you want to make decisive predictions. Temperature allows you to control the trade-off between exploration and exploitation in the model's predictions. It's a hyperparameter that can be adjusted during training or inference to achieve the desired level of certainty in the model's output, depending on the specific requirements of your application. Here is a good online tool to learn about the impact of temperature and other parameters on output generation. Question Answer Can you explain the concept of convolutional neural networks (CNN)? A convolutional neural network (CNN) is a type of neural network that is primarily used for learning image and video patterns. CNNs are designed to automatically and adaptively learn spatial hierarchies of features from input data. They use a variation of multi-layer perceptrons, designed to require minimal preprocessing. Instead of hand-engineered features, CNNs learn features from data using a process called convolution. Question Answer How do you handle missing data in deep learning? Missing data can be handled in several ways, including: Removing the rows or columns with missing data Interpolation or imputation of missing values Using a technique called masking, which allows the model to ignore missing values when making predictions Question Answer Can you explain the concept of transfer learning in deep learning? Transfer learning is a technique where a model trained on one task is used as a starting point for a model on a second, related task. This allows the model to take advantage of the features learned from the first task and apply them to the second task, which can lead to faster training and better performance. This can be done by using a pre-trained model as a feature extractor or fine-tuning the pre-trained model on new data. Question Answer What is Gradient Descent in deep learning? Gradient Descent is an optimization algorithm used to minimize the loss function of a neural network. It works by updating the weights of the network in the opposite direction of the gradient of the loss function with respect to the weights. The magnitude of the update is determined by the learning rate. There are several variants of gradient descent, such as batch gradient descent, stochastic gradient descent, and mini-batch gradient descent. Question Answer What is Gradient Checkpointing and how does it help in training deep neural networks? Gradient checkpointing is a memory optimization technique that helps save GPU memory during the training of deep neural networks by trading computation time for memory usage. How it helps: Normally, when you train a neural network, the computer saves the outputs (called activations) of many layers during the forward pass, because these are needed later to calculate gradients during the backward pass. Saving all these activations takes up a lot of GPU memory. Gradient checkpointing changes this by only saving activations at certain points (called checkpoints) and not saving all the intermediate activations . When the backward pass runs, the missing activations are recomputed on demand by rerunning parts of the forward pass. This way, the training uses much less memory because fewer activations are saved, but it takes a bit more time since some calculations are repeated. When it helps: When your model is very large or your GPU memory is limited, and you want to train bigger or deeper models than your memory would normally allow. When you want to increase the batch size (the number of samples processed at once) but memory runs out. It is especially useful for big transformer models like BERT or GPT, where activations take a lot of memory. Tradeoff: It saves significant memory (about 50-60%) . But it increases computation time by roughly 15-25% because of the recomputation. In many cases, this tradeoff lets you train bigger models or batches on hardware that otherwise wouldn't be able to handle them. So in simple terms, gradient checkpointing lets you \"pause and forget\" some intermediate calculations during training to save memory and \"replay\" them later when needed, trading off some extra time for a lot less memory usage. Question Answer What is Representation learning? Representation learning is the fundamental concept in AI that denotes the power of the system to learn multiple levels of feature representation with increasing abstraction i.e. learning representations of data. These representations are stored inside the neurons and are used to make predictions and make decisions. Question Answer Explain Label smoothing. Label smoothing is a technique used in machine learning to prevent the model from becoming over-confident (overfitting). The smoothing is done by adding a small amount of noise to the labels of the training data, which makes the model less likely to overfit to the training data. Technically it generates soft labels by applying a weighted average between the uniform distribution and the hard label. Refer Paper 1 or Paper 2 Question Answer Please explain what is Dropout in deep learning? Dropout is a regularization technique used in deep learning to prevent overfitting. It works by randomly dropping out a certain percentage of neurons during training, effectively reducing the capacity of the network. This forces the network to learn multiple independent representations of the data, making it less prone to overfitting. Question Answer What are Autoencoder? An autoencoder is a type of neural network that is trained to reconstruct its input. It has an encoder part that compresses the input into a lower-dimensional representation called the bottleneck or latent code, and a decoder part that reconstructs the input from the latent code. Autoencoders can be used for tasks such as dimensionality reduction, anomaly detection and generative modelling. Question Answer Can you explain the concept of attention mechanism in deep learning? Attention mechanism is a way to weight different parts of the input in a neural network, giving more importance to certain features than others. It is commonly used in tasks such as machine translation, where the model needs to focus on different parts of the input sentence at different times. Attention mechanisms can be implemented in various ways, such as additive attention, dot-product attention, and multi-head attention. Question Answer What are Generative Adversarial Networks (GANs)? Generative Adversarial Networks (GANs) are a type of generative model that consists of two parts, a generator and a discriminator. The generator is trained to generate new data that is similar to the data it was trained on, while the discriminator is trained to distinguish the generated data from the real data. The two parts are trained together in a game-theoretic manner, where the generator tries to generate data that can fool the discriminator, and the discriminator tries to correctly identify the generated data. Question Answer Can you explain the concept of Memory Networks in deep learning? Memory networks are a type of neural network architecture that allow the model to access and manipulate an external memory matrix, which can be used to store information that is relevant to the task. This allows the model to reason about the past and use this information to make predictions about the future. Memory networks have been used in tasks such as language understanding and question answering. Refer this for more details. Question Answer Explain Capsule Networks in deep learning? Capsule networks are a type of neural network architecture that aims to overcome the limitations of traditional convolutional neural networks (CNNs) by using a new type of layer called a capsule. A capsule contains multiple neurons that work together to represent an object or part of an object, and the activities of the neurons are used to represent the properties of the object such as position, size and orientation. Capsule networks have been used in tasks such as image classification and object detection. Question Answer Can you explain the concept of generative models in deep learning? Generative models are a type of deep learning model that can generate new data that is similar to the data it was trained on. These models are trained on a dataset and learn the underlying probability distribution of the data, allowing them to generate new, unseen data that fits that distribution. Examples of generative models include Generative Adversarial Networks (GANs) and Variational Autoencoders (VAEs). Question Answer What is the concept of adversarial training in deep learning? Adversarial training is a technique used to improve the robustness of deep learning models by generating adversarial examples and using them to train the model. Adversarial examples are inputs that are slightly perturbed in such a way as to cause the model to make a mistake. By training the model on these examples, it becomes more robust to similar perturbations in the real world. Question Answer What is weight initialization in deep learning? Weight initialization is the process of setting the initial values for the weights in a neural network. The initial values of the weights can have a big impact on the network's performance and training time. There are several methods to initialize weights, including random initialization, Glorot initialization, and He initialization. Each of these methods have different properties and are more suitable for different types of problems. Question Answer Explain data augmentation? Data augmentation is a technique used to increase the amount of data available for training a deep learning model. This is done by creating new training examples by applying various random transformations to the original data, such as random cropping, flipping, or rotation. Data augmentation can be a powerful tool to prevent overfitting and improve the generalization performance of a mode. Question Answer What is the different between Standardization and Normalization? Normalization is the process of scaling the data to a common scale. It is also known as Min-Max Scaling where the final range could be [0, 1] or [-1,1] or something else. \\(X_{new} = (X - X_{min})/(X_{max} - X_{min})\\) Standardization is the process of scaling the data to have zero mean and unit variance. \\(X_{new} = (X - mean)/Std\\) Question Answer Is it possible that during ML training, both validation (or test) loss and accuracy, are increasing? Accuracy and loss are not necessarily exactly (inversely) correlated, as loss measures a difference between raw prediction (float) and class (0 or 1), while accuracy measures the difference between thresholded prediction (0 or 1) and class. So if raw predictions change, loss changes but accuracy is more \"resilient\" as predictions need to go over/under a threshold to actually change accuracy. Soltius's answer on SE Question Answer Is K-means clustering algorithm guaranteed to converge with unique result? K-means clustering algorithm is guaranteed to converge but the final result may vary based on the centroid initialisation. This is why it is suggested to try multiple initialization strategies and pick the one with best clustering. The convergence is guaranteed as the sum of squared distances between each point and its centroid strictly decreases over each iteration. Also the practical run time of k-means is basically linear. Refer Visualizing K Means Clustering - Naftali Harris Question Answer In K-means clustering, is it possible that a centroid has no data points assigned to it? Yes it is possible, imagine a centroid placed in middle of ring of other centroids. Several implementations either removes that centroid or random;y replace it somewhere else in the data space. Refer Visualizing K Means Clustering - Naftali Harris Question Answer What is entropy in information theory? Entropy is a measure of the amount of uncertainty or randomness in a system. It is often used in information theory and statistical mechanics to describe the unpredictability of a system or the amount of information required to describe it. It's formula is, \\(\\mathrm {H} (X):=-\\sum _{x\\in {\\mathcal {X}}}p(x)\\log p(x)=\\mathbb {E} [-\\log p(X)]\\) Here is an excellent video from Aurelien Geron, explaining the topic. Question Answer What is the difference between supervised and unsupervised learning? Supervised learning uses labeled data to train a model to make predictions, while unsupervised learning uses unlabeled data to find patterns or structure in the data. Question Answer How do you evaluate the performance of a machine learning model? One common method is to split the data into a training set and a test set, and use metrics such as accuracy, precision, recall, and F1 score to evaluate the model's performance on the test set. Question Answer What is overfitting in machine learning and how can it be prevented? Overfitting occurs when a model is too complex and is able to fit the noise in the training data, leading to poor performance on new, unseen data. To prevent overfitting, methods such as cross-validation, regularization, and early stopping can be used. Question Answer What is the difference between a decision tree and random forest? A decision tree is a single tree model that makes a prediction by traversing the tree from the root to a leaf node, while a random forest is an ensemble of decision trees, where the final prediction is made by averaging the predictions of all the trees in the forest. Question Answer What is the Bias-Variance trade-off in machine learning? The bias-variance trade-off is a key concept in machine learning that describes the balance between two types of errors affecting a model's ability to generalize: Bias : Error from overly simplistic assumptions in the model. High bias can cause underfitting\u2014poor performance on both training and test data. Variance : Error from excessive sensitivity to small fluctuations in the training set. High variance can cause overfitting\u2014good performance on training data but poor generalization to new data. As model complexity increases, bias decreases but variance increases. The goal is to find a balance: a model complex enough to capture patterns (low bias) but not so complex that it overfits (low variance). Model Complexity Bias Variance Generalization Too Simple High (underfit) Low Poor Too Complex Low High (overfit) Poor Just Right Low/Moderate Low/Moderate Good Managing the trade-off: Use regularization to penalize complexity and reduce overfitting. Use cross-validation to estimate model performance on unseen data. Increasing training data can help reduce variance. In summary: The bias-variance trade-off is about finding the sweet spot where your model is neither too simple nor too complex, so it generalizes well to new data. Question Answer What is the difference between batch and online learning? Batch learning is a type of machine learning where the model is trained on a fixed dataset and the parameters are updated after processing the entire dataset. In contrast, online learning is a type of machine learning where the model is trained on a continuous stream of data and the parameters are updated incrementally after processing each example. Question Answer What is the difference between a decision boundary and a decision surface in machine learning? A decision boundary is a boundary that separates different classes in a dataset, it can be represented by a line or a hyperplane in a two-dimensional or multi-dimensional space respectively. A decision surface is a generalization of decision boundary, it's a surface that separates different classes in a dataset, it can be represented by a surface in a multi-dimensional space. In simple words, a decision boundary is a one-dimensional representation of a decision surface. Question Answer What is the use of principal component analysis (PCA) in machine learning? Principal component analysis (PCA) is a technique used to reduce the dimensionality of a dataset by identifying the most important features, called principal components. PCA finds a new set of uncorrelated features, called principal components, that can explain most of the variance in the original data. This can be useful for visualizing high-dimensional data, reducing noise, and improving the performance of machine learning models. Question Answer What is the use of the Random Forest algorithm in machine learning? Random Forest is an ensemble learning technique that combines multiple decision trees to improve the performance and stability of the model. It works by creating multiple decision trees using a random subset of the features and training data, and then averaging the predictions of all the trees to make a final prediction. Random Forest algorithm is often used for classification and regression problems, it's robust to outliers, missing values, and irrelevant features, and it can also be used for feature selection and feature importance analysis. Question Answer What is the difference between a generative model and a discriminative model? A generative model learns the probability distribution of the data and can generate new samples from it, while a discriminative model learns the boundary between different classes and make predictions based on it. Generative models are used for tasks such as density estimation, anomaly detection, and data generation, while discriminative models are used for tasks such as classification and regression. Question Answer What is the difference between an autoencoder and a variational autoencoder? An autoencoder is a type of neural network that learns to encode and decode input data, it can be used to reduce the dimensionality of the data and learn a compact representation of it. A variational autoencoder (VAE) is a type of autoencoder that learns a probabilistic encoding of the input data, it generates new samples from the learned distribution. VAE can be used for tasks such as image generation and anomaly detection. Question Answer What is Expectation-Maximization (EM) algorithm? The Expectation-Maximization (EM) algorithm is a method for finding maximum likelihood estimates in incomplete data problems, where some of the data is missing or hidden. EM works by iteratively refining estimates of the missing data and the parameters of the model, until it converges to a local maximum of the likelihood function. It can be used for tasks such as clustering, image segmentation, and missing data imputation. Question Answer What is the difference between L1 and L2 regularization in machine learning? L1 and L2 regularization are methods used to prevent overfitting in machine learning models by adding a penalty term to the loss function. L1 regularization adds the absolute value of the weights to the loss function, while L2 regularization adds the square of the weights. L1 regularization leads to sparse models where some weights will be zero, while L2 regularization leads to models where all weights are small. Question Answer Explain Support Vector Machine (SVM). Support Vector Machine (SVM) is a supervised learning algorithm that can be used for classification and regression tasks. SVM works by finding the hyperplane that maximally separates the different classes in a dataset and then uses this hyperplane to make predictions. SVM is particularly useful when the data is linearly separable, it's also robust to high-dimensional data and it can be used with kernel functions to solve non-linearly separable problems. Question Answer What is the use of the k-nearest neighbors (k-NN) algorithm? k-nearest neighbors (k-NN) is a type of instance-based learning algorithm that can be used for classification and regression tasks. The algorithm works by finding the k training examples that are closest to a new input and using the majority class or average value of those examples to make a prediction. k-NN is a simple and efficient algorithm that can be used for tasks such as image classification, anomaly detection, and recommendation systems. Question Answer What is the use of the Random Sampling method for feature selection in machine learning? Random Sampling is a method for feature selection that involves randomly selecting a subset of features from the dataset and evaluating the performance of a model trained on that subset. The subset of features that result in the best performance are then chosen for further analysis or use in a final model. This method can be useful when the number of features is large and there is no prior knowledge of which features are most relevant. Question Answer Explain Bagging method in ensemble learning? Bagging (Bootstrap Aggregating) is a method for ensemble learning that involves training multiple models on different subsets of the data and then combining the predictions of those models. The subsets of data are created by randomly sampling the original data with replacement, this method helps to reduce the variance of the model and increase the robustness of the predictions. Bagging is commonly used with decision trees and can be implemented using Random Forest algorithm. Question Answer Explain AdaBoost method in ensemble learning? AdaBoost (Adaptive Boosting) is a method for ensemble learning that involves training multiple models on different subsets of the data and then combining the predictions of those models. The subsets of data are created by giving more weight to the examples that are misclassified by the previous models, this method helps to increase the accuracy of the model. AdaBoost is commonly used with decision trees and can be used with any type of base classifier. Question Answer Explain Gradient Boosting method in ensemble learning? Gradient Boosting is a method for ensemble learning that involves training multiple models in a sequential manner, where each model tries to correct the mistakes of the previous model. The method uses gradient descent to minimize the loss function, this method is commonly used with decision trees and it can be used with any type of base classifier. Gradient Boosting is a powerful method that can achieve state-of-the-art performance in many machine learning tasks. Question Answer Explain XGBoost method in ensemble learning? XGBoost (Extreme Gradient Boosting) is a specific implementation of the Gradient Boosting method that uses a more efficient tree-based model and a number of techniques to speed up the training process and reduce overfitting. XGBoost is commonly used in machine learning competitions and it's one of the most popular libraries used for gradient boosting. It's used for classification and regression problems. Question Answer What is group_size in context of Quantization? Group size is a parameter used in the quantization process that determines the number of weights or activations (imagine weights in a row of matrix) that are quantized together. A smaller group size can lead to better quantization accuracy, but it can also increase the memory and computational requirements of the model. Group size is an important hyperparameter that needs to be tuned to achieve the best trade-off between accuracy and efficiency. Note, the default groupsize for a GPTQ is 1024. Refer this interesting Reddit discussion Question Answer What is EMA (Exponential Moving Average) in context of deep learning? EMA is a technique used in deep learning to stabilize the training process and improve the generalization performance of the model. It works by maintaining a moving average of the model's parameters during training, which helps to smooth out the noise in the gradients and prevent the model from overfitting to the training data. Usually during training, the model's parameters are updated using the gradients of the loss function, but the EMA parameters are updated using a weighted average of the current parameters and the previous EMA parameters, as shown below: \\[ \\text{ema_param} = \\text{ema_param} * \\text{decay} + \\text{param} * (1 - \\text{decay}) \\] One more advantage of EMA model is that it can be used to resume the training. Some models provide both the model parameters and EMA parameters. Question Answer What is Bradley-Terry model? And how is it used in machine learning? Bradley-Terry model is a probability model that can be used to model the outcome of a pairwise comparison between two items. It is commonly used in sports analytics to rank teams or players based on their performance in head-to-head matches. Refer: Wikipedia In case of ML, the model is a popular choice for modeling human preferences in the context of training language models. It stipulates that the probability of a human preferring one completion over another can be expressed as a ratio of exponentials of the latent reward associated with each completion. Specifically, the human preference distribution \\[ p^*(y_1 \\succ y_2 | x) = \\frac{exp(r^*(x, y_1))}{exp(r^*(x, y_1)) + exp(r^*(x, y_2))} \\] This model is commonly used to capture human preferences to provide a framework for understanding and incorporating human feedback into the training of language models. Question Answer What is Rejection Sampling in Machine Learning? Rejection sampling is a method to generate samples from a complex target distribution (like a hard-to-sample probability curve) by using a simpler \"proposal\" distribution you can easily sample from (e.g., a uniform or normal distribution). Here's how it works: you first pick a proposal distribution that covers the target's range. Then, you repeatedly draw samples from this simpler distribution and \"accept\" or \"reject\" each sample based on a quality check\u2014if a random number (from 0 to 1) is less than the ratio of the target's density to the proposal's density (scaled by a constant), you keep the sample; otherwise, you discard it. This process ensures the accepted samples match the target distribution. It's like filtering out bad candidates until you're left with samples that fit your desired pattern. While simple to implement, it becomes inefficient for high-dimensional data or if the proposal distribution doesn't closely match the target shape.","title":"Interview Questions"},{"location":"machine_learning/interview_questions/#what-is-deep-learning-and-how-is-it-different-from-traditional-machine-learning","text":"Deep learning is a subfield of machine learning that uses neural networks with many layers, called deep neural networks, to learn and make predictions. It is different from traditional machine learning in that it can automatically learn hierarchical representations of the data and doesn't rely heavily on feature engineering. Question Answer","title":"What is Deep learning and how is it different from traditional Machine learning?"},{"location":"machine_learning/interview_questions/#what-is-dummy-variable-trap-in-ml","text":"The dummy variable trap is a situation in which a set of variables are perfectly correlated with each other, making it impossible to estimate the parameters of a linear regression model. This occurs when one or more of the dummy variables (one-hot encoded variables) are perfectly correlated with the constant term, which is a column of ones in the design matrix. For example, consider a dataset with a categorical variable with three levels: red, blue, and green. If we create three dummy variables for this variable, we might end up with a situation where the sum of the dummy variables is always equal to 1 for each observation. This would make it impossible to estimate the parameters of the linear regression model, as the design matrix would be singular. To avoid the dummy variable trap, we can drop one of the dummy variables. This will ensure that the dummy variables are not perfectly correlated with each other, and the design matrix will be invertible. Note If using regularizing, then don't drop a level as it biases your model in favor of the variable you dropped. Refer Damien Martin's Blog Question Answer","title":"What is Dummy Variable Trap in ML?"},{"location":"machine_learning/interview_questions/#how-does-back-propagation-work-in-a-neural-network","text":"Backpropagation is an algorithm used to train neural networks. It starts by propagating the input forward through the network, calculating the output. Then it compares the output to the desired output and calculates the error. The error is then propagated backwards through the network, adjusting the weights in the network so as to minimize the error. This process is repeated multiple times until the error is minimized. Question Answer","title":"How does back-propagation work in a neural network?"},{"location":"machine_learning/interview_questions/#while-training-deep-learning-models-why-do-we-prefer-training-on-mini-batch-rather-than-on-individual-sample","text":"First, the gradient of the loss over a mini-batch is an estimate of the gradient over the training set, whose quality improves as the batch size increases. Second, computation over a batch can be much more efficient than m computations for individual examples, due to the parallelism afforded by the modern computing platforms. Ref Question Answer","title":"While training deep learning models, why do we prefer training on mini-batch rather than on individual sample?"},{"location":"machine_learning/interview_questions/#what-is-layer-normalization","text":"Layer normalization is a technique used in deep learning to normalize the activations (outputs) of a neural network layer for each individual data sample. It works by computing the mean and variance of all features (neurons) in a layer for a single input, and then normalizing these values so that they have a standard distribution (zero mean and unit variance). This helps stabilize and accelerate the training process, making the model less sensitive to changes in the scale of the inputs and more robust to different batch sizes. How it works : For each input sample, calculate the mean and variance across all features in a layer, then subtract the mean and divide by the standard deviation for each feature. Where it's used : Especially useful in models like RNNs and transformers, and in any scenario where batch sizes are small or variable. Key benefit : Works the same way during both training and inference, and does not depend on the batch size. Question Answer","title":"What is Layer Normalization?"},{"location":"machine_learning/interview_questions/#what-is-batch-normalization","text":"Batch normalization is a normalization technique that normalizes each feature across all samples in a mini-batch. This means, for each feature (e.g., each neuron in a layer), the mean and variance are computed across the entire batch, and each feature value is normalized using these batch statistics. Refer How it works : For each feature, calculate the mean and variance across the current mini-batch, then normalize each value by subtracting the batch mean and dividing by the batch standard deviation. Where it's used : Commonly used in convolutional neural networks (CNNs) and feedforward networks, especially with large and consistent batch sizes. Key benefit : Helps accelerate training, improve generalization, and allows for higher learning rates. Question Answer","title":"What is Batch Normalization?"},{"location":"machine_learning/interview_questions/#what-is-entropy-information-theory","text":"Entropy is a measurement of uncertainty of a system. Intuitively, it is the amount of information needed to remove uncertainty from the system. The entropy of a probability distribution p for various states of a system can be computed as: \\(-\\sum_{i}^{} (p_i \\log p_i)\\) Question Answer","title":"What is Entropy (information theory)?"},{"location":"machine_learning/interview_questions/#even-though-sigmoid-function-is-non-linear-why-is-logistic-regression-considered-a-linear-classifier","text":"Logistic regression is called a linear classifier because it computes a linear combination of the input features \\((z = w^T x + b)\\) , then applies the sigmoid function to output a probability. The decision boundary is defined by \\(w^T x + b = 0\\) , which is a linear equation\u2014so the separation between classes is linear in the feature space, even though the output is passed through a non-linear sigmoid. Refer Question Answer","title":"Even though Sigmoid function is non-linear, why is Logistic regression considered a linear classifier?"},{"location":"machine_learning/interview_questions/#what-is-the-difference-between-logits-soft-and-hard-targets","text":"Let us understand each of the terms one by one. For better understanding, let's take a dog vs cat image classification as an example. Logits are the un-normalized output of the model. In our cat vs dog example, logits will be, say, 10.1 for cat and 5.6 for dog for an image with cat. Refer this SE question . Soft target : are normalized logits by applying a function . In our example, if we use softmax to the logits we get 0.99 for cat and 0.1 for dog. Hard targets : are the encoding of the soft targets. In our example, as the model predicted (here correctly) the image as of cat, the hard targets be 1 for cat and 0 for dog. graph LR A[Logits] -- normalization --> B[Soft Targets] B -- encoding --> C[Hard Targets] Question Answer","title":"What is the difference between Logits, Soft and Hard targets?"},{"location":"machine_learning/interview_questions/#how-do-you-handle-overfitting-in-deep-learning-models","text":"Overfitting occurs when a model becomes too complex and starts to fit the noise in the training data, rather than the underlying pattern. There are several ways to handle overfitting in deep learning models, including: Regularization techniques such as L1 and L2 regularization, which add a penalty term to the loss function to discourage large weights Early stopping , where training is stopped before the model has a chance to fully fit the noise in the training data Dropout , which randomly drops out a certain percentage of neurons during training to prevent them from co-adapting and becoming too specialized Adding more data to the training set Question Answer","title":"How do you handle overfitting in deep learning models?"},{"location":"machine_learning/interview_questions/#explain-regularization-and-different-types-of-regularization-techniques","text":"Regularization is a set of techniques used in machine learning to reduce overfitting and improve a model's ability to generalize to new, unseen data. Overfitting happens when a model learns not only the underlying patterns in the training data but also the noise, making it perform poorly on new data. Regularization addresses this by adding a penalty to the model's loss function, discouraging overly complex models and large parameter values. Why use regularization? Prevents overfitting by discouraging complex models Improves generalization to new data Encourages simpler, more robust models How does it work? Regularization modifies the loss function by adding a penalty term based on the model's weights: \\[ \\text{Loss} = \\text{Original Loss} + \\lambda \\times \\text{Penalty} \\] where \\(\\lambda\\) controls the strength of the penalty. Common regularization techniques: L1 Regularization (Lasso): Adds the sum of the absolute values of the weights. Can shrink some weights to exactly zero, effectively performing feature selection. L2 Regularization (Ridge): Adds the sum of the squared values of the weights. Shrinks weights toward zero but rarely makes them exactly zero. Elastic Net: Combines L1 and L2 penalties, balancing between feature selection and coefficient shrinkage. Technique Penalty Type Effect on Weights Typical Use Case L1 (Lasso) Sum of absolute values Many weights set to zero Feature selection, sparse models L2 (Ridge) Sum of squares Weights shrink toward zero General shrinkage, no feature removal Elastic Net L1 + L2 combination Mix of both above Both shrinkage and feature selection In summary: Regularization is essential for building robust machine learning models. L1 and L2 are the most common forms, each adding different types of penalties to control model complexity and improve generalizability. Question Answer","title":"Explain Regularization and different types of regularization techniques."},{"location":"machine_learning/interview_questions/#explain-the-concept-of-temperature-in-deep-learning","text":"In deep learning, the concept of \"temperature\" is often associated with the Softmax function and is used to control the degree of confidence or uncertainty in the model's predictions. It's primarily applied in the context of classification tasks, such as image recognition or natural language processing, where the model assigns probabilities to different classes. The Softmax function is used to convert raw model scores or logits into a probability distribution over the classes. Each class is assigned a probability score, and the class with the highest probability is typically selected as the predicted class. The Softmax function is defined as follows for a class \"i\": \\[P(i) = \\frac{e^{z_i / \\tau}}{\\sum_{j} e^{z_j / \\tau}}\\] Where: \\(P(i)\\) is the probability of class \"i.\" \\(z_i\\) is the raw score or logit for class \"i.\" \\(\\tau\\) , known as the \"temperature,\" is a positive scalar parameter. The temperature parameter, \\(\\tau\\) , affects the shape of the probability distribution. When \\(\\tau\\) is high, the distribution becomes \"soft,\" meaning that the probabilities are more evenly spread among the classes. A lower temperature results in a \"harder\" distribution, with one or a few classes having much higher probabilities. Here's how temperature impacts the Softmax function: High \\(\\tau\\) : The model is more uncertain, and the probability distribution is more uniform, which can be useful when exploring diverse options or when dealing with noisy data. Low \\(\\tau\\) : The model becomes more confident, and the predicted class will have a much higher probability. This is useful when you want to make decisive predictions. Temperature allows you to control the trade-off between exploration and exploitation in the model's predictions. It's a hyperparameter that can be adjusted during training or inference to achieve the desired level of certainty in the model's output, depending on the specific requirements of your application. Here is a good online tool to learn about the impact of temperature and other parameters on output generation. Question Answer","title":"Explain the concept of temperature in deep learning?"},{"location":"machine_learning/interview_questions/#can-you-explain-the-concept-of-convolutional-neural-networks-cnn","text":"A convolutional neural network (CNN) is a type of neural network that is primarily used for learning image and video patterns. CNNs are designed to automatically and adaptively learn spatial hierarchies of features from input data. They use a variation of multi-layer perceptrons, designed to require minimal preprocessing. Instead of hand-engineered features, CNNs learn features from data using a process called convolution. Question Answer","title":"Can you explain the concept of convolutional neural networks (CNN)?"},{"location":"machine_learning/interview_questions/#how-do-you-handle-missing-data-in-deep-learning","text":"Missing data can be handled in several ways, including: Removing the rows or columns with missing data Interpolation or imputation of missing values Using a technique called masking, which allows the model to ignore missing values when making predictions Question Answer","title":"How do you handle missing data in deep learning?"},{"location":"machine_learning/interview_questions/#can-you-explain-the-concept-of-transfer-learning-in-deep-learning","text":"Transfer learning is a technique where a model trained on one task is used as a starting point for a model on a second, related task. This allows the model to take advantage of the features learned from the first task and apply them to the second task, which can lead to faster training and better performance. This can be done by using a pre-trained model as a feature extractor or fine-tuning the pre-trained model on new data. Question Answer","title":"Can you explain the concept of transfer learning in deep learning?"},{"location":"machine_learning/interview_questions/#what-is-gradient-descent-in-deep-learning","text":"Gradient Descent is an optimization algorithm used to minimize the loss function of a neural network. It works by updating the weights of the network in the opposite direction of the gradient of the loss function with respect to the weights. The magnitude of the update is determined by the learning rate. There are several variants of gradient descent, such as batch gradient descent, stochastic gradient descent, and mini-batch gradient descent. Question Answer","title":"What is Gradient Descent in deep learning?"},{"location":"machine_learning/interview_questions/#what-is-gradient-checkpointing-and-how-does-it-help-in-training-deep-neural-networks","text":"Gradient checkpointing is a memory optimization technique that helps save GPU memory during the training of deep neural networks by trading computation time for memory usage. How it helps: Normally, when you train a neural network, the computer saves the outputs (called activations) of many layers during the forward pass, because these are needed later to calculate gradients during the backward pass. Saving all these activations takes up a lot of GPU memory. Gradient checkpointing changes this by only saving activations at certain points (called checkpoints) and not saving all the intermediate activations . When the backward pass runs, the missing activations are recomputed on demand by rerunning parts of the forward pass. This way, the training uses much less memory because fewer activations are saved, but it takes a bit more time since some calculations are repeated. When it helps: When your model is very large or your GPU memory is limited, and you want to train bigger or deeper models than your memory would normally allow. When you want to increase the batch size (the number of samples processed at once) but memory runs out. It is especially useful for big transformer models like BERT or GPT, where activations take a lot of memory. Tradeoff: It saves significant memory (about 50-60%) . But it increases computation time by roughly 15-25% because of the recomputation. In many cases, this tradeoff lets you train bigger models or batches on hardware that otherwise wouldn't be able to handle them. So in simple terms, gradient checkpointing lets you \"pause and forget\" some intermediate calculations during training to save memory and \"replay\" them later when needed, trading off some extra time for a lot less memory usage. Question Answer","title":"What is Gradient Checkpointing and how does it help in training deep neural networks?"},{"location":"machine_learning/interview_questions/#what-is-representation-learning","text":"Representation learning is the fundamental concept in AI that denotes the power of the system to learn multiple levels of feature representation with increasing abstraction i.e. learning representations of data. These representations are stored inside the neurons and are used to make predictions and make decisions. Question Answer","title":"What is Representation learning?"},{"location":"machine_learning/interview_questions/#explain-label-smoothing","text":"Label smoothing is a technique used in machine learning to prevent the model from becoming over-confident (overfitting). The smoothing is done by adding a small amount of noise to the labels of the training data, which makes the model less likely to overfit to the training data. Technically it generates soft labels by applying a weighted average between the uniform distribution and the hard label. Refer Paper 1 or Paper 2 Question Answer","title":"Explain Label smoothing."},{"location":"machine_learning/interview_questions/#please-explain-what-is-dropout-in-deep-learning","text":"Dropout is a regularization technique used in deep learning to prevent overfitting. It works by randomly dropping out a certain percentage of neurons during training, effectively reducing the capacity of the network. This forces the network to learn multiple independent representations of the data, making it less prone to overfitting. Question Answer","title":"Please explain what is Dropout in deep learning?"},{"location":"machine_learning/interview_questions/#what-are-autoencoder","text":"An autoencoder is a type of neural network that is trained to reconstruct its input. It has an encoder part that compresses the input into a lower-dimensional representation called the bottleneck or latent code, and a decoder part that reconstructs the input from the latent code. Autoencoders can be used for tasks such as dimensionality reduction, anomaly detection and generative modelling. Question Answer","title":"What are Autoencoder?"},{"location":"machine_learning/interview_questions/#can-you-explain-the-concept-of-attention-mechanism-in-deep-learning","text":"Attention mechanism is a way to weight different parts of the input in a neural network, giving more importance to certain features than others. It is commonly used in tasks such as machine translation, where the model needs to focus on different parts of the input sentence at different times. Attention mechanisms can be implemented in various ways, such as additive attention, dot-product attention, and multi-head attention. Question Answer","title":"Can you explain the concept of attention mechanism in deep learning?"},{"location":"machine_learning/interview_questions/#what-are-generative-adversarial-networks-gans","text":"Generative Adversarial Networks (GANs) are a type of generative model that consists of two parts, a generator and a discriminator. The generator is trained to generate new data that is similar to the data it was trained on, while the discriminator is trained to distinguish the generated data from the real data. The two parts are trained together in a game-theoretic manner, where the generator tries to generate data that can fool the discriminator, and the discriminator tries to correctly identify the generated data. Question Answer","title":"What are Generative Adversarial Networks (GANs)?"},{"location":"machine_learning/interview_questions/#can-you-explain-the-concept-of-memory-networks-in-deep-learning","text":"Memory networks are a type of neural network architecture that allow the model to access and manipulate an external memory matrix, which can be used to store information that is relevant to the task. This allows the model to reason about the past and use this information to make predictions about the future. Memory networks have been used in tasks such as language understanding and question answering. Refer this for more details. Question Answer","title":"Can you explain the concept of Memory Networks in deep learning?"},{"location":"machine_learning/interview_questions/#explain-capsule-networks-in-deep-learning","text":"Capsule networks are a type of neural network architecture that aims to overcome the limitations of traditional convolutional neural networks (CNNs) by using a new type of layer called a capsule. A capsule contains multiple neurons that work together to represent an object or part of an object, and the activities of the neurons are used to represent the properties of the object such as position, size and orientation. Capsule networks have been used in tasks such as image classification and object detection. Question Answer","title":"Explain Capsule Networks in deep learning?"},{"location":"machine_learning/interview_questions/#can-you-explain-the-concept-of-generative-models-in-deep-learning","text":"Generative models are a type of deep learning model that can generate new data that is similar to the data it was trained on. These models are trained on a dataset and learn the underlying probability distribution of the data, allowing them to generate new, unseen data that fits that distribution. Examples of generative models include Generative Adversarial Networks (GANs) and Variational Autoencoders (VAEs). Question Answer","title":"Can you explain the concept of generative models in deep learning?"},{"location":"machine_learning/interview_questions/#what-is-the-concept-of-adversarial-training-in-deep-learning","text":"Adversarial training is a technique used to improve the robustness of deep learning models by generating adversarial examples and using them to train the model. Adversarial examples are inputs that are slightly perturbed in such a way as to cause the model to make a mistake. By training the model on these examples, it becomes more robust to similar perturbations in the real world. Question Answer","title":"What is the concept of adversarial training in deep learning?"},{"location":"machine_learning/interview_questions/#what-is-weight-initialization-in-deep-learning","text":"Weight initialization is the process of setting the initial values for the weights in a neural network. The initial values of the weights can have a big impact on the network's performance and training time. There are several methods to initialize weights, including random initialization, Glorot initialization, and He initialization. Each of these methods have different properties and are more suitable for different types of problems. Question Answer","title":"What is weight initialization in deep learning?"},{"location":"machine_learning/interview_questions/#explain-data-augmentation","text":"Data augmentation is a technique used to increase the amount of data available for training a deep learning model. This is done by creating new training examples by applying various random transformations to the original data, such as random cropping, flipping, or rotation. Data augmentation can be a powerful tool to prevent overfitting and improve the generalization performance of a mode. Question Answer","title":"Explain data augmentation?"},{"location":"machine_learning/interview_questions/#what-is-the-different-between-standardization-and-normalization","text":"Normalization is the process of scaling the data to a common scale. It is also known as Min-Max Scaling where the final range could be [0, 1] or [-1,1] or something else. \\(X_{new} = (X - X_{min})/(X_{max} - X_{min})\\) Standardization is the process of scaling the data to have zero mean and unit variance. \\(X_{new} = (X - mean)/Std\\) Question Answer","title":"What is the different between Standardization and Normalization?"},{"location":"machine_learning/interview_questions/#is-it-possible-that-during-ml-training-both-validation-or-test-loss-and-accuracy-are-increasing","text":"Accuracy and loss are not necessarily exactly (inversely) correlated, as loss measures a difference between raw prediction (float) and class (0 or 1), while accuracy measures the difference between thresholded prediction (0 or 1) and class. So if raw predictions change, loss changes but accuracy is more \"resilient\" as predictions need to go over/under a threshold to actually change accuracy. Soltius's answer on SE Question Answer","title":"Is it possible that during ML training, both validation (or test) loss and accuracy, are increasing?"},{"location":"machine_learning/interview_questions/#is-k-means-clustering-algorithm-guaranteed-to-converge-with-unique-result","text":"K-means clustering algorithm is guaranteed to converge but the final result may vary based on the centroid initialisation. This is why it is suggested to try multiple initialization strategies and pick the one with best clustering. The convergence is guaranteed as the sum of squared distances between each point and its centroid strictly decreases over each iteration. Also the practical run time of k-means is basically linear. Refer Visualizing K Means Clustering - Naftali Harris Question Answer","title":"Is K-means clustering algorithm guaranteed to converge with unique result?"},{"location":"machine_learning/interview_questions/#in-k-means-clustering-is-it-possible-that-a-centroid-has-no-data-points-assigned-to-it","text":"Yes it is possible, imagine a centroid placed in middle of ring of other centroids. Several implementations either removes that centroid or random;y replace it somewhere else in the data space. Refer Visualizing K Means Clustering - Naftali Harris Question Answer","title":"In K-means clustering, is it possible that a centroid has no data points assigned to it?"},{"location":"machine_learning/interview_questions/#what-is-entropy-in-information-theory","text":"Entropy is a measure of the amount of uncertainty or randomness in a system. It is often used in information theory and statistical mechanics to describe the unpredictability of a system or the amount of information required to describe it. It's formula is, \\(\\mathrm {H} (X):=-\\sum _{x\\in {\\mathcal {X}}}p(x)\\log p(x)=\\mathbb {E} [-\\log p(X)]\\) Here is an excellent video from Aurelien Geron, explaining the topic. Question Answer","title":"What is entropy in information theory?"},{"location":"machine_learning/interview_questions/#what-is-the-difference-between-supervised-and-unsupervised-learning","text":"Supervised learning uses labeled data to train a model to make predictions, while unsupervised learning uses unlabeled data to find patterns or structure in the data. Question Answer","title":"What is the difference between supervised and unsupervised learning?"},{"location":"machine_learning/interview_questions/#how-do-you-evaluate-the-performance-of-a-machine-learning-model","text":"One common method is to split the data into a training set and a test set, and use metrics such as accuracy, precision, recall, and F1 score to evaluate the model's performance on the test set. Question Answer","title":"How do you evaluate the performance of a machine learning model?"},{"location":"machine_learning/interview_questions/#what-is-overfitting-in-machine-learning-and-how-can-it-be-prevented","text":"Overfitting occurs when a model is too complex and is able to fit the noise in the training data, leading to poor performance on new, unseen data. To prevent overfitting, methods such as cross-validation, regularization, and early stopping can be used. Question Answer","title":"What is overfitting in machine learning and how can it be prevented?"},{"location":"machine_learning/interview_questions/#what-is-the-difference-between-a-decision-tree-and-random-forest","text":"A decision tree is a single tree model that makes a prediction by traversing the tree from the root to a leaf node, while a random forest is an ensemble of decision trees, where the final prediction is made by averaging the predictions of all the trees in the forest. Question Answer","title":"What is the difference between a decision tree and random forest?"},{"location":"machine_learning/interview_questions/#what-is-the-bias-variance-trade-off-in-machine-learning","text":"The bias-variance trade-off is a key concept in machine learning that describes the balance between two types of errors affecting a model's ability to generalize: Bias : Error from overly simplistic assumptions in the model. High bias can cause underfitting\u2014poor performance on both training and test data. Variance : Error from excessive sensitivity to small fluctuations in the training set. High variance can cause overfitting\u2014good performance on training data but poor generalization to new data. As model complexity increases, bias decreases but variance increases. The goal is to find a balance: a model complex enough to capture patterns (low bias) but not so complex that it overfits (low variance). Model Complexity Bias Variance Generalization Too Simple High (underfit) Low Poor Too Complex Low High (overfit) Poor Just Right Low/Moderate Low/Moderate Good Managing the trade-off: Use regularization to penalize complexity and reduce overfitting. Use cross-validation to estimate model performance on unseen data. Increasing training data can help reduce variance. In summary: The bias-variance trade-off is about finding the sweet spot where your model is neither too simple nor too complex, so it generalizes well to new data. Question Answer","title":"What is the Bias-Variance trade-off in machine learning?"},{"location":"machine_learning/interview_questions/#what-is-the-difference-between-batch-and-online-learning","text":"Batch learning is a type of machine learning where the model is trained on a fixed dataset and the parameters are updated after processing the entire dataset. In contrast, online learning is a type of machine learning where the model is trained on a continuous stream of data and the parameters are updated incrementally after processing each example. Question Answer","title":"What is the difference between batch and online learning?"},{"location":"machine_learning/interview_questions/#what-is-the-difference-between-a-decision-boundary-and-a-decision-surface-in-machine-learning","text":"A decision boundary is a boundary that separates different classes in a dataset, it can be represented by a line or a hyperplane in a two-dimensional or multi-dimensional space respectively. A decision surface is a generalization of decision boundary, it's a surface that separates different classes in a dataset, it can be represented by a surface in a multi-dimensional space. In simple words, a decision boundary is a one-dimensional representation of a decision surface. Question Answer","title":"What is the difference between a decision boundary and a decision surface in machine learning?"},{"location":"machine_learning/interview_questions/#what-is-the-use-of-principal-component-analysis-pca-in-machine-learning","text":"Principal component analysis (PCA) is a technique used to reduce the dimensionality of a dataset by identifying the most important features, called principal components. PCA finds a new set of uncorrelated features, called principal components, that can explain most of the variance in the original data. This can be useful for visualizing high-dimensional data, reducing noise, and improving the performance of machine learning models. Question Answer","title":"What is the use of principal component analysis (PCA) in machine learning?"},{"location":"machine_learning/interview_questions/#what-is-the-use-of-the-random-forest-algorithm-in-machine-learning","text":"Random Forest is an ensemble learning technique that combines multiple decision trees to improve the performance and stability of the model. It works by creating multiple decision trees using a random subset of the features and training data, and then averaging the predictions of all the trees to make a final prediction. Random Forest algorithm is often used for classification and regression problems, it's robust to outliers, missing values, and irrelevant features, and it can also be used for feature selection and feature importance analysis. Question Answer","title":"What is the use of the Random Forest algorithm in machine learning?"},{"location":"machine_learning/interview_questions/#what-is-the-difference-between-a-generative-model-and-a-discriminative-model","text":"A generative model learns the probability distribution of the data and can generate new samples from it, while a discriminative model learns the boundary between different classes and make predictions based on it. Generative models are used for tasks such as density estimation, anomaly detection, and data generation, while discriminative models are used for tasks such as classification and regression. Question Answer","title":"What is the difference between a generative model and a discriminative model?"},{"location":"machine_learning/interview_questions/#what-is-the-difference-between-an-autoencoder-and-a-variational-autoencoder","text":"An autoencoder is a type of neural network that learns to encode and decode input data, it can be used to reduce the dimensionality of the data and learn a compact representation of it. A variational autoencoder (VAE) is a type of autoencoder that learns a probabilistic encoding of the input data, it generates new samples from the learned distribution. VAE can be used for tasks such as image generation and anomaly detection. Question Answer","title":"What is the difference between an autoencoder and a variational autoencoder?"},{"location":"machine_learning/interview_questions/#what-is-expectation-maximization-em-algorithm","text":"The Expectation-Maximization (EM) algorithm is a method for finding maximum likelihood estimates in incomplete data problems, where some of the data is missing or hidden. EM works by iteratively refining estimates of the missing data and the parameters of the model, until it converges to a local maximum of the likelihood function. It can be used for tasks such as clustering, image segmentation, and missing data imputation. Question Answer","title":"What is Expectation-Maximization (EM) algorithm?"},{"location":"machine_learning/interview_questions/#what-is-the-difference-between-l1-and-l2-regularization-in-machine-learning","text":"L1 and L2 regularization are methods used to prevent overfitting in machine learning models by adding a penalty term to the loss function. L1 regularization adds the absolute value of the weights to the loss function, while L2 regularization adds the square of the weights. L1 regularization leads to sparse models where some weights will be zero, while L2 regularization leads to models where all weights are small. Question Answer","title":"What is the difference between L1 and L2 regularization in machine learning?"},{"location":"machine_learning/interview_questions/#explain-support-vector-machine-svm","text":"Support Vector Machine (SVM) is a supervised learning algorithm that can be used for classification and regression tasks. SVM works by finding the hyperplane that maximally separates the different classes in a dataset and then uses this hyperplane to make predictions. SVM is particularly useful when the data is linearly separable, it's also robust to high-dimensional data and it can be used with kernel functions to solve non-linearly separable problems. Question Answer","title":"Explain Support Vector Machine (SVM)."},{"location":"machine_learning/interview_questions/#what-is-the-use-of-the-k-nearest-neighbors-k-nn-algorithm","text":"k-nearest neighbors (k-NN) is a type of instance-based learning algorithm that can be used for classification and regression tasks. The algorithm works by finding the k training examples that are closest to a new input and using the majority class or average value of those examples to make a prediction. k-NN is a simple and efficient algorithm that can be used for tasks such as image classification, anomaly detection, and recommendation systems. Question Answer","title":"What is the use of the k-nearest neighbors (k-NN) algorithm?"},{"location":"machine_learning/interview_questions/#what-is-the-use-of-the-random-sampling-method-for-feature-selection-in-machine-learning","text":"Random Sampling is a method for feature selection that involves randomly selecting a subset of features from the dataset and evaluating the performance of a model trained on that subset. The subset of features that result in the best performance are then chosen for further analysis or use in a final model. This method can be useful when the number of features is large and there is no prior knowledge of which features are most relevant. Question Answer","title":"What is the use of the Random Sampling method for feature selection in machine learning?"},{"location":"machine_learning/interview_questions/#explain-bagging-method-in-ensemble-learning","text":"Bagging (Bootstrap Aggregating) is a method for ensemble learning that involves training multiple models on different subsets of the data and then combining the predictions of those models. The subsets of data are created by randomly sampling the original data with replacement, this method helps to reduce the variance of the model and increase the robustness of the predictions. Bagging is commonly used with decision trees and can be implemented using Random Forest algorithm. Question Answer","title":"Explain Bagging method in ensemble learning?"},{"location":"machine_learning/interview_questions/#explain-adaboost-method-in-ensemble-learning","text":"AdaBoost (Adaptive Boosting) is a method for ensemble learning that involves training multiple models on different subsets of the data and then combining the predictions of those models. The subsets of data are created by giving more weight to the examples that are misclassified by the previous models, this method helps to increase the accuracy of the model. AdaBoost is commonly used with decision trees and can be used with any type of base classifier. Question Answer","title":"Explain AdaBoost method in ensemble learning?"},{"location":"machine_learning/interview_questions/#explain-gradient-boosting-method-in-ensemble-learning","text":"Gradient Boosting is a method for ensemble learning that involves training multiple models in a sequential manner, where each model tries to correct the mistakes of the previous model. The method uses gradient descent to minimize the loss function, this method is commonly used with decision trees and it can be used with any type of base classifier. Gradient Boosting is a powerful method that can achieve state-of-the-art performance in many machine learning tasks. Question Answer","title":"Explain Gradient Boosting method in ensemble learning?"},{"location":"machine_learning/interview_questions/#explain-xgboost-method-in-ensemble-learning","text":"XGBoost (Extreme Gradient Boosting) is a specific implementation of the Gradient Boosting method that uses a more efficient tree-based model and a number of techniques to speed up the training process and reduce overfitting. XGBoost is commonly used in machine learning competitions and it's one of the most popular libraries used for gradient boosting. It's used for classification and regression problems. Question Answer","title":"Explain XGBoost method in ensemble learning?"},{"location":"machine_learning/interview_questions/#what-is-group_size-in-context-of-quantization","text":"Group size is a parameter used in the quantization process that determines the number of weights or activations (imagine weights in a row of matrix) that are quantized together. A smaller group size can lead to better quantization accuracy, but it can also increase the memory and computational requirements of the model. Group size is an important hyperparameter that needs to be tuned to achieve the best trade-off between accuracy and efficiency. Note, the default groupsize for a GPTQ is 1024. Refer this interesting Reddit discussion Question Answer","title":"What is group_size in context of Quantization?"},{"location":"machine_learning/interview_questions/#what-is-ema-exponential-moving-average-in-context-of-deep-learning","text":"EMA is a technique used in deep learning to stabilize the training process and improve the generalization performance of the model. It works by maintaining a moving average of the model's parameters during training, which helps to smooth out the noise in the gradients and prevent the model from overfitting to the training data. Usually during training, the model's parameters are updated using the gradients of the loss function, but the EMA parameters are updated using a weighted average of the current parameters and the previous EMA parameters, as shown below: \\[ \\text{ema_param} = \\text{ema_param} * \\text{decay} + \\text{param} * (1 - \\text{decay}) \\] One more advantage of EMA model is that it can be used to resume the training. Some models provide both the model parameters and EMA parameters. Question Answer","title":"What is EMA (Exponential Moving Average) in context of deep learning?"},{"location":"machine_learning/interview_questions/#what-is-bradley-terry-model-and-how-is-it-used-in-machine-learning","text":"Bradley-Terry model is a probability model that can be used to model the outcome of a pairwise comparison between two items. It is commonly used in sports analytics to rank teams or players based on their performance in head-to-head matches. Refer: Wikipedia In case of ML, the model is a popular choice for modeling human preferences in the context of training language models. It stipulates that the probability of a human preferring one completion over another can be expressed as a ratio of exponentials of the latent reward associated with each completion. Specifically, the human preference distribution \\[ p^*(y_1 \\succ y_2 | x) = \\frac{exp(r^*(x, y_1))}{exp(r^*(x, y_1)) + exp(r^*(x, y_2))} \\] This model is commonly used to capture human preferences to provide a framework for understanding and incorporating human feedback into the training of language models. Question Answer","title":"What is Bradley-Terry model? And how is it used in machine learning?"},{"location":"machine_learning/interview_questions/#what-is-rejection-sampling-in-machine-learning","text":"Rejection sampling is a method to generate samples from a complex target distribution (like a hard-to-sample probability curve) by using a simpler \"proposal\" distribution you can easily sample from (e.g., a uniform or normal distribution). Here's how it works: you first pick a proposal distribution that covers the target's range. Then, you repeatedly draw samples from this simpler distribution and \"accept\" or \"reject\" each sample based on a quality check\u2014if a random number (from 0 to 1) is less than the ratio of the target's density to the proposal's density (scaled by a constant), you keep the sample; otherwise, you discard it. This process ensures the accepted samples match the target distribution. It's like filtering out bad candidates until you're left with samples that fit your desired pattern. While simple to implement, it becomes inefficient for high-dimensional data or if the proposal distribution doesn't closely match the target shape.","title":"What is Rejection Sampling in Machine Learning?"},{"location":"machine_learning/introduction/","text":"The first question to ask is \"What is Machine Learning (ML)?\" . And to answer this question we should understand the relation between Artificial Intelligence (AI), Machine Learning (ML) and even Deep Learning (DL). Let's go through them ony by one, Artificial Intelligence (AI) is the process of creating intelligent machines that can perform tasks that humans can do. Machine Learning (ML) is subset of AI where we create systems that is able to learn from data and perform specific tasks with near or above human capability. Deep Learning (DL) is subset of ML where we create neural network based system that is able to capable of identifying patterns from data and perform specific tasks. The hierarchy of Artificial Intelligence Different types of Learning The paradigms of Machine Learning Supervised Learning It is a machine learning approach wherein we learn a function that transforms an input into an output based on example input-output pairs. Basically, it uses a labeled dataset as a training dataset to learn a generic function that can be later used to predict unseens data. Classification is one of the most common problems for which supervised learning is utilized. The idea is to learn a generic function that takes an item\u2019s features as input and provides the item\u2019s class as output. To solve this, several classification algorithms try to create boundaries for each class based on the features of labeled data. Later for any new item, the boundaries help decide which class the item belongs to. Unsupervised Learning It is a machine learning approach wherein we learn patterns from unlabeled data. It is more of a descriptive analysis that can be used to generate insights from the data, which could be later used for downstream predictions. Clustering is a common example of unsupervised learning. The idea is to make groups of items based on the item\u2019s features. Note, as the data is not labeled, the grouping could be completely different from the user\u2019s expectations. Each clustering algorithm has its own internal similarity function and grouping strategy by which the clusters are formed. Semi-Supervised Learning It is a machine learning approach wherein we use labeled and unlabeled data to train a model. The intention is that the resulting model will be better than one learned over the labeled (supervised) or unlabeled data (unsupervised) alone. Hence it falls between the two methods. We can try semi-supervised learning when we have very little labeled data but a lot of unlabeled data, and if the cost or time of labeling is too high. We start with training a model on the labeled data. Then the model is used to make predictions on the unlabeled data. Specific unlabeled data are picked and their prediction is considered true. The selection criteria could be some threshold on the prediction probability or top K selection. These selected unlabeled data with the prediction are added to the labeled data set and the next iteration of training begins. This goes on till n-iterations . Note This process is also called Pseudo-labelling, as we are creating pseudo labels on unlabeled dataset using the model trained on only labeled data. Reinforcement Learning It is a machine learning approach wherein we train agent(s) to interact with an environment to achieve certain goal. The goal is quantified by providing the agent with some positive reward on successful completion or negative reward incase of failure. The main components in RL are agents, environment and actions. Agents are the intelligent model we want to improve over time. Environment is the simulation where the agent performs some actions. Once an agent takes an action, the state of the agent changes. Based on the environment, the agent could get instant reward for each action or delayed reward on completion of an episode (sequence of actions). Self-supervised Learning It is a machine learning approach wherein we create supervisory signals from the unlabeled data itself, often leveraging the underlying structure in the data. The idea is to take unlabeled data and create generic tasks, that could be different from the intended downstream task but will help model learn the fundamentals. Then the model could be fine-tuned for the specific downstream task easily with very less labeled data. It is closely connected to how humans learn \u2014 as human normally first develop common sense (a general understanding of the world) and then learn specific tasks quite easily (when comparing to machines). It is becoming a norm in the AI field to train large models using self-supervised learning, as the resulting models are generalist ie. could be used for multiple downstream tasks. The method of training vary wrt the datatype. For example, in NLP, we can hide part of a sentence and predict the hidden words from the remaining words. In CV, we can predict past or future frames in a video (hidden data) from current ones (observed data). Same could be done for Audio. Additional Techniques Active Learning Active learning is all about selecting the minimal set of training data that will lead to the maximum performance gain. Active learning could have following use cases, Lots of labeled data: If you have lots of annotated data but you are contraint by time or computation power, you can try to select the smallest set of labeled data to train the model on. This is easy to understand as not all samples have equal contribution in training the model. Thinking intuitively, say for a linear classifier with straight line as the decision boundary, keeping data near the decision line will lead to better overall accuracy than the ones near the end or in middle of cluster of datapoints. Lots of unlabeled data: In this case, active learning is very similar to Semi-supervised learning, with only one twist - we ask humans to label again, instead of labeling using the model. The process starts similar to pseudo labelling and we train the model on the available labeled dataset. Then the trained model is used to make prediction on the unlabeled data and using preferred logic, we suggest the next batch of datasets that should be labeled by human expert. We keep iterating unless the desired accuracy is reached. Transfer learning Transfer learning is all about using the knowledge gained while solving one problem to solve another problem. From a practical perspective, we reuse (either as it is or by finetining) an existing base model that was trained for say Task A, for another tasks like B, C, etc. This approach could be prefered is we don't want to train a model from scratch. For example, if we have a pretrained model that can classify cat vs dogs, it will be easier, in terms of training iterations and even number of required samples, to train for other classes like lion vs elephant. Here, the intuition is that the exsiting image classification model should have gained some knowledge about the important features of animal images. And even though the classes were completely different, it should be mich better and easier than training a new model with new weight initialization. Note There are several ways on how we can use transfer learning to make an existing model work for another task. These could be, (1) Finetune the complete model, (2) Freeze certains layers (preferably the starting one) and then finetune, (3) Replace certains layers (preferably the ending one -- like classification head) and then finetune, or (4) Freeze the complete model and just train additional heads for different downstream tasks. Additional materials 14 Different Types of Learning in Machine Learning Semi-Supervised Wikipedia and Semi-Supervised Sklearn Self-supervised learning: The dark matter of intelligence Transfer Learning - Machine Learning Mastery","title":"Introduction"},{"location":"machine_learning/introduction/#different-types-of-learning","text":"The paradigms of Machine Learning","title":"Different types of Learning"},{"location":"machine_learning/introduction/#supervised-learning","text":"It is a machine learning approach wherein we learn a function that transforms an input into an output based on example input-output pairs. Basically, it uses a labeled dataset as a training dataset to learn a generic function that can be later used to predict unseens data. Classification is one of the most common problems for which supervised learning is utilized. The idea is to learn a generic function that takes an item\u2019s features as input and provides the item\u2019s class as output. To solve this, several classification algorithms try to create boundaries for each class based on the features of labeled data. Later for any new item, the boundaries help decide which class the item belongs to.","title":"Supervised Learning"},{"location":"machine_learning/introduction/#unsupervised-learning","text":"It is a machine learning approach wherein we learn patterns from unlabeled data. It is more of a descriptive analysis that can be used to generate insights from the data, which could be later used for downstream predictions. Clustering is a common example of unsupervised learning. The idea is to make groups of items based on the item\u2019s features. Note, as the data is not labeled, the grouping could be completely different from the user\u2019s expectations. Each clustering algorithm has its own internal similarity function and grouping strategy by which the clusters are formed.","title":"Unsupervised Learning"},{"location":"machine_learning/introduction/#semi-supervised-learning","text":"It is a machine learning approach wherein we use labeled and unlabeled data to train a model. The intention is that the resulting model will be better than one learned over the labeled (supervised) or unlabeled data (unsupervised) alone. Hence it falls between the two methods. We can try semi-supervised learning when we have very little labeled data but a lot of unlabeled data, and if the cost or time of labeling is too high. We start with training a model on the labeled data. Then the model is used to make predictions on the unlabeled data. Specific unlabeled data are picked and their prediction is considered true. The selection criteria could be some threshold on the prediction probability or top K selection. These selected unlabeled data with the prediction are added to the labeled data set and the next iteration of training begins. This goes on till n-iterations . Note This process is also called Pseudo-labelling, as we are creating pseudo labels on unlabeled dataset using the model trained on only labeled data.","title":"Semi-Supervised Learning"},{"location":"machine_learning/introduction/#reinforcement-learning","text":"It is a machine learning approach wherein we train agent(s) to interact with an environment to achieve certain goal. The goal is quantified by providing the agent with some positive reward on successful completion or negative reward incase of failure. The main components in RL are agents, environment and actions. Agents are the intelligent model we want to improve over time. Environment is the simulation where the agent performs some actions. Once an agent takes an action, the state of the agent changes. Based on the environment, the agent could get instant reward for each action or delayed reward on completion of an episode (sequence of actions).","title":"Reinforcement Learning"},{"location":"machine_learning/introduction/#self-supervised-learning","text":"It is a machine learning approach wherein we create supervisory signals from the unlabeled data itself, often leveraging the underlying structure in the data. The idea is to take unlabeled data and create generic tasks, that could be different from the intended downstream task but will help model learn the fundamentals. Then the model could be fine-tuned for the specific downstream task easily with very less labeled data. It is closely connected to how humans learn \u2014 as human normally first develop common sense (a general understanding of the world) and then learn specific tasks quite easily (when comparing to machines). It is becoming a norm in the AI field to train large models using self-supervised learning, as the resulting models are generalist ie. could be used for multiple downstream tasks. The method of training vary wrt the datatype. For example, in NLP, we can hide part of a sentence and predict the hidden words from the remaining words. In CV, we can predict past or future frames in a video (hidden data) from current ones (observed data). Same could be done for Audio.","title":"Self-supervised Learning"},{"location":"machine_learning/introduction/#additional-techniques","text":"","title":"Additional Techniques"},{"location":"machine_learning/introduction/#active-learning","text":"Active learning is all about selecting the minimal set of training data that will lead to the maximum performance gain. Active learning could have following use cases, Lots of labeled data: If you have lots of annotated data but you are contraint by time or computation power, you can try to select the smallest set of labeled data to train the model on. This is easy to understand as not all samples have equal contribution in training the model. Thinking intuitively, say for a linear classifier with straight line as the decision boundary, keeping data near the decision line will lead to better overall accuracy than the ones near the end or in middle of cluster of datapoints. Lots of unlabeled data: In this case, active learning is very similar to Semi-supervised learning, with only one twist - we ask humans to label again, instead of labeling using the model. The process starts similar to pseudo labelling and we train the model on the available labeled dataset. Then the trained model is used to make prediction on the unlabeled data and using preferred logic, we suggest the next batch of datasets that should be labeled by human expert. We keep iterating unless the desired accuracy is reached.","title":"Active Learning"},{"location":"machine_learning/introduction/#transfer-learning","text":"Transfer learning is all about using the knowledge gained while solving one problem to solve another problem. From a practical perspective, we reuse (either as it is or by finetining) an existing base model that was trained for say Task A, for another tasks like B, C, etc. This approach could be prefered is we don't want to train a model from scratch. For example, if we have a pretrained model that can classify cat vs dogs, it will be easier, in terms of training iterations and even number of required samples, to train for other classes like lion vs elephant. Here, the intuition is that the exsiting image classification model should have gained some knowledge about the important features of animal images. And even though the classes were completely different, it should be mich better and easier than training a new model with new weight initialization. Note There are several ways on how we can use transfer learning to make an existing model work for another task. These could be, (1) Finetune the complete model, (2) Freeze certains layers (preferably the starting one) and then finetune, (3) Replace certains layers (preferably the ending one -- like classification head) and then finetune, or (4) Freeze the complete model and just train additional heads for different downstream tasks.","title":"Transfer learning"},{"location":"machine_learning/introduction/#additional-materials","text":"14 Different Types of Learning in Machine Learning Semi-Supervised Wikipedia and Semi-Supervised Sklearn Self-supervised learning: The dark matter of intelligence Transfer Learning - Machine Learning Mastery","title":"Additional materials"},{"location":"machine_learning/loss_functions/","text":"Note This page is still not complete and new sections might get added later. That said, the existing content is ready to be consumed. \ud83c\udf54 Introduction Loss functions are the \"ideal objectives\" that neural networks (NN) tries to optimize. In fact, they are the mathematical personification of what we want to achieve with the NN. As the name suggests, it is a function that takes input and compute a loss value that determines how further away the current model is from the ideal model for that example. In an ideal world, we would expect the loss value to be 0, but in reality it could get very close to 0. We also have cost functions that is nothing but aggrgation of the loss functions over a batch or complete dataset. The cost function is the function that we use in practice to optimize the model. Hint Loss functions --> loss on one example Cost functions --> loss on entire dataset or a batch Types of Loss functions Selecting a loss function for your NN depends a lot on your use case and even the type of data you are working with. For example, in case of regression, you can use MSE loss function. In case of classification, you can use Cross Entropy loss function. Here, we will go through some examples of loss functions. MAE (L1 loss) Mean Absolute Error (MAE) loss function is used to calculate regression loss. Due to the presence of absolute term instead of square, it is more robust to outliers. It is differentiable at all points expect when predicted target value equals true target value. The actual formula is shown below, \\[{\\displaystyle \\mathrm {MAE_{loss}}(i) ={\\left|y_{i}-\\hat {y_{i}}\\right|}}\\] \\[{\\displaystyle \\mathrm {MAE_{cost}} ={\\frac {1}{n}{\\sum _{i=1}^{n} \\mathrm{MAE_loss}(i)}}}\\] MSE (L2 loss) Mean Squared Error (MSE) loss function is used to measure the difference between the predicted value and the actual value. Basically it is the mean squared euclidean distance. It is most widely used loss function for regression tasks and representation (embedding) similarity task. The actual formuale is shown below, \\[{\\displaystyle \\operatorname {MSE_loss}(i) = (y_{i}-{\\hat {y_{i}}})^{2}}\\] \\[{\\displaystyle \\operatorname {MSE_cost} ={\\frac {1}{n}}\\sum _{i=1}^{n}\\operatorname {MSE_loss}(i)}\\] The MSE cost function is less resistant to outliers since the loss function squares big mistakes in order to punish the model. As a result, if the data is prone to many outliers, you shouldn't utilise L2 loss. Cross entropy loss Cross entropy loss is used for classification tasks. It is a simplification of Kullback\u2013Leibler divergence that is used to compute the difference between two probability distributions (here the model's prediction and true one) . For binary classification the formula is shown below, ( \\(y\\) is the actual class and \\(\\hat{y}\\) is the predicted class) \\[{\\displaystyle \\operatorname {CrossEntropy_loss}(i) = -(y_i \\log(\\hat{y_i})+(1-y_i) \\log(1-\\hat{y_i}))}\\] \\[{\\displaystyle \\operatorname {CrossEntropy_cost} ={\\frac {1}{n}}\\sum _{i=1}^{n}\\operatorname {CrossEntropy_loss}(i)}\\] For binary classification, \\(y_i\\) can be either 0 or 1. Let's go through the different possibilities, if \\(y_i=1\\) , the loss function reduces to only the left part i.e. \\(-y_i \\log(\\hat{y_i})\\) now to have a small loss, model would want the \\(\\log(\\hat{y_i})\\) to be large (bcoz of negative sign) . for this, model will make \\(\\hat{y_i}\\) large (ideally 1) if \\(y_i=0\\) , the loss function reduces to only the right part i.e. \\(-(1-y_i) \\log(1-\\hat{y_i})\\) now to have a small loss, model would want the \\(\\log(1 - \\hat{y_i})\\) to be large (bcoz of negative sign) . for this, model will make \\(\\hat{y_i}\\) small (ideally 0) Note For both the cases we want to make sure that \\(\\hat{y_i}\\) is bounded between 0 and 1. For this, usually the output of model is passed through some activation function like sigmoid. Additionally, some people may argue why not use a simple \\((\\hat{y}-y)^2\\) as the loss function for classification task. The major problem is that with this loss function the optimization becomes non convex hence the model will not converge. Above we can see loss function graph plotted for both the cases, Red line is for case when \\(y_i=1\\) . The line is plotted for \\(x=-y_i \\log(\\hat{y_i})\\) . As we want the loss to be zero, it is only possible for \\(y_i=1\\) . Blue line is for case when \\(y_i=0\\) . The line is plotted for \\(x=-(1-y_i) \\log(1-\\hat{y_i})\\) . As we want the loss to be zero, it is only possible for \\(y_i=0\\) . Hint Refer this excellent video from AndrewNg on CrossEntropyLoss for more details. References [1] Triplet Loss and Online Triplet Mining in TensorFlow [2] The 7 Most Common Machine Learning Loss Functions","title":"Loss functions"},{"location":"machine_learning/loss_functions/#introduction","text":"Loss functions are the \"ideal objectives\" that neural networks (NN) tries to optimize. In fact, they are the mathematical personification of what we want to achieve with the NN. As the name suggests, it is a function that takes input and compute a loss value that determines how further away the current model is from the ideal model for that example. In an ideal world, we would expect the loss value to be 0, but in reality it could get very close to 0. We also have cost functions that is nothing but aggrgation of the loss functions over a batch or complete dataset. The cost function is the function that we use in practice to optimize the model. Hint Loss functions --> loss on one example Cost functions --> loss on entire dataset or a batch","title":"Introduction"},{"location":"machine_learning/loss_functions/#types-of-loss-functions","text":"Selecting a loss function for your NN depends a lot on your use case and even the type of data you are working with. For example, in case of regression, you can use MSE loss function. In case of classification, you can use Cross Entropy loss function. Here, we will go through some examples of loss functions.","title":"Types of Loss functions"},{"location":"machine_learning/loss_functions/#mae-l1-loss","text":"Mean Absolute Error (MAE) loss function is used to calculate regression loss. Due to the presence of absolute term instead of square, it is more robust to outliers. It is differentiable at all points expect when predicted target value equals true target value. The actual formula is shown below, \\[{\\displaystyle \\mathrm {MAE_{loss}}(i) ={\\left|y_{i}-\\hat {y_{i}}\\right|}}\\] \\[{\\displaystyle \\mathrm {MAE_{cost}} ={\\frac {1}{n}{\\sum _{i=1}^{n} \\mathrm{MAE_loss}(i)}}}\\]","title":"MAE (L1 loss)"},{"location":"machine_learning/loss_functions/#mse-l2-loss","text":"Mean Squared Error (MSE) loss function is used to measure the difference between the predicted value and the actual value. Basically it is the mean squared euclidean distance. It is most widely used loss function for regression tasks and representation (embedding) similarity task. The actual formuale is shown below, \\[{\\displaystyle \\operatorname {MSE_loss}(i) = (y_{i}-{\\hat {y_{i}}})^{2}}\\] \\[{\\displaystyle \\operatorname {MSE_cost} ={\\frac {1}{n}}\\sum _{i=1}^{n}\\operatorname {MSE_loss}(i)}\\] The MSE cost function is less resistant to outliers since the loss function squares big mistakes in order to punish the model. As a result, if the data is prone to many outliers, you shouldn't utilise L2 loss.","title":"MSE (L2 loss)"},{"location":"machine_learning/loss_functions/#cross-entropy-loss","text":"Cross entropy loss is used for classification tasks. It is a simplification of Kullback\u2013Leibler divergence that is used to compute the difference between two probability distributions (here the model's prediction and true one) . For binary classification the formula is shown below, ( \\(y\\) is the actual class and \\(\\hat{y}\\) is the predicted class) \\[{\\displaystyle \\operatorname {CrossEntropy_loss}(i) = -(y_i \\log(\\hat{y_i})+(1-y_i) \\log(1-\\hat{y_i}))}\\] \\[{\\displaystyle \\operatorname {CrossEntropy_cost} ={\\frac {1}{n}}\\sum _{i=1}^{n}\\operatorname {CrossEntropy_loss}(i)}\\] For binary classification, \\(y_i\\) can be either 0 or 1. Let's go through the different possibilities, if \\(y_i=1\\) , the loss function reduces to only the left part i.e. \\(-y_i \\log(\\hat{y_i})\\) now to have a small loss, model would want the \\(\\log(\\hat{y_i})\\) to be large (bcoz of negative sign) . for this, model will make \\(\\hat{y_i}\\) large (ideally 1) if \\(y_i=0\\) , the loss function reduces to only the right part i.e. \\(-(1-y_i) \\log(1-\\hat{y_i})\\) now to have a small loss, model would want the \\(\\log(1 - \\hat{y_i})\\) to be large (bcoz of negative sign) . for this, model will make \\(\\hat{y_i}\\) small (ideally 0) Note For both the cases we want to make sure that \\(\\hat{y_i}\\) is bounded between 0 and 1. For this, usually the output of model is passed through some activation function like sigmoid. Additionally, some people may argue why not use a simple \\((\\hat{y}-y)^2\\) as the loss function for classification task. The major problem is that with this loss function the optimization becomes non convex hence the model will not converge. Above we can see loss function graph plotted for both the cases, Red line is for case when \\(y_i=1\\) . The line is plotted for \\(x=-y_i \\log(\\hat{y_i})\\) . As we want the loss to be zero, it is only possible for \\(y_i=1\\) . Blue line is for case when \\(y_i=0\\) . The line is plotted for \\(x=-(1-y_i) \\log(1-\\hat{y_i})\\) . As we want the loss to be zero, it is only possible for \\(y_i=0\\) . Hint Refer this excellent video from AndrewNg on CrossEntropyLoss for more details.","title":"Cross entropy loss"},{"location":"machine_learning/loss_functions/#references","text":"[1] Triplet Loss and Online Triplet Mining in TensorFlow [2] The 7 Most Common Machine Learning Loss Functions","title":"References"},{"location":"machine_learning/model_compression_intro/","text":"Model Compression Introduction Introduction Large Deep Learning models provide high accuracy for majority of tasks, but they compromise with speed. This could be a deal breaker for industrial use case, where sometimes hundreds or thousands of inferences needs to be made in short amount of time. In fact we have two major problems to solve here, and let's take a detour to explore what can be done about them from the AIOps perspective (i.e. not involving Data Scientists at all) , Slower model leading to high inference time . To solve this issue we can, Use more powerful compute: just use newer and faster machine! \ud83d\ude0e Use GPU or TPU compute: use GPU computes (if only using CPU till now) to enhance Deep learning models performance due to faster matrix juggling by GPUs. High demand leading to a lots of inference request in short amount of time. To solve this issue we can, Multi Threading : if your system performs some I/O calls or DB calls or 3rd party API polling, multi threading could be the way to improve inference speed. Basically, while one thread is busy perfoming asyncronous task, another task can take over and start running. Multi Processing : we can utilize multiple cores of a compute to create multiple processes, each working independently of each other. Note Multi-processing is a memory (or GPU) consuming task. This is because if you create 4 workers (4 processes), OS will create 4 copies of your model! For a 1GB model, 4GB will be consumed just to keep the system up and running. Multi Instances : if you are using K8, just create multiple nodes of the code. It's like creating multiple copies of the code and running them independently on different computes. Note Multi Instances is a costly task, as each new replication needs a new compute which will increase the overall cost. All of the above proposed solutions have one major flaw -- it will cost you money \ud83d\udcb0 and that too on a recurrent basis if you plan to keep the model running for months. On top of it, all of these are not the \"Data Scientist\" way of tacking the problem \ud83d\ude0a Can we do something more scientific? \ud83e\udd14 Enter model compression techniques, where the intuition is to reduce the size of the model which will inherently increase the speed of the inference (or training) . And do this with minimal compromise on the accuracy! Note Please understand that the main assumption before applying model compression techniques is that to create a good smaller model, it is more optimal (in terms of either cost, time, data or accuracy) to utilize an existing good bigger model, rather than training the smaller model from scratch on the same data. From another perspective, people might argue that if they have sufficient compute and data, why not just train a smaller model from scratch? A counter argument could be that for the same data, a bigger model will most likely always provide better accuracy, so using a bigger model to distil a smaller model might induce some additional knowledge from the teacher model or at the least drastically reduce the learning time. Types of Model compression At a high level, there are following types of model compression. We will go through them one by one. Knowledge Distillation : in these methods, we distil the learned information (or knowledge) from one neural network model (generally larger) to another model (generally smaller) . Quantization : in these methods, we transform the data type used to represent the weights and activations of Neural networks which leads to reduction in memory consumption. Parameter Pruning and Sharing : in these methods, we remove the non-essential parameters from a neural network with minimal to no effect on the overall performance. ( Lazy Data Scientist at work - \ud83d\ude34) We will discuss each of these methods in detail in the next sections.","title":"Introduction"},{"location":"machine_learning/model_compression_intro/#model-compression-introduction","text":"","title":"Model Compression Introduction"},{"location":"machine_learning/model_compression_intro/#introduction","text":"Large Deep Learning models provide high accuracy for majority of tasks, but they compromise with speed. This could be a deal breaker for industrial use case, where sometimes hundreds or thousands of inferences needs to be made in short amount of time. In fact we have two major problems to solve here, and let's take a detour to explore what can be done about them from the AIOps perspective (i.e. not involving Data Scientists at all) , Slower model leading to high inference time . To solve this issue we can, Use more powerful compute: just use newer and faster machine! \ud83d\ude0e Use GPU or TPU compute: use GPU computes (if only using CPU till now) to enhance Deep learning models performance due to faster matrix juggling by GPUs. High demand leading to a lots of inference request in short amount of time. To solve this issue we can, Multi Threading : if your system performs some I/O calls or DB calls or 3rd party API polling, multi threading could be the way to improve inference speed. Basically, while one thread is busy perfoming asyncronous task, another task can take over and start running. Multi Processing : we can utilize multiple cores of a compute to create multiple processes, each working independently of each other. Note Multi-processing is a memory (or GPU) consuming task. This is because if you create 4 workers (4 processes), OS will create 4 copies of your model! For a 1GB model, 4GB will be consumed just to keep the system up and running. Multi Instances : if you are using K8, just create multiple nodes of the code. It's like creating multiple copies of the code and running them independently on different computes. Note Multi Instances is a costly task, as each new replication needs a new compute which will increase the overall cost. All of the above proposed solutions have one major flaw -- it will cost you money \ud83d\udcb0 and that too on a recurrent basis if you plan to keep the model running for months. On top of it, all of these are not the \"Data Scientist\" way of tacking the problem \ud83d\ude0a Can we do something more scientific? \ud83e\udd14 Enter model compression techniques, where the intuition is to reduce the size of the model which will inherently increase the speed of the inference (or training) . And do this with minimal compromise on the accuracy! Note Please understand that the main assumption before applying model compression techniques is that to create a good smaller model, it is more optimal (in terms of either cost, time, data or accuracy) to utilize an existing good bigger model, rather than training the smaller model from scratch on the same data. From another perspective, people might argue that if they have sufficient compute and data, why not just train a smaller model from scratch? A counter argument could be that for the same data, a bigger model will most likely always provide better accuracy, so using a bigger model to distil a smaller model might induce some additional knowledge from the teacher model or at the least drastically reduce the learning time.","title":"Introduction"},{"location":"machine_learning/model_compression_intro/#types-of-model-compression","text":"At a high level, there are following types of model compression. We will go through them one by one. Knowledge Distillation : in these methods, we distil the learned information (or knowledge) from one neural network model (generally larger) to another model (generally smaller) . Quantization : in these methods, we transform the data type used to represent the weights and activations of Neural networks which leads to reduction in memory consumption. Parameter Pruning and Sharing : in these methods, we remove the non-essential parameters from a neural network with minimal to no effect on the overall performance. ( Lazy Data Scientist at work - \ud83d\ude34) We will discuss each of these methods in detail in the next sections.","title":"Types of Model compression"},{"location":"machine_learning/model_compression_kd/","text":"Introduction Teacher with a student. Source: DallE The main idea in Knowledge Distillation (KD) is to make a smaller model (student model) mimic the larger model (teacher model) . This could lead to student model having competitive or sometimes even superior performance than teacher model. In generic sense, the distillation process is like this -- first, the teacher model is trained on the training data to learn the task-specific features, and then the student model is trained to mimic the teacher model by paying attention to certain characteristics (or knowledge ) of the teacher model. Note Remember there will always be a compromise between speed and accuracy. As you decrease the size of model (by model compression techniques) the accuracy will also drop. The science here is to make sure that decrease in size is drastic whereas that in accuracy is not too drastic. And this relationship must be kept in mind before making the choice to do KD. For example, in certain use case related to medical domain, accuracy is of upmost importance and developers should be aware of the associated risks. To better understand the different ways of performing KD, we should first understand two things - (1) knowledge, and (2) distillation schemes. Let's go through them one by one. Types of Knowledge Before we start to distil knowledge, we should first define and understand what is meant by \"knowledge\" in context of neural network -- is it the prediction OR the activation parameters OR activations for one input OR maybe multiple inputs? Once we know this, we can try to teach student model to mimic that particular characterisitics of the teacher model. Based on this intuition, let's categorize knowledge and respective distillation techniques. Different types of knowledge in Deep teacher network. [1] Response Based Knowledge Here, we define the final layer output of the teacher model as the knowledge, so the idea is to train a student model that will mimic the final prediction of the teacher model. For example, for a cat vs dog image classification model, if the teacher model classifies an image as 'Cat', a good student model should also learn from the same classification and vice-versa. Now the final predictions could also be of multiple types - logits (the model output) , soft targets (the class probabilities) or hard targets (the class enums) ( refer ). Developers can select any of the prediction types, but usually soft targets are preferred , as they contain more information than hard target and are not as specific or architecture dependent as logits. Technically, we first predict the responses of student and teacher model on a sample, then compute the distillation loss on the difference between the logits (or other prediction) values generated by both. The distillation loss is denoted by \\(L_R(z_t, z_s)\\) where \\(L_R()\\) denotes the divergence loss and \\(z_t\\) and \\(z_s\\) denotes logits of teacher and student models respectively. In case of soft targets, we compute the probability of logits of one class wrt to other classes using softmax function, \\[p(z_i,T) = \\frac{exp(z_i/T)}{\\sum{}_j exp(z_j/T)}\\] and the distillation loss becomes \\(L_R(p(z_t,T),p(z_s,T))\\) which often employs Kullback-Leibler divergence loss. Note, here \\(T\\) is the temperature . In terms of final loss, researchers also recommend complimenting distillation loss with student loss which could be cross-entropy loss ( \\(L_{CE}(y, p(z_s, T=1))\\) ) between the ground truth label and soft logits of the student model. Feature Based Knowledge Here, we define the feature activations (present in the intermediate layers) of the teacher model as the knowledge. This is in line with the intuition of representation learning or feature learning. Hence, the main idea is to match the feature activations of one or more intermediate layers of the teacher and student model. The distillation loss for feature-based knowledge transfer is given below, where, \\(f_t(x)\\) and \\(f_s(x)\\) are feature map of intermediate layers of teacher and student model respectively. \\(\u03a6_t(.)\\) and \\(\u03a6_s(.)\\) are the transformation functions used when the teacher and student model are not of the same shape. Finally, \\(L_F()\\) is the similarity function used to match the feature map of the teacher and student model. \\[L_{F_{ea}D}(f_t(x), f_s(x)) = L_F(\u03a6_t(f_t(x)),\u03a6_s(f_s(x)))\\] Note Easier said than done, there are some open research questions when using feature based knowledge, Which intermediate layers to choose? (i.e. \\(f_t(x)\\) and \\(f_s(x)\\) ) How to match the feature representation of teacher and student models? (i.e. \\(L_F()\\) ) Relation Based Knowledge Here, we define knowledge as the relationship among different representations for the same data sample or even across different data samples. This representation can again be either from intermediate layer (feature-based) or output layer (response-based) . The intuition here is that looking across multiple layers or data samples at the same time could highlight some hidden pattern or structure which will be useful for student model to learn. Consider the classical King - Man + Women = Queen notation, which when represented as word embedding and visualized in the embedding space showcase directional pattern. The idea here is to learn this pattern rather than individual details of the representation. The distillation loss can be expressed as shown below, where \\(x_i\\) is one input sampled from \\(X^N\\) , \\(f_T(.)\\) and \\(s_T(.)\\) can be defined as the intermediate or output layer values of the teacher and student model respectively (wrt to an input) , \\(t_i=f_T(x_i)\\) and \\(s_i=f_s(x_i)\\) , \\(\\psi\\) is a relationship potential function (like a similarity function) and \\(l\\) is the loss that penalize difference between the teacher and the student. \\[L_{RKD} = \\sum_{(x_1, ... , x_n) \\epsilon X^N} l(\\psi(t_1, ..., t_n), \\psi(s_1, ..., s_n))\\] Note Response-based and Feature-based approaches are collectively called Individual Knowledge Distillation as they transfer knowledge from individual outputs of the teacher to student. This is in contrast with Relational Knowledge Distillation which extracts knowledge using relationships between different outputs of the teacher and student models. Distillation Schemes Different distillation schemes. [1] Offline Distillation This is the classical KD scheme, and as the name suggests, the transfer of knowledge happens in an offline fashion wherein the knowledge is transferred from a pre-trained teacher model to the student model (one-way only) . The complete training process has two stages, First, a large teacher model is trained on a big set of training samples before distillation. This process is time and money intensive; and Second, the teacher model is used to extract the knowledge in the form of logits or the intermediate features, which are then used to guide the training of the student model during distillation. Online Distillation Online knowledge distillation, is used to transfer knowledge from a larger model to a smaller one in a continuous and sequential manner. This method involves live training of both the teacher and student models, and the whole knowledge distillation framework is end-to-end trainable. As new data becomes available, the teacher model is updated in real-time, and the student model learns from the teacher's updated output. This dynamic learning process enables the student model to continually improve its performance, ensuring it remains aligned with the latest insights from the teacher model. This makes the approach suitable for cases when large-capacity high performance teacher model is not available , or when the data is continuously changing. Self-Distillation There are several challenges in online or offline distillation process, like (1) which teacher model to choose (the most accurate one is not always the better one) , (2) the student model always has a degraded performance wrt the teacher model. Self Distillation is a special case of online distillation wherein the same network is utilised for both teacher and student roles. To be more exact, the knowledge from the deeper sections of the network is distilled into its shallow sections. For this the network utilizes the attention maps of its own layers as distillation targets for its lower layers. There are even some special cases where knowledge in the earlier epochs of the network (teacher) is transfered into its later epochs (student) . Hint A very good analogy of comparing KD schemes wrt human teacher-student is provided in [1] as follows, \"Offline distillation means the knowledgeable teacher teaches a student knowledge; online distillation means both teacher and student study together with each other; self-distillation means student learn knowledge by oneself.\" Teacher-Student Architecture Relationship of the teacher and student models [1] The teacher-student architecture plays a crucial role in knowledge distillation. The design of both the teacher and student networks is vital for effective knowledge transfer. In traditional approaches, student networks are simplified versions of teachers, quantized structures, or small networks optimized for basic operations. However, the model capacity gap between large teachers and small students can hinder knowledge transfer. Various methods have been developed to address this issue, including teacher assistants, residual learning, and structural compression. Some methods aim to minimize the structural differences between teachers and students. Additionally, depth-wise separable convolution and neural architecture search have been employed to design efficient networks for mobile and embedded devices. The future of knowledge distillation might involve an adaptive teacher-student learning architecture, where neural architecture search is used to optimize both student structure and knowledge transfer. This joint search guided by the teacher model is an interesting avenue for further research in the field. References [1] J Gou et al. - Knowledge Distillation: A Survey [2] Relational Knowledge Distillation","title":"Knowledge Distillation"},{"location":"machine_learning/model_compression_kd/#introduction","text":"Teacher with a student. Source: DallE The main idea in Knowledge Distillation (KD) is to make a smaller model (student model) mimic the larger model (teacher model) . This could lead to student model having competitive or sometimes even superior performance than teacher model. In generic sense, the distillation process is like this -- first, the teacher model is trained on the training data to learn the task-specific features, and then the student model is trained to mimic the teacher model by paying attention to certain characteristics (or knowledge ) of the teacher model. Note Remember there will always be a compromise between speed and accuracy. As you decrease the size of model (by model compression techniques) the accuracy will also drop. The science here is to make sure that decrease in size is drastic whereas that in accuracy is not too drastic. And this relationship must be kept in mind before making the choice to do KD. For example, in certain use case related to medical domain, accuracy is of upmost importance and developers should be aware of the associated risks. To better understand the different ways of performing KD, we should first understand two things - (1) knowledge, and (2) distillation schemes. Let's go through them one by one.","title":"Introduction"},{"location":"machine_learning/model_compression_kd/#types-of-knowledge","text":"Before we start to distil knowledge, we should first define and understand what is meant by \"knowledge\" in context of neural network -- is it the prediction OR the activation parameters OR activations for one input OR maybe multiple inputs? Once we know this, we can try to teach student model to mimic that particular characterisitics of the teacher model. Based on this intuition, let's categorize knowledge and respective distillation techniques. Different types of knowledge in Deep teacher network. [1]","title":"Types of Knowledge"},{"location":"machine_learning/model_compression_kd/#response-based-knowledge","text":"Here, we define the final layer output of the teacher model as the knowledge, so the idea is to train a student model that will mimic the final prediction of the teacher model. For example, for a cat vs dog image classification model, if the teacher model classifies an image as 'Cat', a good student model should also learn from the same classification and vice-versa. Now the final predictions could also be of multiple types - logits (the model output) , soft targets (the class probabilities) or hard targets (the class enums) ( refer ). Developers can select any of the prediction types, but usually soft targets are preferred , as they contain more information than hard target and are not as specific or architecture dependent as logits. Technically, we first predict the responses of student and teacher model on a sample, then compute the distillation loss on the difference between the logits (or other prediction) values generated by both. The distillation loss is denoted by \\(L_R(z_t, z_s)\\) where \\(L_R()\\) denotes the divergence loss and \\(z_t\\) and \\(z_s\\) denotes logits of teacher and student models respectively. In case of soft targets, we compute the probability of logits of one class wrt to other classes using softmax function, \\[p(z_i,T) = \\frac{exp(z_i/T)}{\\sum{}_j exp(z_j/T)}\\] and the distillation loss becomes \\(L_R(p(z_t,T),p(z_s,T))\\) which often employs Kullback-Leibler divergence loss. Note, here \\(T\\) is the temperature . In terms of final loss, researchers also recommend complimenting distillation loss with student loss which could be cross-entropy loss ( \\(L_{CE}(y, p(z_s, T=1))\\) ) between the ground truth label and soft logits of the student model.","title":"Response Based Knowledge"},{"location":"machine_learning/model_compression_kd/#feature-based-knowledge","text":"Here, we define the feature activations (present in the intermediate layers) of the teacher model as the knowledge. This is in line with the intuition of representation learning or feature learning. Hence, the main idea is to match the feature activations of one or more intermediate layers of the teacher and student model. The distillation loss for feature-based knowledge transfer is given below, where, \\(f_t(x)\\) and \\(f_s(x)\\) are feature map of intermediate layers of teacher and student model respectively. \\(\u03a6_t(.)\\) and \\(\u03a6_s(.)\\) are the transformation functions used when the teacher and student model are not of the same shape. Finally, \\(L_F()\\) is the similarity function used to match the feature map of the teacher and student model. \\[L_{F_{ea}D}(f_t(x), f_s(x)) = L_F(\u03a6_t(f_t(x)),\u03a6_s(f_s(x)))\\] Note Easier said than done, there are some open research questions when using feature based knowledge, Which intermediate layers to choose? (i.e. \\(f_t(x)\\) and \\(f_s(x)\\) ) How to match the feature representation of teacher and student models? (i.e. \\(L_F()\\) )","title":"Feature Based Knowledge"},{"location":"machine_learning/model_compression_kd/#relation-based-knowledge","text":"Here, we define knowledge as the relationship among different representations for the same data sample or even across different data samples. This representation can again be either from intermediate layer (feature-based) or output layer (response-based) . The intuition here is that looking across multiple layers or data samples at the same time could highlight some hidden pattern or structure which will be useful for student model to learn. Consider the classical King - Man + Women = Queen notation, which when represented as word embedding and visualized in the embedding space showcase directional pattern. The idea here is to learn this pattern rather than individual details of the representation. The distillation loss can be expressed as shown below, where \\(x_i\\) is one input sampled from \\(X^N\\) , \\(f_T(.)\\) and \\(s_T(.)\\) can be defined as the intermediate or output layer values of the teacher and student model respectively (wrt to an input) , \\(t_i=f_T(x_i)\\) and \\(s_i=f_s(x_i)\\) , \\(\\psi\\) is a relationship potential function (like a similarity function) and \\(l\\) is the loss that penalize difference between the teacher and the student. \\[L_{RKD} = \\sum_{(x_1, ... , x_n) \\epsilon X^N} l(\\psi(t_1, ..., t_n), \\psi(s_1, ..., s_n))\\] Note Response-based and Feature-based approaches are collectively called Individual Knowledge Distillation as they transfer knowledge from individual outputs of the teacher to student. This is in contrast with Relational Knowledge Distillation which extracts knowledge using relationships between different outputs of the teacher and student models.","title":"Relation Based Knowledge"},{"location":"machine_learning/model_compression_kd/#distillation-schemes","text":"Different distillation schemes. [1]","title":"Distillation Schemes"},{"location":"machine_learning/model_compression_kd/#offline-distillation","text":"This is the classical KD scheme, and as the name suggests, the transfer of knowledge happens in an offline fashion wherein the knowledge is transferred from a pre-trained teacher model to the student model (one-way only) . The complete training process has two stages, First, a large teacher model is trained on a big set of training samples before distillation. This process is time and money intensive; and Second, the teacher model is used to extract the knowledge in the form of logits or the intermediate features, which are then used to guide the training of the student model during distillation.","title":"Offline Distillation"},{"location":"machine_learning/model_compression_kd/#online-distillation","text":"Online knowledge distillation, is used to transfer knowledge from a larger model to a smaller one in a continuous and sequential manner. This method involves live training of both the teacher and student models, and the whole knowledge distillation framework is end-to-end trainable. As new data becomes available, the teacher model is updated in real-time, and the student model learns from the teacher's updated output. This dynamic learning process enables the student model to continually improve its performance, ensuring it remains aligned with the latest insights from the teacher model. This makes the approach suitable for cases when large-capacity high performance teacher model is not available , or when the data is continuously changing.","title":"Online Distillation"},{"location":"machine_learning/model_compression_kd/#self-distillation","text":"There are several challenges in online or offline distillation process, like (1) which teacher model to choose (the most accurate one is not always the better one) , (2) the student model always has a degraded performance wrt the teacher model. Self Distillation is a special case of online distillation wherein the same network is utilised for both teacher and student roles. To be more exact, the knowledge from the deeper sections of the network is distilled into its shallow sections. For this the network utilizes the attention maps of its own layers as distillation targets for its lower layers. There are even some special cases where knowledge in the earlier epochs of the network (teacher) is transfered into its later epochs (student) . Hint A very good analogy of comparing KD schemes wrt human teacher-student is provided in [1] as follows, \"Offline distillation means the knowledgeable teacher teaches a student knowledge; online distillation means both teacher and student study together with each other; self-distillation means student learn knowledge by oneself.\"","title":"Self-Distillation"},{"location":"machine_learning/model_compression_kd/#teacher-student-architecture","text":"Relationship of the teacher and student models [1] The teacher-student architecture plays a crucial role in knowledge distillation. The design of both the teacher and student networks is vital for effective knowledge transfer. In traditional approaches, student networks are simplified versions of teachers, quantized structures, or small networks optimized for basic operations. However, the model capacity gap between large teachers and small students can hinder knowledge transfer. Various methods have been developed to address this issue, including teacher assistants, residual learning, and structural compression. Some methods aim to minimize the structural differences between teachers and students. Additionally, depth-wise separable convolution and neural architecture search have been employed to design efficient networks for mobile and embedded devices. The future of knowledge distillation might involve an adaptive teacher-student learning architecture, where neural architecture search is used to optimize both student structure and knowledge transfer. This joint search guided by the teacher model is an interesting avenue for further research in the field.","title":"Teacher-Student Architecture"},{"location":"machine_learning/model_compression_kd/#references","text":"[1] J Gou et al. - Knowledge Distillation: A Survey [2] Relational Knowledge Distillation","title":"References"},{"location":"machine_learning/model_compression_quant/","text":"Introduction Quantization is a technique that has been used in digital computing for a long time. It involves compressing data by converting a continuous signal or data set into a discrete set of values or levels. Neural Networks (NNs) present unique challenges and opportunities in the context of quantization. Firstly, both inference and training of NNs require significant computational resources, making the efficient representation of numerical values crucial. Secondly, many current NN models are highly over-parameterized, allowing scope for techniques that could reduce bit precision without sacrificing accuracy. However, an important distinction is that NNs exhibit remarkable resilience to aggressive quantization and extreme discretization. That said, by moving from floating-point representations to low-precision fixed integer values represented in four bits or less, it is possible to significantly reduce memory footprint and latency. In fact, reductions of 4x to 8x are often observed in practice in these applications. This article serves as a beginner-friendly introduction to quantization in deep learning. Data Types and Representations Before diving into the topic, let\u2019s understand the importance and advantages of using smaller data-type representations. Neural Nets consists of weights which are matrices of numbers, where each number is mostly represented in float32 data type. This means each number\u2019s size is 32 bits (4 bytes) and an average-sized LLM of 7B parameters (like LLaMA) will have a size around 7 * 10^9 * 4 = 28GB! This is vRAM required just for inference, and for training, you might need 2x more memory as the system needs to store gradients as well. (For finetuning, the memory requirements depend on which optimizer we are using. AdamW needs 8 bytes per parameter) . Now if we can use half-precision ( float16 ) our memory requirements are reduced by half and for much advanced 8-bit representation it becomes just 1/4th of the original requirement! Below is a table with different data types, their ranges, size and more details. Data Type Min Max Range Bits Accumulation Data Type uint8 0 255 0-255 8 uint16 int8 -128 127 -128 to 127 8 int16 uint16 0 65535 0-65535 16 uint32 int16 -32768 32767 -32768 to 32767 16 int32 uint32 0 4294967295 0-4294967295 32 uint64 int32 -2147483648 2147483647 -2147483648 to 2147483647 32 int64 uint64 0 18446744073709551615 0-18446744073709551615 64 uint64 int64 -9223372036854775808 9223372036854775807 -9223372036854775808 to 9223372036854775807 64 int64 float16 -65504 65504 -65504 to 65504 16 float32 float32 -3.4028235E+38 3.4028235E+38 -3.4028235E+38 to 3.4028235E+38 32 float64 float64 -1.7976931348623157E+308 1.7976931348623157E+308 -1.7976931348623157E+308 to 1.7976931348623157E+308 64 float128 Note float128 isn't a standard data type in many environments, and the accumulation type for some might vary based on the context or platform. For float types, the range values typically represent the maximum magnitude, not the precise range of normal numbers. Please verify against your specific environment or programming language for the most accurate information. Basics of Quantizations Now we are ready to tackle the basic concepts of Quantization in Deep Learning. Uniform vs Non-Uniform Quantization A normal quantization function is shown below where \\( S \\) is a scaling factor, \\( Z \\) is an integer zero point, and \\( \\text{Int} \\) represents an integer mapping through rounding. In the scaling factor \\( S \\) , \\([\\alpha, \\beta]\\) denotes the clipping range i.e. a bounded range that we are clipping the real values with, and \\(b\\) is the quantization bit width. The key characteristic of uniform quantization is that the quantized values are evenly spaced. This spacing can be visualized in a graph where the distance between each quantized level is constant. \\[ Q(r) = \\text{Int}\\left(\\frac{r}{S}\\right) - Z; \\] \\[ S = \\frac{\\beta - \\alpha}{2^b - 1}, \\] In contrast to uniform quantization, non-uniform quantization methods produce quantized values that are not evenly spaced. Non-uniform quantization can be more efficient in representing values with a non-linear distribution. However, implementing non-uniform quantization schemes efficiently on general computation hardware (e.g., GPU and CPU) is typically challenging. Therefore, uniform quantization is currently the most commonly used method due to its simplicity and efficient mapping to hardware. Source: [1] Also note that for both uniform and non-uniform quantization, the original real values can be approximated through dequantization, using the inverse operation \\( \\tilde{r} = S(Q(r) + Z) \\) . However, due to the rounding inherent in the quantization process, the recovered values \\( \\tilde{r} \\) will not be exactly the same as the original \\( r \\) . This approximation error is a trade-off for the benefit of reduced precision and computational complexity. Symmetric vs. Asymmetric Quantization Source: [1] In symmetric quantization, the scaling factor \\( S \\) is determined using a symmetric clipping range, typically defined as \\( \\alpha = -\\beta \\) . The value for \\( \\alpha \\) and \\( \\beta \\) is often selected based on the maximum absolute value in the data, resulting in \\( -\\alpha = \\beta = \\max(|r_{\\max}|, |r_{\\min}|) \\) . Symmetric quantization simplifies the quantization process by setting the zero point \\( Z \\) to zero, thus the quantization equation becomes \\( Q(r) = \\text{Int}\\left(\\frac{r}{S}\\right) \\) . There are two versions of symmetric quantization: full range, which utilizes the entire representable range of the data type (e.g., INT8), and restricted range, which excludes the extremes for better accuracy. Symmetric quantization is preferred for weight quantization in practice due to computational efficiency and straightforward implementation. Asymmetric quantization uses the actual minimum and maximum values of the data as the clipping range, i.e., \\( \\alpha = r_{\\min} \\) and \\( \\beta = r_{\\max} \\) , resulting in a non-symmetric range where \\( -\\alpha \\neq \\beta \\) . This method may provide a tighter clipping range which is advantageous when the data distribution is imbalanced, such as activations following a ReLU function. Asymmetric quantization allows for a more precise representation of the data's distribution, but at the cost of a more complex quantization process due to the non-zero zero point. Hint Both symmetric and asymmetric quantization require calibration, which involves selecting the appropriate clipping range. A common method is to use the min/max values of the signal; however, this can be susceptible to outliers which may expand the range unnecessarily and reduce quantization resolution. Alternative methods include using percentiles or optimizing for the minimum Kullback-Leibler divergence to minimize information loss. Dynamic vs Static Quantization So far we have discussed about calibrating the clipping range for weights which is relatively simple as it does not change during inference. Calibrating the activations is different as its range could be different for different input. Let's look into different ways to handle it, Dynamic quantization involves calculating the clipping range ( \\([\u03b1, \u03b2]\\) ) in real-time for each activation map based on the current input. Since activation maps change with each new input sample, dynamic range calibration allows the quantization process to adapt to these changes, potentially leading to higher accuracy. The trade-off, however, is the computational overhead required to compute signal statistics on the fly for every input during runtime. Static quantization, in contrast, involves determining a fixed clipping range prior to inference. This range is computed using a series of calibration inputs to estimate the typical range of activations. The advantage of this approach is the elimination of computational overhead during inference, as the range is not recalculated for each input. While typically less accurate than dynamic quantization due to its non-adaptive nature, static quantization benefits from methods that optimize the range, such as minimizing the Mean Squared Error between the original and quantized distributions. Other metrics like entropy can also be used, but MSE remains the most popular. Quantization Granularity Quantization granularity refers to the level of detail at which the clipping range \\([\u03b1, \u03b2]\\) is determined for quantization. There are various levels at which this can be implemented: Layerwise quantization sets a single clipping range based on the collective statistics of all the weights in a layer's convolutional filters. This method is straightforward to implement but may lead to suboptimal accuracy. The reason is that different filters within the layer can have widely varying ranges, and using a single range for all may compromise the resolution of filters with narrower weight ranges. Groupwise quantization segments multiple channels within a layer and calculates a clipping range for each group. This method can be beneficial when parameter distributions vary significantly within the layer, allowing for more tailored quantization. However, managing multiple scaling factors adds complexity. Channelwise quantization assigns a unique clipping range and scaling factor to each channel or convolutional filter. This granularity level is widely adopted because it provides a high quantization resolution and often yields higher accuracy without significant overhead. Sub-channelwise quantization further divides the granularity to smaller groups within a convolution or fully-connected layer. Although it could potentially lead to even higher accuracy due to finer resolution, the computational overhead of managing numerous scaling factors is considerable. Therefore, while channelwise quantization is a standard practice, sub-channelwise is not, due to its complexity and overhead. Source: [1] Quantization Strategies Below are three primary ways quantization can be performed wrt neural networks: Quantization-Aware Training (QAT): Quantization may skew the weights by moving them away from their converged points. To mitigate this, in QAT the model is retrained with quantized parameters to converge to a new optimal point. This involves using a forward and backward pass on a quantized model but updating the model parameters in floating-point precision. After each gradient update, the model parameters are quantized again. QAT utilizes techniques such as the Straight Through Estimator (STE) to approximate the gradient of the non-differentiable quantization operator. Other approaches like regularization operators or different gradient approximations are also explored. Advantages: QAT typically results in models with better performance and minimal accuracy loss due to the careful retraining with quantized parameters. Disadvantages: It is computationally expensive as it involves retraining the model, often for several hundred epochs. Post-Training Quantization (PTQ): PTQ is applied after a model has been trained with full precision. It adjusts the weights and activations of a model without any retraining or fine-tuning. Various methods exist to mitigate accuracy loss in PTQ, including bias correction methods, optimal clipping range calculations, outlier channel splitting, and adaptive rounding methods. That said, it might require some example data to calibrate the quantization parameters. Advantages: PTQ is a quick and often negligible overhead method for reducing the size of neural network models. It is particularly useful when training data is limited or unavailable. Disadvantages: Generally, PTQ leads to lower accuracy compared to QAT, particularly for low-precision quantization. Note While no model finetuning happens in PTQ, we may use training dataset for activation calibration. Zero-shot Quantization (ZSQ): ZSQ refers to performing quantization without any access to the training or validation data, not even example sample for calibration. This is particularly vital for scenarios where we want quick turnaround time on quantization. Advantages: ZSQ is simplest form of quantization and it is crucial for scenarios where data privacy or availability is a concern. It allows the quantization of models without needing access to any dataset. Disadvantages: While innovative, ZSQ methods may not capture the nuances of the actual data distribution as effectively as methods with access to real data, potentially leading to less accurate models. It also has quite a bit of overhead in terms of loading model as quantization usually happens during loading. In summary, each quantization method has its own set of trade-offs between accuracy, efficiency, and applicability. The choice among QAT, PTQ, and ZSQ depends largely on the specific constraints of the deployment environment, the availability of computational resources, and the necessity for data privacy. Quantization in Practice In practice, PTQ (Post-Training Quantization) and ZSQ (Zero-shot Quantization) are most widely used quantization methods due to their simplicity and minimal overhead. It is particularly effective for reducing the size of neural network models without requiring access to the original training data. Here is a 30k feet look of how playing with quantization looks like in practice: First we get the model which is trained in full precision (float32) . Next, we can either quantize the model and save it (ex: loading an quantized model TheBloke/Llama-2-7B-Chat-AWQ ) or we can quantize the model during loading (ex: HuggingFace supports like load_in_4_bit option as bitsandbytes config) Based on the quantization method, models can be dynamically dequantized (converted back to higher precision) during inference. This is because inference requires a forward pass which consists of complex computations like matrix multiplication and currently float-float matmul is much faster than int-int matmul. ( Refer ) Hint You can find thousands of quantized models (with different algorithms) on the TheBloke's collection in HuggingFace. Now, let's look into some of the popular quantization methods and their practical details. AWQ Activation-aware Weight Quantization (AWQ) [3], introduced in Oct 2023, is a PTQ type and Weight only quantization method based on the fact that not all weights are equally important for the model's performance. With this in mind, AWQ tries to identify those salient weights using the activation distribution where weights with larger activation magnitudes are deemed crucial for model performance. On further analysis, it was found that just a minor fraction (~1%) of weights, if left unquantized (FP16) could lead to non-significant change in model performance. While this is a crucial observation, it is also important to note that partial quantization of weights leads to mixed-precision data types, which are not efficiently handled in many hardware architectures. To circumvent these complexities, AWQ introduces a novel per-channel scaling technique that scales the weights (multiple weight by scale \\(s\\) and inverse scale the activation i.e multiply activation by \\(1/s\\) ) before quantization, where \\(s\\) is usually greater than 1, and it is determined by a grid search. This minor trick optimizes the quantization process, removes the need for mixed-precision data types, and keep the performance consistent with 1% FP16 weights. Source: [3] Empirical evidence demonstrates AWQ's superiority over existing quantization techniques, achieving remarkable speedups and facilitating the deployment of large models on constrained hardware environments. Notably, AWQ has enabled the efficient deployment of massive LLMs, such as the Llama-2-13B model, on single GPU platforms with limited memory (~8GB), and has achieved significant performance gains across diverse LLMs with varying parameter sizes. Better Perplexity score of AWQ on LLaMA-1 and 2 models in comparison with other quantization techniques. Source: [3] Running inference on AWQ model can be done using the transformers library. Below is an example of how to use AWQ model for inference. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # install # !pip install autoawq # import import time from transformers import AutoModelForCausalLM , AutoTokenizer # AWQ quantized model model_id = \"TheBloke/Llama-2-7B-Chat-AWQ\" # load model model = AutoModelForCausalLM . from_pretrained ( model_id , device_map = \"cuda:0\" ) # load tokenizer tokenizer = AutoTokenizer . from_pretrained ( model_id , trust_remote_code = False ) # tokenize the prompt tokens = tokenizer ( \"Tell me a joke\" , return_tensors = 'pt' ) . input_ids . cuda () # generating output start_time = time . time () generation_output = model . generate ( tokens , temperature = 0.7 , max_new_tokens = 50 ) end_time = time . time () # the output print ( \"Output: \" , tokenizer . decode ( generation_output [ 0 ])) # calc and print the speed # Calculate the number of tokens generated num_tokens = len ( generation_output [ 0 ]) - tokens . shape [ 1 ] # Calculate the tokens per second tokens_per_second = num_tokens / ( end_time - start_time ) print ( \"Tokens per second:\" , tokens_per_second ) Further, if you want to quantize a model and save it, you can use the below code ( Code Source ). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # imports from awq import AutoAWQForCausalLM from transformers import AutoTokenizer # model and quantization path model_path = 'mistralai/Mistral-7B-Instruct-v0.2' quant_path = 'mistral-instruct-v0.2-awq' # set quantization config quant_config = { \"zero_point\" : True , \"q_group_size\" : 128 , \"w_bit\" : 4 , \"version\" : \"GEMM\" } # Load model model = AutoAWQForCausalLM . from_pretrained ( model_path , ** { \"low_cpu_mem_usage\" : True , \"use_cache\" : False } ) # Load tokenizer tokenizer = AutoTokenizer . from_pretrained ( model_path , trust_remote_code = True ) # Quantize model . quantize ( tokenizer , quant_config = quant_config ) # Save quantized model model . save_quantized ( quant_path ) tokenizer . save_pretrained ( quant_path ) We can modify the config based on our requirement, but the important settings are zero_point (for zero point quantization) , q_group_size (for group size) , w_bit (for weight bit) and version (for the version of AWQ) . The quantized model will be saved at quant_path . As part of AWQ quantization, calibration is needed to identify the salient weights and this is done on a small set of training data so that the model does not loose its generalization ability. The above code does it with the default dataset (512 samples of mit-han-lab/pile-val-backup ) , but if you want to use your own dataset, you can refer this code . Note AWQ models come in multiple flavors and you can choose the version best suited for your need. As per AutoAWQ Github Repo these are, GEMM : Much faster than FP16 at batch sizes below 8 (good with large contexts) . GEMV : 20% faster than GEMM, only batch size 1 (not good for large context) . Note You need GPU with compute capacity >=7 to run AWQ models as they are optimized for GPU inference. You can check your GPU's compute capacity here . GPTQ GPTQ [5], introduced in March 2023, is a PTQ type and one-shot weight quantization method designed to efficiently and accurately compress GPT models even of bigger size such as GPT-3 with 175 billion parameters. GPTQ achieves this by utilizing approximate second-order information to reduce the models' weight bitwidth to 3 or 4 bits, with minimal loss in accuracy compared to the uncompressed model. This method significantly improves upon previous one-shot quantization approaches, doubling the compression gains while maintaining accuracy. As a result, it enables the execution of a 175 billion-parameter model on a single GPU for the first time, facilitating generative inference tasks. Additionally, GPTQ demonstrates reasonable accuracy even when weights are quantized to 2 bits or to a ternary level. Experimental results reveal that GPTQ can accelerate end-to-end inference by approximately 3.25 times on high-end GPUs (like NVIDIA A100) and by 4.5 times on more cost-effective GPUs (like NVIDIA A6000). Here is how you can run inference on GPTQ model. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # Install ! pip install auto - gptq optimum # Imports import time from transformers import AutoTokenizer from auto_gptq import AutoGPTQForCausalLM , BaseQuantizeConfig # Model and tokenizer model_id = \"TheBloke/Llama-2-7b-Chat-GPTQ\" # load quantized model model = AutoGPTQForCausalLM . from_quantized ( model_id , device = \"cuda:0\" ) # load tokenizer tokenizer = AutoTokenizer . from_pretrained ( model_id , use_fast = True ) # Inference tokens = tokenizer ( \"Tell me a joke. \\n Joke:\" , return_tensors = \"pt\" ) . to ( model . device ) # Calculate the time taken to generate the output start_time = time . time () generation_output = model . generate ( ** tokens , temperature = 0.001 , max_new_tokens = 50 ) end_time = time . time () print ( \"Output: \" , tokenizer . decode ( generation_output [ 0 ])) # Calculate the number of tokens generated num_tokens = len ( generation_output [ 0 ]) - tokens [ 'input_ids' ] . shape [ 1 ] # Calculate the tokens per second tokens_per_second = num_tokens / ( end_time - start_time ) print ( \"Tokens per second:\" , tokens_per_second ) # or you can also use pipeline # pipeline = TextGenerationPipeline(model=model, tokenizer=tokenizer) # print(pipeline(\"auto-gptq is\")[0][\"generated_text\"]) Quantizing a model using GPTQ can be done using the below code. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # install ! pip install auto - gptq optimum # imports from auto_gptq import AutoGPTQForCausalLM , BaseQuantizeConfig from transformers import AutoTokenizer # model and quantization path pretrained_model_name = \"facebook/opt-125m\" quantize_config = BaseQuantizeConfig ( bits = 4 , group_size = 128 ) model = AutoGPTQForCausalLM . from_pretrained ( pretrained_model_name , quantize_config ) tokenizer = AutoTokenizer . from_pretrained ( pretrained_model_name ) # example for quantization calibration (here we have only provided one, in reality provide multiple) examples = [ tokenizer ( \"auto-gptq is an easy-to-use model quantization library with user-friendly apis, based on GPTQ algorithm.\" ) ] # quantize model . quantize ( examples ) # save quantized model quantized_model_dir = \"opt-125m-4bit-128g\" model . save_quantized ( quantized_model_dir ) By default, the saved file type is .bin , you can also set use_safetensors=True to save a .safetensors model file. The format of model file base name saved using this method is: gptq_model-{bits}bit-{group_size}g . Pretrained model's config and the quantize config will also be saved with file names config.json and quantize_config.json , respectively. (Refer) BitsAndBytes BitsAndBytes [7] is a Python package to perform ZSQ on models to convert them to 8bit or 4bit representations. To load a model in 4bit quantization with the transformers library, you simply set the load_in_4bit=True flag and specify a device_map=\"auto\" when using the from_pretrained method. This process automatically infers an optimal device map, facilitating efficient model loading. For example, loading a model can be done as follows: 1 2 3 4 5 # import from transformers import BitsAndBytesConfig , AutoModelForCausalLM # load model model = AutoModelForCausalLM . from_pretrained ( \"facebook/opt-350m\" , \\ load_in_4bit = True , device_map = \"auto\" ) Note It's important not to manually assign the device after loading the model with a device map to avoid potential issues. Quantized models automatically cast submodules to float16 , but this can be modified (e.g., keeping layer norms in float32) by specifying torch_dtype in the from_pretrained method. For those interested in exploring beyond the basics, various 4bit quantization types are available, such as NF4 (normalized float 4) or pure FP4, with NF4 generally recommended for its performance benefits. Additional features like double quantization via bnb_4bit_use_double_quant can save extra bits per parameter (by enabling a second round of quantization to further compress the model) , and the computation precision ( bnb_4bit_compute_dtype ) can be adjusted to balance between speed and resource usage. Advanced configurations, such as NF4 quantization with double quantization and altered compute dtype for faster training, are facilitated through the BitsAndBytesConfig class. For instance, configuring a model with NF4 quantization and bfloat16 compute dtype can be achieved as follows: 1 2 3 4 5 6 7 8 9 10 11 # import import torch from transformers import BitsAndBytesConfig , AutoModelForCausalLM # define config nf4_config = BitsAndBytesConfig ( load_in_4bit = True , bnb_4bit_quant_type = \"nf4\" , bnb_4bit_use_double_quant = True , bnb_4bit_compute_dtype = torch . bfloat16 ) # load model model_nf4 = AutoModelForCausalLM . from_pretrained ( model_id , quantization_config = nf4_config ) Hint Use double quant only if you have problems with memory, use NF4 for higher precision, and use a 16-bit dtype for faster finetuning. Refer Hint If your hardware supports it, bf16 is the optimal compute dtype. The default is float32 for backward compatibility and numerical stability. float16 often leads to numerical instabilities, but bfloat16 provides the benefits of both worlds: numerical stability equivalent to float32 , but combined with the memory footprint and significant computation speedup of a 16-bit data type. Therefore, be sure to check if your hardware supports bf16 and configure it using the bnb_4bit_compute_dtype parameter in BitsAndBytesConfig . Refer GGML/GGUF GGUF [9] (older version was called GGML) is a file format developed by Georgi Gerganov specifically for the rapid loading and saving of models, along with its user-friendly approach to model reading. The format is designed to be a single-file deployment format (as it contains all the necessary information for model loading) , is compatible with memory-mapped files (mmap) and is extensible (support legacy models) . It was initially developed for whisper.cpp and later extended into llama.cpp . This made it the go to format for transformer models (which is the back bone of all LLMs today) and it is especially suited for anyone who wants to run model locally or on edge devices or use it for devices with limited GPU memory. That said, with advent of quantization for model compression especially for running LLMs on low memory devices, several quantization techniques were added into the llama.cpp package. Below is a table that summarizes the quantization techniques with more helpful practical details. ID Quantization Type Size Perplexity Increase @ 7B Quality Loss Level Recommendation 2 Q4_0 3.50G +0.2499 Very high Legacy, use Q3_K_M 3 Q4_1 3.90G +0.1846 Substantial Legacy, use Q3_K_L 8 Q5_0 4.30G +0.0796 Balanced Legacy, use Q4_K_M 9 Q5_1 4.70G +0.0415 Low Legacy, use Q5_K_M 10 Q2_K 2.67G +0.8698 Extreme Not recommended 11 Q3_K_S 2.75G +0.5505 Very high 12 Q3_K_M or Q3_K 3.06G +0.2437 Very high 13 Q3_K_L 3.35G +0.1803 Substantial 14 Q4_K_S 3.56G +0.1149 Significant 15 Q4_K_M or Q4_K 3.80G +0.0535 Balanced Recommended 16 Q5_K_S 4.33G +0.0353 Low Recommended 17 Q5_K_M or Q5_K 4.45G +0.0142 Very low Recommended 18 Q6_K 5.15G +0.0044 Extremely low 7 Q8_0 6.70G +0.0004 Extremely low Not recommended 1 F16 13.00G Virtually no Not recommended 0 F32 26.00G Lossless Not recommended Hint While selecting which quantization version to use, it is important to consider the trade-off between model size and quality. It also depends on the specific use case and the available resources. That said, if you are looking for something small and fast that does not compromise a lot on quality, Q5_K_M is a good choice. Furthermore, it's good to know the two types of quantization supported in llama.cpp - \"type-0\" where weights w are obtained from quants q using \\(w = d * q\\) , where d is the block scale and \"type-1\" where weights are given by \\(w = d * q + m\\) , where m is the block minimum. The naming convention of quantized model is Q{bits}_K_{type} or Q{bits}_{type} where bits is the number of bits, type is the type of quantization, and presence of K denotes that the new k-quant technique is used. The S , M , and L in the type are the size of the model where the S is the smallest, M is the medium, and L is the largest. This PR comment provides further details on underlying techniques as follows, The following new quantization types are added to ggml: GGML_TYPE_Q2_K - \"type-1\" 2-bit quantization in super-blocks containing 16 blocks, each block having 16 weight. Block scales and mins are quantized with 4 bits. This ends up effectively using 2.5625 bits per weight (bpw) GGML_TYPE_Q3_K - \"type-0\" 3-bit quantization in super-blocks containing 16 blocks, each block having 16 weights. Scales are quantized with 6 bits. This end up using 3.4375 bpw. GGML_TYPE_Q4_K - \"type-1\" 4-bit quantization in super-blocks containing 8 blocks, each block having 32 weights. Scales and mins are quantized with 6 bits. This ends up using 4.5 bpw. GGML_TYPE_Q5_K - \"type-1\" 5-bit quantization. Same super-block structure as GGML_TYPE_Q4_K resulting in 5.5 bpw GGML_TYPE_Q6_K - \"type-0\" 6-bit quantization. Super-blocks with 16 blocks, each block having 16 weights. Scales are quantized with 8 bits. This ends up using 6.5625 bpw GGML_TYPE_Q8_K - \"type-0\" 8-bit quantization. Only used for quantizing intermediate results. The difference to the existing Q8_0 is that the block size is 256. All 2-6 bit dot products are implemented for this quantization type. This is exposed via llama.cpp quantization types that define various \"quantization mixes\" as follows: LLAMA_FTYPE_MOSTLY_Q2_K - uses GGML_TYPE_Q4_K for the attention.vw and feed_forward.w2 tensors, GGML_TYPE_Q2_K for the other tensors. LLAMA_FTYPE_MOSTLY_Q3_K_S - uses GGML_TYPE_Q3_K for all tensors LLAMA_FTYPE_MOSTLY_Q3_K_M - uses GGML_TYPE_Q4_K for the attention.wv, attention.wo, and feed_forward.w2 tensors, else GGML_TYPE_Q3_K LLAMA_FTYPE_MOSTLY_Q3_K_L - uses GGML_TYPE_Q5_K for the attention.wv, attention.wo, and feed_forward.w2 tensors, else GGML_TYPE_Q3_K LLAMA_FTYPE_MOSTLY_Q4_K_S - uses GGML_TYPE_Q4_K for all tensors LLAMA_FTYPE_MOSTLY_Q4_K_M - uses GGML_TYPE_Q6_K for half of the attention.wv and feed_forward.w2 tensors, else GGML_TYPE_Q4_K LLAMA_FTYPE_MOSTLY_Q5_K_S - uses GGML_TYPE_Q5_K for all tensors LLAMA_FTYPE_MOSTLY_Q5_K_M - uses GGML_TYPE_Q6_K for half of the attention.wv and feed_forward.w2 tensors, else GGML_TYPE_Q5_K LLAMA_FTYPE_MOSTLY_Q6_K- uses 6-bit quantization (GGML_TYPE_Q8_K) for all tensors Fortunately, it is common practice to quantize all variants before open sourcing them, as it is evident from any of the GGUF models uploaded by TheBloke's collection in HuggingFace. LLaMa-2 GGUF version by TheBloke on HuggingFace contains all GGUF quantization versions. Source Model can be loaded using the ctransformers library and additional details like which quantization version to load can be specified. Below is an example of how to load a model with Q4_K_M quantization version. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ## Install # Base ctransformers with no GPU acceleration pip install ctransformers >= 0.2.24 # Or with CUDA GPU acceleration pip install ctransformers [ cuda ] >= 0.2.24 # Or with ROCm GPU acceleration CT_HIPBLAS = 1 pip install ctransformers >= 0.2.24 -- no - binary ctransformers # Or with Metal GPU acceleration for macOS systems CT_METAL = 1 pip install ctransformers >= 0.2.24 -- no - binary ctransformers ## Import from ctransformers import AutoModelForCausalLM ## Load the model # Set gpu_layers to the number of layers to offload to GPU. # Set to 0 if no GPU acceleration is available on your system. llm = AutoModelForCausalLM . from_pretrained ( \"TheBloke/Llama-2-7b-Chat-GGUF\" , model_file = \"llama-2-7b-chat.q4_K_M.gguf\" , model_type = \"llama\" , gpu_layers = 50 ) ## Run inference print ( llm ( \"AI is going to\" )) Fine-tuning the model can be done very easily using the llama.cpp library. Below is an example [9] 1 2 3 4 5 6 7 8 9 10 11 12 # Install llama.cpp ! git clone https : // github . com / ggerganov / llama . cpp ! cd llama . cpp && git pull && make clean && LLAMA_CUBLAS = 1 make ! pip install - r llama . cpp / requirements . txt # Manual - Download the model to quantize (`.bin` format) # Convert to fp16 (as by default it is f32) ! python llama . cpp / convert . py \"pytorch_model-00001-of-00001.bin\" -- outtype f16 -- outfile \"pytorch_model.fp16.bin\" # quantize ! ./ llama . cpp / quantize \"pytorch_model.fp16.bin\" \"pytorch_model.q5_k_m.gguf\" \"q5_k_m\" References [1] A Survey of Quantization Methods for Efficient Neural Network Inference [2] Maarten Grootendorst's Blog - Which Quantization Method is Right for You? (GPTQ vs. GGUF vs. AWQ) [3] AWQ: Activation-aware Weight Quantization for LLM Compression and Acceleration - Paper | Official Code [4] AutoAWQ Github Repo - Link [5] GPTQ - Paper | Official Code [6] AutoGPTQ Github Repo - Link [7] BitsAndBytes - Official Doc | Support for 4-bit and QLora Blog | HuggingFace Integration Blog [8] LLM.int8() - Blog [9] GGUF/GGML - Official Docs | Blog - Quantize Llama_2 models using GGML | K Quants [10] A Visual Guide to Quantization","title":"Model Quantization"},{"location":"machine_learning/model_compression_quant/#introduction","text":"Quantization is a technique that has been used in digital computing for a long time. It involves compressing data by converting a continuous signal or data set into a discrete set of values or levels. Neural Networks (NNs) present unique challenges and opportunities in the context of quantization. Firstly, both inference and training of NNs require significant computational resources, making the efficient representation of numerical values crucial. Secondly, many current NN models are highly over-parameterized, allowing scope for techniques that could reduce bit precision without sacrificing accuracy. However, an important distinction is that NNs exhibit remarkable resilience to aggressive quantization and extreme discretization. That said, by moving from floating-point representations to low-precision fixed integer values represented in four bits or less, it is possible to significantly reduce memory footprint and latency. In fact, reductions of 4x to 8x are often observed in practice in these applications. This article serves as a beginner-friendly introduction to quantization in deep learning.","title":"Introduction"},{"location":"machine_learning/model_compression_quant/#data-types-and-representations","text":"Before diving into the topic, let\u2019s understand the importance and advantages of using smaller data-type representations. Neural Nets consists of weights which are matrices of numbers, where each number is mostly represented in float32 data type. This means each number\u2019s size is 32 bits (4 bytes) and an average-sized LLM of 7B parameters (like LLaMA) will have a size around 7 * 10^9 * 4 = 28GB! This is vRAM required just for inference, and for training, you might need 2x more memory as the system needs to store gradients as well. (For finetuning, the memory requirements depend on which optimizer we are using. AdamW needs 8 bytes per parameter) . Now if we can use half-precision ( float16 ) our memory requirements are reduced by half and for much advanced 8-bit representation it becomes just 1/4th of the original requirement! Below is a table with different data types, their ranges, size and more details. Data Type Min Max Range Bits Accumulation Data Type uint8 0 255 0-255 8 uint16 int8 -128 127 -128 to 127 8 int16 uint16 0 65535 0-65535 16 uint32 int16 -32768 32767 -32768 to 32767 16 int32 uint32 0 4294967295 0-4294967295 32 uint64 int32 -2147483648 2147483647 -2147483648 to 2147483647 32 int64 uint64 0 18446744073709551615 0-18446744073709551615 64 uint64 int64 -9223372036854775808 9223372036854775807 -9223372036854775808 to 9223372036854775807 64 int64 float16 -65504 65504 -65504 to 65504 16 float32 float32 -3.4028235E+38 3.4028235E+38 -3.4028235E+38 to 3.4028235E+38 32 float64 float64 -1.7976931348623157E+308 1.7976931348623157E+308 -1.7976931348623157E+308 to 1.7976931348623157E+308 64 float128 Note float128 isn't a standard data type in many environments, and the accumulation type for some might vary based on the context or platform. For float types, the range values typically represent the maximum magnitude, not the precise range of normal numbers. Please verify against your specific environment or programming language for the most accurate information.","title":"Data Types and Representations"},{"location":"machine_learning/model_compression_quant/#basics-of-quantizations","text":"Now we are ready to tackle the basic concepts of Quantization in Deep Learning.","title":"Basics of Quantizations"},{"location":"machine_learning/model_compression_quant/#uniform-vs-non-uniform-quantization","text":"A normal quantization function is shown below where \\( S \\) is a scaling factor, \\( Z \\) is an integer zero point, and \\( \\text{Int} \\) represents an integer mapping through rounding. In the scaling factor \\( S \\) , \\([\\alpha, \\beta]\\) denotes the clipping range i.e. a bounded range that we are clipping the real values with, and \\(b\\) is the quantization bit width. The key characteristic of uniform quantization is that the quantized values are evenly spaced. This spacing can be visualized in a graph where the distance between each quantized level is constant. \\[ Q(r) = \\text{Int}\\left(\\frac{r}{S}\\right) - Z; \\] \\[ S = \\frac{\\beta - \\alpha}{2^b - 1}, \\] In contrast to uniform quantization, non-uniform quantization methods produce quantized values that are not evenly spaced. Non-uniform quantization can be more efficient in representing values with a non-linear distribution. However, implementing non-uniform quantization schemes efficiently on general computation hardware (e.g., GPU and CPU) is typically challenging. Therefore, uniform quantization is currently the most commonly used method due to its simplicity and efficient mapping to hardware. Source: [1] Also note that for both uniform and non-uniform quantization, the original real values can be approximated through dequantization, using the inverse operation \\( \\tilde{r} = S(Q(r) + Z) \\) . However, due to the rounding inherent in the quantization process, the recovered values \\( \\tilde{r} \\) will not be exactly the same as the original \\( r \\) . This approximation error is a trade-off for the benefit of reduced precision and computational complexity.","title":"Uniform vs Non-Uniform Quantization"},{"location":"machine_learning/model_compression_quant/#symmetric-vs-asymmetric-quantization","text":"Source: [1] In symmetric quantization, the scaling factor \\( S \\) is determined using a symmetric clipping range, typically defined as \\( \\alpha = -\\beta \\) . The value for \\( \\alpha \\) and \\( \\beta \\) is often selected based on the maximum absolute value in the data, resulting in \\( -\\alpha = \\beta = \\max(|r_{\\max}|, |r_{\\min}|) \\) . Symmetric quantization simplifies the quantization process by setting the zero point \\( Z \\) to zero, thus the quantization equation becomes \\( Q(r) = \\text{Int}\\left(\\frac{r}{S}\\right) \\) . There are two versions of symmetric quantization: full range, which utilizes the entire representable range of the data type (e.g., INT8), and restricted range, which excludes the extremes for better accuracy. Symmetric quantization is preferred for weight quantization in practice due to computational efficiency and straightforward implementation. Asymmetric quantization uses the actual minimum and maximum values of the data as the clipping range, i.e., \\( \\alpha = r_{\\min} \\) and \\( \\beta = r_{\\max} \\) , resulting in a non-symmetric range where \\( -\\alpha \\neq \\beta \\) . This method may provide a tighter clipping range which is advantageous when the data distribution is imbalanced, such as activations following a ReLU function. Asymmetric quantization allows for a more precise representation of the data's distribution, but at the cost of a more complex quantization process due to the non-zero zero point. Hint Both symmetric and asymmetric quantization require calibration, which involves selecting the appropriate clipping range. A common method is to use the min/max values of the signal; however, this can be susceptible to outliers which may expand the range unnecessarily and reduce quantization resolution. Alternative methods include using percentiles or optimizing for the minimum Kullback-Leibler divergence to minimize information loss.","title":"Symmetric vs. Asymmetric Quantization"},{"location":"machine_learning/model_compression_quant/#dynamic-vs-static-quantization","text":"So far we have discussed about calibrating the clipping range for weights which is relatively simple as it does not change during inference. Calibrating the activations is different as its range could be different for different input. Let's look into different ways to handle it, Dynamic quantization involves calculating the clipping range ( \\([\u03b1, \u03b2]\\) ) in real-time for each activation map based on the current input. Since activation maps change with each new input sample, dynamic range calibration allows the quantization process to adapt to these changes, potentially leading to higher accuracy. The trade-off, however, is the computational overhead required to compute signal statistics on the fly for every input during runtime. Static quantization, in contrast, involves determining a fixed clipping range prior to inference. This range is computed using a series of calibration inputs to estimate the typical range of activations. The advantage of this approach is the elimination of computational overhead during inference, as the range is not recalculated for each input. While typically less accurate than dynamic quantization due to its non-adaptive nature, static quantization benefits from methods that optimize the range, such as minimizing the Mean Squared Error between the original and quantized distributions. Other metrics like entropy can also be used, but MSE remains the most popular.","title":"Dynamic vs Static Quantization"},{"location":"machine_learning/model_compression_quant/#quantization-granularity","text":"Quantization granularity refers to the level of detail at which the clipping range \\([\u03b1, \u03b2]\\) is determined for quantization. There are various levels at which this can be implemented: Layerwise quantization sets a single clipping range based on the collective statistics of all the weights in a layer's convolutional filters. This method is straightforward to implement but may lead to suboptimal accuracy. The reason is that different filters within the layer can have widely varying ranges, and using a single range for all may compromise the resolution of filters with narrower weight ranges. Groupwise quantization segments multiple channels within a layer and calculates a clipping range for each group. This method can be beneficial when parameter distributions vary significantly within the layer, allowing for more tailored quantization. However, managing multiple scaling factors adds complexity. Channelwise quantization assigns a unique clipping range and scaling factor to each channel or convolutional filter. This granularity level is widely adopted because it provides a high quantization resolution and often yields higher accuracy without significant overhead. Sub-channelwise quantization further divides the granularity to smaller groups within a convolution or fully-connected layer. Although it could potentially lead to even higher accuracy due to finer resolution, the computational overhead of managing numerous scaling factors is considerable. Therefore, while channelwise quantization is a standard practice, sub-channelwise is not, due to its complexity and overhead. Source: [1]","title":"Quantization Granularity"},{"location":"machine_learning/model_compression_quant/#quantization-strategies","text":"Below are three primary ways quantization can be performed wrt neural networks: Quantization-Aware Training (QAT): Quantization may skew the weights by moving them away from their converged points. To mitigate this, in QAT the model is retrained with quantized parameters to converge to a new optimal point. This involves using a forward and backward pass on a quantized model but updating the model parameters in floating-point precision. After each gradient update, the model parameters are quantized again. QAT utilizes techniques such as the Straight Through Estimator (STE) to approximate the gradient of the non-differentiable quantization operator. Other approaches like regularization operators or different gradient approximations are also explored. Advantages: QAT typically results in models with better performance and minimal accuracy loss due to the careful retraining with quantized parameters. Disadvantages: It is computationally expensive as it involves retraining the model, often for several hundred epochs. Post-Training Quantization (PTQ): PTQ is applied after a model has been trained with full precision. It adjusts the weights and activations of a model without any retraining or fine-tuning. Various methods exist to mitigate accuracy loss in PTQ, including bias correction methods, optimal clipping range calculations, outlier channel splitting, and adaptive rounding methods. That said, it might require some example data to calibrate the quantization parameters. Advantages: PTQ is a quick and often negligible overhead method for reducing the size of neural network models. It is particularly useful when training data is limited or unavailable. Disadvantages: Generally, PTQ leads to lower accuracy compared to QAT, particularly for low-precision quantization. Note While no model finetuning happens in PTQ, we may use training dataset for activation calibration. Zero-shot Quantization (ZSQ): ZSQ refers to performing quantization without any access to the training or validation data, not even example sample for calibration. This is particularly vital for scenarios where we want quick turnaround time on quantization. Advantages: ZSQ is simplest form of quantization and it is crucial for scenarios where data privacy or availability is a concern. It allows the quantization of models without needing access to any dataset. Disadvantages: While innovative, ZSQ methods may not capture the nuances of the actual data distribution as effectively as methods with access to real data, potentially leading to less accurate models. It also has quite a bit of overhead in terms of loading model as quantization usually happens during loading. In summary, each quantization method has its own set of trade-offs between accuracy, efficiency, and applicability. The choice among QAT, PTQ, and ZSQ depends largely on the specific constraints of the deployment environment, the availability of computational resources, and the necessity for data privacy.","title":"Quantization Strategies"},{"location":"machine_learning/model_compression_quant/#quantization-in-practice","text":"In practice, PTQ (Post-Training Quantization) and ZSQ (Zero-shot Quantization) are most widely used quantization methods due to their simplicity and minimal overhead. It is particularly effective for reducing the size of neural network models without requiring access to the original training data. Here is a 30k feet look of how playing with quantization looks like in practice: First we get the model which is trained in full precision (float32) . Next, we can either quantize the model and save it (ex: loading an quantized model TheBloke/Llama-2-7B-Chat-AWQ ) or we can quantize the model during loading (ex: HuggingFace supports like load_in_4_bit option as bitsandbytes config) Based on the quantization method, models can be dynamically dequantized (converted back to higher precision) during inference. This is because inference requires a forward pass which consists of complex computations like matrix multiplication and currently float-float matmul is much faster than int-int matmul. ( Refer ) Hint You can find thousands of quantized models (with different algorithms) on the TheBloke's collection in HuggingFace. Now, let's look into some of the popular quantization methods and their practical details.","title":"Quantization in Practice"},{"location":"machine_learning/model_compression_quant/#awq","text":"Activation-aware Weight Quantization (AWQ) [3], introduced in Oct 2023, is a PTQ type and Weight only quantization method based on the fact that not all weights are equally important for the model's performance. With this in mind, AWQ tries to identify those salient weights using the activation distribution where weights with larger activation magnitudes are deemed crucial for model performance. On further analysis, it was found that just a minor fraction (~1%) of weights, if left unquantized (FP16) could lead to non-significant change in model performance. While this is a crucial observation, it is also important to note that partial quantization of weights leads to mixed-precision data types, which are not efficiently handled in many hardware architectures. To circumvent these complexities, AWQ introduces a novel per-channel scaling technique that scales the weights (multiple weight by scale \\(s\\) and inverse scale the activation i.e multiply activation by \\(1/s\\) ) before quantization, where \\(s\\) is usually greater than 1, and it is determined by a grid search. This minor trick optimizes the quantization process, removes the need for mixed-precision data types, and keep the performance consistent with 1% FP16 weights. Source: [3] Empirical evidence demonstrates AWQ's superiority over existing quantization techniques, achieving remarkable speedups and facilitating the deployment of large models on constrained hardware environments. Notably, AWQ has enabled the efficient deployment of massive LLMs, such as the Llama-2-13B model, on single GPU platforms with limited memory (~8GB), and has achieved significant performance gains across diverse LLMs with varying parameter sizes. Better Perplexity score of AWQ on LLaMA-1 and 2 models in comparison with other quantization techniques. Source: [3] Running inference on AWQ model can be done using the transformers library. Below is an example of how to use AWQ model for inference. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # install # !pip install autoawq # import import time from transformers import AutoModelForCausalLM , AutoTokenizer # AWQ quantized model model_id = \"TheBloke/Llama-2-7B-Chat-AWQ\" # load model model = AutoModelForCausalLM . from_pretrained ( model_id , device_map = \"cuda:0\" ) # load tokenizer tokenizer = AutoTokenizer . from_pretrained ( model_id , trust_remote_code = False ) # tokenize the prompt tokens = tokenizer ( \"Tell me a joke\" , return_tensors = 'pt' ) . input_ids . cuda () # generating output start_time = time . time () generation_output = model . generate ( tokens , temperature = 0.7 , max_new_tokens = 50 ) end_time = time . time () # the output print ( \"Output: \" , tokenizer . decode ( generation_output [ 0 ])) # calc and print the speed # Calculate the number of tokens generated num_tokens = len ( generation_output [ 0 ]) - tokens . shape [ 1 ] # Calculate the tokens per second tokens_per_second = num_tokens / ( end_time - start_time ) print ( \"Tokens per second:\" , tokens_per_second ) Further, if you want to quantize a model and save it, you can use the below code ( Code Source ). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # imports from awq import AutoAWQForCausalLM from transformers import AutoTokenizer # model and quantization path model_path = 'mistralai/Mistral-7B-Instruct-v0.2' quant_path = 'mistral-instruct-v0.2-awq' # set quantization config quant_config = { \"zero_point\" : True , \"q_group_size\" : 128 , \"w_bit\" : 4 , \"version\" : \"GEMM\" } # Load model model = AutoAWQForCausalLM . from_pretrained ( model_path , ** { \"low_cpu_mem_usage\" : True , \"use_cache\" : False } ) # Load tokenizer tokenizer = AutoTokenizer . from_pretrained ( model_path , trust_remote_code = True ) # Quantize model . quantize ( tokenizer , quant_config = quant_config ) # Save quantized model model . save_quantized ( quant_path ) tokenizer . save_pretrained ( quant_path ) We can modify the config based on our requirement, but the important settings are zero_point (for zero point quantization) , q_group_size (for group size) , w_bit (for weight bit) and version (for the version of AWQ) . The quantized model will be saved at quant_path . As part of AWQ quantization, calibration is needed to identify the salient weights and this is done on a small set of training data so that the model does not loose its generalization ability. The above code does it with the default dataset (512 samples of mit-han-lab/pile-val-backup ) , but if you want to use your own dataset, you can refer this code . Note AWQ models come in multiple flavors and you can choose the version best suited for your need. As per AutoAWQ Github Repo these are, GEMM : Much faster than FP16 at batch sizes below 8 (good with large contexts) . GEMV : 20% faster than GEMM, only batch size 1 (not good for large context) . Note You need GPU with compute capacity >=7 to run AWQ models as they are optimized for GPU inference. You can check your GPU's compute capacity here .","title":"AWQ"},{"location":"machine_learning/model_compression_quant/#gptq","text":"GPTQ [5], introduced in March 2023, is a PTQ type and one-shot weight quantization method designed to efficiently and accurately compress GPT models even of bigger size such as GPT-3 with 175 billion parameters. GPTQ achieves this by utilizing approximate second-order information to reduce the models' weight bitwidth to 3 or 4 bits, with minimal loss in accuracy compared to the uncompressed model. This method significantly improves upon previous one-shot quantization approaches, doubling the compression gains while maintaining accuracy. As a result, it enables the execution of a 175 billion-parameter model on a single GPU for the first time, facilitating generative inference tasks. Additionally, GPTQ demonstrates reasonable accuracy even when weights are quantized to 2 bits or to a ternary level. Experimental results reveal that GPTQ can accelerate end-to-end inference by approximately 3.25 times on high-end GPUs (like NVIDIA A100) and by 4.5 times on more cost-effective GPUs (like NVIDIA A6000). Here is how you can run inference on GPTQ model. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # Install ! pip install auto - gptq optimum # Imports import time from transformers import AutoTokenizer from auto_gptq import AutoGPTQForCausalLM , BaseQuantizeConfig # Model and tokenizer model_id = \"TheBloke/Llama-2-7b-Chat-GPTQ\" # load quantized model model = AutoGPTQForCausalLM . from_quantized ( model_id , device = \"cuda:0\" ) # load tokenizer tokenizer = AutoTokenizer . from_pretrained ( model_id , use_fast = True ) # Inference tokens = tokenizer ( \"Tell me a joke. \\n Joke:\" , return_tensors = \"pt\" ) . to ( model . device ) # Calculate the time taken to generate the output start_time = time . time () generation_output = model . generate ( ** tokens , temperature = 0.001 , max_new_tokens = 50 ) end_time = time . time () print ( \"Output: \" , tokenizer . decode ( generation_output [ 0 ])) # Calculate the number of tokens generated num_tokens = len ( generation_output [ 0 ]) - tokens [ 'input_ids' ] . shape [ 1 ] # Calculate the tokens per second tokens_per_second = num_tokens / ( end_time - start_time ) print ( \"Tokens per second:\" , tokens_per_second ) # or you can also use pipeline # pipeline = TextGenerationPipeline(model=model, tokenizer=tokenizer) # print(pipeline(\"auto-gptq is\")[0][\"generated_text\"]) Quantizing a model using GPTQ can be done using the below code. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # install ! pip install auto - gptq optimum # imports from auto_gptq import AutoGPTQForCausalLM , BaseQuantizeConfig from transformers import AutoTokenizer # model and quantization path pretrained_model_name = \"facebook/opt-125m\" quantize_config = BaseQuantizeConfig ( bits = 4 , group_size = 128 ) model = AutoGPTQForCausalLM . from_pretrained ( pretrained_model_name , quantize_config ) tokenizer = AutoTokenizer . from_pretrained ( pretrained_model_name ) # example for quantization calibration (here we have only provided one, in reality provide multiple) examples = [ tokenizer ( \"auto-gptq is an easy-to-use model quantization library with user-friendly apis, based on GPTQ algorithm.\" ) ] # quantize model . quantize ( examples ) # save quantized model quantized_model_dir = \"opt-125m-4bit-128g\" model . save_quantized ( quantized_model_dir ) By default, the saved file type is .bin , you can also set use_safetensors=True to save a .safetensors model file. The format of model file base name saved using this method is: gptq_model-{bits}bit-{group_size}g . Pretrained model's config and the quantize config will also be saved with file names config.json and quantize_config.json , respectively. (Refer)","title":"GPTQ"},{"location":"machine_learning/model_compression_quant/#bitsandbytes","text":"BitsAndBytes [7] is a Python package to perform ZSQ on models to convert them to 8bit or 4bit representations. To load a model in 4bit quantization with the transformers library, you simply set the load_in_4bit=True flag and specify a device_map=\"auto\" when using the from_pretrained method. This process automatically infers an optimal device map, facilitating efficient model loading. For example, loading a model can be done as follows: 1 2 3 4 5 # import from transformers import BitsAndBytesConfig , AutoModelForCausalLM # load model model = AutoModelForCausalLM . from_pretrained ( \"facebook/opt-350m\" , \\ load_in_4bit = True , device_map = \"auto\" ) Note It's important not to manually assign the device after loading the model with a device map to avoid potential issues. Quantized models automatically cast submodules to float16 , but this can be modified (e.g., keeping layer norms in float32) by specifying torch_dtype in the from_pretrained method. For those interested in exploring beyond the basics, various 4bit quantization types are available, such as NF4 (normalized float 4) or pure FP4, with NF4 generally recommended for its performance benefits. Additional features like double quantization via bnb_4bit_use_double_quant can save extra bits per parameter (by enabling a second round of quantization to further compress the model) , and the computation precision ( bnb_4bit_compute_dtype ) can be adjusted to balance between speed and resource usage. Advanced configurations, such as NF4 quantization with double quantization and altered compute dtype for faster training, are facilitated through the BitsAndBytesConfig class. For instance, configuring a model with NF4 quantization and bfloat16 compute dtype can be achieved as follows: 1 2 3 4 5 6 7 8 9 10 11 # import import torch from transformers import BitsAndBytesConfig , AutoModelForCausalLM # define config nf4_config = BitsAndBytesConfig ( load_in_4bit = True , bnb_4bit_quant_type = \"nf4\" , bnb_4bit_use_double_quant = True , bnb_4bit_compute_dtype = torch . bfloat16 ) # load model model_nf4 = AutoModelForCausalLM . from_pretrained ( model_id , quantization_config = nf4_config ) Hint Use double quant only if you have problems with memory, use NF4 for higher precision, and use a 16-bit dtype for faster finetuning. Refer Hint If your hardware supports it, bf16 is the optimal compute dtype. The default is float32 for backward compatibility and numerical stability. float16 often leads to numerical instabilities, but bfloat16 provides the benefits of both worlds: numerical stability equivalent to float32 , but combined with the memory footprint and significant computation speedup of a 16-bit data type. Therefore, be sure to check if your hardware supports bf16 and configure it using the bnb_4bit_compute_dtype parameter in BitsAndBytesConfig . Refer","title":"BitsAndBytes"},{"location":"machine_learning/model_compression_quant/#ggmlgguf","text":"GGUF [9] (older version was called GGML) is a file format developed by Georgi Gerganov specifically for the rapid loading and saving of models, along with its user-friendly approach to model reading. The format is designed to be a single-file deployment format (as it contains all the necessary information for model loading) , is compatible with memory-mapped files (mmap) and is extensible (support legacy models) . It was initially developed for whisper.cpp and later extended into llama.cpp . This made it the go to format for transformer models (which is the back bone of all LLMs today) and it is especially suited for anyone who wants to run model locally or on edge devices or use it for devices with limited GPU memory. That said, with advent of quantization for model compression especially for running LLMs on low memory devices, several quantization techniques were added into the llama.cpp package. Below is a table that summarizes the quantization techniques with more helpful practical details. ID Quantization Type Size Perplexity Increase @ 7B Quality Loss Level Recommendation 2 Q4_0 3.50G +0.2499 Very high Legacy, use Q3_K_M 3 Q4_1 3.90G +0.1846 Substantial Legacy, use Q3_K_L 8 Q5_0 4.30G +0.0796 Balanced Legacy, use Q4_K_M 9 Q5_1 4.70G +0.0415 Low Legacy, use Q5_K_M 10 Q2_K 2.67G +0.8698 Extreme Not recommended 11 Q3_K_S 2.75G +0.5505 Very high 12 Q3_K_M or Q3_K 3.06G +0.2437 Very high 13 Q3_K_L 3.35G +0.1803 Substantial 14 Q4_K_S 3.56G +0.1149 Significant 15 Q4_K_M or Q4_K 3.80G +0.0535 Balanced Recommended 16 Q5_K_S 4.33G +0.0353 Low Recommended 17 Q5_K_M or Q5_K 4.45G +0.0142 Very low Recommended 18 Q6_K 5.15G +0.0044 Extremely low 7 Q8_0 6.70G +0.0004 Extremely low Not recommended 1 F16 13.00G Virtually no Not recommended 0 F32 26.00G Lossless Not recommended Hint While selecting which quantization version to use, it is important to consider the trade-off between model size and quality. It also depends on the specific use case and the available resources. That said, if you are looking for something small and fast that does not compromise a lot on quality, Q5_K_M is a good choice. Furthermore, it's good to know the two types of quantization supported in llama.cpp - \"type-0\" where weights w are obtained from quants q using \\(w = d * q\\) , where d is the block scale and \"type-1\" where weights are given by \\(w = d * q + m\\) , where m is the block minimum. The naming convention of quantized model is Q{bits}_K_{type} or Q{bits}_{type} where bits is the number of bits, type is the type of quantization, and presence of K denotes that the new k-quant technique is used. The S , M , and L in the type are the size of the model where the S is the smallest, M is the medium, and L is the largest. This PR comment provides further details on underlying techniques as follows, The following new quantization types are added to ggml: GGML_TYPE_Q2_K - \"type-1\" 2-bit quantization in super-blocks containing 16 blocks, each block having 16 weight. Block scales and mins are quantized with 4 bits. This ends up effectively using 2.5625 bits per weight (bpw) GGML_TYPE_Q3_K - \"type-0\" 3-bit quantization in super-blocks containing 16 blocks, each block having 16 weights. Scales are quantized with 6 bits. This end up using 3.4375 bpw. GGML_TYPE_Q4_K - \"type-1\" 4-bit quantization in super-blocks containing 8 blocks, each block having 32 weights. Scales and mins are quantized with 6 bits. This ends up using 4.5 bpw. GGML_TYPE_Q5_K - \"type-1\" 5-bit quantization. Same super-block structure as GGML_TYPE_Q4_K resulting in 5.5 bpw GGML_TYPE_Q6_K - \"type-0\" 6-bit quantization. Super-blocks with 16 blocks, each block having 16 weights. Scales are quantized with 8 bits. This ends up using 6.5625 bpw GGML_TYPE_Q8_K - \"type-0\" 8-bit quantization. Only used for quantizing intermediate results. The difference to the existing Q8_0 is that the block size is 256. All 2-6 bit dot products are implemented for this quantization type. This is exposed via llama.cpp quantization types that define various \"quantization mixes\" as follows: LLAMA_FTYPE_MOSTLY_Q2_K - uses GGML_TYPE_Q4_K for the attention.vw and feed_forward.w2 tensors, GGML_TYPE_Q2_K for the other tensors. LLAMA_FTYPE_MOSTLY_Q3_K_S - uses GGML_TYPE_Q3_K for all tensors LLAMA_FTYPE_MOSTLY_Q3_K_M - uses GGML_TYPE_Q4_K for the attention.wv, attention.wo, and feed_forward.w2 tensors, else GGML_TYPE_Q3_K LLAMA_FTYPE_MOSTLY_Q3_K_L - uses GGML_TYPE_Q5_K for the attention.wv, attention.wo, and feed_forward.w2 tensors, else GGML_TYPE_Q3_K LLAMA_FTYPE_MOSTLY_Q4_K_S - uses GGML_TYPE_Q4_K for all tensors LLAMA_FTYPE_MOSTLY_Q4_K_M - uses GGML_TYPE_Q6_K for half of the attention.wv and feed_forward.w2 tensors, else GGML_TYPE_Q4_K LLAMA_FTYPE_MOSTLY_Q5_K_S - uses GGML_TYPE_Q5_K for all tensors LLAMA_FTYPE_MOSTLY_Q5_K_M - uses GGML_TYPE_Q6_K for half of the attention.wv and feed_forward.w2 tensors, else GGML_TYPE_Q5_K LLAMA_FTYPE_MOSTLY_Q6_K- uses 6-bit quantization (GGML_TYPE_Q8_K) for all tensors Fortunately, it is common practice to quantize all variants before open sourcing them, as it is evident from any of the GGUF models uploaded by TheBloke's collection in HuggingFace. LLaMa-2 GGUF version by TheBloke on HuggingFace contains all GGUF quantization versions. Source Model can be loaded using the ctransformers library and additional details like which quantization version to load can be specified. Below is an example of how to load a model with Q4_K_M quantization version. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ## Install # Base ctransformers with no GPU acceleration pip install ctransformers >= 0.2.24 # Or with CUDA GPU acceleration pip install ctransformers [ cuda ] >= 0.2.24 # Or with ROCm GPU acceleration CT_HIPBLAS = 1 pip install ctransformers >= 0.2.24 -- no - binary ctransformers # Or with Metal GPU acceleration for macOS systems CT_METAL = 1 pip install ctransformers >= 0.2.24 -- no - binary ctransformers ## Import from ctransformers import AutoModelForCausalLM ## Load the model # Set gpu_layers to the number of layers to offload to GPU. # Set to 0 if no GPU acceleration is available on your system. llm = AutoModelForCausalLM . from_pretrained ( \"TheBloke/Llama-2-7b-Chat-GGUF\" , model_file = \"llama-2-7b-chat.q4_K_M.gguf\" , model_type = \"llama\" , gpu_layers = 50 ) ## Run inference print ( llm ( \"AI is going to\" )) Fine-tuning the model can be done very easily using the llama.cpp library. Below is an example [9] 1 2 3 4 5 6 7 8 9 10 11 12 # Install llama.cpp ! git clone https : // github . com / ggerganov / llama . cpp ! cd llama . cpp && git pull && make clean && LLAMA_CUBLAS = 1 make ! pip install - r llama . cpp / requirements . txt # Manual - Download the model to quantize (`.bin` format) # Convert to fp16 (as by default it is f32) ! python llama . cpp / convert . py \"pytorch_model-00001-of-00001.bin\" -- outtype f16 -- outfile \"pytorch_model.fp16.bin\" # quantize ! ./ llama . cpp / quantize \"pytorch_model.fp16.bin\" \"pytorch_model.q5_k_m.gguf\" \"q5_k_m\"","title":"GGML/GGUF"},{"location":"machine_learning/model_compression_quant/#references","text":"[1] A Survey of Quantization Methods for Efficient Neural Network Inference [2] Maarten Grootendorst's Blog - Which Quantization Method is Right for You? (GPTQ vs. GGUF vs. AWQ) [3] AWQ: Activation-aware Weight Quantization for LLM Compression and Acceleration - Paper | Official Code [4] AutoAWQ Github Repo - Link [5] GPTQ - Paper | Official Code [6] AutoGPTQ Github Repo - Link [7] BitsAndBytes - Official Doc | Support for 4-bit and QLora Blog | HuggingFace Integration Blog [8] LLM.int8() - Blog [9] GGUF/GGML - Official Docs | Blog - Quantize Llama_2 models using GGML | K Quants [10] A Visual Guide to Quantization","title":"References"},{"location":"machine_learning/ranking_algorithms/","text":"Introduction Suppose you have a decision to make \u2014 like buying a house, or a car, or even a guitar. You don\u2019t want to choose randomly or get biased by someone\u2019s suggestion, but want to make an educated decision. For this, you gathered some information about the entity you want to buy (let\u2019s say it\u2019s a car). So you have a list of N cars with their price information. As usual, we won\u2019t want to spend more, we can just sort the cars by their price (in ascending order) and pick the top one (with the smallest price), and we are done! This was decision making with a single criterion. But alas if life is so easy We would also like the car to have good mileage, better engine, faster acceleration (if you want to race), and some more. Here, you want to choose a car with the smallest price, but the highest mileage and acceleration, and so on. This problem can\u2019t be so easily solved by simple sorting. Enter multi-criteria decision-making algorithms! an Egyptian painting of a man dissecting a car to understand it better (Created by DallE) Dataset Let\u2019s choose one dataset so it becomes easier to visualize the result, to understand what\u2019s really happening behind the scenes and finally build intuition. For this, I am picking cars dataset. It contains information about different cars. For each car, we will focus on a subset of attributes. Also, I am filtering to only 10 rows (unique cars) to make our life easier. Look at the selected data, 10 rows from the cars dataset Explaining the attributes in the dataset, mpg : a measure of how far a car can travel if you put just one gallon of petrol or diesel in its tank (mileage). Higher the better displacement : engine displacement is the measure of the cylinder volume swept by all of the pistons of a piston engine. More displacement means more power. Higher the better weight : the weight of the car. Lower the better acceleration : a measure of how long it takes the car to reach a speed from 0. Higher the acceleration, better the car for drag racing \ud83c\udfce\ufe0f Higher the better price : the price of the car. Lower the better Here please notice some points, The unit and distribution of the attributes are not the same. Price is in 1000s of $, acceleration in 10s of seconds and so on. describing each of the numerical columns (the attributes) of the selected data The direction to classify the best for each attribute vary as well. Here, we want to find a car with high values in mpg , displacement and acceleration . At the same time, low values in weight and price . This notion of high and low can be inferred as maximizing and minimizing the attributes, respectively. There could be an additional requirement where we don\u2019t consider each attribute equal. For example, If I want a car for racing and say I am sponsored by a billionaire , then I won\u2019t care about mpg and price so much. I want the faster and lightest car possible. But what if I am a student (hence most probably on a strict budget) and travel a lot, then suddenly mpg and price become the most important attribute and I don\u2019t give a damn about displacement . These notions of important of attributes can be inferred as weights assigned to each attribute. Say, price is 30% important, while displacement is only 10% and so on. With the requirements clear, let\u2019s try to see how we can solve these kinds of problems. Generic methodology Multi-criteria decision solvers basically have a common methodology, that tries to do the following, Consider one attribute at a time and try to maximize or minimize it (as per the requirement) . Do this for all attributes to generate optimized scores for each attribute. Introduce weights to each attributes to get optimized weighted scores. Combine the weighted scores (of each attribute) to create a final score for an entity (here car). At this point, we have transformed the requirements into a single numerical attribute (final score) . We can sort on this to get the best car (this time we sort by descending as we want to pick one with maximum score) . Let\u2019s explore each step with examples. Normalize with Maximize and Minimize Remember the first point from the dataset section, attributes have very different units and distributions, which we need to handle. One possible solution is to normalize each attribute between the same range. And we also want the direction of goodness to be similar (irrespective of the attribute logic) i.e. for all attributes, values near maximum of range (say 1) should mean that car is good in that attribute and lower values (say near 0) means they are bad. We do this using any one of the following formula, normalization logic for maximizing and minimizing an attribute values Maximize: Let's pick one attribute, say mpg , that is eligible for maximization. We can update the mpg of each car by dividing it by sum of mpg of all cars (sum normalization) . If you notice, this is the first maximization equation from the figure above. Another option or formula is to consider the max of mpg (max normalization) or perform max-min scaling. The intention is, after applying this to the attribute that is eligible for maximization, the range of each attribute will be the same as well as we can infer that value close to 1 means good. Example for sum normalization heatmap of the original data. Check the \u2018mpg\u2019 value of \u2018ford torino\u2019. Originally its 17 but after sum normalization, it should be 17/156=0.109. Similarly, the \u2018price\u2019 is 20k, after inverse it will be 1/(20k/287872) = 14.4 Minimize: The formulae for minimizing is nearly the same as the maximizing one, we just inverse it (1 divided by maximize) or mirror it (by subtracting it from 1) to actually reverse the goodness direction (otherwise 1 will mean bad and 0 will mean good) . Apply weights We just need to superimpose the weight over the optimized scores, which can be easily done by multiplying the weights to the optimized score. Here as well we can introduce different types of normalization, as it is : directly multiply the weights to optimized score sum : normalize the weights by sum logic (discussed above) then multiply. max : normalize by max logic, then multiply. weight modification logic Combine the scores Finally, we combine the score to make it one. This can be done by two different logic, sum : add all individual scores together product : multiply all individual scores together. In fact, many implementations add the logarithm of the value instead of taking products, this is done to handle small values that can result in very smaller result when multiplying. Implementation Note Update - March 2022: Due to code breaking changes in the latest version of scikit-criteria, it is recommended to use v0.2.11 of the package for the code discussed in the article. Code repository is here. We have a python package named skcriteria that provides many algorithms for multi criteria decision-making problem. Actually two algorithms inside the skcriteria.madm.simple module are, WeightedSum \u2014 individual score combine logic is sum WeightedProduct \u2014 individual score combine logic is product (sum of log) And both of these methods take two parameters as input, mnorm \u2014 define value maximize normalization logic (minimization is always the inverse of the same maximize logic). wnorm \u2014 define weight normalization logic To perform ranking on our data, first, we need to load it as their skcriteria.Data object by, 1 2 3 4 5 6 7 criteria_data = Data ( cars_data . iloc [:, 1 :], # the pandas dataframe [ MAX , MAX , MIN , MAX , MIN ], # direction of goodness for each column anames = cars_data [ 'car_name' ], # each entity's name, here car name cnames = cars_data . columns [ 1 :], # attribute/column name # weights=[1,1,1,1,1] # weights for each attribute (optional) ) ALT./CRIT. mpg (max) displacement (max) weight (min) acceleration (max) price (min) chevrolet chevelle malibu 18 307 3504 12 25561.6 buick skylark 320 15 350 3693 11.5 24221.4 plymouth satellite 18 318 3436 11 27240.8 amc rebel sst 16 304 3433 12 33685 ford torino 17 302 3449 10.5 20000 ford galaxie 500 15 429 4341 10 30000 chevrolet impala 14 454 4354 9 35764.3 plymouth fury iii 14 440 4312 8.5 25899.5 pontiac catalina 14 455 4425 10 32882.5 amc ambassador dpl 15 390 3850 8.5 32617.1 With the data loaded, all we need to do is call the appropriate decision maker function with data object and parameter settings. The output has one additional rank column to show the final ranking by considering all of the mentioned criteria. 1 2 3 4 from skcriteria.madm import simple # weighted sum dm = simple . WeightedSum ( mnorm = \"sum\" ) dec = dm . decide ( criteria_data ) ALT./CRIT. mpg (max) displacement (max) weight (min) acceleration (max) price (min) Rank chevrolet chevelle malibu 18 307 3504 12 25561.6 3 buick skylark 320 15 350 3693 11.5 24221.4 2 plymouth satellite 18 318 3436 11 27240.8 4 amc rebel sst 16 304 3433 12 33685 6 ford torino 17 302 3449 10.5 20000 1 ford galaxie 500 15 429 4341 10 30000 8 chevrolet impala 14 454 4354 9 35764.3 10 plymouth fury iii 14 440 4312 8.5 25899.5 5 pontiac catalina 14 455 4425 10 32882.5 9 amc ambassador dpl 15 390 3850 8.5 32617.1 7 We can even export the final score by dec.e_.points and the ranks by dec.rank_ . Comparison Let\u2019s compare the result of different decision making algorithms (with different parameters) on our dataset. To do so, I use the weightedSum and weightedProduct implementations (once with max and then with sum value normalization). I also implemented a normalize_data function which by default performs minmax and subtract normalization. Then I apply a sum combine on the output. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # import from skcriteria.madm import simple # make a copy of original dataset cars_data_copy = cars_data . copy () # weighted sum, sumNorm dm = simple . WeightedSum ( mnorm = \"sum\" ) dec = dm . decide ( criteria_data ) cars_data_copy . loc [:, 'rank_weightedSum_sumNorm_inverse' ] = dec . rank_ # weighted sum, maxNorm dm = simple . WeightedSum ( mnorm = \"max\" ) dec = dm . decide ( criteria_data ) cars_data_copy . loc [:, 'rank_weightedSum_maxNorm_inverse' ] = dec . rank_ # weighted product, sumNorm dm = simple . WeightedProduct ( mnorm = \"sum\" ) dec = dm . decide ( criteria_data ) cars_data_copy . loc [:, 'rank_weightedProduct_sumNorm_inverse' ] = dec . rank_ # weighted product, sumNorm dm = simple . WeightedProduct ( mnorm = \"max\" ) dec = dm . decide ( criteria_data ) cars_data_copy . loc [:, 'rank_weightedProduct_maxNorm_inverse' ] = dec . rank_ # min max scale + mirror cars_data_copy . loc [:, 'rank_weightedSum_minmaxScale_subtract' ] = \\ pd . Series ( normalize_data () . sum ( axis = 1 )) . rank ( ascending = False ) . astype ( int ) Finally, I plot a parallel coordinate graphs, where each axis(vertical line) denotes one solver type and the values denote the rank of a car by that solver. Each line is for one car and going from left to right, it shows the journey \u2014 how the rank of a car changes as you switch among different solvers. Journey of a car as we switch decision solver Some points to consider, Ford Torino is rank 1 (car with the highest score) for 4/5 solvers. Minmax favors Chevrolet Malibu. Impala is the universal low ranker :( Both implementations of weightedProduct is giving the same ranking to all cars. Nothing interesting here. High variance in the rankings of both the weightedSum implementations. MinMax gives the most diverse rankings for top 4 guys. The main reason behind the variance of result when changing the normalization (from sum to max) is due to the translation done on the original data. This translation changes the range of data (like scales everything between x and y ) and in case of inverse modifies the linearity as well (say, equal steps of 1 in original data is not consistent in transformed data). This will become more clear by following result, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import numpy as np x = np . array ( range ( 1 , 10 )) print ( \"X: \" , x ) print ( \"MinMax: \" , minmax_scale ( x )) print ( \"MinMax_subtract: \" , 1 - minmax_scale ( x )) print ( \"sumNorm: \" , x / sum ( x )) print ( \"sumNorm_inverse: \" , ( 1 / ( x / sum ( x )))) print ( \"maxNorm: \" , x / max ( x )) print ( \"maxNorm_inverse: \" , 1 / ( x / max ( x ))) ## Output X : [ 1 2 3 4 5 6 7 8 9 ] MinMax : [ 0. 0.125 0.25 0.375 0.5 0.625 0.75 0.875 1. ] MinMax_subtract : [ 1. 0.875 0.75 0.625 0.5 0.375 0.25 0.125 0. ] sumNorm : [ 0.02222222 0.04444444 0.06666667 0.08888889 0.11111111 0.13333333 0.15555556 0.17777778 0.2 ] sumNorm_inverse : [ 45. 22.5 15. 11.25 9. 7.5 6.42857143 5.625 5. ] maxNorm : [ 0.11111111 0.22222222 0.33333333 0.44444444 0.55555556 0.66666667 0.77777778 0.88888889 1. ] maxNorm_inverse : [ 9. 4.5 3. 2.25 1.8 1.5 1.28571429 1.125 1. ] Here, input data consist numbers 1 to 9 (notice, the difference between any two consecutive number is 1 i.e. step is same). Approach one (minmax) translates the data between 0 and 1 and the step is still the same. Now look at minimization logic ( _inverse ) of approach 2 and 3. Here at the start (low original values) the step is nearly the half of the last element, but near the end (high original value) the step is very small, even though in the original data we are moving with same step of 1. Because of this, in case of minimization, a very high score is given to \u201cgood\u201d cars (with low values) and even a small impurity matter (when minimized, high value = low score) and results in a drastic decrease in score. It\u2019s like we are being very picky, either you are the best or you get half the score :) On the other hand, for higher values, small impurities doesn\u2019t matter. If the car is already bad by that attribute, then we don\u2019t care if its value is 7 or 8 or 9 and the reduction in the score is much less! We can use this understanding to pick the right decision solver with the right parameter as per our need. Conclusion This article has just touched the surface of the multi-criteria decision making domain. Even in skcriteria package there are many more algorithms like TOPSIS and MOORA which have quite a different intuition to solve these problems. But even then the notion of goodness and the idea to handle individual attributes to finally combine them all together is used in many of them. So maybe we will explore more algorithms in another article. The major takeaways from this article should be to understand the why and what of decision makers. That each such decision can be manipulated by multiple criteria. And also that we may have a different notion of goodness and importance assigned to each criterion. Finally, we have different varieties of solvers that can be build by taking permutation of logic and parameters, and nearly all of them give different and interesting results based on our need! Cheers","title":"Ranking Algorithms"},{"location":"machine_learning/ranking_algorithms/#introduction","text":"Suppose you have a decision to make \u2014 like buying a house, or a car, or even a guitar. You don\u2019t want to choose randomly or get biased by someone\u2019s suggestion, but want to make an educated decision. For this, you gathered some information about the entity you want to buy (let\u2019s say it\u2019s a car). So you have a list of N cars with their price information. As usual, we won\u2019t want to spend more, we can just sort the cars by their price (in ascending order) and pick the top one (with the smallest price), and we are done! This was decision making with a single criterion. But alas if life is so easy We would also like the car to have good mileage, better engine, faster acceleration (if you want to race), and some more. Here, you want to choose a car with the smallest price, but the highest mileage and acceleration, and so on. This problem can\u2019t be so easily solved by simple sorting. Enter multi-criteria decision-making algorithms! an Egyptian painting of a man dissecting a car to understand it better (Created by DallE)","title":"Introduction"},{"location":"machine_learning/ranking_algorithms/#dataset","text":"Let\u2019s choose one dataset so it becomes easier to visualize the result, to understand what\u2019s really happening behind the scenes and finally build intuition. For this, I am picking cars dataset. It contains information about different cars. For each car, we will focus on a subset of attributes. Also, I am filtering to only 10 rows (unique cars) to make our life easier. Look at the selected data, 10 rows from the cars dataset Explaining the attributes in the dataset, mpg : a measure of how far a car can travel if you put just one gallon of petrol or diesel in its tank (mileage). Higher the better displacement : engine displacement is the measure of the cylinder volume swept by all of the pistons of a piston engine. More displacement means more power. Higher the better weight : the weight of the car. Lower the better acceleration : a measure of how long it takes the car to reach a speed from 0. Higher the acceleration, better the car for drag racing \ud83c\udfce\ufe0f Higher the better price : the price of the car. Lower the better Here please notice some points, The unit and distribution of the attributes are not the same. Price is in 1000s of $, acceleration in 10s of seconds and so on. describing each of the numerical columns (the attributes) of the selected data The direction to classify the best for each attribute vary as well. Here, we want to find a car with high values in mpg , displacement and acceleration . At the same time, low values in weight and price . This notion of high and low can be inferred as maximizing and minimizing the attributes, respectively. There could be an additional requirement where we don\u2019t consider each attribute equal. For example, If I want a car for racing and say I am sponsored by a billionaire , then I won\u2019t care about mpg and price so much. I want the faster and lightest car possible. But what if I am a student (hence most probably on a strict budget) and travel a lot, then suddenly mpg and price become the most important attribute and I don\u2019t give a damn about displacement . These notions of important of attributes can be inferred as weights assigned to each attribute. Say, price is 30% important, while displacement is only 10% and so on. With the requirements clear, let\u2019s try to see how we can solve these kinds of problems.","title":"Dataset"},{"location":"machine_learning/ranking_algorithms/#generic-methodology","text":"Multi-criteria decision solvers basically have a common methodology, that tries to do the following, Consider one attribute at a time and try to maximize or minimize it (as per the requirement) . Do this for all attributes to generate optimized scores for each attribute. Introduce weights to each attributes to get optimized weighted scores. Combine the weighted scores (of each attribute) to create a final score for an entity (here car). At this point, we have transformed the requirements into a single numerical attribute (final score) . We can sort on this to get the best car (this time we sort by descending as we want to pick one with maximum score) . Let\u2019s explore each step with examples.","title":"Generic methodology"},{"location":"machine_learning/ranking_algorithms/#normalize-with-maximize-and-minimize","text":"Remember the first point from the dataset section, attributes have very different units and distributions, which we need to handle. One possible solution is to normalize each attribute between the same range. And we also want the direction of goodness to be similar (irrespective of the attribute logic) i.e. for all attributes, values near maximum of range (say 1) should mean that car is good in that attribute and lower values (say near 0) means they are bad. We do this using any one of the following formula, normalization logic for maximizing and minimizing an attribute values Maximize: Let's pick one attribute, say mpg , that is eligible for maximization. We can update the mpg of each car by dividing it by sum of mpg of all cars (sum normalization) . If you notice, this is the first maximization equation from the figure above. Another option or formula is to consider the max of mpg (max normalization) or perform max-min scaling. The intention is, after applying this to the attribute that is eligible for maximization, the range of each attribute will be the same as well as we can infer that value close to 1 means good. Example for sum normalization heatmap of the original data. Check the \u2018mpg\u2019 value of \u2018ford torino\u2019. Originally its 17 but after sum normalization, it should be 17/156=0.109. Similarly, the \u2018price\u2019 is 20k, after inverse it will be 1/(20k/287872) = 14.4 Minimize: The formulae for minimizing is nearly the same as the maximizing one, we just inverse it (1 divided by maximize) or mirror it (by subtracting it from 1) to actually reverse the goodness direction (otherwise 1 will mean bad and 0 will mean good) .","title":"Normalize with Maximize and Minimize"},{"location":"machine_learning/ranking_algorithms/#apply-weights","text":"We just need to superimpose the weight over the optimized scores, which can be easily done by multiplying the weights to the optimized score. Here as well we can introduce different types of normalization, as it is : directly multiply the weights to optimized score sum : normalize the weights by sum logic (discussed above) then multiply. max : normalize by max logic, then multiply. weight modification logic","title":"Apply weights"},{"location":"machine_learning/ranking_algorithms/#combine-the-scores","text":"Finally, we combine the score to make it one. This can be done by two different logic, sum : add all individual scores together product : multiply all individual scores together. In fact, many implementations add the logarithm of the value instead of taking products, this is done to handle small values that can result in very smaller result when multiplying.","title":"Combine the scores"},{"location":"machine_learning/ranking_algorithms/#implementation","text":"Note Update - March 2022: Due to code breaking changes in the latest version of scikit-criteria, it is recommended to use v0.2.11 of the package for the code discussed in the article. Code repository is here. We have a python package named skcriteria that provides many algorithms for multi criteria decision-making problem. Actually two algorithms inside the skcriteria.madm.simple module are, WeightedSum \u2014 individual score combine logic is sum WeightedProduct \u2014 individual score combine logic is product (sum of log) And both of these methods take two parameters as input, mnorm \u2014 define value maximize normalization logic (minimization is always the inverse of the same maximize logic). wnorm \u2014 define weight normalization logic To perform ranking on our data, first, we need to load it as their skcriteria.Data object by, 1 2 3 4 5 6 7 criteria_data = Data ( cars_data . iloc [:, 1 :], # the pandas dataframe [ MAX , MAX , MIN , MAX , MIN ], # direction of goodness for each column anames = cars_data [ 'car_name' ], # each entity's name, here car name cnames = cars_data . columns [ 1 :], # attribute/column name # weights=[1,1,1,1,1] # weights for each attribute (optional) ) ALT./CRIT. mpg (max) displacement (max) weight (min) acceleration (max) price (min) chevrolet chevelle malibu 18 307 3504 12 25561.6 buick skylark 320 15 350 3693 11.5 24221.4 plymouth satellite 18 318 3436 11 27240.8 amc rebel sst 16 304 3433 12 33685 ford torino 17 302 3449 10.5 20000 ford galaxie 500 15 429 4341 10 30000 chevrolet impala 14 454 4354 9 35764.3 plymouth fury iii 14 440 4312 8.5 25899.5 pontiac catalina 14 455 4425 10 32882.5 amc ambassador dpl 15 390 3850 8.5 32617.1 With the data loaded, all we need to do is call the appropriate decision maker function with data object and parameter settings. The output has one additional rank column to show the final ranking by considering all of the mentioned criteria. 1 2 3 4 from skcriteria.madm import simple # weighted sum dm = simple . WeightedSum ( mnorm = \"sum\" ) dec = dm . decide ( criteria_data ) ALT./CRIT. mpg (max) displacement (max) weight (min) acceleration (max) price (min) Rank chevrolet chevelle malibu 18 307 3504 12 25561.6 3 buick skylark 320 15 350 3693 11.5 24221.4 2 plymouth satellite 18 318 3436 11 27240.8 4 amc rebel sst 16 304 3433 12 33685 6 ford torino 17 302 3449 10.5 20000 1 ford galaxie 500 15 429 4341 10 30000 8 chevrolet impala 14 454 4354 9 35764.3 10 plymouth fury iii 14 440 4312 8.5 25899.5 5 pontiac catalina 14 455 4425 10 32882.5 9 amc ambassador dpl 15 390 3850 8.5 32617.1 7 We can even export the final score by dec.e_.points and the ranks by dec.rank_ .","title":"Implementation"},{"location":"machine_learning/ranking_algorithms/#comparison","text":"Let\u2019s compare the result of different decision making algorithms (with different parameters) on our dataset. To do so, I use the weightedSum and weightedProduct implementations (once with max and then with sum value normalization). I also implemented a normalize_data function which by default performs minmax and subtract normalization. Then I apply a sum combine on the output. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # import from skcriteria.madm import simple # make a copy of original dataset cars_data_copy = cars_data . copy () # weighted sum, sumNorm dm = simple . WeightedSum ( mnorm = \"sum\" ) dec = dm . decide ( criteria_data ) cars_data_copy . loc [:, 'rank_weightedSum_sumNorm_inverse' ] = dec . rank_ # weighted sum, maxNorm dm = simple . WeightedSum ( mnorm = \"max\" ) dec = dm . decide ( criteria_data ) cars_data_copy . loc [:, 'rank_weightedSum_maxNorm_inverse' ] = dec . rank_ # weighted product, sumNorm dm = simple . WeightedProduct ( mnorm = \"sum\" ) dec = dm . decide ( criteria_data ) cars_data_copy . loc [:, 'rank_weightedProduct_sumNorm_inverse' ] = dec . rank_ # weighted product, sumNorm dm = simple . WeightedProduct ( mnorm = \"max\" ) dec = dm . decide ( criteria_data ) cars_data_copy . loc [:, 'rank_weightedProduct_maxNorm_inverse' ] = dec . rank_ # min max scale + mirror cars_data_copy . loc [:, 'rank_weightedSum_minmaxScale_subtract' ] = \\ pd . Series ( normalize_data () . sum ( axis = 1 )) . rank ( ascending = False ) . astype ( int ) Finally, I plot a parallel coordinate graphs, where each axis(vertical line) denotes one solver type and the values denote the rank of a car by that solver. Each line is for one car and going from left to right, it shows the journey \u2014 how the rank of a car changes as you switch among different solvers. Journey of a car as we switch decision solver Some points to consider, Ford Torino is rank 1 (car with the highest score) for 4/5 solvers. Minmax favors Chevrolet Malibu. Impala is the universal low ranker :( Both implementations of weightedProduct is giving the same ranking to all cars. Nothing interesting here. High variance in the rankings of both the weightedSum implementations. MinMax gives the most diverse rankings for top 4 guys. The main reason behind the variance of result when changing the normalization (from sum to max) is due to the translation done on the original data. This translation changes the range of data (like scales everything between x and y ) and in case of inverse modifies the linearity as well (say, equal steps of 1 in original data is not consistent in transformed data). This will become more clear by following result, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import numpy as np x = np . array ( range ( 1 , 10 )) print ( \"X: \" , x ) print ( \"MinMax: \" , minmax_scale ( x )) print ( \"MinMax_subtract: \" , 1 - minmax_scale ( x )) print ( \"sumNorm: \" , x / sum ( x )) print ( \"sumNorm_inverse: \" , ( 1 / ( x / sum ( x )))) print ( \"maxNorm: \" , x / max ( x )) print ( \"maxNorm_inverse: \" , 1 / ( x / max ( x ))) ## Output X : [ 1 2 3 4 5 6 7 8 9 ] MinMax : [ 0. 0.125 0.25 0.375 0.5 0.625 0.75 0.875 1. ] MinMax_subtract : [ 1. 0.875 0.75 0.625 0.5 0.375 0.25 0.125 0. ] sumNorm : [ 0.02222222 0.04444444 0.06666667 0.08888889 0.11111111 0.13333333 0.15555556 0.17777778 0.2 ] sumNorm_inverse : [ 45. 22.5 15. 11.25 9. 7.5 6.42857143 5.625 5. ] maxNorm : [ 0.11111111 0.22222222 0.33333333 0.44444444 0.55555556 0.66666667 0.77777778 0.88888889 1. ] maxNorm_inverse : [ 9. 4.5 3. 2.25 1.8 1.5 1.28571429 1.125 1. ] Here, input data consist numbers 1 to 9 (notice, the difference between any two consecutive number is 1 i.e. step is same). Approach one (minmax) translates the data between 0 and 1 and the step is still the same. Now look at minimization logic ( _inverse ) of approach 2 and 3. Here at the start (low original values) the step is nearly the half of the last element, but near the end (high original value) the step is very small, even though in the original data we are moving with same step of 1. Because of this, in case of minimization, a very high score is given to \u201cgood\u201d cars (with low values) and even a small impurity matter (when minimized, high value = low score) and results in a drastic decrease in score. It\u2019s like we are being very picky, either you are the best or you get half the score :) On the other hand, for higher values, small impurities doesn\u2019t matter. If the car is already bad by that attribute, then we don\u2019t care if its value is 7 or 8 or 9 and the reduction in the score is much less! We can use this understanding to pick the right decision solver with the right parameter as per our need.","title":"Comparison"},{"location":"machine_learning/ranking_algorithms/#conclusion","text":"This article has just touched the surface of the multi-criteria decision making domain. Even in skcriteria package there are many more algorithms like TOPSIS and MOORA which have quite a different intuition to solve these problems. But even then the notion of goodness and the idea to handle individual attributes to finally combine them all together is used in many of them. So maybe we will explore more algorithms in another article. The major takeaways from this article should be to understand the why and what of decision makers. That each such decision can be manipulated by multiple criteria. And also that we may have a different notion of goodness and importance assigned to each criterion. Finally, we have different varieties of solvers that can be build by taking permutation of logic and parameters, and nearly all of them give different and interesting results based on our need! Cheers","title":"Conclusion"},{"location":"natural_language_processing/BERT/","text":"BERT Introduction BERT stands for B idirectional E ncoder R epresentations from T ransformers. ( devlin2019bert ) Basically, it is a modification of Transformers ( vaswani2017attention ), where we just keep the encoder part and discard the decoder part. Transformer architecture. BERT is the left part i.e. encoder part. ( vaswani2017attention ) At the time of release, it obtained state-of-the-art results on eleven natural language processing tasks. To quote the paper, \" [paper pushed] the GLUE score to 80.5% (7.7% point absolute improvement), MultiNLI accuracy to 86.7% (4.6% absolute improvement), SQuAD v1.1 question answering Test F1 to 93.2 (1.5 point absolute improvement) and SQuAD v2.0 Test F1 to 83.1 (5.1 point absolute improvement). \" The major motivation behind BERT is to handle the limitation of the existing language models which are unidirectional in nature. This means that they only consider text left to right for sentence level inference. BERT on the other hand, allows tokens to attend to both sides in self-attention layer. This is one of the major reason for it high performance. Differences in pre-training model architectures. BERT uses a bidirectional Transformer. OpenAI GPT uses a left-to-right Transformer. ELMo uses the concatenation of independently trained left-to-right and right-toleft LSTMs to generate features for downstream tasks. Among the three, only BERT representations are jointly conditioned on both left and right context in all layers. In addition to the architecture differences, BERT and OpenAI GPT are fine-tuning approaches, while ELMo is a feature-based approach.. ( devlin2019bert ) The most fascinating feature of BERT is that it is super easy to use it for a large number of NLP tasks. The idea is to take the pretrained BERT model and later fine tune it for the specific task. The pre-trained model is trained on a large corpus in a unsupervised manner, hence the model learns the generic representations of the tokens from large corpus of text. This makes it easy to later fine tune it for any other NLP task, as the model comes pretrained with large context about the language, grammar and semantic representations. Illustrations of Fine-tuning BERT on Different Tasks. ( devlin2019bert ) Training BERT is an interesting paradigm in itself. The original paper proposed two unsupervised methods for training, Masked LM (MLM) : Where some percentage (15%) of the input tokens are masked at random, and then the model tries to predict those masked tokens. They created a special token [MASK] for this purpose. Next Sentence Prediction (NSP) : Where two sentences A and B are chosen such that, 50% of the time B is the actual next sentence that follows A (labelled as IsNext ), and 50% of the time it is a random sentence from the corpus (labelled as NotNext ). The model is trained to predict if the second sentences follow the first or not. Analysis BERT output and finetuning (unsupervised) An analysis on the selection of suitable BERT output and the advantage of fine-tuning (unsupervised learning on unlabeled data on tasks like MLM) the model was done. The report provides following performance table comparing different experiments. Complete article here . Exp no Model name F1 macro score Accuracy 1 Pooler output 64.6% 68.4% 2 Last hidden state 86.7% 87.5% 3 Fine-tuned and Pooler output 87.5% 88.1% 4 Fine-tuned and last hidden state 79.8% 81.3% It also answers following questions, Should I only use CLS token or all token's output for sentence representation? Well, it depends. From the experiments, it seems if you are fine-tuning the model, using the pooler output will be better. But if there is no fine-tuning, the last hidden state output is much better. Personally, I will prefer the last hidden state output, as it provides comparative result without any additional compute expensive fine-tuning. Will fine-tuning the model beforehand increase the accuracy? A definite yes! Exp 3 and 4 reports higher score than Exp 1 and 2. So if you have the time and resource (which ironically is not usually the case), go for fine-tuning! Is BERT a Text Generation model? Short answer is no. BERT is not a text generation model or a language model because the probability of the predicting a token in masked input is dependent on the context of the token. This context is bidirectional, hence the model is not able to predict the next token in the sequence accurately with only one directional context (as expected for language model) . Several analysis were done on the text generation prowess of BERT model. One such analysis is presented in this paper . Here the authors presents BERT as markov random field language model. Then after some errors were pointed out wrt paper, the authors corrected the claim and suggested BERT is a non-equilibrium language model ( here ) Tip Do you know that during mask prediction, BERT model predicts some tokens for [PAD] tokens as well. This is true for sentences that are smaller than the max length of the model and hence require padding. In a sense, this is kind of text generation, where you just provide the sentence and the model predicts the next token till the max length. But as expected the prediction is not that accurate. BERT for sentence representation? One question usually asked is that - \"Can we use BERT to generate meaningful sentence representations?\" The answer is \"No\". Don't get me wrong, while it is possible to use BERT to generate sentence representations, but the key word here is \"meaningful\". One of the way to do this is to pass one sentence to the model and get the representation for fixed [CLS] token as sentence representation. But as shown in [2], this common practice yields bad sentence embedding, often even worse than Glove embeddings (which was introduced in 2014) ! The major problem here is the pre-training strategy used to train BERT. While it is good for downstream tasks like classification, it's not that good for generating generic representations. This is because for correct sentence representation, we want the embeddings of similar sentences closer to each other and dissimilar sentences to be further apart. And this is not what happens during BERT pretraining. To cater to this issue, we will have to further finetune the model. And in fact, this is where BERT shines again, as with minimal training (sometimes even for 20 mins with <1000 samples) we can expect good results. One of the ways to finetune for sentence represenration is to use triplet loss. For this, we prepare a dataset with a combination of (anchor, positive, negative) sentences. Here anchor is the base sentence, positive is the sentence that is similar to the anchor sentence, and negative is the sentence that is dissimilar to the anchor sentence. The model is trained to \"bring\" the representation of (anchor, positive) closer and (anchor, negative) apart. The loss is defined below, where \\(s_*\\) is the respective sentence representation and \\(\\epsilon\\) is the margin. \\[triplet loss = max( \\parallel s_a - s_p \\parallel - \\parallel s_a - s_n \\parallel + \\epsilon , 0)\\] Code Pretrained BERT for Sentiment Classification The code contains the Dataset and Dataloader as well, which can be referred for any fine tuning task. Download dataset from IMDB 50k review 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 # helper import pandas as pd import numpy as np from tqdm import tqdm from sklearn.model_selection import train_test_split # for BERT model from transformers import BertTokenizer , BertModel from transformers import BertForSequenceClassification # for DL stuff import torch import pytorch_lightning as pl from torch.nn import Softmax , Linear from torchmetrics import Accuracy , F1 from torch.utils.data import Dataset , DataLoader from pytorch_lightning.loggers import WandbLogger model_name = 'bert-base-uncased' # load dataset and sample 10k reviews. df = pd . read_csv ( \"../input/imdb-dataset-of-50k-movie-reviews/IMDB Dataset.csv\" ) df = df . sample ( 10000 , random_state = 1 ) # divide into test and train X_train , X_test , y_train , y_test = \\ train_test_split ( df [ 'review' ] . tolist (), df [ 'sentiment' ] . tolist (), shuffle = True , test_size = 0.33 , random_state = 1 , stratify = df [ 'sentiment' ]) # define dataset with load and prep functions. Pass all the data at a time. def squz ( x , dim = 0 ): return torch . squeeze ( x , dim ) class IMDBDataset ( Dataset ): def __init__ ( self , sentences , labels , max_length = 512 , model_name = 'bert-base-uncased' ): # var self . sentences = sentences self . labels = [[ 'positive' , 'negative' ] . index ( x ) for x in labels ] self . max_length = max_length # tokenizer self . tokenizer = BertTokenizer . from_pretrained ( model_name ) def __len__ ( self ): return len ( self . sentences ) def __getitem__ ( self , index ): # Select sample sentence = self . sentences [ index ] label = self . labels [ index ] # Load data and get label X = self . tokenizer ( sentence , padding = \"max_length\" , truncation = True , max_length = self . max_length , return_tensors = \"pt\" ) X = { key : squz ( value ) for key , value in X . items ()} y = label # return return X , y # init the train and test dataset train_dataset = IMDBDataset ( X_train , y_train ) test_dataset = IMDBDataset ( X_test , y_test ) # create the dataloader train_dataloader = DataLoader ( train_dataset , batch_size = 16 , shuffle = True ) test_dataloader = DataLoader ( test_dataset , batch_size = 16 , shuffle = True ) # define BERT model class BERT_pooler_output ( pl . LightningModule ): def __init__ ( self , model_name = 'bert-base-uncased' ): super () . __init__ () # model and layers self . BERTModel = BertModel . from_pretrained ( model_name ) self . linear1 = Linear ( 768 , 128 ) self . linear2 = Linear ( 128 , 2 ) self . softmax = Softmax ( dim = 1 ) self . relu = torch . nn . ReLU () # loss self . criterion = torch . nn . CrossEntropyLoss () # performance self . accuracy = Accuracy () self . f1 = F1 ( num_classes = 2 , average = 'macro' ) def forward ( self , x ): # pass input to BERTmodel input_ids , attention_mask = x [ 'input_ids' ], x [ 'attention_mask' ] bert_output = self . BERTModel ( input_ids , attention_mask = attention_mask ) output = bert_output . pooler_output output = self . relu ( self . linear1 ( output )) output = self . linear2 ( output ) return output def training_step ( self , batch , batch_idx ): x , y = batch x_hat = self . forward ( x ) loss = self . criterion ( x_hat , y ) acc = self . accuracy ( x_hat . argmax ( dim = 1 ), y ) f1 = self . f1 ( x_hat . argmax ( dim = 1 ), y ) self . log ( 'loss' , loss , on_step = False , on_epoch = True , prog_bar = True , logger = True ) self . log ( 'acc' , acc , on_step = False , on_epoch = True , prog_bar = True , logger = True ) self . log ( 'f1' , f1 , on_step = False , on_epoch = True , prog_bar = True , logger = True ) return { 'loss' : loss } def validation_step ( self , batch , batch_idx ): x , y = batch x_hat = self . forward ( x ) acc = self . accuracy ( x_hat . argmax ( dim = 1 ), y ) f1 = self . f1 ( x_hat . argmax ( dim = 1 ), y ) self . log ( 'val_acc' , acc , on_step = False , on_epoch = True , prog_bar = True , logger = True ) self . log ( 'val_f1' , f1 , on_step = False , on_epoch = True , prog_bar = True , logger = True ) def configure_optimizers ( self ): # freezing the params of BERT model for name , param in self . named_parameters (): if 'BERTModel' in name : param . requires_grad = False # define the optimizer optimizer = torch . optim . Adam ( filter ( lambda p : p . requires_grad , self . parameters ()), lr = 1e-3 ) return optimizer # init model model = BERT_pooler_output () # init trainer trainer = pl . Trainer ( gpus = 1 , max_epochs = 3 ) # train the model trainer . fit ( model , train_dataloader , test_dataloader ) Fine tuning the BERT model Fine tuning could include training BERT on one or many of the proposed unsupervised tasks. Here, we will train the BERT on MLM (Masked language modeling) task. This includes masking some tokens of input and BERT predicting the token based on the context tokens. Referenced from this video of James Briggs . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 # IMPORT ========= import pandas as pd from tqdm import tqdm import numpy as np import numpy as np # for deep learning import torch import torch.nn as nn import torch.optim as optim # load BERT model from transformers import AdamW from transformers import BertTokenizer , BertForMaskedLM # MODEL LOAD ========= model_path = \"bert-base-uncased\" # if local copy is not present tokenizer = BertTokenizer . from_pretrained ( model_path ) model = BertForMaskedLM . from_pretrained ( model_path ) # DATA PREP 1 ========= df = pd . read_csv ( \"file_with_text.csv\" ) # tokenize inputs = tokenizer ( df [ 'review' ] . tolist (), return_tensors = 'pt' , max_length = 512 , truncation = True , padding = 'max_length' ) inputs [ 'labels' ] = inputs . input_ids . detach () . clone () # create random array of floats with equal dimensions to input_ids tensor rand = torch . rand ( inputs . input_ids . shape ) # create mask array - mask tokens except special tokens like CLS and SEP mask_ratio = 0.3 mask_arr = ( rand < mask_ratio ) * ( inputs . input_ids != 101 ) * \\ ( inputs . input_ids != 102 ) * ( inputs . input_ids != 0 ) # get the indices where to add mask selection = [] for i in range ( inputs . input_ids . shape [ 0 ]): selection . append ( torch . flatten ( mask_arr [ i ] . nonzero ()) . tolist () ) # add the mask for i in range ( inputs . input_ids . shape [ 0 ]): inputs . input_ids [ i , selection [ i ]] = 103 # DATA PREP 2 - DATALOADER ========= # define dataset class class IMDBDataset ( torch . utils . data . Dataset ): def __init__ ( self , encodings ): self . encodings = encodings def __getitem__ ( self , idx ): return { key : torch . tensor ( val [ idx ]) for key , val in self . encodings . items ()} def __len__ ( self ): return len ( self . encodings . input_ids ) # create instance dataset = IMDBDataset ( inputs ) loader = torch . utils . data . DataLoader ( dataset , batch_size = 8 , shuffle = True ) # PRE_TRAIN ============= device = torch . device ( 'cuda' ) if torch . cuda . is_available () else torch . device ( 'cpu' ) # and move our model over to the selected device model . to ( device ) # activate training mode model . train () # initialize optimizer optimizer = AdamW ( model . parameters (), lr = 5e-5 ) # TRAIN ===================== epochs = 20 for epoch in range ( epochs ): # setup loop with TQDM and dataloader loop = tqdm ( loader , leave = True ) for batch in loop : # initialize calculated gradients (from prev step) optimizer . zero_grad () # pull all tensor batches required for training input_ids = batch [ 'input_ids' ] . to ( device ) attention_mask = batch [ 'attention_mask' ] . to ( device ) labels = batch [ 'labels' ] . to ( device ) # process outputs = model ( input_ids , attention_mask = attention_mask , labels = labels ) # extract loss loss = outputs . loss # calculate loss for every parameter that needs grad update loss . backward () # update parameters optimizer . step () # print relevant info to progress bar loop . set_description ( f 'Epoch { epoch } ' ) loop . set_postfix ( loss = loss . item ()) # SAVE MODEL ===================== model . save_pretrained ( \"bert_finetuned_on_text/\" ) tokenizer . save_pretrained ( \"bert_finetuned_on_text/\" ) BERT output for sentence level inference BERT provides pooler_output and last_hidden_state as two potential \" representations \" for sentence level inference. pooler_output is the embedding of the [CLS] special token. In many cases it is considered as a valid representation of the complete sentence. 1 2 3 BERTModel = BertModel . from_pretrained ( 'bert-base-uncased' ) bert_output = BERTModel ( input_ids , attention_mask = attention_mask ) output = bert_output . pooler_output last_hidden_state contains the embeddings of all tokens in the sentence from the last hidden state. We can apply permutation invariant methods (like max, mean or sum) to aggregate the embeddings into a single sentence representation. 1 2 3 BERTModel = BertModel . from_pretrained ( 'bert-base-uncased' ) bert_output = BERTModel ( input_ids , attention_mask = attention_mask ) output = squeeze ( torch . matmul ( attention_mask . type ( torch . float32 ) . view ( - 1 , 1 , 512 ), bert_output [ 'last_hidden_state' ]), 1 ) Tip Consider finetuning the BERT model (triplet loss) further to generate meaningful sentence representation, as pretrained BERT model is even worse than Glove embeddings [2]. For more details look at this analysis or use S-BERT package to finetune. References [1] Jay Alammar's blog \"The Illustrated BERT, ELMo, and co. (How NLP Cracked Transfer Learning)\" [2] Sentence-BERT: Sentence Embeddings using Siamese BERT-Networks","title":"BERT"},{"location":"natural_language_processing/BERT/#bert","text":"","title":"BERT"},{"location":"natural_language_processing/BERT/#introduction","text":"BERT stands for B idirectional E ncoder R epresentations from T ransformers. ( devlin2019bert ) Basically, it is a modification of Transformers ( vaswani2017attention ), where we just keep the encoder part and discard the decoder part. Transformer architecture. BERT is the left part i.e. encoder part. ( vaswani2017attention ) At the time of release, it obtained state-of-the-art results on eleven natural language processing tasks. To quote the paper, \" [paper pushed] the GLUE score to 80.5% (7.7% point absolute improvement), MultiNLI accuracy to 86.7% (4.6% absolute improvement), SQuAD v1.1 question answering Test F1 to 93.2 (1.5 point absolute improvement) and SQuAD v2.0 Test F1 to 83.1 (5.1 point absolute improvement). \" The major motivation behind BERT is to handle the limitation of the existing language models which are unidirectional in nature. This means that they only consider text left to right for sentence level inference. BERT on the other hand, allows tokens to attend to both sides in self-attention layer. This is one of the major reason for it high performance. Differences in pre-training model architectures. BERT uses a bidirectional Transformer. OpenAI GPT uses a left-to-right Transformer. ELMo uses the concatenation of independently trained left-to-right and right-toleft LSTMs to generate features for downstream tasks. Among the three, only BERT representations are jointly conditioned on both left and right context in all layers. In addition to the architecture differences, BERT and OpenAI GPT are fine-tuning approaches, while ELMo is a feature-based approach.. ( devlin2019bert ) The most fascinating feature of BERT is that it is super easy to use it for a large number of NLP tasks. The idea is to take the pretrained BERT model and later fine tune it for the specific task. The pre-trained model is trained on a large corpus in a unsupervised manner, hence the model learns the generic representations of the tokens from large corpus of text. This makes it easy to later fine tune it for any other NLP task, as the model comes pretrained with large context about the language, grammar and semantic representations. Illustrations of Fine-tuning BERT on Different Tasks. ( devlin2019bert ) Training BERT is an interesting paradigm in itself. The original paper proposed two unsupervised methods for training, Masked LM (MLM) : Where some percentage (15%) of the input tokens are masked at random, and then the model tries to predict those masked tokens. They created a special token [MASK] for this purpose. Next Sentence Prediction (NSP) : Where two sentences A and B are chosen such that, 50% of the time B is the actual next sentence that follows A (labelled as IsNext ), and 50% of the time it is a random sentence from the corpus (labelled as NotNext ). The model is trained to predict if the second sentences follow the first or not.","title":"Introduction"},{"location":"natural_language_processing/BERT/#analysis","text":"","title":"Analysis"},{"location":"natural_language_processing/BERT/#bert-output-and-finetuning-unsupervised","text":"An analysis on the selection of suitable BERT output and the advantage of fine-tuning (unsupervised learning on unlabeled data on tasks like MLM) the model was done. The report provides following performance table comparing different experiments. Complete article here . Exp no Model name F1 macro score Accuracy 1 Pooler output 64.6% 68.4% 2 Last hidden state 86.7% 87.5% 3 Fine-tuned and Pooler output 87.5% 88.1% 4 Fine-tuned and last hidden state 79.8% 81.3% It also answers following questions, Should I only use CLS token or all token's output for sentence representation? Well, it depends. From the experiments, it seems if you are fine-tuning the model, using the pooler output will be better. But if there is no fine-tuning, the last hidden state output is much better. Personally, I will prefer the last hidden state output, as it provides comparative result without any additional compute expensive fine-tuning. Will fine-tuning the model beforehand increase the accuracy? A definite yes! Exp 3 and 4 reports higher score than Exp 1 and 2. So if you have the time and resource (which ironically is not usually the case), go for fine-tuning!","title":"BERT output and finetuning (unsupervised)"},{"location":"natural_language_processing/BERT/#is-bert-a-text-generation-model","text":"Short answer is no. BERT is not a text generation model or a language model because the probability of the predicting a token in masked input is dependent on the context of the token. This context is bidirectional, hence the model is not able to predict the next token in the sequence accurately with only one directional context (as expected for language model) . Several analysis were done on the text generation prowess of BERT model. One such analysis is presented in this paper . Here the authors presents BERT as markov random field language model. Then after some errors were pointed out wrt paper, the authors corrected the claim and suggested BERT is a non-equilibrium language model ( here ) Tip Do you know that during mask prediction, BERT model predicts some tokens for [PAD] tokens as well. This is true for sentences that are smaller than the max length of the model and hence require padding. In a sense, this is kind of text generation, where you just provide the sentence and the model predicts the next token till the max length. But as expected the prediction is not that accurate.","title":"Is BERT a Text Generation model?"},{"location":"natural_language_processing/BERT/#bert-for-sentence-representation","text":"One question usually asked is that - \"Can we use BERT to generate meaningful sentence representations?\" The answer is \"No\". Don't get me wrong, while it is possible to use BERT to generate sentence representations, but the key word here is \"meaningful\". One of the way to do this is to pass one sentence to the model and get the representation for fixed [CLS] token as sentence representation. But as shown in [2], this common practice yields bad sentence embedding, often even worse than Glove embeddings (which was introduced in 2014) ! The major problem here is the pre-training strategy used to train BERT. While it is good for downstream tasks like classification, it's not that good for generating generic representations. This is because for correct sentence representation, we want the embeddings of similar sentences closer to each other and dissimilar sentences to be further apart. And this is not what happens during BERT pretraining. To cater to this issue, we will have to further finetune the model. And in fact, this is where BERT shines again, as with minimal training (sometimes even for 20 mins with <1000 samples) we can expect good results. One of the ways to finetune for sentence represenration is to use triplet loss. For this, we prepare a dataset with a combination of (anchor, positive, negative) sentences. Here anchor is the base sentence, positive is the sentence that is similar to the anchor sentence, and negative is the sentence that is dissimilar to the anchor sentence. The model is trained to \"bring\" the representation of (anchor, positive) closer and (anchor, negative) apart. The loss is defined below, where \\(s_*\\) is the respective sentence representation and \\(\\epsilon\\) is the margin. \\[triplet loss = max( \\parallel s_a - s_p \\parallel - \\parallel s_a - s_n \\parallel + \\epsilon , 0)\\]","title":"BERT for sentence representation?"},{"location":"natural_language_processing/BERT/#code","text":"","title":"Code"},{"location":"natural_language_processing/BERT/#pretrained-bert-for-sentiment-classification","text":"The code contains the Dataset and Dataloader as well, which can be referred for any fine tuning task. Download dataset from IMDB 50k review 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 # helper import pandas as pd import numpy as np from tqdm import tqdm from sklearn.model_selection import train_test_split # for BERT model from transformers import BertTokenizer , BertModel from transformers import BertForSequenceClassification # for DL stuff import torch import pytorch_lightning as pl from torch.nn import Softmax , Linear from torchmetrics import Accuracy , F1 from torch.utils.data import Dataset , DataLoader from pytorch_lightning.loggers import WandbLogger model_name = 'bert-base-uncased' # load dataset and sample 10k reviews. df = pd . read_csv ( \"../input/imdb-dataset-of-50k-movie-reviews/IMDB Dataset.csv\" ) df = df . sample ( 10000 , random_state = 1 ) # divide into test and train X_train , X_test , y_train , y_test = \\ train_test_split ( df [ 'review' ] . tolist (), df [ 'sentiment' ] . tolist (), shuffle = True , test_size = 0.33 , random_state = 1 , stratify = df [ 'sentiment' ]) # define dataset with load and prep functions. Pass all the data at a time. def squz ( x , dim = 0 ): return torch . squeeze ( x , dim ) class IMDBDataset ( Dataset ): def __init__ ( self , sentences , labels , max_length = 512 , model_name = 'bert-base-uncased' ): # var self . sentences = sentences self . labels = [[ 'positive' , 'negative' ] . index ( x ) for x in labels ] self . max_length = max_length # tokenizer self . tokenizer = BertTokenizer . from_pretrained ( model_name ) def __len__ ( self ): return len ( self . sentences ) def __getitem__ ( self , index ): # Select sample sentence = self . sentences [ index ] label = self . labels [ index ] # Load data and get label X = self . tokenizer ( sentence , padding = \"max_length\" , truncation = True , max_length = self . max_length , return_tensors = \"pt\" ) X = { key : squz ( value ) for key , value in X . items ()} y = label # return return X , y # init the train and test dataset train_dataset = IMDBDataset ( X_train , y_train ) test_dataset = IMDBDataset ( X_test , y_test ) # create the dataloader train_dataloader = DataLoader ( train_dataset , batch_size = 16 , shuffle = True ) test_dataloader = DataLoader ( test_dataset , batch_size = 16 , shuffle = True ) # define BERT model class BERT_pooler_output ( pl . LightningModule ): def __init__ ( self , model_name = 'bert-base-uncased' ): super () . __init__ () # model and layers self . BERTModel = BertModel . from_pretrained ( model_name ) self . linear1 = Linear ( 768 , 128 ) self . linear2 = Linear ( 128 , 2 ) self . softmax = Softmax ( dim = 1 ) self . relu = torch . nn . ReLU () # loss self . criterion = torch . nn . CrossEntropyLoss () # performance self . accuracy = Accuracy () self . f1 = F1 ( num_classes = 2 , average = 'macro' ) def forward ( self , x ): # pass input to BERTmodel input_ids , attention_mask = x [ 'input_ids' ], x [ 'attention_mask' ] bert_output = self . BERTModel ( input_ids , attention_mask = attention_mask ) output = bert_output . pooler_output output = self . relu ( self . linear1 ( output )) output = self . linear2 ( output ) return output def training_step ( self , batch , batch_idx ): x , y = batch x_hat = self . forward ( x ) loss = self . criterion ( x_hat , y ) acc = self . accuracy ( x_hat . argmax ( dim = 1 ), y ) f1 = self . f1 ( x_hat . argmax ( dim = 1 ), y ) self . log ( 'loss' , loss , on_step = False , on_epoch = True , prog_bar = True , logger = True ) self . log ( 'acc' , acc , on_step = False , on_epoch = True , prog_bar = True , logger = True ) self . log ( 'f1' , f1 , on_step = False , on_epoch = True , prog_bar = True , logger = True ) return { 'loss' : loss } def validation_step ( self , batch , batch_idx ): x , y = batch x_hat = self . forward ( x ) acc = self . accuracy ( x_hat . argmax ( dim = 1 ), y ) f1 = self . f1 ( x_hat . argmax ( dim = 1 ), y ) self . log ( 'val_acc' , acc , on_step = False , on_epoch = True , prog_bar = True , logger = True ) self . log ( 'val_f1' , f1 , on_step = False , on_epoch = True , prog_bar = True , logger = True ) def configure_optimizers ( self ): # freezing the params of BERT model for name , param in self . named_parameters (): if 'BERTModel' in name : param . requires_grad = False # define the optimizer optimizer = torch . optim . Adam ( filter ( lambda p : p . requires_grad , self . parameters ()), lr = 1e-3 ) return optimizer # init model model = BERT_pooler_output () # init trainer trainer = pl . Trainer ( gpus = 1 , max_epochs = 3 ) # train the model trainer . fit ( model , train_dataloader , test_dataloader )","title":"Pretrained BERT for Sentiment Classification"},{"location":"natural_language_processing/BERT/#fine-tuning-the-bert-model","text":"Fine tuning could include training BERT on one or many of the proposed unsupervised tasks. Here, we will train the BERT on MLM (Masked language modeling) task. This includes masking some tokens of input and BERT predicting the token based on the context tokens. Referenced from this video of James Briggs . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 # IMPORT ========= import pandas as pd from tqdm import tqdm import numpy as np import numpy as np # for deep learning import torch import torch.nn as nn import torch.optim as optim # load BERT model from transformers import AdamW from transformers import BertTokenizer , BertForMaskedLM # MODEL LOAD ========= model_path = \"bert-base-uncased\" # if local copy is not present tokenizer = BertTokenizer . from_pretrained ( model_path ) model = BertForMaskedLM . from_pretrained ( model_path ) # DATA PREP 1 ========= df = pd . read_csv ( \"file_with_text.csv\" ) # tokenize inputs = tokenizer ( df [ 'review' ] . tolist (), return_tensors = 'pt' , max_length = 512 , truncation = True , padding = 'max_length' ) inputs [ 'labels' ] = inputs . input_ids . detach () . clone () # create random array of floats with equal dimensions to input_ids tensor rand = torch . rand ( inputs . input_ids . shape ) # create mask array - mask tokens except special tokens like CLS and SEP mask_ratio = 0.3 mask_arr = ( rand < mask_ratio ) * ( inputs . input_ids != 101 ) * \\ ( inputs . input_ids != 102 ) * ( inputs . input_ids != 0 ) # get the indices where to add mask selection = [] for i in range ( inputs . input_ids . shape [ 0 ]): selection . append ( torch . flatten ( mask_arr [ i ] . nonzero ()) . tolist () ) # add the mask for i in range ( inputs . input_ids . shape [ 0 ]): inputs . input_ids [ i , selection [ i ]] = 103 # DATA PREP 2 - DATALOADER ========= # define dataset class class IMDBDataset ( torch . utils . data . Dataset ): def __init__ ( self , encodings ): self . encodings = encodings def __getitem__ ( self , idx ): return { key : torch . tensor ( val [ idx ]) for key , val in self . encodings . items ()} def __len__ ( self ): return len ( self . encodings . input_ids ) # create instance dataset = IMDBDataset ( inputs ) loader = torch . utils . data . DataLoader ( dataset , batch_size = 8 , shuffle = True ) # PRE_TRAIN ============= device = torch . device ( 'cuda' ) if torch . cuda . is_available () else torch . device ( 'cpu' ) # and move our model over to the selected device model . to ( device ) # activate training mode model . train () # initialize optimizer optimizer = AdamW ( model . parameters (), lr = 5e-5 ) # TRAIN ===================== epochs = 20 for epoch in range ( epochs ): # setup loop with TQDM and dataloader loop = tqdm ( loader , leave = True ) for batch in loop : # initialize calculated gradients (from prev step) optimizer . zero_grad () # pull all tensor batches required for training input_ids = batch [ 'input_ids' ] . to ( device ) attention_mask = batch [ 'attention_mask' ] . to ( device ) labels = batch [ 'labels' ] . to ( device ) # process outputs = model ( input_ids , attention_mask = attention_mask , labels = labels ) # extract loss loss = outputs . loss # calculate loss for every parameter that needs grad update loss . backward () # update parameters optimizer . step () # print relevant info to progress bar loop . set_description ( f 'Epoch { epoch } ' ) loop . set_postfix ( loss = loss . item ()) # SAVE MODEL ===================== model . save_pretrained ( \"bert_finetuned_on_text/\" ) tokenizer . save_pretrained ( \"bert_finetuned_on_text/\" )","title":"Fine tuning the BERT model"},{"location":"natural_language_processing/BERT/#bert-output-for-sentence-level-inference","text":"BERT provides pooler_output and last_hidden_state as two potential \" representations \" for sentence level inference. pooler_output is the embedding of the [CLS] special token. In many cases it is considered as a valid representation of the complete sentence. 1 2 3 BERTModel = BertModel . from_pretrained ( 'bert-base-uncased' ) bert_output = BERTModel ( input_ids , attention_mask = attention_mask ) output = bert_output . pooler_output last_hidden_state contains the embeddings of all tokens in the sentence from the last hidden state. We can apply permutation invariant methods (like max, mean or sum) to aggregate the embeddings into a single sentence representation. 1 2 3 BERTModel = BertModel . from_pretrained ( 'bert-base-uncased' ) bert_output = BERTModel ( input_ids , attention_mask = attention_mask ) output = squeeze ( torch . matmul ( attention_mask . type ( torch . float32 ) . view ( - 1 , 1 , 512 ), bert_output [ 'last_hidden_state' ]), 1 ) Tip Consider finetuning the BERT model (triplet loss) further to generate meaningful sentence representation, as pretrained BERT model is even worse than Glove embeddings [2]. For more details look at this analysis or use S-BERT package to finetune.","title":"BERT output for sentence level inference"},{"location":"natural_language_processing/BERT/#references","text":"[1] Jay Alammar's blog \"The Illustrated BERT, ELMo, and co. (How NLP Cracked Transfer Learning)\" [2] Sentence-BERT: Sentence Embeddings using Siamese BERT-Networks","title":"References"},{"location":"natural_language_processing/FlanModels/","text":"Flan Models Introduction In \u201cScaling Instruction-Finetuned Language Models\u201d, researchers propose an LLM fine-tuning strategy that focus on using dataset in form of instructions with other tricks like (1) scaling the number of tasks, (2) scaling the model size, and (3) finetuning on chain-of-thought data. The resulting models were called Flan-{source_model} like Flan-T5 and Flan-PaLM which showcase enhanced performance when compared with their namesakes. Flan models are finetuned on ~1.8k tasks w & w/o CoT and exemplars (zero shots and few shots) and evaluated on unseen tasks. Note All Flan models like Flan-T5 are only finetuned and not trained from scratch. Dataset The Flan models were finetuned on 1836 tasks. Here are some definitions, \u201c Dataset\u201d is an data source (ex: SQuAD) , \u201c Task category \u201d is a unique task setup like query generation or question answering. \u201c Task \u201d is unique combinations of <dataset, task category> . This is possible because a single dataset can be used for different task categrory (ex: SQuAD for query generation or QA or context generation) . Combining 473 datasets and 146 task category we end up with 1836 different tasks. Dataset, Task Category and Task details of finetuning and held out data. Finetuning process Instruction finetuning was performed for T5, PaLM and U-PaLM, where the model sizes span from Flan-T5-small (80M parameters) , to PaLM and U-PaLM (540B parameters) . Same training procedure was used for each model except for a few hyperparameters like learning rate, batch size, dropout, and finetuning steps. Constant learning rate schedule was used to finetune using the Adafactor optimizer. Notably, the amount of compute used for finetuning is only a small fraction relative to the training compute, as shown in the table below. All Flan models only use a fraction of compute for finetuning that was used for model training, with max usage going only upto 1.6%. Results Instruction finetuning (Flan) showcased improved performance across multiple models and dataset, sometimes going as far as double digit improvements! Code The code of inference and finetuning Flan models are very similar to the original models. Below we will show inference code for Flan-T5, which is similar to the T5 inference . Similarly, if you want to further finetune Flan-T5 for your use case, you can refer T5 finetuning code . If you are using HuggingFace, then all you need to do is replace the model name to google/flan-t5-{size} , where size could be small , base , large , xl and xxl . Flan-T5 Inference The following code is referenced from the HuggingFace Flan-T5 page [2] 1 2 3 4 5 6 7 8 9 10 11 # import from transformers import AutoModelForSeq2SeqLM , AutoTokenizer # load the model and tokenizer model = AutoModelForSeq2SeqLM . from_pretrained ( \"google/flan-t5-small\" ) tokenizer = AutoTokenizer . from_pretrained ( \"google/flan-t5-small\" ) # run on sample input inputs = tokenizer ( \"A step by step recipe to make bolognese pasta:\" , return_tensors = \"pt\" ) outputs = model . generate ( ** inputs ) print ( tokenizer . batch_decode ( outputs , skip_special_tokens = True )) References [1] Scaling Instruction-Finetuned Language Models - Paper [2] FlanT5 - HuggingFace","title":"FlanModels"},{"location":"natural_language_processing/FlanModels/#flan-models","text":"","title":"Flan Models"},{"location":"natural_language_processing/FlanModels/#introduction","text":"In \u201cScaling Instruction-Finetuned Language Models\u201d, researchers propose an LLM fine-tuning strategy that focus on using dataset in form of instructions with other tricks like (1) scaling the number of tasks, (2) scaling the model size, and (3) finetuning on chain-of-thought data. The resulting models were called Flan-{source_model} like Flan-T5 and Flan-PaLM which showcase enhanced performance when compared with their namesakes. Flan models are finetuned on ~1.8k tasks w & w/o CoT and exemplars (zero shots and few shots) and evaluated on unseen tasks. Note All Flan models like Flan-T5 are only finetuned and not trained from scratch.","title":"Introduction"},{"location":"natural_language_processing/FlanModels/#dataset","text":"The Flan models were finetuned on 1836 tasks. Here are some definitions, \u201c Dataset\u201d is an data source (ex: SQuAD) , \u201c Task category \u201d is a unique task setup like query generation or question answering. \u201c Task \u201d is unique combinations of <dataset, task category> . This is possible because a single dataset can be used for different task categrory (ex: SQuAD for query generation or QA or context generation) . Combining 473 datasets and 146 task category we end up with 1836 different tasks. Dataset, Task Category and Task details of finetuning and held out data.","title":"Dataset"},{"location":"natural_language_processing/FlanModels/#finetuning-process","text":"Instruction finetuning was performed for T5, PaLM and U-PaLM, where the model sizes span from Flan-T5-small (80M parameters) , to PaLM and U-PaLM (540B parameters) . Same training procedure was used for each model except for a few hyperparameters like learning rate, batch size, dropout, and finetuning steps. Constant learning rate schedule was used to finetune using the Adafactor optimizer. Notably, the amount of compute used for finetuning is only a small fraction relative to the training compute, as shown in the table below. All Flan models only use a fraction of compute for finetuning that was used for model training, with max usage going only upto 1.6%.","title":"Finetuning process"},{"location":"natural_language_processing/FlanModels/#results","text":"Instruction finetuning (Flan) showcased improved performance across multiple models and dataset, sometimes going as far as double digit improvements!","title":"Results"},{"location":"natural_language_processing/FlanModels/#code","text":"The code of inference and finetuning Flan models are very similar to the original models. Below we will show inference code for Flan-T5, which is similar to the T5 inference . Similarly, if you want to further finetune Flan-T5 for your use case, you can refer T5 finetuning code . If you are using HuggingFace, then all you need to do is replace the model name to google/flan-t5-{size} , where size could be small , base , large , xl and xxl .","title":"Code"},{"location":"natural_language_processing/FlanModels/#flan-t5-inference","text":"The following code is referenced from the HuggingFace Flan-T5 page [2] 1 2 3 4 5 6 7 8 9 10 11 # import from transformers import AutoModelForSeq2SeqLM , AutoTokenizer # load the model and tokenizer model = AutoModelForSeq2SeqLM . from_pretrained ( \"google/flan-t5-small\" ) tokenizer = AutoTokenizer . from_pretrained ( \"google/flan-t5-small\" ) # run on sample input inputs = tokenizer ( \"A step by step recipe to make bolognese pasta:\" , return_tensors = \"pt\" ) outputs = model . generate ( ** inputs ) print ( tokenizer . batch_decode ( outputs , skip_special_tokens = True ))","title":"Flan-T5 Inference"},{"location":"natural_language_processing/FlanModels/#references","text":"[1] Scaling Instruction-Finetuned Language Models - Paper [2] FlanT5 - HuggingFace","title":"References"},{"location":"natural_language_processing/GPTs/","text":"GPT models Introduction GPT stands for \"Generative Pre-trained Transformer\". It is an autoregressive language model which is based on the decoder block of the Transformer architecture. Transformer architecture. Left part is the encoder, right part is the decoder. GPT is made up of the right part i.e. decoder part. ( vaswani2017attention ) The idea for the model is similar to any text generation model i.e. it takes some prompt as input and generates text as output. But the caveat is that, GPT model's tunable parameter ranges from 100 million to 175 billion, which leads to the model learning much more than basic language syntax information or word related contextual information. In fact, it has been shown that GPT models store additional real-world information as well, and there has been interesting recent research about how much knowledge you can pack into the parameters ( roberts2020knowledge ). GPT models are also famous because they can be easily applied to many downstream NLP tasks. This is because they have been shown to be very good in few-shot leaning, i.e. they are able to perform tasks for which they are not even trained by only providing a few examples! This lead to a new interesting paradigm of prompt engineering, where creating crisp prompt could lead to good results. This means that, instead of playing around with training, just by modifying the input prompt to the model, we can improve the accuracy. Ofcourse, for better accuracy, it is always preferred to fine-tune the model. Example of a sample prompt is provided below ## prompt input - this can be passed to a GPT based model Below are some examples for sentiment detection of movie reviews. Review: I am sad that the hero died. Sentiment: Negative Review: The ending was perfect. Sentiment: Positive Review: The plot was not so good! Sentiment: ## The model should predict the sentiment for the last review. Tip Copy the prompt from above and try it @ GPT-Neo 2.7B model . You should get \"Negative\" as output! We just created a Sentiment detection module without a single training epoch! Analysis Comparing GPT models (basic details) There are two famous series of GPT models, GPT-{1,2,3}: the original series released by OpenAI , a San Francisco-based artificial intelligence research laboratory. It includes GPT-1 ( radford2018improving , GPT-2 radford2019language , GPT-3 brown2020language ) GPT-{Neo, J}: the open source series released by EleutherAI . For GPT-Neo, the architecture is quite similar to GPT-3, but training was done on The Pile , an 825 GB sized text dataset. Details of the models are as follows, ( details ) models released by year open-source model size GPT-1 OpenAI 2018 yes 110M GPT-2 OpenAI 2019 yes 117M, 345M, 774M, 1.5B GPT-3 OpenAI 2020 no 175B GPT-Neo EleutherAI 2021 yes 125M, 1.3B, 2.7B GPT-J EleutherAI 2021 yes 6B Code The most recent open-source models from OpenAI and EleutherAI are GPT-2 and GPT-Neo, respectively. And as they share nearly the same architecture, the majority of the code for inference or training, or fine-tuning remains the same. Hence for brevity's sake, code for GPT-2 will be shared, but I will point out changes required to make it work for GPT-Neo model as well. Inference of GPT-2 pre-trained model For a simple inference, we will load the pre-trained GPT-2 model and use it for a dummy sentiment detection task (using the prompt shared above). To make this code work for GPT-Neo, - import GPTNeoForCausalLM at line 2 - replace line 5 with model_name = \"EleutherAI/gpt-neo-2.7B\" (choose from any of the available sized models) - use GPTNeoForCausalLM in place of GPT2LMHeadModel at line 9 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 # import from transformers import GPT2Tokenizer , GPT2LMHeadModel # model name model_name = \"gpt2\" # load tokenizer and model tokenizer = GPT2Tokenizer . from_pretrained ( model_name ) model = GPT2LMHeadModel . from_pretrained ( model_name ) . cuda () # create prompt prompt = \"\"\" Below are some examples for sentiment detection of movie reviews. Review: I am sad that the hero died. Sentiment: Negative Review: The ending was perfect. Sentiment: Positive Review: The plot was not so good! Sentiment:\"\"\" # generate tokens generated = tokenizer ( prompt , return_tensors = \"pt\" ) . input_ids . cuda () # perform prediction sample_outputs = model . generate ( generated , do_sample = False , top_k = 50 , max_length = 512 , top_p = 0.90 , temperature = 0 , num_return_sequences = 0 ) # decode the predicted tokens into texts predicted_text = tokenizer . decode ( sample_outputs [ 0 ], skip_special_tokens = True ) print ( predicted_text ) \"\"\"Output --> Below are some examples for sentiment detection of movie reviews. Review: I am sad that the hero died. Sentiment: Negative Review: The ending was perfect. Sentiment: Positive Review: The plot was not so good! Sentiment: Negative \"\"\" Note As GPT2 is a language model style decoder with no special encoder block, the output contains the input plus additional generations. This can be observed from the above example. On the other hand, output of T5 model is pure new generations (without the repetition of input) as it has encoder-decoder architecture. Finetuning GPT-2 (for sentiment classification) Tweet sentiment data can be downloaded from here We add the special tokens at line 72, so that the model learns the start and end of the prompt. This will be helpful later on during the testing phase, as we don't want the model to keep on writing the next word, but it should know when to stop the process. This can be done by setting the eos_token and training the model to predict the same. Note Original GPT-2 paper and implementation uses <|endoftext|> as the eos_token and bos_token (beginning of sentence) . We can do the same, but for clarity in the implementation, we can also use <|startoftext|> as bos_token special token. We also define how to process the training data inside data_collator on line 91. The first two elements within the collator are input_ids -\u200athe tokenized prompt and attention_mask -\u200aa simple 1/0 vector which denote which part of the tokenized vector is prompt and which part is the padding. The last part is quite interesting, where we pass the input data as the label instead of just the sentiment labels. This is because we are training a language model, hence we want the model to learn the pattern of the prompt and not just sentiment class. In a sense, the model learns to predict the words of the input tweet + sentiment structured in the prompt, and in the process learn the sentiment detection task. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 # download packages #!pip install transformers==4.8.2 # import packages import re import torch import random import pandas as pd from tqdm import tqdm from torch.utils.data import Dataset from sklearn.metrics import f1_score from sklearn.model_selection import train_test_split from transformers import GPT2Tokenizer , TrainingArguments , Trainer , GPT2LMHeadModel ## Define class and functions #-------- # Dataset class class SentimentDataset ( Dataset ): def __init__ ( self , txt_list , label_list , tokenizer , max_length ): # define variables self . input_ids = [] self . attn_masks = [] self . labels = [] map_label = { 0 : 'negative' , 4 : 'positive' } # iterate through the dataset for txt , label in zip ( txt_list , label_list ): # prepare the text prep_txt = f '<|startoftext|>Tweet: { txt } <|pad|>Sentiment: { map_label [ label ] } <|endoftext|>' # tokenize encodings_dict = tokenizer ( prep_txt , truncation = True , max_length = max_length , padding = \"max_length\" ) # append to list self . input_ids . append ( torch . tensor ( encodings_dict [ 'input_ids' ])) self . attn_masks . append ( torch . tensor ( encodings_dict [ 'attention_mask' ])) self . labels . append ( map_label [ label ]) def __len__ ( self ): return len ( self . input_ids ) def __getitem__ ( self , idx ): return self . input_ids [ idx ], self . attn_masks [ idx ], self . labels [ idx ] # Data load function def load_sentiment_dataset ( tokenizer ): # load dataset and sample 10k reviews. file_path = \"../input/sentiment140/training.1600000.processed.noemoticon.csv\" df = pd . read_csv ( file_path , encoding = 'ISO-8859-1' , header = None ) df = df [[ 0 , 5 ]] df . columns = [ 'label' , 'text' ] df = df . sample ( 10000 , random_state = 1 ) # divide into test and train X_train , X_test , y_train , y_test = \\ train_test_split ( df [ 'text' ] . tolist (), df [ 'label' ] . tolist (), shuffle = True , test_size = 0.05 , random_state = 1 , stratify = df [ 'label' ]) # format into SentimentDataset class train_dataset = SentimentDataset ( X_train , y_train , tokenizer , max_length = 512 ) # return return train_dataset , ( X_test , y_test ) ## Load model and data #-------- # set model name model_name = \"gpt2\" # seed torch . manual_seed ( 42 ) # load tokenizer and model tokenizer = GPT2Tokenizer . from_pretrained ( model_name , bos_token = '<|startoftext|>' , eos_token = '<|endoftext|>' , pad_token = '<|pad|>' ) model = GPT2LMHeadModel . from_pretrained ( model_name ) . cuda () model . resize_token_embeddings ( len ( tokenizer )) # prepare and load dataset train_dataset , test_dataset = load_sentiment_dataset ( tokenizer ) ## Train #-------- # creating training arguments training_args = TrainingArguments ( output_dir = 'results' , num_train_epochs = 2 , logging_steps = 10 , load_best_model_at_end = True , save_strategy = \"epoch\" , evaluation_strategy = \"epoch\" , per_device_train_batch_size = 2 , per_device_eval_batch_size = 2 , warmup_steps = 100 , weight_decay = 0.01 , logging_dir = 'logs' ) # start training Trainer ( model = model , args = training_args , train_dataset = train_dataset , eval_dataset = test_dataset , data_collator = lambda data : { 'input_ids' : torch . stack ([ f [ 0 ] for f in data ]), 'attention_mask' : torch . stack ([ f [ 1 ] for f in data ]), 'labels' : torch . stack ([ f [ 0 ] for f in data ])}) . train () ## Test ---------- # set the model to eval mode _ = model . eval () # run model inference on all test data original_label , predicted_label , original_text , predicted_text = [], [], [], [] map_label = { 0 : 'negative' , 4 : 'positive' } # iter over all of the test data for text , label in tqdm ( zip ( test_dataset [ 0 ], test_dataset [ 1 ])): # create prompt (in compliance with the one used during training) prompt = f '<|startoftext|>Tweet: { text } \\n Sentiment:' # generate tokens generated = tokenizer ( f \" { prompt } \" , return_tensors = \"pt\" ) . input_ids . cuda () # perform prediction sample_outputs = model . generate ( generated , do_sample = False , top_k = 50 , max_length = 512 , top_p = 0.90 , temperature = 0 , num_return_sequences = 0 ) # decode the predicted tokens into texts predicted_text = tokenizer . decode ( sample_outputs [ 0 ], skip_special_tokens = True ) # extract the predicted sentiment try : pred_sentiment = re . findall ( \" \\n Sentiment: (.*)\" , predicted_text )[ - 1 ] except : pred_sentiment = \"None\" # append results original_label . append ( map_label [ label ]) predicted_label . append ( pred_sentiment ) original_text . append ( text ) predicted_text . append ( pred_text ) # transform result into dataframe df = pd . DataFrame ({ 'original_text' : original_text , 'predicted_label' : predicted_label , 'original_label' : original_label , 'predicted_text' : predicted_text }) # predict the accuracy print ( f1_score ( original_label , predicted_label , average = 'macro' )) Inference of GPT-3 Running GPT-3 model is super easy using the OpenAI python package . Here is how to do it, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # install # pip install --upgrade openai # import import openai # set API org and key openai . organization = \"OPENAI_API_ORG\" # replace or comment openai . api_key = \"OPENAI_API_KEY\" # replace # inference response = openai . Completion . create ( model = \"text-davinci-002\" , # set as per your need prompt = 'Tell me a Joke:' , max_tokens = 256 , # set as per your need top_p = 1 , # set as per your need temperature = 0.7 , # set as per your need ) # Output: # \"choices\": [ # { # \"finish_reason\": \"stop\", # \"index\": 0, # \"logprobs\": null, # \"text\": \"\\n\\nWhy did the chicken cross the road?\\n\\nTo get to the other side.\" # } # ], # \"created\": 1667925044, # \"id\": \"cmpl-6ALmmOOkVWE03AmO9Cur8XM3jpEXk\", # \"model\": \"text-davinci-002\", # \"object\": \"text_completion\", # \"usage\": { # \"completion_tokens\": 19, # \"prompt_tokens\": 6, # \"total_tokens\": 25 # } Finetuning GPT-3 While GPT-3 is not open source, OpenAI has provided the paid option to finetune the model . At the time of writing, free credits were provided to new users -- so another reason to go and register now They expose several APIs to perform finetuning. In a sense they are doing most of the heavy lifting by making the finetuning process super easy. To begin with, make sure you have the OpenAI python library installed. Do it by pip install openai . Then make sure the data is in correct format. Basically you require a .csv file with atleast two columns - prompt and completion with the respective data. Ideally the documentation suggest to have atleast 100 examples. Next, we will prepare a jsonl file using the csv file. OpenAI expects the data in this format. And they also expose an API to do so, just run the following in CLI. 1 openai tools fine_tunes.prepare_data -f data_to_fine_tune.csv Now we will upload the prepared data to the OpenAI Server. Do this by running following code in Python. 1 2 3 4 5 6 7 8 # set the organization and api key (you can get them from Manage Account page) openai . organization = \"my-organization-key\" openai . api_key = \"my-api-key\" # upload the data to OpenAI Server file_meta_data = openai . File . create ( file = open ( f \"data_to_fine_tune_prepared.jsonl\" , encoding = 'utf-8' ), purpose = 'fine-tune' ) Now we will train the model. Do this by running following code in Python. 1 print ( openai . FineTune . create ( model = \"curie\" , training_file = file_meta_data [ \"id\" ])) And there we go, the finetuning has started! You can monitor the progress by running openai.FineTune.list() . The last entry will contain a status key that will change to succeeded when the finetuning is complete. Also, note down the model name from the fine_tuned_model key, you will need it later to access the trained model. Btw if you only want to print the last entry try this instead openai.FineTune.list()['data'][-1] . After the finetuning is done, you can use the model as usual from the playground or API! Tip OpenAI provides multiple models (engines) with different accuracy and speed. These are Davinci , Curie , Babbadge and Ada - in the descending order of accuracy but increasing speed. Additional materials The Illustrated GPT-2 (Visualizing Transformer Language Models) - Link","title":"GPTs"},{"location":"natural_language_processing/GPTs/#gpt-models","text":"","title":"GPT models"},{"location":"natural_language_processing/GPTs/#introduction","text":"GPT stands for \"Generative Pre-trained Transformer\". It is an autoregressive language model which is based on the decoder block of the Transformer architecture. Transformer architecture. Left part is the encoder, right part is the decoder. GPT is made up of the right part i.e. decoder part. ( vaswani2017attention ) The idea for the model is similar to any text generation model i.e. it takes some prompt as input and generates text as output. But the caveat is that, GPT model's tunable parameter ranges from 100 million to 175 billion, which leads to the model learning much more than basic language syntax information or word related contextual information. In fact, it has been shown that GPT models store additional real-world information as well, and there has been interesting recent research about how much knowledge you can pack into the parameters ( roberts2020knowledge ). GPT models are also famous because they can be easily applied to many downstream NLP tasks. This is because they have been shown to be very good in few-shot leaning, i.e. they are able to perform tasks for which they are not even trained by only providing a few examples! This lead to a new interesting paradigm of prompt engineering, where creating crisp prompt could lead to good results. This means that, instead of playing around with training, just by modifying the input prompt to the model, we can improve the accuracy. Ofcourse, for better accuracy, it is always preferred to fine-tune the model. Example of a sample prompt is provided below ## prompt input - this can be passed to a GPT based model Below are some examples for sentiment detection of movie reviews. Review: I am sad that the hero died. Sentiment: Negative Review: The ending was perfect. Sentiment: Positive Review: The plot was not so good! Sentiment: ## The model should predict the sentiment for the last review. Tip Copy the prompt from above and try it @ GPT-Neo 2.7B model . You should get \"Negative\" as output! We just created a Sentiment detection module without a single training epoch!","title":"Introduction"},{"location":"natural_language_processing/GPTs/#analysis","text":"","title":"Analysis"},{"location":"natural_language_processing/GPTs/#comparing-gpt-models-basic-details","text":"There are two famous series of GPT models, GPT-{1,2,3}: the original series released by OpenAI , a San Francisco-based artificial intelligence research laboratory. It includes GPT-1 ( radford2018improving , GPT-2 radford2019language , GPT-3 brown2020language ) GPT-{Neo, J}: the open source series released by EleutherAI . For GPT-Neo, the architecture is quite similar to GPT-3, but training was done on The Pile , an 825 GB sized text dataset. Details of the models are as follows, ( details ) models released by year open-source model size GPT-1 OpenAI 2018 yes 110M GPT-2 OpenAI 2019 yes 117M, 345M, 774M, 1.5B GPT-3 OpenAI 2020 no 175B GPT-Neo EleutherAI 2021 yes 125M, 1.3B, 2.7B GPT-J EleutherAI 2021 yes 6B","title":"Comparing GPT models (basic details)"},{"location":"natural_language_processing/GPTs/#code","text":"The most recent open-source models from OpenAI and EleutherAI are GPT-2 and GPT-Neo, respectively. And as they share nearly the same architecture, the majority of the code for inference or training, or fine-tuning remains the same. Hence for brevity's sake, code for GPT-2 will be shared, but I will point out changes required to make it work for GPT-Neo model as well.","title":"Code"},{"location":"natural_language_processing/GPTs/#inference-of-gpt-2-pre-trained-model","text":"For a simple inference, we will load the pre-trained GPT-2 model and use it for a dummy sentiment detection task (using the prompt shared above). To make this code work for GPT-Neo, - import GPTNeoForCausalLM at line 2 - replace line 5 with model_name = \"EleutherAI/gpt-neo-2.7B\" (choose from any of the available sized models) - use GPTNeoForCausalLM in place of GPT2LMHeadModel at line 9 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 # import from transformers import GPT2Tokenizer , GPT2LMHeadModel # model name model_name = \"gpt2\" # load tokenizer and model tokenizer = GPT2Tokenizer . from_pretrained ( model_name ) model = GPT2LMHeadModel . from_pretrained ( model_name ) . cuda () # create prompt prompt = \"\"\" Below are some examples for sentiment detection of movie reviews. Review: I am sad that the hero died. Sentiment: Negative Review: The ending was perfect. Sentiment: Positive Review: The plot was not so good! Sentiment:\"\"\" # generate tokens generated = tokenizer ( prompt , return_tensors = \"pt\" ) . input_ids . cuda () # perform prediction sample_outputs = model . generate ( generated , do_sample = False , top_k = 50 , max_length = 512 , top_p = 0.90 , temperature = 0 , num_return_sequences = 0 ) # decode the predicted tokens into texts predicted_text = tokenizer . decode ( sample_outputs [ 0 ], skip_special_tokens = True ) print ( predicted_text ) \"\"\"Output --> Below are some examples for sentiment detection of movie reviews. Review: I am sad that the hero died. Sentiment: Negative Review: The ending was perfect. Sentiment: Positive Review: The plot was not so good! Sentiment: Negative \"\"\" Note As GPT2 is a language model style decoder with no special encoder block, the output contains the input plus additional generations. This can be observed from the above example. On the other hand, output of T5 model is pure new generations (without the repetition of input) as it has encoder-decoder architecture.","title":"Inference of GPT-2 pre-trained model"},{"location":"natural_language_processing/GPTs/#finetuning-gpt-2-for-sentiment-classification","text":"Tweet sentiment data can be downloaded from here We add the special tokens at line 72, so that the model learns the start and end of the prompt. This will be helpful later on during the testing phase, as we don't want the model to keep on writing the next word, but it should know when to stop the process. This can be done by setting the eos_token and training the model to predict the same. Note Original GPT-2 paper and implementation uses <|endoftext|> as the eos_token and bos_token (beginning of sentence) . We can do the same, but for clarity in the implementation, we can also use <|startoftext|> as bos_token special token. We also define how to process the training data inside data_collator on line 91. The first two elements within the collator are input_ids -\u200athe tokenized prompt and attention_mask -\u200aa simple 1/0 vector which denote which part of the tokenized vector is prompt and which part is the padding. The last part is quite interesting, where we pass the input data as the label instead of just the sentiment labels. This is because we are training a language model, hence we want the model to learn the pattern of the prompt and not just sentiment class. In a sense, the model learns to predict the words of the input tweet + sentiment structured in the prompt, and in the process learn the sentiment detection task. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 # download packages #!pip install transformers==4.8.2 # import packages import re import torch import random import pandas as pd from tqdm import tqdm from torch.utils.data import Dataset from sklearn.metrics import f1_score from sklearn.model_selection import train_test_split from transformers import GPT2Tokenizer , TrainingArguments , Trainer , GPT2LMHeadModel ## Define class and functions #-------- # Dataset class class SentimentDataset ( Dataset ): def __init__ ( self , txt_list , label_list , tokenizer , max_length ): # define variables self . input_ids = [] self . attn_masks = [] self . labels = [] map_label = { 0 : 'negative' , 4 : 'positive' } # iterate through the dataset for txt , label in zip ( txt_list , label_list ): # prepare the text prep_txt = f '<|startoftext|>Tweet: { txt } <|pad|>Sentiment: { map_label [ label ] } <|endoftext|>' # tokenize encodings_dict = tokenizer ( prep_txt , truncation = True , max_length = max_length , padding = \"max_length\" ) # append to list self . input_ids . append ( torch . tensor ( encodings_dict [ 'input_ids' ])) self . attn_masks . append ( torch . tensor ( encodings_dict [ 'attention_mask' ])) self . labels . append ( map_label [ label ]) def __len__ ( self ): return len ( self . input_ids ) def __getitem__ ( self , idx ): return self . input_ids [ idx ], self . attn_masks [ idx ], self . labels [ idx ] # Data load function def load_sentiment_dataset ( tokenizer ): # load dataset and sample 10k reviews. file_path = \"../input/sentiment140/training.1600000.processed.noemoticon.csv\" df = pd . read_csv ( file_path , encoding = 'ISO-8859-1' , header = None ) df = df [[ 0 , 5 ]] df . columns = [ 'label' , 'text' ] df = df . sample ( 10000 , random_state = 1 ) # divide into test and train X_train , X_test , y_train , y_test = \\ train_test_split ( df [ 'text' ] . tolist (), df [ 'label' ] . tolist (), shuffle = True , test_size = 0.05 , random_state = 1 , stratify = df [ 'label' ]) # format into SentimentDataset class train_dataset = SentimentDataset ( X_train , y_train , tokenizer , max_length = 512 ) # return return train_dataset , ( X_test , y_test ) ## Load model and data #-------- # set model name model_name = \"gpt2\" # seed torch . manual_seed ( 42 ) # load tokenizer and model tokenizer = GPT2Tokenizer . from_pretrained ( model_name , bos_token = '<|startoftext|>' , eos_token = '<|endoftext|>' , pad_token = '<|pad|>' ) model = GPT2LMHeadModel . from_pretrained ( model_name ) . cuda () model . resize_token_embeddings ( len ( tokenizer )) # prepare and load dataset train_dataset , test_dataset = load_sentiment_dataset ( tokenizer ) ## Train #-------- # creating training arguments training_args = TrainingArguments ( output_dir = 'results' , num_train_epochs = 2 , logging_steps = 10 , load_best_model_at_end = True , save_strategy = \"epoch\" , evaluation_strategy = \"epoch\" , per_device_train_batch_size = 2 , per_device_eval_batch_size = 2 , warmup_steps = 100 , weight_decay = 0.01 , logging_dir = 'logs' ) # start training Trainer ( model = model , args = training_args , train_dataset = train_dataset , eval_dataset = test_dataset , data_collator = lambda data : { 'input_ids' : torch . stack ([ f [ 0 ] for f in data ]), 'attention_mask' : torch . stack ([ f [ 1 ] for f in data ]), 'labels' : torch . stack ([ f [ 0 ] for f in data ])}) . train () ## Test ---------- # set the model to eval mode _ = model . eval () # run model inference on all test data original_label , predicted_label , original_text , predicted_text = [], [], [], [] map_label = { 0 : 'negative' , 4 : 'positive' } # iter over all of the test data for text , label in tqdm ( zip ( test_dataset [ 0 ], test_dataset [ 1 ])): # create prompt (in compliance with the one used during training) prompt = f '<|startoftext|>Tweet: { text } \\n Sentiment:' # generate tokens generated = tokenizer ( f \" { prompt } \" , return_tensors = \"pt\" ) . input_ids . cuda () # perform prediction sample_outputs = model . generate ( generated , do_sample = False , top_k = 50 , max_length = 512 , top_p = 0.90 , temperature = 0 , num_return_sequences = 0 ) # decode the predicted tokens into texts predicted_text = tokenizer . decode ( sample_outputs [ 0 ], skip_special_tokens = True ) # extract the predicted sentiment try : pred_sentiment = re . findall ( \" \\n Sentiment: (.*)\" , predicted_text )[ - 1 ] except : pred_sentiment = \"None\" # append results original_label . append ( map_label [ label ]) predicted_label . append ( pred_sentiment ) original_text . append ( text ) predicted_text . append ( pred_text ) # transform result into dataframe df = pd . DataFrame ({ 'original_text' : original_text , 'predicted_label' : predicted_label , 'original_label' : original_label , 'predicted_text' : predicted_text }) # predict the accuracy print ( f1_score ( original_label , predicted_label , average = 'macro' ))","title":"Finetuning GPT-2 (for sentiment classification)"},{"location":"natural_language_processing/GPTs/#inference-of-gpt-3","text":"Running GPT-3 model is super easy using the OpenAI python package . Here is how to do it, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # install # pip install --upgrade openai # import import openai # set API org and key openai . organization = \"OPENAI_API_ORG\" # replace or comment openai . api_key = \"OPENAI_API_KEY\" # replace # inference response = openai . Completion . create ( model = \"text-davinci-002\" , # set as per your need prompt = 'Tell me a Joke:' , max_tokens = 256 , # set as per your need top_p = 1 , # set as per your need temperature = 0.7 , # set as per your need ) # Output: # \"choices\": [ # { # \"finish_reason\": \"stop\", # \"index\": 0, # \"logprobs\": null, # \"text\": \"\\n\\nWhy did the chicken cross the road?\\n\\nTo get to the other side.\" # } # ], # \"created\": 1667925044, # \"id\": \"cmpl-6ALmmOOkVWE03AmO9Cur8XM3jpEXk\", # \"model\": \"text-davinci-002\", # \"object\": \"text_completion\", # \"usage\": { # \"completion_tokens\": 19, # \"prompt_tokens\": 6, # \"total_tokens\": 25 # }","title":"Inference of GPT-3"},{"location":"natural_language_processing/GPTs/#finetuning-gpt-3","text":"While GPT-3 is not open source, OpenAI has provided the paid option to finetune the model . At the time of writing, free credits were provided to new users -- so another reason to go and register now They expose several APIs to perform finetuning. In a sense they are doing most of the heavy lifting by making the finetuning process super easy. To begin with, make sure you have the OpenAI python library installed. Do it by pip install openai . Then make sure the data is in correct format. Basically you require a .csv file with atleast two columns - prompt and completion with the respective data. Ideally the documentation suggest to have atleast 100 examples. Next, we will prepare a jsonl file using the csv file. OpenAI expects the data in this format. And they also expose an API to do so, just run the following in CLI. 1 openai tools fine_tunes.prepare_data -f data_to_fine_tune.csv Now we will upload the prepared data to the OpenAI Server. Do this by running following code in Python. 1 2 3 4 5 6 7 8 # set the organization and api key (you can get them from Manage Account page) openai . organization = \"my-organization-key\" openai . api_key = \"my-api-key\" # upload the data to OpenAI Server file_meta_data = openai . File . create ( file = open ( f \"data_to_fine_tune_prepared.jsonl\" , encoding = 'utf-8' ), purpose = 'fine-tune' ) Now we will train the model. Do this by running following code in Python. 1 print ( openai . FineTune . create ( model = \"curie\" , training_file = file_meta_data [ \"id\" ])) And there we go, the finetuning has started! You can monitor the progress by running openai.FineTune.list() . The last entry will contain a status key that will change to succeeded when the finetuning is complete. Also, note down the model name from the fine_tuned_model key, you will need it later to access the trained model. Btw if you only want to print the last entry try this instead openai.FineTune.list()['data'][-1] . After the finetuning is done, you can use the model as usual from the playground or API! Tip OpenAI provides multiple models (engines) with different accuracy and speed. These are Davinci , Curie , Babbadge and Ada - in the descending order of accuracy but increasing speed.","title":"Finetuning GPT-3"},{"location":"natural_language_processing/GPTs/#additional-materials","text":"The Illustrated GPT-2 (Visualizing Transformer Language Models) - Link","title":"Additional materials"},{"location":"natural_language_processing/T5/","text":"T5 Introduction T5 stands for \"Text-to-Text Transfer Transformer\". It was released by Google on 2020. As the name suggests, it's a tranformer based encoder-decoder model used for text generation. For more details about other text generation models, refer the Text Generation chapter. In contrast to other famous Transformer based models like BERT or GPT, which is made up of either the encoder or decoder part of the Transformer, T5 paper showcase that using the complete encoder-decoder architecture is better than only using decoder. Apart from this, the paper also curated and released Colossal Clean Crawled Corpus (C4) - a huge crawled and cleaned dataset for pre-training language model using self-supervised learning. ( raffel2020exploring ) Transformer architecture. Left part is the encoder, right part is the decoder. T5's architecture is very similar to this one. ( vaswani2017attention raffel2020exploring ) Due to this nature of T5, for training or finetuning, the model requires a pair of input and output sequences/text. Some example tasks that can be performed using T5 is shown below, T5 text-to-text framework examples. See: Google Blog Based on the original T5, there has been several variations explored such as, (refer T5 @ HuggingFace ) T5v1.1: T5v1.1 is an improved version of T5 with some architectural tweaks, and is pre-trained on C4 only without mixing in the supervised tasks. mT5: mT5 is a multilingual T5 model. It is pre-trained on the mC4 corpus, which includes 101 languages. byT5: byT5 is a T5 model pre-trained on byte sequences rather than SentencePiece subword token sequences. Long-T5: For use case where we need to process longer input ( Refer ) Note As mentioned above, for multi-lingual purpose refer mT5 which was trained on >100 languages. That said, original T5 was also trained on translation task from English to German, French and Romanian. So the output can sometimes contains tokens from these languages! Paper details Transformer Architecture To compare different architectures suitable for languague models, T5 authors considered basically three varieties, Encoder-Decoder: A standard encoder-decoder architecture uses fully visible masking in the encoder and the encoder-decoder attention, with causal masking (attention mask) in the decoder. Masking is done to make sure the output at a position doesn't attend to future output for prediction. Language model: A language model consists of a single Transformer layer stack and is fed the concatenation of the input and target, using a causal mask throughout. As usual with LMs, the output only attends to the past input or output. Prefix LM: Adding a prefix to a language model corresponds to allowing fully-visible masking over a portion of the input. It is very similar to LM, just that any output will attend to a certain portion of the input that contains prefix could could contain task specific information like translate English to German: . Schematics of the Transformer architecture variants considered by T5 paper. ( raffel2020exploring ) T5 found the transformer based architecture to perform better than others. Pre-training Strategy T5 is trained with multi-task learning methodology, where the idea is to club multiple tasks while pre-training the model. These multiple tasks are further clubbed into two groups based on how they are trained, Unsupervised training: this includes training on the C4 dataset using the classic language model training tasks with maximum likelihood objective. For unsupervised tasks like MLM, T5 has 100 special tokens <extra_id_0> to <extra_id_99> which can be used to format the input and output text. For the sentence \"My name is Mohit Mayank\" where I want to mask \"name is\", the input is My <extra_id_0> Mohit Mayank and required output will be <extra_id_0> name is <extra_id_1> . Supervised training: this includes adding several NLP based tasks like question-answering, summarization, classification, etc. The model is trained with the curated training data in a supervised fashion, but all these tasks are transformed to work with text-in text-out format as suitable for encoder-decoder models. The data for supervised training is created separately for input and output text. For input it looks like {task_prefix}: {input_sequences}</s> . Similarly for the output text it looks like <pad> {output_sequence}</s> . One example could be: translate English to German: The house is wonderful.</s> for input and <pad> Das Haus ist wunderbar.</s> for output. This is then passed to the model to compute loss on the output part and then backpropagated to decrease the loss. Note T5 authors also released checkpoint models which are only unsupervised trained on the C4 dataset. More details and model is available here . T5 also compared different unsupervised objectives i.e. different training stratigies for unsupervised training which could lead to better performance. A visual guide to the search space is shown below. A flow chart of the exploration of unsupervised objectives by the T5 paper. ( raffel2020exploring ) To begin with, there were three High-level approaches, (1) Language modeling: where you take predict the next word based on historical words, (2) BERT-style: where you mask certain words and model predict those masked words, or (3) Deshuffling: where you shuffle the sentence and model predicts the unshuffled correct sentence as output. After experimenting with these BERT-style approach gave the best result and hence was selecte for next level of analysis. Next, different corruption startegies were tried. Originally BERT proposed MASD based approach but for language model setting, T5 authors observed Replace span works better. In replace span you mask consecutive tokens and language model predicts the masked spans. Span corruption used for unsupervised training in T5. ( raffel2020exploring ) Finally, different rate of corruption rate and corruption span length were experimentally selected. Performance score T5 paper reports following performance score on different datasets, T5 performance score on different datasets. ( raffel2020exploring ) Code T5 Inference Running T5 is super easy using HuggingFace . Let's do it, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # install packages ! pip install transformers # import from transformers import T5Tokenizer , T5ForConditionalGeneration # load the tokenizers and model tokenizer = T5Tokenizer . from_pretrained ( \"t5-small\" ) # vocab size is 32100. model = T5ForConditionalGeneration . from_pretrained ( \"t5-small\" ) # for a phrase get the tokenised input ids input_ids = tokenizer ( \"translate English to German: I am going to the party.\" , return_tensors = \"pt\" ) . input_ids # use the input ids to generte output outputs = model . generate ( input_ids ) # decode the output token ids to text print ( tokenizer . decode ( outputs [ 0 ], skip_special_tokens = True )) ## Output --> ## Ich werde zur Partei gehen. T5 finetuning Before we dive into finetuning, here are some tips if you are going to use PyTorch or Keras. We can use high learning rate for AdamW optimizer in range of 1e-4 and 3e-4. Btw T5 was originally pre-trained with AdaFactor optimizer. We can add task specific prefix like translate English to German: or summarize: in the input sequence if your task is similar to the ones T5 was originally pre-trained with. We should replace the PAD token ids 0 with -100 so that it is ignored from loss computation. Btw PAD token is used as start sequence token for the labels (text that is to be generated). To keep things simpler, we can use SimpleT5 , an excellent package that abstract a lot of technicalities. For dataset, we can go with Tweet sentiment data, that can be downloaded from here Some differences from training other text generation models (due to the SimpleT5 package), We don't need the Dataset class, as SimpleT5 works directly on pandas dataframe. Hence we load the data, do some initial pre-processing, split the data and return the pandas dataframe. (no need to tokenize, create Dataset class, isn't this great!?) One more point to note is that we do not need to create prompt formats for this package. This way we can separate out the input tweet and sentiment label into different columns, here source_text and target_text , respectively (Line 29 and 30) . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 # import import pandas as pd from simplet5 import SimpleT5 from sklearn.metrics import f1_score from sklearn.model_selection import train_test_split # Data loading # ------- # Data load function def load_sentiment_dataset ( random_seed = 1 ): # load dataset and sample 10k reviews. file_path = \"../input/sentiment140/training.1600000.processed.noemoticon.csv\" df = pd . read_csv ( file_path , encoding = 'ISO-8859-1' , header = None ) df = df [[ 0 , 5 ]] df . columns = [ 'label' , 'text' ] df = df . sample ( 10000 , random_state = 1 ) # modify the label map_label = { 0 : 'negative' , 4 : 'positive' } df [ 'label' ] = df [ 'label' ] . apply ( lambda x : map_label [ x ]) # divide into test and train X_train , X_test , y_train , y_test = \\ train_test_split ( df [ 'text' ] . tolist (), df [ 'label' ] . tolist (), shuffle = True , test_size = 0.05 , random_state = random_seed , stratify = df [ 'label' ]) # transform train and test data into pandas dataframe train_data = pd . DataFrame ({ 'source_text' : X_train , 'target_text' : y_train }) test_data = pd . DataFrame ({ 'source_text' : X_test , 'target_text' : y_test }) # return return train_data , test_data # load train_df , test_df = load_sentiment_dataset () # Train # ------- # load model model = SimpleT5 () model . from_pretrained ( model_type = \"t5\" , model_name = \"t5-base\" ) # train model model . train ( train_df = train_df , eval_df = test_df , source_max_token_len = 300 , target_max_token_len = 200 , batch_size = 8 , max_epochs = 2 , outputdir = \"outputs\" , use_gpu = True ) # Test # ------- # load the best model last_epoch_model = \"...\" # put the name here model . load_model ( \"t5\" , last_epoch_model , use_gpu = True ) # for each test data perform prediction predictions = [] for index , row in test_df . iterrows (): prediction = model . predict ( row [ 'source_text' ])[ 0 ] predictions . append ( prediction ) # computer performance df = test_df . copy () df [ 'predicted_label' ] = predictions df [ 'original_label' ] = df [ 'target_text' ] print ( f1_score ( df [ 'original_label' ], df [ 'predicted_label' ], average = 'macro' )) References [1] Exploring Transfer Learning with T5: the Text-To-Text Transfer Transformer - Link [2] T5 finetuning tips - HF forum","title":"T5"},{"location":"natural_language_processing/T5/#t5","text":"","title":"T5"},{"location":"natural_language_processing/T5/#introduction","text":"T5 stands for \"Text-to-Text Transfer Transformer\". It was released by Google on 2020. As the name suggests, it's a tranformer based encoder-decoder model used for text generation. For more details about other text generation models, refer the Text Generation chapter. In contrast to other famous Transformer based models like BERT or GPT, which is made up of either the encoder or decoder part of the Transformer, T5 paper showcase that using the complete encoder-decoder architecture is better than only using decoder. Apart from this, the paper also curated and released Colossal Clean Crawled Corpus (C4) - a huge crawled and cleaned dataset for pre-training language model using self-supervised learning. ( raffel2020exploring ) Transformer architecture. Left part is the encoder, right part is the decoder. T5's architecture is very similar to this one. ( vaswani2017attention raffel2020exploring ) Due to this nature of T5, for training or finetuning, the model requires a pair of input and output sequences/text. Some example tasks that can be performed using T5 is shown below, T5 text-to-text framework examples. See: Google Blog Based on the original T5, there has been several variations explored such as, (refer T5 @ HuggingFace ) T5v1.1: T5v1.1 is an improved version of T5 with some architectural tweaks, and is pre-trained on C4 only without mixing in the supervised tasks. mT5: mT5 is a multilingual T5 model. It is pre-trained on the mC4 corpus, which includes 101 languages. byT5: byT5 is a T5 model pre-trained on byte sequences rather than SentencePiece subword token sequences. Long-T5: For use case where we need to process longer input ( Refer ) Note As mentioned above, for multi-lingual purpose refer mT5 which was trained on >100 languages. That said, original T5 was also trained on translation task from English to German, French and Romanian. So the output can sometimes contains tokens from these languages!","title":"Introduction"},{"location":"natural_language_processing/T5/#paper-details","text":"","title":"Paper details"},{"location":"natural_language_processing/T5/#transformer-architecture","text":"To compare different architectures suitable for languague models, T5 authors considered basically three varieties, Encoder-Decoder: A standard encoder-decoder architecture uses fully visible masking in the encoder and the encoder-decoder attention, with causal masking (attention mask) in the decoder. Masking is done to make sure the output at a position doesn't attend to future output for prediction. Language model: A language model consists of a single Transformer layer stack and is fed the concatenation of the input and target, using a causal mask throughout. As usual with LMs, the output only attends to the past input or output. Prefix LM: Adding a prefix to a language model corresponds to allowing fully-visible masking over a portion of the input. It is very similar to LM, just that any output will attend to a certain portion of the input that contains prefix could could contain task specific information like translate English to German: . Schematics of the Transformer architecture variants considered by T5 paper. ( raffel2020exploring ) T5 found the transformer based architecture to perform better than others.","title":"Transformer Architecture"},{"location":"natural_language_processing/T5/#pre-training-strategy","text":"T5 is trained with multi-task learning methodology, where the idea is to club multiple tasks while pre-training the model. These multiple tasks are further clubbed into two groups based on how they are trained, Unsupervised training: this includes training on the C4 dataset using the classic language model training tasks with maximum likelihood objective. For unsupervised tasks like MLM, T5 has 100 special tokens <extra_id_0> to <extra_id_99> which can be used to format the input and output text. For the sentence \"My name is Mohit Mayank\" where I want to mask \"name is\", the input is My <extra_id_0> Mohit Mayank and required output will be <extra_id_0> name is <extra_id_1> . Supervised training: this includes adding several NLP based tasks like question-answering, summarization, classification, etc. The model is trained with the curated training data in a supervised fashion, but all these tasks are transformed to work with text-in text-out format as suitable for encoder-decoder models. The data for supervised training is created separately for input and output text. For input it looks like {task_prefix}: {input_sequences}</s> . Similarly for the output text it looks like <pad> {output_sequence}</s> . One example could be: translate English to German: The house is wonderful.</s> for input and <pad> Das Haus ist wunderbar.</s> for output. This is then passed to the model to compute loss on the output part and then backpropagated to decrease the loss. Note T5 authors also released checkpoint models which are only unsupervised trained on the C4 dataset. More details and model is available here . T5 also compared different unsupervised objectives i.e. different training stratigies for unsupervised training which could lead to better performance. A visual guide to the search space is shown below. A flow chart of the exploration of unsupervised objectives by the T5 paper. ( raffel2020exploring ) To begin with, there were three High-level approaches, (1) Language modeling: where you take predict the next word based on historical words, (2) BERT-style: where you mask certain words and model predict those masked words, or (3) Deshuffling: where you shuffle the sentence and model predicts the unshuffled correct sentence as output. After experimenting with these BERT-style approach gave the best result and hence was selecte for next level of analysis. Next, different corruption startegies were tried. Originally BERT proposed MASD based approach but for language model setting, T5 authors observed Replace span works better. In replace span you mask consecutive tokens and language model predicts the masked spans. Span corruption used for unsupervised training in T5. ( raffel2020exploring ) Finally, different rate of corruption rate and corruption span length were experimentally selected.","title":"Pre-training Strategy"},{"location":"natural_language_processing/T5/#performance-score","text":"T5 paper reports following performance score on different datasets, T5 performance score on different datasets. ( raffel2020exploring )","title":"Performance score"},{"location":"natural_language_processing/T5/#code","text":"","title":"Code"},{"location":"natural_language_processing/T5/#t5-inference","text":"Running T5 is super easy using HuggingFace . Let's do it, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # install packages ! pip install transformers # import from transformers import T5Tokenizer , T5ForConditionalGeneration # load the tokenizers and model tokenizer = T5Tokenizer . from_pretrained ( \"t5-small\" ) # vocab size is 32100. model = T5ForConditionalGeneration . from_pretrained ( \"t5-small\" ) # for a phrase get the tokenised input ids input_ids = tokenizer ( \"translate English to German: I am going to the party.\" , return_tensors = \"pt\" ) . input_ids # use the input ids to generte output outputs = model . generate ( input_ids ) # decode the output token ids to text print ( tokenizer . decode ( outputs [ 0 ], skip_special_tokens = True )) ## Output --> ## Ich werde zur Partei gehen.","title":"T5 Inference"},{"location":"natural_language_processing/T5/#t5-finetuning","text":"Before we dive into finetuning, here are some tips if you are going to use PyTorch or Keras. We can use high learning rate for AdamW optimizer in range of 1e-4 and 3e-4. Btw T5 was originally pre-trained with AdaFactor optimizer. We can add task specific prefix like translate English to German: or summarize: in the input sequence if your task is similar to the ones T5 was originally pre-trained with. We should replace the PAD token ids 0 with -100 so that it is ignored from loss computation. Btw PAD token is used as start sequence token for the labels (text that is to be generated). To keep things simpler, we can use SimpleT5 , an excellent package that abstract a lot of technicalities. For dataset, we can go with Tweet sentiment data, that can be downloaded from here Some differences from training other text generation models (due to the SimpleT5 package), We don't need the Dataset class, as SimpleT5 works directly on pandas dataframe. Hence we load the data, do some initial pre-processing, split the data and return the pandas dataframe. (no need to tokenize, create Dataset class, isn't this great!?) One more point to note is that we do not need to create prompt formats for this package. This way we can separate out the input tweet and sentiment label into different columns, here source_text and target_text , respectively (Line 29 and 30) . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 # import import pandas as pd from simplet5 import SimpleT5 from sklearn.metrics import f1_score from sklearn.model_selection import train_test_split # Data loading # ------- # Data load function def load_sentiment_dataset ( random_seed = 1 ): # load dataset and sample 10k reviews. file_path = \"../input/sentiment140/training.1600000.processed.noemoticon.csv\" df = pd . read_csv ( file_path , encoding = 'ISO-8859-1' , header = None ) df = df [[ 0 , 5 ]] df . columns = [ 'label' , 'text' ] df = df . sample ( 10000 , random_state = 1 ) # modify the label map_label = { 0 : 'negative' , 4 : 'positive' } df [ 'label' ] = df [ 'label' ] . apply ( lambda x : map_label [ x ]) # divide into test and train X_train , X_test , y_train , y_test = \\ train_test_split ( df [ 'text' ] . tolist (), df [ 'label' ] . tolist (), shuffle = True , test_size = 0.05 , random_state = random_seed , stratify = df [ 'label' ]) # transform train and test data into pandas dataframe train_data = pd . DataFrame ({ 'source_text' : X_train , 'target_text' : y_train }) test_data = pd . DataFrame ({ 'source_text' : X_test , 'target_text' : y_test }) # return return train_data , test_data # load train_df , test_df = load_sentiment_dataset () # Train # ------- # load model model = SimpleT5 () model . from_pretrained ( model_type = \"t5\" , model_name = \"t5-base\" ) # train model model . train ( train_df = train_df , eval_df = test_df , source_max_token_len = 300 , target_max_token_len = 200 , batch_size = 8 , max_epochs = 2 , outputdir = \"outputs\" , use_gpu = True ) # Test # ------- # load the best model last_epoch_model = \"...\" # put the name here model . load_model ( \"t5\" , last_epoch_model , use_gpu = True ) # for each test data perform prediction predictions = [] for index , row in test_df . iterrows (): prediction = model . predict ( row [ 'source_text' ])[ 0 ] predictions . append ( prediction ) # computer performance df = test_df . copy () df [ 'predicted_label' ] = predictions df [ 'original_label' ] = df [ 'target_text' ] print ( f1_score ( df [ 'original_label' ], df [ 'predicted_label' ], average = 'macro' ))","title":"T5 finetuning"},{"location":"natural_language_processing/T5/#references","text":"[1] Exploring Transfer Learning with T5: the Text-To-Text Transfer Transformer - Link [2] T5 finetuning tips - HF forum","title":"References"},{"location":"natural_language_processing/data_to_text_generation/","text":"Warning This page is still ongoing modifications. Please check back after some time or contact me if it has been a while! Sorry for the inconvenience Introduction Data to Text generation is a task with structured data as input and unstructured text as output. As an example, consider the use case of trying to summarize a table data, where table is the input and text as output. KELM [3] is an interesting example. In the paper , the authors try to train a language model using Knowledge graph triplets. But as a KG stores structured data, the first task done by authors was to create subgraphs of KG and verbalize it (as shown below) An example illustration of converting an entity subgraph (in bubbles) into synthetic natural sentences (far right). [3] For this they \"developed a verbalization pipeline named \u201cText from KG Generator\u201d (TEKGEN), which is made up of the following components: a large training corpus of heuristically aligned Wikipedia text and Wikidata KG triples, a text-to-text generator (T5) to convert the KG triples to text, an entity subgraph creator for generating groups of triples to be verbalized together, and finally, a post-processing filter to remove low quality outputs. The result is a corpus containing the entire Wikidata KG as natural text, which we call the Knowledge-Enhanced Language Model (KELM) corpus. It consists of ~18M sentences spanning ~45M triples and ~1500 relations.\" [3] References [1] NLP Progress - Data-to-Text Generation [2] The 2020 Bilingual, Bi-Directional WebNLG+ Shared Task: Overview and Evaluation Results (WebNLG+ 2020) [3] KELM: Integrating Knowledge Graphs with Language Model Pre-training Corpora","title":"Data-to-Text Generation"},{"location":"natural_language_processing/data_to_text_generation/#introduction","text":"Data to Text generation is a task with structured data as input and unstructured text as output. As an example, consider the use case of trying to summarize a table data, where table is the input and text as output. KELM [3] is an interesting example. In the paper , the authors try to train a language model using Knowledge graph triplets. But as a KG stores structured data, the first task done by authors was to create subgraphs of KG and verbalize it (as shown below) An example illustration of converting an entity subgraph (in bubbles) into synthetic natural sentences (far right). [3] For this they \"developed a verbalization pipeline named \u201cText from KG Generator\u201d (TEKGEN), which is made up of the following components: a large training corpus of heuristically aligned Wikipedia text and Wikidata KG triples, a text-to-text generator (T5) to convert the KG triples to text, an entity subgraph creator for generating groups of triples to be verbalized together, and finally, a post-processing filter to remove low quality outputs. The result is a corpus containing the entire Wikidata KG as natural text, which we call the Knowledge-Enhanced Language Model (KELM) corpus. It consists of ~18M sentences spanning ~45M triples and ~1500 relations.\" [3]","title":"Introduction"},{"location":"natural_language_processing/data_to_text_generation/#references","text":"[1] NLP Progress - Data-to-Text Generation [2] The 2020 Bilingual, Bi-Directional WebNLG+ Shared Task: Overview and Evaluation Results (WebNLG+ 2020) [3] KELM: Integrating Knowledge Graphs with Language Model Pre-training Corpora","title":"References"},{"location":"natural_language_processing/deepseek/","text":"Introduction In recent years, Large Language Models (LLMs) have undergone rapid evolution, arguably inching closer to Artificial General Intelligence (AGI). A critical component in this progress has been post-training, which enhances reasoning capabilities, aligns models with social values, and adapts them to user preferences. DeepSeek-R1, developed by DeepSeek, represents a significant leap forward in this domain, showcasing the potential of reinforcement learning (RL) to dramatically improve LLMs' reasoning abilities. And the best part, it's open-source! The journey to DeepSeek-R1 began with DeepSeek-R1-Zero, a model trained using large-scale RL without any supervised fine-tuning (SFT). This approach demonstrated that LLMs could develop remarkable reasoning capabilities through pure RL. Building on this foundation, DeepSeek-R1 incorporates multi-stage training and cold-start data to address challenges like poor readability and language mixing, while further enhancing reasoning performance. Benchmark performance of DeepSeek-R1 [1] Architecture DeepSeek-R1 builds upon the architectural foundations of DeepSeek-V3, which serves as its base model. It utilizes a Mixture of Experts (MoE) architecture, which allows for efficient scaling of model capacity. The model activates 37 billion parameters during inference, while its total parameter count reaches an impressive 671 billion. This architecture enables DeepSeek-R1 to handle complex reasoning tasks with high efficiency and effectiveness. Illustration of the basic architecture of DeepSeek-R1 based on DeepSeek-V3 [1] [2] Mixture of Experts (MoE) Framework DeepSeek-R1 inherits DeepSeek-V3's MoE architecture featuring: 671B total parameters with 37B activated per token during inference 128,000 token context window for long-context understanding Hierarchical expert structure with: Shared experts: 8 always-active generalist modules handling common patterns Routed experts: 128 specialized modules activated based on input content Hint If you want to learn more about the MoE framework and models, you can refer this article . Performance Optimization Metric DeepSeek-V3 Conventional MoE Training Efficiency (TFLOPS) 180 154 Memory Usage per Token 0.83MB 1.42MB Expert Utilization Rate 93.4% 78.1% Context Processing Speed 12.8k t/s 8.4k t/s This architectural foundation enables DeepSeek-R1 to handle complex reasoning chains while maintaining operational efficiency. The MoE structure allows specialized expert networks to focus on different aspects of problem-solving, with the routing mechanism dynamically assembling teams of experts for each query. Combined with the reinforcement learning enhancements described in the original paper, this creates a powerful framework for advanced reasoning tasks. Methods The development of DeepSeek-R1 involved several innovative approaches: 1. DeepSeek-R1-Zero: Pure Reinforcement Learning The initial model, DeepSeek-R1-Zero, was trained using Group Relative Policy Optimization (GRPO), a RL algorithm that foregoes the critic model to save training costs. The reward system primarily consisted of accuracy rewards for correct answers and format rewards to enforce proper structuring of the reasoning process. While the model performed surprisingly well in reasoning tasks it encounters challenges such as poor readability, and language mixing. AIME accuracy of DeepSeek-R1-Zero during training. For each question, [author] sample 16 responses and calculate the overall average accuracy to ensure a stable evaluation. [1] 2. Cold Start for DeepSeek-R1 To address the limitations of DeepSeek-R1-Zero, the researchers collected a small amount of long Chain-of-Thought (CoT) data to fine-tune the base model. This approach improved readability and provided a better starting point for subsequent RL training. 3. Reasoning-oriented Reinforcement Learning After the cold start, DeepSeek-R1 underwent large-scale RL training focused on enhancing reasoning capabilities in areas such as coding, mathematics, science, and logical reasoning. A language consistency reward was introduced to mitigate language mixing issues. Note So apparently, DeepSeek R1 was nerfed to reason in only one language. During training, DeepSeek R1 CoT used to often mix languages particularly when RL prompts were multilingual. Researchers added a language consistency reward in RL training to reduce this, measuring the proportion of target language words. While this slightly reduced performance, it was done as it aligns with human preferences for readability. Refer 4. Rejection Sampling and Supervised Fine-Tuning Upon convergence of the reasoning-oriented RL, the researchers collected new Supervised Fine-Tuning (SFT) data through rejection sampling . This data included both reasoning and non-reasoning tasks, enhancing the model's general capabilities. 5. Reinforcement Learning for All Scenarios The final stage involved another round of RL, this time aimed at improving the model's helpfulness and harmlessness while refining its reasoning abilities. This stage utilized a combination of rule-based rewards for reasoning tasks and reward models for general scenarios. 6. Distillation to Smaller Models To make the advanced reasoning capabilities more accessible, the researchers distilled DeepSeek-R1's knowledge into smaller dense models based on Qwen and Llama architectures. For distilled models, authors apply only SFT and do not include an RL stage, even though incorporating RL could substantially boost model performance. Note There is a major takeaway from this analysis regarding the efficiency of Distillation on different technique GRPO vs SFT: Transferring knowledge from advanced AI models to smaller versions (\"distillation\") often works better than training compact models (< 3B models) with resource-heavy reinforcement learning (RL), which demands massive computing power and still underperforms. In short, if your model is <3B parameters and you have sufficient data, consider supervised finetuning over RL based training. Experiments The researchers conducted extensive evaluations of DeepSeek-R1 across a wide range of benchmarks, including: Knowledge and reasoning: MMLU, MMLU-Redux, MMLU-Pro, GPQA Diamond, SimpleQA Mathematics: AIME 2024, MATH-500, CNMO 2024 Coding: LiveCodeBench, Codeforces, SWE-Bench Verified, Aider Language understanding: DROP, IF-Eval, FRAMES Open-ended generation: AlpacaEval 2.0, ArenaHard Chinese language tasks: CLUEWSC, C-Eval, C-SimpleQA The evaluation setup included a maximum generation length of 32,768 tokens and used pass@k evaluation with non-zero temperature sampling to ensure reliable performance estimates. Results DeepSeek-R1 demonstrated impressive performance across various benchmarks: Reasoning tasks: On AIME 2024, DeepSeek-R1 achieved a 79.8% Pass@1 score and for MATH-500, it attained a remarkable 97.3% score slightly surpassing OpenAI-o1-1217. Coding tasks: DeepSeek-R1 showed expert-level performance in code competition tasks, achieving a 2,029 Elo rating on Codeforces, outperforming 96.3% of human participants. Knowledge benchmarks: The model significantly outperformed its predecessor, DeepSeek-V3, on tasks like MMLU (90.8%), MMLU-Pro (84.0%), and GPQA Diamond (71.5%). Open-ended generation: DeepSeek-R1 excelled in creative writing and general question answering, achieving an 87.6% win-rate on AlpacaEval 2.0 and a 92.3% win-rate on ArenaHard. Long-context understanding: The model demonstrated outstanding performance on tasks requiring comprehension of extended contexts, substantially outperforming DeepSeek-V3. Comparison between DeepSeek-R1 and other representative models [1] Distilled models: Smaller models distilled from DeepSeek-R1 also showed impressive results. For instance, DeepSeek-R1-Distill-Qwen-7B achieved 55.5% on AIME 2024, surpassing the much larger QwQ-32B-Preview. Comparison of DeepSeek-R1 distilled models and other comparable models on reasoning-related benchmarks [1] Code DeepSeek-R1-Zero exhibits an \u201caha moment\u201d during training. This happened during the RL training phase wherein the model allocates more thinking time to a problem by reevaluating its initial approach. This behavior showcases the model\u2019s growing reasoning abilities and the unexpected sophistication of reinforcement learning outcomes. The algorithm credited to this is Group Relative Policy Optimization (GRPO). Based on this, there has been several attempts to replicate similar moment using much smaller models. In Mini-R1 [3], the author ( Philipp Schmid ) wanted to recreate the small \"aha moment\" of DeepSeek-R1 using Group Relative Policy Optimization (GRPO) and the Countdown Game. The aim was to train an open model ( Qwen-2.5-3B ) using reinforcement learning trying to teach it self-verification and search abilities all on its own to solve the Countdown Game. For context, the Countdown game is a numbers puzzle where players use a set of randomly drawn numbers and basic arithmetic operations (+, -, \u00d7, \u00f7) to reach or get as close as possible to a target number. At the end, the author was able to achieve 50% accuracy by 450th step of training. One interesting point to note is that in the experiment, GRPO with two rule-based rewards demanded a lot of power: 4 H100 GPUs for 6 hours over 450 training steps on a 3-billion-parameter model. This illustrates the hefty compute required for scaling reinforcement learning\u2014remember, DeepSeek a 671-billion model gained its performance after training over 8000 steps! In another attempt , author ( Will brown ) tried to fine-tune Qwen2.5-1.5B-Instruct model on school math word problem dataset, which was optimised for Google Colab by Anton for Qwen-2.5-0.5B base model here . This increased the base model's performance on by 10% from 41.6% to ~51% via GRPO. GRPO code is available on trl python package and the process to finetune your model is as simple as shown below, [3] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 # install the packages ! pip install trl # import the packages from trl import GRPOConfig , GRPOTrainer , get_peft_config , ModelConfig # define the reward function # NOTE - this is a dummy reward function, you should code this as per your training requirement. def dummy_reward_func ( completions , target , nums , ** kwargs ): for completion in completions : if \"<think>\" in completion and \"</think>\" in completion : return 1.0 else : return 0.0 # define the model model_config = ModelConfig ( model_name_or_path = \"Qwen/Qwen2.5-0.5B-Instruct\" , # you can even use base model torch_dtype = \"bfloat16\" , attn_implementation = \"flash_attention_2\" , use_peft = True , load_in_4bit = True , ) # set the hyperparameter training_args = GRPOConfig ( output_dir = \"qwen-r1\" , lr_scheduler_type = \"cosine\" , logging_steps = 10 , max_steps = 100 , max_prompt_length = 256 , max_completion_length = 1024 , ) # create the trainer trainer = GRPOTrainer ( model = model_config . model_name_or_path , reward_funcs = [ dummy_reward_func ], args = training_args , train_dataset = train_dataset , # after loading the train dataset eval_dataset = test_dataset , # after loading the test dataset peft_config = get_peft_config ( model_config ), ) # start the training trainer . train () And that's it! It is recommended to refer to [3] for more specific details about training and remember to continue training (by increasing the steps) until the model converges. Do save intermediate checkpoints while training. Hint All of the DeepSeek models are open-sourced and can be downloaded from the DeepSeek page on HuggingFace. Limitations While the DeepSeek-R1 model will be considered a benchmark in AI open-source history, the researchers did acknowledge some limitations of the model. Here are four key factors to keep in mind before using it: (refer) General Capability: DeepSeek-R1 currently lags behind DeepSeek-V3 in tasks like function calling, multi-turn conversations, complex role-playing, and structured JSON output. If your use case heavily relies on these advanced features, maybe reconsider. Language Mixing Challenges: DeepSeek-R1 is optimized for Chinese and English. However, this can lead to language mixing issues when handling queries in other languages. For example, it may default to reasoning or responding in English, even if the query is in a different language. Keep this in mind if your application favors xAI by exposing the reasoning to users. Prompt Engineering Sensitivity : Unlike some models that thrive on few-shot prompting, DeepSeek-R1 performs best with zero-shot settings. Overloading it with examples or overly complex prompts can degrade its performance. For optimal results, keep prompts simple and directly specify the desired output format. Software Engineering Limitations : DeepSeek-R1 has not yet shown significant improvements over DeepSeek-V3 for software engineering tasks due to inefficiencies in reinforcement learning (RL) processes. Future models might address this through techniques like rejection sampling and asynchronous evaluations, but for now, expect limited performance in this domain. Conclusion DeepSeek-R1 represents a significant advancement in the field of LLMs, particularly in enhancing reasoning capabilities through reinforcement learning. The model's performance across various benchmarks demonstrates its potential to revolutionize AI applications in fields such as education, creative writing, data analysis, etc. Key contributions of this research include: Demonstrating the effectiveness of pure RL in developing reasoning capabilities without relying on supervised fine-tuning. Introducing a multi-stage training pipeline that combines RL with carefully curated cold-start data to improve model performance and readability. Successfully distilling advanced reasoning capabilities into smaller, more efficient models, making these capabilities more accessible to the broader research community. As the field of AI continues to evolve, DeepSeek-R1 stands as a testament to the power of reinforcement learning in pushing the boundaries of what large language models can achieve. Its open-source nature and the availability of distilled smaller models promise to accelerate further research and development in artificial intelligence. References [1] DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning [2] DeepSeek-V3 Technical Report [3] Mini-R1: Reproduce Deepseek R1 \u201eaha moment\u201c a RL tutorial","title":"DeepSeek R1"},{"location":"natural_language_processing/deepseek/#introduction","text":"In recent years, Large Language Models (LLMs) have undergone rapid evolution, arguably inching closer to Artificial General Intelligence (AGI). A critical component in this progress has been post-training, which enhances reasoning capabilities, aligns models with social values, and adapts them to user preferences. DeepSeek-R1, developed by DeepSeek, represents a significant leap forward in this domain, showcasing the potential of reinforcement learning (RL) to dramatically improve LLMs' reasoning abilities. And the best part, it's open-source! The journey to DeepSeek-R1 began with DeepSeek-R1-Zero, a model trained using large-scale RL without any supervised fine-tuning (SFT). This approach demonstrated that LLMs could develop remarkable reasoning capabilities through pure RL. Building on this foundation, DeepSeek-R1 incorporates multi-stage training and cold-start data to address challenges like poor readability and language mixing, while further enhancing reasoning performance. Benchmark performance of DeepSeek-R1 [1]","title":"Introduction"},{"location":"natural_language_processing/deepseek/#architecture","text":"DeepSeek-R1 builds upon the architectural foundations of DeepSeek-V3, which serves as its base model. It utilizes a Mixture of Experts (MoE) architecture, which allows for efficient scaling of model capacity. The model activates 37 billion parameters during inference, while its total parameter count reaches an impressive 671 billion. This architecture enables DeepSeek-R1 to handle complex reasoning tasks with high efficiency and effectiveness. Illustration of the basic architecture of DeepSeek-R1 based on DeepSeek-V3 [1] [2]","title":"Architecture"},{"location":"natural_language_processing/deepseek/#mixture-of-experts-moe-framework","text":"DeepSeek-R1 inherits DeepSeek-V3's MoE architecture featuring: 671B total parameters with 37B activated per token during inference 128,000 token context window for long-context understanding Hierarchical expert structure with: Shared experts: 8 always-active generalist modules handling common patterns Routed experts: 128 specialized modules activated based on input content Hint If you want to learn more about the MoE framework and models, you can refer this article .","title":"Mixture of Experts (MoE) Framework"},{"location":"natural_language_processing/deepseek/#performance-optimization","text":"Metric DeepSeek-V3 Conventional MoE Training Efficiency (TFLOPS) 180 154 Memory Usage per Token 0.83MB 1.42MB Expert Utilization Rate 93.4% 78.1% Context Processing Speed 12.8k t/s 8.4k t/s This architectural foundation enables DeepSeek-R1 to handle complex reasoning chains while maintaining operational efficiency. The MoE structure allows specialized expert networks to focus on different aspects of problem-solving, with the routing mechanism dynamically assembling teams of experts for each query. Combined with the reinforcement learning enhancements described in the original paper, this creates a powerful framework for advanced reasoning tasks.","title":"Performance Optimization"},{"location":"natural_language_processing/deepseek/#methods","text":"The development of DeepSeek-R1 involved several innovative approaches:","title":"Methods"},{"location":"natural_language_processing/deepseek/#1-deepseek-r1-zero-pure-reinforcement-learning","text":"The initial model, DeepSeek-R1-Zero, was trained using Group Relative Policy Optimization (GRPO), a RL algorithm that foregoes the critic model to save training costs. The reward system primarily consisted of accuracy rewards for correct answers and format rewards to enforce proper structuring of the reasoning process. While the model performed surprisingly well in reasoning tasks it encounters challenges such as poor readability, and language mixing. AIME accuracy of DeepSeek-R1-Zero during training. For each question, [author] sample 16 responses and calculate the overall average accuracy to ensure a stable evaluation. [1]","title":"1. DeepSeek-R1-Zero: Pure Reinforcement Learning"},{"location":"natural_language_processing/deepseek/#2-cold-start-for-deepseek-r1","text":"To address the limitations of DeepSeek-R1-Zero, the researchers collected a small amount of long Chain-of-Thought (CoT) data to fine-tune the base model. This approach improved readability and provided a better starting point for subsequent RL training.","title":"2. Cold Start for DeepSeek-R1"},{"location":"natural_language_processing/deepseek/#3-reasoning-oriented-reinforcement-learning","text":"After the cold start, DeepSeek-R1 underwent large-scale RL training focused on enhancing reasoning capabilities in areas such as coding, mathematics, science, and logical reasoning. A language consistency reward was introduced to mitigate language mixing issues. Note So apparently, DeepSeek R1 was nerfed to reason in only one language. During training, DeepSeek R1 CoT used to often mix languages particularly when RL prompts were multilingual. Researchers added a language consistency reward in RL training to reduce this, measuring the proportion of target language words. While this slightly reduced performance, it was done as it aligns with human preferences for readability. Refer","title":"3. Reasoning-oriented Reinforcement Learning"},{"location":"natural_language_processing/deepseek/#4-rejection-sampling-and-supervised-fine-tuning","text":"Upon convergence of the reasoning-oriented RL, the researchers collected new Supervised Fine-Tuning (SFT) data through rejection sampling . This data included both reasoning and non-reasoning tasks, enhancing the model's general capabilities.","title":"4. Rejection Sampling and Supervised Fine-Tuning"},{"location":"natural_language_processing/deepseek/#5-reinforcement-learning-for-all-scenarios","text":"The final stage involved another round of RL, this time aimed at improving the model's helpfulness and harmlessness while refining its reasoning abilities. This stage utilized a combination of rule-based rewards for reasoning tasks and reward models for general scenarios.","title":"5. Reinforcement Learning for All Scenarios"},{"location":"natural_language_processing/deepseek/#6-distillation-to-smaller-models","text":"To make the advanced reasoning capabilities more accessible, the researchers distilled DeepSeek-R1's knowledge into smaller dense models based on Qwen and Llama architectures. For distilled models, authors apply only SFT and do not include an RL stage, even though incorporating RL could substantially boost model performance. Note There is a major takeaway from this analysis regarding the efficiency of Distillation on different technique GRPO vs SFT: Transferring knowledge from advanced AI models to smaller versions (\"distillation\") often works better than training compact models (< 3B models) with resource-heavy reinforcement learning (RL), which demands massive computing power and still underperforms. In short, if your model is <3B parameters and you have sufficient data, consider supervised finetuning over RL based training.","title":"6. Distillation to Smaller Models"},{"location":"natural_language_processing/deepseek/#experiments","text":"The researchers conducted extensive evaluations of DeepSeek-R1 across a wide range of benchmarks, including: Knowledge and reasoning: MMLU, MMLU-Redux, MMLU-Pro, GPQA Diamond, SimpleQA Mathematics: AIME 2024, MATH-500, CNMO 2024 Coding: LiveCodeBench, Codeforces, SWE-Bench Verified, Aider Language understanding: DROP, IF-Eval, FRAMES Open-ended generation: AlpacaEval 2.0, ArenaHard Chinese language tasks: CLUEWSC, C-Eval, C-SimpleQA The evaluation setup included a maximum generation length of 32,768 tokens and used pass@k evaluation with non-zero temperature sampling to ensure reliable performance estimates.","title":"Experiments"},{"location":"natural_language_processing/deepseek/#results","text":"DeepSeek-R1 demonstrated impressive performance across various benchmarks: Reasoning tasks: On AIME 2024, DeepSeek-R1 achieved a 79.8% Pass@1 score and for MATH-500, it attained a remarkable 97.3% score slightly surpassing OpenAI-o1-1217. Coding tasks: DeepSeek-R1 showed expert-level performance in code competition tasks, achieving a 2,029 Elo rating on Codeforces, outperforming 96.3% of human participants. Knowledge benchmarks: The model significantly outperformed its predecessor, DeepSeek-V3, on tasks like MMLU (90.8%), MMLU-Pro (84.0%), and GPQA Diamond (71.5%). Open-ended generation: DeepSeek-R1 excelled in creative writing and general question answering, achieving an 87.6% win-rate on AlpacaEval 2.0 and a 92.3% win-rate on ArenaHard. Long-context understanding: The model demonstrated outstanding performance on tasks requiring comprehension of extended contexts, substantially outperforming DeepSeek-V3. Comparison between DeepSeek-R1 and other representative models [1] Distilled models: Smaller models distilled from DeepSeek-R1 also showed impressive results. For instance, DeepSeek-R1-Distill-Qwen-7B achieved 55.5% on AIME 2024, surpassing the much larger QwQ-32B-Preview. Comparison of DeepSeek-R1 distilled models and other comparable models on reasoning-related benchmarks [1]","title":"Results"},{"location":"natural_language_processing/deepseek/#code","text":"DeepSeek-R1-Zero exhibits an \u201caha moment\u201d during training. This happened during the RL training phase wherein the model allocates more thinking time to a problem by reevaluating its initial approach. This behavior showcases the model\u2019s growing reasoning abilities and the unexpected sophistication of reinforcement learning outcomes. The algorithm credited to this is Group Relative Policy Optimization (GRPO). Based on this, there has been several attempts to replicate similar moment using much smaller models. In Mini-R1 [3], the author ( Philipp Schmid ) wanted to recreate the small \"aha moment\" of DeepSeek-R1 using Group Relative Policy Optimization (GRPO) and the Countdown Game. The aim was to train an open model ( Qwen-2.5-3B ) using reinforcement learning trying to teach it self-verification and search abilities all on its own to solve the Countdown Game. For context, the Countdown game is a numbers puzzle where players use a set of randomly drawn numbers and basic arithmetic operations (+, -, \u00d7, \u00f7) to reach or get as close as possible to a target number. At the end, the author was able to achieve 50% accuracy by 450th step of training. One interesting point to note is that in the experiment, GRPO with two rule-based rewards demanded a lot of power: 4 H100 GPUs for 6 hours over 450 training steps on a 3-billion-parameter model. This illustrates the hefty compute required for scaling reinforcement learning\u2014remember, DeepSeek a 671-billion model gained its performance after training over 8000 steps! In another attempt , author ( Will brown ) tried to fine-tune Qwen2.5-1.5B-Instruct model on school math word problem dataset, which was optimised for Google Colab by Anton for Qwen-2.5-0.5B base model here . This increased the base model's performance on by 10% from 41.6% to ~51% via GRPO. GRPO code is available on trl python package and the process to finetune your model is as simple as shown below, [3] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 # install the packages ! pip install trl # import the packages from trl import GRPOConfig , GRPOTrainer , get_peft_config , ModelConfig # define the reward function # NOTE - this is a dummy reward function, you should code this as per your training requirement. def dummy_reward_func ( completions , target , nums , ** kwargs ): for completion in completions : if \"<think>\" in completion and \"</think>\" in completion : return 1.0 else : return 0.0 # define the model model_config = ModelConfig ( model_name_or_path = \"Qwen/Qwen2.5-0.5B-Instruct\" , # you can even use base model torch_dtype = \"bfloat16\" , attn_implementation = \"flash_attention_2\" , use_peft = True , load_in_4bit = True , ) # set the hyperparameter training_args = GRPOConfig ( output_dir = \"qwen-r1\" , lr_scheduler_type = \"cosine\" , logging_steps = 10 , max_steps = 100 , max_prompt_length = 256 , max_completion_length = 1024 , ) # create the trainer trainer = GRPOTrainer ( model = model_config . model_name_or_path , reward_funcs = [ dummy_reward_func ], args = training_args , train_dataset = train_dataset , # after loading the train dataset eval_dataset = test_dataset , # after loading the test dataset peft_config = get_peft_config ( model_config ), ) # start the training trainer . train () And that's it! It is recommended to refer to [3] for more specific details about training and remember to continue training (by increasing the steps) until the model converges. Do save intermediate checkpoints while training. Hint All of the DeepSeek models are open-sourced and can be downloaded from the DeepSeek page on HuggingFace.","title":"Code"},{"location":"natural_language_processing/deepseek/#limitations","text":"While the DeepSeek-R1 model will be considered a benchmark in AI open-source history, the researchers did acknowledge some limitations of the model. Here are four key factors to keep in mind before using it: (refer) General Capability: DeepSeek-R1 currently lags behind DeepSeek-V3 in tasks like function calling, multi-turn conversations, complex role-playing, and structured JSON output. If your use case heavily relies on these advanced features, maybe reconsider. Language Mixing Challenges: DeepSeek-R1 is optimized for Chinese and English. However, this can lead to language mixing issues when handling queries in other languages. For example, it may default to reasoning or responding in English, even if the query is in a different language. Keep this in mind if your application favors xAI by exposing the reasoning to users. Prompt Engineering Sensitivity : Unlike some models that thrive on few-shot prompting, DeepSeek-R1 performs best with zero-shot settings. Overloading it with examples or overly complex prompts can degrade its performance. For optimal results, keep prompts simple and directly specify the desired output format. Software Engineering Limitations : DeepSeek-R1 has not yet shown significant improvements over DeepSeek-V3 for software engineering tasks due to inefficiencies in reinforcement learning (RL) processes. Future models might address this through techniques like rejection sampling and asynchronous evaluations, but for now, expect limited performance in this domain.","title":"Limitations"},{"location":"natural_language_processing/deepseek/#conclusion","text":"DeepSeek-R1 represents a significant advancement in the field of LLMs, particularly in enhancing reasoning capabilities through reinforcement learning. The model's performance across various benchmarks demonstrates its potential to revolutionize AI applications in fields such as education, creative writing, data analysis, etc. Key contributions of this research include: Demonstrating the effectiveness of pure RL in developing reasoning capabilities without relying on supervised fine-tuning. Introducing a multi-stage training pipeline that combines RL with carefully curated cold-start data to improve model performance and readability. Successfully distilling advanced reasoning capabilities into smaller, more efficient models, making these capabilities more accessible to the broader research community. As the field of AI continues to evolve, DeepSeek-R1 stands as a testament to the power of reinforcement learning in pushing the boundaries of what large language models can achieve. Its open-source nature and the availability of distilled smaller models promise to accelerate further research and development in artificial intelligence.","title":"Conclusion"},{"location":"natural_language_processing/deepseek/#references","text":"[1] DeepSeek-R1: Incentivizing Reasoning Capability in LLMs via Reinforcement Learning [2] DeepSeek-V3 Technical Report [3] Mini-R1: Reproduce Deepseek R1 \u201eaha moment\u201c a RL tutorial","title":"References"},{"location":"natural_language_processing/explainable_ai_llm/","text":"Explainable AI: Language Models Hold your large language models accountable by learning how to \"explain\" the predictions. Introduction Just like a coin, explainability in AI has two faces\u200a-\u200aone it shows to the developers (who actually build the models) and the other to the users (the end customers). The former face (IE i.e. intrinsic explainability) is a technical indicator to the builder that explains the working of the model. Whereas the latter (EE i.e. extrinsic explainability) is proof to the customers about the model's predictions. While IE is required for any reasonable model improvement, we need EE for factual confirmation. A simple layman who ends up using the model's prediction needs to know why is the model suggesting something. This article provides a brief introduction and famous techniques used to infer both types of explainabilities, with a focus on large language models. Large Language models As the name suggests, language models (LMs) try to model a language by creating probability distribution over the sequence of tokens (that can be words). This can be applied to the text generation task, as once the model is good enough with the probability, it can start predicting the next words provided some contextual words (prompts). This idea forms the basis of the research in deep learning-based (DL) Natural Language Processing (NLP), where newer and SotA models are becoming better with the probability distribution. And recently several powerful models like GPT-3 are able to generate text which is very hard to distinguish from human-written text! GPT-3 is used to predict the next words for the prompt \"To be or not to be\". The output is quite impressive! [By Author] LLMs are leading the scoreboard for several tasks in NLP. But one existing problem with them (or any DL model in fact) is that they are inherently black boxes i.e. it becomes extremely difficult to explain the predictions. Let us try to shine some grey lights on these black boxes! Intrinsic explainability Intrinsic explainability tries to provide technical clarity on why the model made some predictions. Large LMs (LLMs) are mostly DL-based models and while they become better with predictions given more data or network parameters, it comes with a cost of explainability. They are not straight forward explainable and we need to derive ways to infer why a model made the prediction. Below let's briefly go through some of those ways. Attention-based The recent LLMs utilize Transformer-based architecture for enhanced performance. What makes Transformers unique is the presence of multiple attention layers and heads to capture bidirectional and context-aware token representation. Each attention head learns certain patterns that could help in language modeling. These patterns could be positional (attend to the previous word) or lexical (attend to acronyms, synonyms, etc) in nature. And when we combine multiple such heads in multiple layers, the overall model is able to capture sophisticated patterns and provide accurate predictions. These kinds of internal and low-level patterns can be observed by using attention score visualization tools like bertviz [1]. There could be two major types of visualizations, (1) Attention head visualization\u200a-\u200awhich could be helpful to see how the model attends to certain words with another word in context, and (2) Neuron visualization\u200a-\u200awhich could be used to connect the model behaviors to neuron values. For the Attention head visualization, you can select the model, the layer, and the head to explore the different attention patterns. One example is shown below. Example of Attention head view to detect association of words in the model. Also useful to detect gender biases. [1] Here the layer 5 and 11th head of the model (2nd last blue color box from the color palette) seems to incorporate the gender-specific patterns (lexical) in the language. That is why, the attention score for gender-related words (She, girl), (He, boy), (He, Bob), etc is high. As such, this head could be used to identify gender bias as well, which is evident from the associations\u200a-\u200a (nurse, She) and (doctor, He). Similar biases can be identified from other heads. The neuron view is useful to drill down even deeper into the attentions scores to identify the specific neuron leading to certain behaviors in the model. One such example is shown below, Neuron view of GPT-2 for layer 1, head 10 [1] Neuron view of BERT for layer 0, head 0 (same one depicted above). Positive and negative values are colored blue and orange, respectively, with color saturation based on the magnitude of the value. As with the attention-head view, connecting lines are weighted based on attention between the words. Saliency methods Attention presents a very myopic view as they are limited to a certain part of language models. As such they just provide the behavior for that part of the model. As an analogy, it's like explaining just one line of the complete code. This ideation has led to a debate on whether attention really presents the true explainability of the complete model?! To mitigate these concerns, there has been renewed interest in old, tried, and tested saliency methods [2]. These are, Gradient-based: where we compute the gradient of the neural network's outcome with respect to the input. The idea is quite simple\u200a-\u200a as we compute gradients of the output wrt to the different parameters to find the importance and magnitude of correction needed for the parameters, why not do the same but for the inputs? This computation provides us a holistic view of the importance of each input wrt to the output. Propagation-based: Gradient-based approach is a plain vanilla approach where backpropagation happens without additional computation at any layer i.e. it's a simple inverse (not mathematically) of the forward pass. In the propagation-based approach, we perform relevance-based modifications at each layer. It can be thought of as an enhanced version of the gradient-based approach. Occlusion based: where we measure the importance of input on the output by erasing the input and estimating the effect on the output. It can be done by either recomputing output with the particular input missing or a mask in its place. Intuitively, the variation in the output will be high in case the input is important, and close to zero otherwise. There are several open-source packages like Ecco, that provide the option to visualize the saliency measure. One example is shown below, Gradient-based method to visualize the importance of the input words for the next word prediction (India) [By Author] Here, for the input \"New Delhi is the capital of\", LLM returned \"India\" which is factually correct. But intuitively, we would like to know which certain part of the input motivated the model to make such a prediction. The important measure is highlighted with color in the image, and as visible it gave a high score to \"New Delhi\" and \"capital\"! Extrinsic explainability The intrinsic measures fall short of covering the \"needs\" of explainability due to two reasons. Firstly, while it may help the model developer with access to internal metrics, it becomes quite difficult for the stakeholders on the other end of the spectrum to make sense of these complicated numbers. We are talking about the end-user of the model who could be a doctor in healthcare, engineers in mechanical, sales executive in the sales domain, and so on. They care more about factual correctness than the reason behind a model's prediction. Secondly, even the model developers will be concerned if the internal metrics make sense but the output doesn't (output is incorrect). The problem with the existing language models is that they contain all their knowledge within the parameters. GPT-3 is made up of 175 Billion parameters and it has been shown to work on a large number of downstream tasks. It generates the text based on the information it learned and stored in its parameters during the training and fine-tuning phase. Take one task of question answering as an example, where the question is \"Who is the Prime Minister of India?\". While the model may answer it correctly now, how about after the next election? The answer is obvious, it will fail. This is because the information gained is constant and would need re-training to calibrate constantly with the latest events in the world (which is a costly affair [3]). Because of all these reasons, there has been a research interest in enhancing the language models by complimenting them with a connection to a dynamic knowledge base\u200a-\u200athat is kept up to date just like any other database. Some examples by the leading AI teams in the world are as follows, GopherCite [4] from DeepMind is an enhancement of their language model named Gopher. It was created to solve the existing problem of \"hallucinations\" in the Gopher model. In their terms, hallucination of the model leads to incorrect, sometimes nonsensical, text generations. Because of this, humans are required to not take the output for granted and perform proof checks. GopherCite removes that human dependency to some extent by using Google search to find relevant quotes as proof for its prediction. In case no such high probable proofs are found, it even admits defeat instead of providing a wrong answer! Gradient-based method to visualize the importance of the input words for the next word prediction (India) [By Author] WebGPT [5] from OpenAI is an attempt by the creators of GPT-3 to solve the hallucination problem. They complimented GPT with an additional model that interacts with text-based web browsers to find the most relevant web pages for the asked question. For this, the model learned basic commands like \"Search \u2026\", \"Find in page: \u2026\", or \"Quote: \u2026\". The model goes through web pages to find passages and then uses these to compose an answer. The final output contains references to the source web pages as an attempt to legitimize the results. Final output generated by WebGPT for the question \"How do neural networks work?\". Note the presence of References at the bottom. Taken from the blog. LaMDA [6] from Google is a language model for dialog-based interactions. A lot of times, the conversation could become complicated (involving non-fictional characters or real entities), and then it becomes imperative that the model knows the correct context and background knowledge. Based on the conversation, LaMDA can call an external information retrieval system to improve the factual groundedness of its responses. Example of a conversation with Mt. Everest using LaMDA. Taken from blog. References [1] A Multiscale Visualization of Attention in the Transformer Model [2] Why use attention as explanation when we have saliency methods? [3] Cost of training GPT-3 | Reddit [4] Teaching language models to support answers with verified quotes [5] WebGPT: Browser-assisted question-answering with human feedback [6] LaMDA: Language Models for Dialog Applications Cheers.","title":"Explainable AI: Language\u00a0Models"},{"location":"natural_language_processing/explainable_ai_llm/#explainable-ai-language-models","text":"Hold your large language models accountable by learning how to \"explain\" the predictions.","title":"Explainable AI: Language\u00a0Models"},{"location":"natural_language_processing/explainable_ai_llm/#introduction","text":"Just like a coin, explainability in AI has two faces\u200a-\u200aone it shows to the developers (who actually build the models) and the other to the users (the end customers). The former face (IE i.e. intrinsic explainability) is a technical indicator to the builder that explains the working of the model. Whereas the latter (EE i.e. extrinsic explainability) is proof to the customers about the model's predictions. While IE is required for any reasonable model improvement, we need EE for factual confirmation. A simple layman who ends up using the model's prediction needs to know why is the model suggesting something. This article provides a brief introduction and famous techniques used to infer both types of explainabilities, with a focus on large language models.","title":"Introduction"},{"location":"natural_language_processing/explainable_ai_llm/#large-language-models","text":"As the name suggests, language models (LMs) try to model a language by creating probability distribution over the sequence of tokens (that can be words). This can be applied to the text generation task, as once the model is good enough with the probability, it can start predicting the next words provided some contextual words (prompts). This idea forms the basis of the research in deep learning-based (DL) Natural Language Processing (NLP), where newer and SotA models are becoming better with the probability distribution. And recently several powerful models like GPT-3 are able to generate text which is very hard to distinguish from human-written text! GPT-3 is used to predict the next words for the prompt \"To be or not to be\". The output is quite impressive! [By Author] LLMs are leading the scoreboard for several tasks in NLP. But one existing problem with them (or any DL model in fact) is that they are inherently black boxes i.e. it becomes extremely difficult to explain the predictions. Let us try to shine some grey lights on these black boxes!","title":"Large Language\u00a0models"},{"location":"natural_language_processing/explainable_ai_llm/#intrinsic-explainability","text":"Intrinsic explainability tries to provide technical clarity on why the model made some predictions. Large LMs (LLMs) are mostly DL-based models and while they become better with predictions given more data or network parameters, it comes with a cost of explainability. They are not straight forward explainable and we need to derive ways to infer why a model made the prediction. Below let's briefly go through some of those ways.","title":"Intrinsic explainability"},{"location":"natural_language_processing/explainable_ai_llm/#attention-based","text":"The recent LLMs utilize Transformer-based architecture for enhanced performance. What makes Transformers unique is the presence of multiple attention layers and heads to capture bidirectional and context-aware token representation. Each attention head learns certain patterns that could help in language modeling. These patterns could be positional (attend to the previous word) or lexical (attend to acronyms, synonyms, etc) in nature. And when we combine multiple such heads in multiple layers, the overall model is able to capture sophisticated patterns and provide accurate predictions. These kinds of internal and low-level patterns can be observed by using attention score visualization tools like bertviz [1]. There could be two major types of visualizations, (1) Attention head visualization\u200a-\u200awhich could be helpful to see how the model attends to certain words with another word in context, and (2) Neuron visualization\u200a-\u200awhich could be used to connect the model behaviors to neuron values. For the Attention head visualization, you can select the model, the layer, and the head to explore the different attention patterns. One example is shown below. Example of Attention head view to detect association of words in the model. Also useful to detect gender biases. [1] Here the layer 5 and 11th head of the model (2nd last blue color box from the color palette) seems to incorporate the gender-specific patterns (lexical) in the language. That is why, the attention score for gender-related words (She, girl), (He, boy), (He, Bob), etc is high. As such, this head could be used to identify gender bias as well, which is evident from the associations\u200a-\u200a (nurse, She) and (doctor, He). Similar biases can be identified from other heads. The neuron view is useful to drill down even deeper into the attentions scores to identify the specific neuron leading to certain behaviors in the model. One such example is shown below, Neuron view of GPT-2 for layer 1, head 10 [1] Neuron view of BERT for layer 0, head 0 (same one depicted above). Positive and negative values are colored blue and orange, respectively, with color saturation based on the magnitude of the value. As with the attention-head view, connecting lines are weighted based on attention between the words.","title":"Attention-based"},{"location":"natural_language_processing/explainable_ai_llm/#saliency-methods","text":"Attention presents a very myopic view as they are limited to a certain part of language models. As such they just provide the behavior for that part of the model. As an analogy, it's like explaining just one line of the complete code. This ideation has led to a debate on whether attention really presents the true explainability of the complete model?! To mitigate these concerns, there has been renewed interest in old, tried, and tested saliency methods [2]. These are, Gradient-based: where we compute the gradient of the neural network's outcome with respect to the input. The idea is quite simple\u200a-\u200a as we compute gradients of the output wrt to the different parameters to find the importance and magnitude of correction needed for the parameters, why not do the same but for the inputs? This computation provides us a holistic view of the importance of each input wrt to the output. Propagation-based: Gradient-based approach is a plain vanilla approach where backpropagation happens without additional computation at any layer i.e. it's a simple inverse (not mathematically) of the forward pass. In the propagation-based approach, we perform relevance-based modifications at each layer. It can be thought of as an enhanced version of the gradient-based approach. Occlusion based: where we measure the importance of input on the output by erasing the input and estimating the effect on the output. It can be done by either recomputing output with the particular input missing or a mask in its place. Intuitively, the variation in the output will be high in case the input is important, and close to zero otherwise. There are several open-source packages like Ecco, that provide the option to visualize the saliency measure. One example is shown below, Gradient-based method to visualize the importance of the input words for the next word prediction (India) [By Author] Here, for the input \"New Delhi is the capital of\", LLM returned \"India\" which is factually correct. But intuitively, we would like to know which certain part of the input motivated the model to make such a prediction. The important measure is highlighted with color in the image, and as visible it gave a high score to \"New Delhi\" and \"capital\"!","title":"Saliency methods"},{"location":"natural_language_processing/explainable_ai_llm/#extrinsic-explainability","text":"The intrinsic measures fall short of covering the \"needs\" of explainability due to two reasons. Firstly, while it may help the model developer with access to internal metrics, it becomes quite difficult for the stakeholders on the other end of the spectrum to make sense of these complicated numbers. We are talking about the end-user of the model who could be a doctor in healthcare, engineers in mechanical, sales executive in the sales domain, and so on. They care more about factual correctness than the reason behind a model's prediction. Secondly, even the model developers will be concerned if the internal metrics make sense but the output doesn't (output is incorrect). The problem with the existing language models is that they contain all their knowledge within the parameters. GPT-3 is made up of 175 Billion parameters and it has been shown to work on a large number of downstream tasks. It generates the text based on the information it learned and stored in its parameters during the training and fine-tuning phase. Take one task of question answering as an example, where the question is \"Who is the Prime Minister of India?\". While the model may answer it correctly now, how about after the next election? The answer is obvious, it will fail. This is because the information gained is constant and would need re-training to calibrate constantly with the latest events in the world (which is a costly affair [3]). Because of all these reasons, there has been a research interest in enhancing the language models by complimenting them with a connection to a dynamic knowledge base\u200a-\u200athat is kept up to date just like any other database. Some examples by the leading AI teams in the world are as follows, GopherCite [4] from DeepMind is an enhancement of their language model named Gopher. It was created to solve the existing problem of \"hallucinations\" in the Gopher model. In their terms, hallucination of the model leads to incorrect, sometimes nonsensical, text generations. Because of this, humans are required to not take the output for granted and perform proof checks. GopherCite removes that human dependency to some extent by using Google search to find relevant quotes as proof for its prediction. In case no such high probable proofs are found, it even admits defeat instead of providing a wrong answer! Gradient-based method to visualize the importance of the input words for the next word prediction (India) [By Author] WebGPT [5] from OpenAI is an attempt by the creators of GPT-3 to solve the hallucination problem. They complimented GPT with an additional model that interacts with text-based web browsers to find the most relevant web pages for the asked question. For this, the model learned basic commands like \"Search \u2026\", \"Find in page: \u2026\", or \"Quote: \u2026\". The model goes through web pages to find passages and then uses these to compose an answer. The final output contains references to the source web pages as an attempt to legitimize the results. Final output generated by WebGPT for the question \"How do neural networks work?\". Note the presence of References at the bottom. Taken from the blog. LaMDA [6] from Google is a language model for dialog-based interactions. A lot of times, the conversation could become complicated (involving non-fictional characters or real entities), and then it becomes imperative that the model knows the correct context and background knowledge. Based on the conversation, LaMDA can call an external information retrieval system to improve the factual groundedness of its responses. Example of a conversation with Mt. Everest using LaMDA. Taken from blog.","title":"Extrinsic explainability"},{"location":"natural_language_processing/explainable_ai_llm/#references","text":"[1] A Multiscale Visualization of Attention in the Transformer Model [2] Why use attention as explanation when we have saliency methods? [3] Cost of training GPT-3 | Reddit [4] Teaching language models to support answers with verified quotes [5] WebGPT: Browser-assisted question-answering with human feedback [6] LaMDA: Language Models for Dialog Applications Cheers.","title":"References"},{"location":"natural_language_processing/interview_questions/","text":"Here are some questions and their answers to make you ready for your next interview. Best of luck Question Answer What are the different types of reasoning tasks in NLP? Arithmetic Reasoning: Arithmetic reasoning is the ability of an NLP system to perform mathematical operations on numerical data. This can include basic arithmetic operations such as addition, subtraction, multiplication, and division as well as more complex operations such as algebraic equations and calculus. Commonsense Reasoning: Commonsense reasoning refers to the ability of an NLP system to make deductions based on the knowledge and information that is commonly understood by humans. This includes understanding social norms, cultural contexts, and everyday life experiences. ( StrategyQA is a sample dataset that contains True/False questions like \"Did Aristotle use a laptop?\") Symbolic Reasoning: Symbolic reasoning involves the ability of an NLP system to manipulate and reason about symbolic representations of information, such as words, phrases, and sentences. This includes tasks such as parsing, string operations, semantic role labeling and entity recognition. (Last Letter Concatenation is a sample dataset with questions like \"Take the last letters of the words in 'Lady Gaga' and concatenate them\") Logic Reasoning: Logic reasoning refers to the ability of an NLP system to perform logical deductions based on formal rules of inference. This can include tasks such as identifying logical fallacies, determining the validity of arguments, and drawing conclusions based on deductive reasoning. (Date understanding is a sample dataset with questions like \"Today is Christmas Eve 1937, what is the date tomorrow in MM/DD/YYYY?\") Question Answer How much VRAM is required to load a 7B LLM? In full precision (float32), the model stores each parameter in 32 bits or 4 bytes. Therefore, for inference only, loading a 7B model requires 28 billion bytes, which is equivalent to 28 GB of GPU memory. If we use half precision, each parameter is stored in 16 bits, or 2 bytes, resulting in a requirement of 14 GB for inference. Additionally, there are more efficient algorithms like 8 bit and 4 bit, where with 4 bits (half a byte) per parameter, only 3.5 GB of memory is needed for inference. For training, the memory requirement depends on the optimizer used. If the regular AdamW optimizer is employed, it necessitates 8 bytes per parameter since it not only stores the parameters but also their gradients and second-order gradients. Therefore, for a 7 billion parameter model, it would require 56 GB of GPU memory. Alternatively, using AdaFactor, which requires 4 bytes per parameter, the memory requirement decreases to 28 GB. There are also optimizers like bitsandbytes, such as the 8-bit AdamW, which only need 2 bytes per parameter, resulting in a 14 GB GPU memory requirement. Source Read for more details Question Answer What are word embeddings in NLP? Word embeddings are a type of representation for words in NLP. They are a dense vector representation of a word, learned from the data using techniques such as word2vec or GloVe. The embeddings capture the semantics of the words, meaning that words with similar meanings will have similar vectors. Word embeddings are used as input in many NLP tasks such as language translation, text classification, and text generation. Question Answer What is Sentence Encoding? Sentence encoding is the process of converting a sentence into a fixed-length vector representation, also known as sentence embeddings. This is done by using techniques such as bag-of-words, TF-IDF, or BERT-based models. Sentence encodings can be used as input in various NLP tasks such as text classification, text generation, and text similarity. Several algorithms first tokenize the sentence in words or tokens, compute thir embedding and then aggregate them (min, max, mean, etc) to get the sentence embedding. Question Answer Explain the concept of attention mechanism in NLP? Attention mechanism is a way to weight different parts of the input in a neural network, giving more importance to certain parts of the input than others. It is commonly used in NLP tasks such as machine translation, where the model needs to focus on different parts of the input sentence at different times. Attention mechanisms can be implemented in various ways, such as additive attention ( \\(\ud835\udc44+\ud835\udc3e\\) ) and dot-product attention ( \\(\ud835\udc44\ud835\udc3e^{\ud835\udc47}\\) ) Question Answer What are transformer models in NLP? Transformer models are a type of neural network architecture that have been successful in various NLP tasks such as language translation and language understanding. They were introduced in the transformer paper and use self-attention mechanism to weigh the different parts of the input. This allows the model to efficiently process long input sequences and handle the dependencies between the words. Refer for more details. Question Answer Can you explain the concept of Named Entity Recognition (NER) in NLP? Named Entity Recognition (NER) is a subtask of information extraction that seeks to locate and classify named entities in text into predefined categories such as person names, organizations, locations, medical codes, time expressions, quantities, monetary values, percentages, etc. NER systems can be rule-based or based on machine learning, and are used in a wide range of applications such as information retrieval, question answering and text summarization. Question Answer Explain Part-of-Speech (POS) tagging in NLP? Part-of-Speech (POS) tagging is the process of marking each word in a text with its corresponding POS tag. This is a fundamental step in many NLP tasks such as parsing, text summarization, and information extraction. POS tagging can be rule-based or based on machine learning, and is typically done using algorithms such as Hidden Markov Models (HMMs) or Conditional Random Fields (CRFs). Question Answer Can you explain the concept of Language Modeling in NLP? Language modeling is the task of predicting the next word in a sentence, given the previous words. This is done by training a model on a large dataset of text, which learns the probability distribution of the words in the language. Language models are used in a wide range of NLP tasks such as machine translation, text generation, and speech recognition. Question Answer Can you explain the concept of Text Summarization? Text summarization is the task of generating a shorter version of a text that retains the most important information. There are two main types of text summarization: extractive and abstractive. Extractive summarization selects important sentences or phrases from the text to form the summary, while abstractive summarization generates new text that captures the meaning of the original text. Question Answer What is Sentiment Analysis? Sentiment analysis is the task of determining the sentiment or emotion of a piece of text. This is typically done by classifying the text as positive, negative, or neutral. Sentiment analysis can be done using a variety of techniques such as rule-based systems, machine learning, and deep learning. It is used in a wide range of applications such as customer feedback analysis and social media analysis. Question Answer Can you explain the concept of Dependency Parsing? Dependency parsing is the task of analyzing the grammatical structure of a sentence, identifying the dependencies between the words. This is done by creating a dependency parse tree, which represents the grammatical relationships between the words in a sentence. Dependency parsing is a fundamental step in many NLP tasks such as machine translation, text summarization, and information extraction. Question Answer Explain the Coreference Resolution task in NLP? Coreference resolution is the task of identifying when different expressions in a text refer to the same entity. This is done by analyzing the text and identifying when two or more expressions have the same referent. Coreference resolution is a fundamental step in many NLP tasks such as machine translation, text summarization, and information extraction. In this example text, \"Mohit lives in Pune and he works as a Data Scientist\" , the co-reference resolution will identify \"Mohit\" and \"he\" as belonging to the same entity. Question Answer Explain Stemming and Lemmatization in NLP? Stemming is the process of reducing inflected (or sometimes derived) words to their word stem, base or root form. This is done by using a stemmer algorithm which removes the suffixes or prefixes from the word. The goal of stemming is to reduce the dimensionality of the text data, grouping together the inflected forms of a word so they can be analyzed as a single term, which can be useful for tasks such as text classification and information retrieval. Lemmatization is the process of reducing a word to its base form, which is called the lemma. This is done by using a lemmatizer algorithm which takes into consideration the context and the part of speech of the word. The goal of lemmatization is to reduce the dimensionality of the text data and group together the different forms of a word so they can be analyzed as a single term, which can be useful for tasks such as text classification and information retrieval. Note An obvious difference is that Lemmatization consider the grammar of the sentence while Stemming only consider the word. Question Answer What is Text Classification? Text classification is the task of assigning predefined categories or labels to a given text. This is done by training a model on a labeled dataset of text, which learns to predict the label of new text. Text classification is used in a wide range of applications such as sentiment analysis, spam detection, and topic classification. There are multiple types of text classification such as, Binary classification: where there only two classes (ex: positive vs negative) Multi-class classification : where there are more than 2 classes (ex: positive, negative and neutral) Multi-label classification : when there are two or more classes and each text can have more than 1 class/label assigned to them (ex: single text can have some positive phrase and negative phrase) Question Answer What are Dialogue Systems in NLP? A Dialogue system, also known as a conversational agent or chatbot, is a computer program that can interact with human users through natural language. It can understand the user's input, generate appropriate responses, and carry out tasks such as answering questions, booking a flight, or making a reservation. Dialogue systems can be rule-based, or based on machine learning and deep learning, and can be integrated into various platforms such as smartphones, websites, and messaging apps. Question Answer Please explain the concept of Text Generation? Text generation is the task of generating new text that is similar to the text it was trained on. This is done by training a model on a large dataset of text, which learns the probability distribution of the words in the language. Text generation can be used for various applications such as chatbot, text completion and summarization. Refer for more details. Question Answer Can you explain the concept of Text Similarity in NLP? Text Similarity is the task of determining how similar two pieces of text are to each other. This is done by comparing the text using various similarity measures such as cosine similarity, Jaccard similarity, or Levenshtein distance. Text similarity can be used in a wide range of applications such as plagiarism detection and text retrieval. Refer for more details. Question Answer Please explain Text Clustering? Text Clustering is the process of grouping similar texts together. This is done by using clustering algorithms such as K-means, Hierarchical Clustering, or DBSCAN. Text clustering can be used in a wide range of applications such as topic modeling, sentiment analysis, and text summarization. This is usually a two step process, first the text is converted to a representation (usually by text embedding algorithms) and then a clustering algorithm is used to create clusters. Question Answer What is Named Entity Disambiguation (NED)? Named Entity Disambiguation (NED) is the task of determining which entity (from a database) a mention (from text or doc) refers to, from a set of candidate entities. This is done by using techniques such as string matching, co-reference resolution, or graph-based methods. NED is important for tasks such as information extraction and knowledge base population. For example, NED will process a wikipedia page and map \"Mohit M.\", \"M. Mayank\", \"Mohit\" and similar named entities with \"Mohit Mayank\" present in the database. Question Answer What is the difference between a feedforward neural network and a recurrent neural network? A feedforward neural network is a type of neural network in which the data flows in one direction, from input to output. There are no loops or connections that allow information to flow in a cyclical manner. On the other hand, a recurrent neural network (RNN) is a type of neural network that allows information to flow in a cyclical manner, with connections between neurons allowing information to be passed from one step of the process to the next. RNNs are useful for tasks such as language modeling and speech recognition, where the current input is dependent on the previous inputs. Question Answer Is BERT a Text Generation model? Short answer is no. BERT is not a text generation model or a language model because the probability of the predicting a token in masked input is dependent on the context of the token. This context is bidirectional, hence the model is not able to predict the next token in the sequence accurately with only one directional context (as expected for language model) . Question Answer What is weight tying in language model? Weight-tying is where you have a language model and use the same weight matrix for the input-to-embedding layer (the input embedding) and the hidden-to-softmax layer (the output embedding). The idea is that these two matrices contain essentially the same information, each having a row per word in the vocabulary. Ref Question Answer What is so special about the special tokens used in different LM tokenizers? Special tokens are called special because they are added for a certain purpose and are independent of the input. For example, in BERT we have [CLS] token that is added at the start of every input sentence and [SEP] is a special separator token. Similarly in GPT2, <|endoftext|> is special token to denote end of sentence. Users can create their own special token based on their specific use case and train them during finetuning. Refer cronoik's answer in SO Question Answer What are Attention Masks? Attention masks are the token level boolean identifiers used to differentiate between important and not important tokens in the input. One use case is during batch training, where a batch with text of different lengths can be created by adding paddings to shorter texts. The padding tokens can be identified using 0 in attention mask and the original input tokens can be marked as 1. Refer blog @ lukesalamone.com Note We can use a special token for padding. For example in BERT it can be [PAD] token and in GPT-2 we can use <|endoftext|> token. Question Answer What is the difference between Attention and Self-Attention? Self-attention (SA) is applied within one component, so the input is from one component only. One example is the encoder block in Transformers, where SA is used, and it takes the tokens from only the sentence as the input. Attention on the other hand can be used to connect two components or modality of data. Decoder in Transformer has Attention layer that connects the encoder and decoder data together. Refer StackExchange QA Question Answer What is the difference between Bi-encoder and Cross-encoder? In the context of NLP, the difference between Bi-encoders and Cross-encoders lies in how they handle and process input sentences and the kind of outputs they produce. Refer SBert Bi-Encoders: Process: Bi-encoders process two sentences (A and B) independently through a transformer network like BERT. Each sentence is input separately, resulting in two separate sentence embeddings (u and v). Output: The output is a pair of sentence embeddings, which can be compared using measures like cosine similarity to determine their relationship or similarity. Usage: These are particularly useful when you want to pre-compute sentence embeddings for a large collection of text, as you can then quickly compare new sentences to the entire collection using the embeddings. They are efficient for tasks that require comparing multiple sentences against one another. Cross-Encoders: Process: Cross-encoders take a pair of sentences as a single input and pass them simultaneously to the transformer network. The model takes into account the interaction between the sentences directly during the encoding process. Output: Instead of separate embeddings, a Cross-encoder outputs a single score or value, typically between 0 and 1, representing the relationship or similarity of the sentence pair. It does not produce separate sentence embeddings. Usage: Cross-encoders are generally more accurate for tasks like semantic similarity or relevance ranking because they consider the interaction between the sentence pair directly. However, they are less efficient compared to Bi-encoders for large-scale tasks because each sentence pair must be processed together and in real-time, making it hard to pre-compute and store representations.","title":"Interview Questions"},{"location":"natural_language_processing/interview_questions/#what-are-the-different-types-of-reasoning-tasks-in-nlp","text":"Arithmetic Reasoning: Arithmetic reasoning is the ability of an NLP system to perform mathematical operations on numerical data. This can include basic arithmetic operations such as addition, subtraction, multiplication, and division as well as more complex operations such as algebraic equations and calculus. Commonsense Reasoning: Commonsense reasoning refers to the ability of an NLP system to make deductions based on the knowledge and information that is commonly understood by humans. This includes understanding social norms, cultural contexts, and everyday life experiences. ( StrategyQA is a sample dataset that contains True/False questions like \"Did Aristotle use a laptop?\") Symbolic Reasoning: Symbolic reasoning involves the ability of an NLP system to manipulate and reason about symbolic representations of information, such as words, phrases, and sentences. This includes tasks such as parsing, string operations, semantic role labeling and entity recognition. (Last Letter Concatenation is a sample dataset with questions like \"Take the last letters of the words in 'Lady Gaga' and concatenate them\") Logic Reasoning: Logic reasoning refers to the ability of an NLP system to perform logical deductions based on formal rules of inference. This can include tasks such as identifying logical fallacies, determining the validity of arguments, and drawing conclusions based on deductive reasoning. (Date understanding is a sample dataset with questions like \"Today is Christmas Eve 1937, what is the date tomorrow in MM/DD/YYYY?\") Question Answer","title":"What are the different types of reasoning tasks in NLP?"},{"location":"natural_language_processing/interview_questions/#how-much-vram-is-required-to-load-a-7b-llm","text":"In full precision (float32), the model stores each parameter in 32 bits or 4 bytes. Therefore, for inference only, loading a 7B model requires 28 billion bytes, which is equivalent to 28 GB of GPU memory. If we use half precision, each parameter is stored in 16 bits, or 2 bytes, resulting in a requirement of 14 GB for inference. Additionally, there are more efficient algorithms like 8 bit and 4 bit, where with 4 bits (half a byte) per parameter, only 3.5 GB of memory is needed for inference. For training, the memory requirement depends on the optimizer used. If the regular AdamW optimizer is employed, it necessitates 8 bytes per parameter since it not only stores the parameters but also their gradients and second-order gradients. Therefore, for a 7 billion parameter model, it would require 56 GB of GPU memory. Alternatively, using AdaFactor, which requires 4 bytes per parameter, the memory requirement decreases to 28 GB. There are also optimizers like bitsandbytes, such as the 8-bit AdamW, which only need 2 bytes per parameter, resulting in a 14 GB GPU memory requirement. Source Read for more details Question Answer","title":"How much VRAM is required to load a 7B LLM?"},{"location":"natural_language_processing/interview_questions/#what-are-word-embeddings-in-nlp","text":"Word embeddings are a type of representation for words in NLP. They are a dense vector representation of a word, learned from the data using techniques such as word2vec or GloVe. The embeddings capture the semantics of the words, meaning that words with similar meanings will have similar vectors. Word embeddings are used as input in many NLP tasks such as language translation, text classification, and text generation. Question Answer","title":"What are word embeddings in NLP?"},{"location":"natural_language_processing/interview_questions/#what-is-sentence-encoding","text":"Sentence encoding is the process of converting a sentence into a fixed-length vector representation, also known as sentence embeddings. This is done by using techniques such as bag-of-words, TF-IDF, or BERT-based models. Sentence encodings can be used as input in various NLP tasks such as text classification, text generation, and text similarity. Several algorithms first tokenize the sentence in words or tokens, compute thir embedding and then aggregate them (min, max, mean, etc) to get the sentence embedding. Question Answer","title":"What is Sentence Encoding?"},{"location":"natural_language_processing/interview_questions/#explain-the-concept-of-attention-mechanism-in-nlp","text":"Attention mechanism is a way to weight different parts of the input in a neural network, giving more importance to certain parts of the input than others. It is commonly used in NLP tasks such as machine translation, where the model needs to focus on different parts of the input sentence at different times. Attention mechanisms can be implemented in various ways, such as additive attention ( \\(\ud835\udc44+\ud835\udc3e\\) ) and dot-product attention ( \\(\ud835\udc44\ud835\udc3e^{\ud835\udc47}\\) ) Question Answer","title":"Explain the concept of attention mechanism in NLP?"},{"location":"natural_language_processing/interview_questions/#what-are-transformer-models-in-nlp","text":"Transformer models are a type of neural network architecture that have been successful in various NLP tasks such as language translation and language understanding. They were introduced in the transformer paper and use self-attention mechanism to weigh the different parts of the input. This allows the model to efficiently process long input sequences and handle the dependencies between the words. Refer for more details. Question Answer","title":"What are transformer models in NLP?"},{"location":"natural_language_processing/interview_questions/#can-you-explain-the-concept-of-named-entity-recognition-ner-in-nlp","text":"Named Entity Recognition (NER) is a subtask of information extraction that seeks to locate and classify named entities in text into predefined categories such as person names, organizations, locations, medical codes, time expressions, quantities, monetary values, percentages, etc. NER systems can be rule-based or based on machine learning, and are used in a wide range of applications such as information retrieval, question answering and text summarization. Question Answer","title":"Can you explain the concept of Named Entity Recognition (NER) in NLP?"},{"location":"natural_language_processing/interview_questions/#explain-part-of-speech-pos-tagging-in-nlp","text":"Part-of-Speech (POS) tagging is the process of marking each word in a text with its corresponding POS tag. This is a fundamental step in many NLP tasks such as parsing, text summarization, and information extraction. POS tagging can be rule-based or based on machine learning, and is typically done using algorithms such as Hidden Markov Models (HMMs) or Conditional Random Fields (CRFs). Question Answer","title":"Explain Part-of-Speech (POS) tagging in NLP?"},{"location":"natural_language_processing/interview_questions/#can-you-explain-the-concept-of-language-modeling-in-nlp","text":"Language modeling is the task of predicting the next word in a sentence, given the previous words. This is done by training a model on a large dataset of text, which learns the probability distribution of the words in the language. Language models are used in a wide range of NLP tasks such as machine translation, text generation, and speech recognition. Question Answer","title":"Can you explain the concept of Language Modeling in NLP?"},{"location":"natural_language_processing/interview_questions/#can-you-explain-the-concept-of-text-summarization","text":"Text summarization is the task of generating a shorter version of a text that retains the most important information. There are two main types of text summarization: extractive and abstractive. Extractive summarization selects important sentences or phrases from the text to form the summary, while abstractive summarization generates new text that captures the meaning of the original text. Question Answer","title":"Can you explain the concept of Text Summarization?"},{"location":"natural_language_processing/interview_questions/#what-is-sentiment-analysis","text":"Sentiment analysis is the task of determining the sentiment or emotion of a piece of text. This is typically done by classifying the text as positive, negative, or neutral. Sentiment analysis can be done using a variety of techniques such as rule-based systems, machine learning, and deep learning. It is used in a wide range of applications such as customer feedback analysis and social media analysis. Question Answer","title":"What is Sentiment Analysis?"},{"location":"natural_language_processing/interview_questions/#can-you-explain-the-concept-of-dependency-parsing","text":"Dependency parsing is the task of analyzing the grammatical structure of a sentence, identifying the dependencies between the words. This is done by creating a dependency parse tree, which represents the grammatical relationships between the words in a sentence. Dependency parsing is a fundamental step in many NLP tasks such as machine translation, text summarization, and information extraction. Question Answer","title":"Can you explain the concept of Dependency Parsing?"},{"location":"natural_language_processing/interview_questions/#explain-the-coreference-resolution-task-in-nlp","text":"Coreference resolution is the task of identifying when different expressions in a text refer to the same entity. This is done by analyzing the text and identifying when two or more expressions have the same referent. Coreference resolution is a fundamental step in many NLP tasks such as machine translation, text summarization, and information extraction. In this example text, \"Mohit lives in Pune and he works as a Data Scientist\" , the co-reference resolution will identify \"Mohit\" and \"he\" as belonging to the same entity. Question Answer","title":"Explain the Coreference Resolution task in NLP?"},{"location":"natural_language_processing/interview_questions/#explain-stemming-and-lemmatization-in-nlp","text":"Stemming is the process of reducing inflected (or sometimes derived) words to their word stem, base or root form. This is done by using a stemmer algorithm which removes the suffixes or prefixes from the word. The goal of stemming is to reduce the dimensionality of the text data, grouping together the inflected forms of a word so they can be analyzed as a single term, which can be useful for tasks such as text classification and information retrieval. Lemmatization is the process of reducing a word to its base form, which is called the lemma. This is done by using a lemmatizer algorithm which takes into consideration the context and the part of speech of the word. The goal of lemmatization is to reduce the dimensionality of the text data and group together the different forms of a word so they can be analyzed as a single term, which can be useful for tasks such as text classification and information retrieval. Note An obvious difference is that Lemmatization consider the grammar of the sentence while Stemming only consider the word. Question Answer","title":"Explain Stemming and Lemmatization in NLP?"},{"location":"natural_language_processing/interview_questions/#what-is-text-classification","text":"Text classification is the task of assigning predefined categories or labels to a given text. This is done by training a model on a labeled dataset of text, which learns to predict the label of new text. Text classification is used in a wide range of applications such as sentiment analysis, spam detection, and topic classification. There are multiple types of text classification such as, Binary classification: where there only two classes (ex: positive vs negative) Multi-class classification : where there are more than 2 classes (ex: positive, negative and neutral) Multi-label classification : when there are two or more classes and each text can have more than 1 class/label assigned to them (ex: single text can have some positive phrase and negative phrase) Question Answer","title":"What is Text Classification?"},{"location":"natural_language_processing/interview_questions/#what-are-dialogue-systems-in-nlp","text":"A Dialogue system, also known as a conversational agent or chatbot, is a computer program that can interact with human users through natural language. It can understand the user's input, generate appropriate responses, and carry out tasks such as answering questions, booking a flight, or making a reservation. Dialogue systems can be rule-based, or based on machine learning and deep learning, and can be integrated into various platforms such as smartphones, websites, and messaging apps. Question Answer","title":"What are Dialogue Systems in NLP?"},{"location":"natural_language_processing/interview_questions/#please-explain-the-concept-of-text-generation","text":"Text generation is the task of generating new text that is similar to the text it was trained on. This is done by training a model on a large dataset of text, which learns the probability distribution of the words in the language. Text generation can be used for various applications such as chatbot, text completion and summarization. Refer for more details. Question Answer","title":"Please explain the concept of Text Generation?"},{"location":"natural_language_processing/interview_questions/#can-you-explain-the-concept-of-text-similarity-in-nlp","text":"Text Similarity is the task of determining how similar two pieces of text are to each other. This is done by comparing the text using various similarity measures such as cosine similarity, Jaccard similarity, or Levenshtein distance. Text similarity can be used in a wide range of applications such as plagiarism detection and text retrieval. Refer for more details. Question Answer","title":"Can you explain the concept of Text Similarity in NLP?"},{"location":"natural_language_processing/interview_questions/#please-explain-text-clustering","text":"Text Clustering is the process of grouping similar texts together. This is done by using clustering algorithms such as K-means, Hierarchical Clustering, or DBSCAN. Text clustering can be used in a wide range of applications such as topic modeling, sentiment analysis, and text summarization. This is usually a two step process, first the text is converted to a representation (usually by text embedding algorithms) and then a clustering algorithm is used to create clusters. Question Answer","title":"Please explain Text Clustering?"},{"location":"natural_language_processing/interview_questions/#what-is-named-entity-disambiguation-ned","text":"Named Entity Disambiguation (NED) is the task of determining which entity (from a database) a mention (from text or doc) refers to, from a set of candidate entities. This is done by using techniques such as string matching, co-reference resolution, or graph-based methods. NED is important for tasks such as information extraction and knowledge base population. For example, NED will process a wikipedia page and map \"Mohit M.\", \"M. Mayank\", \"Mohit\" and similar named entities with \"Mohit Mayank\" present in the database. Question Answer","title":"What is Named Entity Disambiguation (NED)?"},{"location":"natural_language_processing/interview_questions/#what-is-the-difference-between-a-feedforward-neural-network-and-a-recurrent-neural-network","text":"A feedforward neural network is a type of neural network in which the data flows in one direction, from input to output. There are no loops or connections that allow information to flow in a cyclical manner. On the other hand, a recurrent neural network (RNN) is a type of neural network that allows information to flow in a cyclical manner, with connections between neurons allowing information to be passed from one step of the process to the next. RNNs are useful for tasks such as language modeling and speech recognition, where the current input is dependent on the previous inputs. Question Answer","title":"What is the difference between a feedforward neural network and a recurrent neural network?"},{"location":"natural_language_processing/interview_questions/#is-bert-a-text-generation-model","text":"Short answer is no. BERT is not a text generation model or a language model because the probability of the predicting a token in masked input is dependent on the context of the token. This context is bidirectional, hence the model is not able to predict the next token in the sequence accurately with only one directional context (as expected for language model) . Question Answer","title":"Is BERT a Text Generation model?"},{"location":"natural_language_processing/interview_questions/#what-is-weight-tying-in-language-model","text":"Weight-tying is where you have a language model and use the same weight matrix for the input-to-embedding layer (the input embedding) and the hidden-to-softmax layer (the output embedding). The idea is that these two matrices contain essentially the same information, each having a row per word in the vocabulary. Ref Question Answer","title":"What is weight tying in language model?"},{"location":"natural_language_processing/interview_questions/#what-is-so-special-about-the-special-tokens-used-in-different-lm-tokenizers","text":"Special tokens are called special because they are added for a certain purpose and are independent of the input. For example, in BERT we have [CLS] token that is added at the start of every input sentence and [SEP] is a special separator token. Similarly in GPT2, <|endoftext|> is special token to denote end of sentence. Users can create their own special token based on their specific use case and train them during finetuning. Refer cronoik's answer in SO Question Answer","title":"What is so special about the special tokens used in different LM tokenizers?"},{"location":"natural_language_processing/interview_questions/#what-are-attention-masks","text":"Attention masks are the token level boolean identifiers used to differentiate between important and not important tokens in the input. One use case is during batch training, where a batch with text of different lengths can be created by adding paddings to shorter texts. The padding tokens can be identified using 0 in attention mask and the original input tokens can be marked as 1. Refer blog @ lukesalamone.com Note We can use a special token for padding. For example in BERT it can be [PAD] token and in GPT-2 we can use <|endoftext|> token. Question Answer","title":"What are Attention Masks?"},{"location":"natural_language_processing/interview_questions/#what-is-the-difference-between-attention-and-self-attention","text":"Self-attention (SA) is applied within one component, so the input is from one component only. One example is the encoder block in Transformers, where SA is used, and it takes the tokens from only the sentence as the input. Attention on the other hand can be used to connect two components or modality of data. Decoder in Transformer has Attention layer that connects the encoder and decoder data together. Refer StackExchange QA Question Answer","title":"What is the difference between Attention and Self-Attention?"},{"location":"natural_language_processing/interview_questions/#what-is-the-difference-between-bi-encoder-and-cross-encoder","text":"In the context of NLP, the difference between Bi-encoders and Cross-encoders lies in how they handle and process input sentences and the kind of outputs they produce. Refer SBert Bi-Encoders: Process: Bi-encoders process two sentences (A and B) independently through a transformer network like BERT. Each sentence is input separately, resulting in two separate sentence embeddings (u and v). Output: The output is a pair of sentence embeddings, which can be compared using measures like cosine similarity to determine their relationship or similarity. Usage: These are particularly useful when you want to pre-compute sentence embeddings for a large collection of text, as you can then quickly compare new sentences to the entire collection using the embeddings. They are efficient for tasks that require comparing multiple sentences against one another. Cross-Encoders: Process: Cross-encoders take a pair of sentences as a single input and pass them simultaneously to the transformer network. The model takes into account the interaction between the sentences directly during the encoding process. Output: Instead of separate embeddings, a Cross-encoder outputs a single score or value, typically between 0 and 1, representing the relationship or similarity of the sentence pair. It does not produce separate sentence embeddings. Usage: Cross-encoders are generally more accurate for tasks like semantic similarity or relevance ranking because they consider the interaction between the sentence pair directly. However, they are less efficient compared to Bi-encoders for large-scale tasks because each sentence pair must be processed together and in real-time, making it hard to pre-compute and store representations.","title":"What is the difference between Bi-encoder and Cross-encoder?"},{"location":"natural_language_processing/llama/","text":"LLaMA - 1, 2 Introduction In Feb 2023, Meta introduced a collection of foundation language models ranging from 7B to 65B parameters under the name of LLaMA. What makes LLaMA different from other LLMs is, It was trained on 1.4 trillion tokens created using publicly available datasets without resorting to proprietary and inaccessible datasets as done by the likes of Chinchilla, PaLM, or GPT-3. With added improvements, the resulting models are highly competitive against more powerful models. For instance, LLaMA-13B outperforms GPT-3 (175B) on most benchmarks, and LLaMA- 65B is competitive with the best models, Chinchilla-70B and PaLM-540B. Tip \u201cOfficial\u201d weights were only released to the research community and even then you need to fill out a form to request access. That said, there has been \u201cpirating\u201d of the weights that allow anyone to play around with the model. It was quite interesting, more details in this LinkedIn Post LLaMA-2 [3] was announed on July 2023 which was trained on 40% more data (~2 Trillion tokens) than LLaMA-1 and has double the context length (4096 tokens) . Learning from the social media reactions with LLaMA-1, v2 was released for both research and commerical purpose! Architecture Modifications To achieve the enhancements, several modifications were made to the original Transformer architecture. They are, [1] Pre-normalization [from GPT3] To improve the training stability, RMSNorm was used to normalize the input of each transformer sub-layer instead of the output. SwiGLU activation function [from PaLM]. ReLU non-linearity was replaced by the SwiGLU activation function. Rotary Embeddings [from GPTNeo] . Absolute positional embeddings were replaced with rotary positional embeddings (RoPE) at each layer of the network. Training Optimizations On top of architecture modifications, several optimizations were made to improve the training speed of the models. They are, [1] First, an efficient implementation of causal multi-head attention was used to reduce memory usage and runtime. (refer xformers library) To further improve training efficiency, the number of activations that are recomputed was reduced during the backward pass with checkpointing. Additional GPU optimizations were done like overlapping the computation of activations and the communication between GPUs over the network. Dataset The dataset used to train LLaMA-1 was created using only open-source data and is a mixture of several sources, as shown below. This led to the creation of 1.4 Trillion tokens of the total dataset. [1] In LLaMA-2 the dataset size was increased to 2 Trillion tokens by including a new mix of data from publicly available sources, which does not include data from Meta\u2019s products or services. Meta removed data from certain sites known to contain a high volume of personal information about private individuals. Released Models For LLaMA-1, below is the list of models trained as part of the project with additional details like dimensions, attention layers and head as well as the training metrics of the learning rate, batch size and the number of tokens used for training. [1] Under LLaMA-2 only three models 7B, 13B and 70B were released. Inspired Models LLaMA was one of the first opensource work on making powerful LLM accessible to the public. This has inspired release of several similar models, below are some of them. Alpaca LLaMA authors observed that a very small amount of instruction-based finetuning improves the performance of the model on Massive Multitask Language Understanding Tasks (MMLU). It also further improves the ability of the model to follow instructions. That said, they didn\u2019t explore this thread further. Below you can see 5-shot MMLU performance of LLaMA-Instruct model (LLaMA-I) -- it is better than LLaMA model of the same size. [1] Enter Stanford Alpaca [2], an instruction-based finetuned LLaMA that further improves the performance of LLaMA models so much so that even 7B Alpaca model is comparable with OpenAI\u2019s text-davinci-003. Warning Alpaca team suggested that the model is better than LLaMA. There were no comparitive numbers or tables shared. The process starts with first generating 52K instruction-following samples using OpenAI's text-davinci-003. Then LLaMA model was finetuned on these data using supervised learning, basically taking inspiration from self-instruct paper. This process reduces the cost of preparing a GPT level model to under ~ $600 ( $500 to generate the data + $100 to finetune). The process is summarised below, Note The code to generate the 52k dataset along with finetuning recipe was open-sourced [2] OpenLLaMA OpenLLaMA [4] is a permissively licensed open-source reproduction of Meta AI's LLaMA, providing a series of 3B, 7B, and 13B models trained on 1T tokens. OpenLLaMA was trained on the RedPajama dataset and other diverse datasets using cloud TPU-v4s with the EasyLM framework, employing data parallelism and fully sharded data parallelism to enhance efficiency. The models are available in PyTorch and JAX formats. OpenLLaMA's evaluation showcases its comparable and sometimes superior performance across various tasks to the original LLaMA and GPT-J models, reflecting its robustness and reliability. The project was quite active in 2023 with release of v2 and v3 models which was trained on mixture of Falcon refined-web dataset, the starcoder dataset, the wikipedia, arxiv, books and stackexchange from RedPajama. Below is a sample code from their Github [4], 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import torch from transformers import LlamaTokenizer , LlamaForCausalLM ## v2 models model_path = 'openlm-research/open_llama_3b_v2' # model_path = 'openlm-research/open_llama_7b_v2' ## v1 models # model_path = 'openlm-research/open_llama_3b' # model_path = 'openlm-research/open_llama_7b' # model_path = 'openlm-research/open_llama_13b' tokenizer = LlamaTokenizer . from_pretrained ( model_path ) model = LlamaForCausalLM . from_pretrained ( model_path , torch_dtype = torch . float16 , device_map = 'auto' , ) prompt = 'Q: What is the largest animal? \\n A:' input_ids = tokenizer ( prompt , return_tensors = \"pt\" ) . input_ids generation_output = model . generate ( input_ids = input_ids , max_new_tokens = 32 ) print ( tokenizer . decode ( generation_output [ 0 ])) TinyLLaMA TinyLlama is an ambitious open-source project aimed at pretraining a 1.1B parameter Llama model on 3 trillion tokens, striving for both efficiency and compactness. With the goal of completing this massive training within 90 days using 16 A100-40G GPUs, the project began its journey on September 1, 2023. TinyLlama maintains the same architecture and tokenizer as the original Llama model, ensuring compatibility and ease of integration with various existing open-source projects. What sets TinyLlama apart is its compact size, enabling it to be utilized in numerous applications that demand reduced computation and memory footprint, making it particularly suitable for deployment in resource-constrained environments. TinyLLaMA Logo [5] The training utilizes a vast dataset, combining Slimpajama and Starcoderdata to comprise approximately 950 billion tokens, with the total tokens during training reaching 3 trillion. The project is noted for its adaptability and speed, offering multiple optimizations to enhance performance, such as multi-GPU and multi-node distributed training, flash attention 2, and fused operations for LayerNorm, SwiGLU, cross entropy loss, and rotary positional embedding. The models can be found in their HuggingFace Org page . Note As mentioned above, the total dataset size was 950B but as the model was trained for approx 3 epochs the total trainable tokens are 3 Billions. Another point to note is that this model was motivated by the model training saturation details mentioned in LLaMA-2 paper. It shows every model from 70B to 7B are still not saturated even after training for 2B tokens. This approach was an extrapolation on the research by picking a much smaller model (~1B) and going much further (3B tokens) . LiteLLaMA LiteLlama-460M-1T [6] is a model with 460 million parameters, trained on approximately 1 trillion (0.98T) tokens. It leverages the RedPajama dataset for training and utilizes GPT2Tokenizer for text tokenization, preserving high compatibility and performance while reducing the model's size. In terms of evaluation, LiteLlama-460M-1T has been assessed on multiple datasets, but MMLU task showcase its comparative performance when compared to TinyLLaMA. The project, developed by Xiaotian Han from Texas A&M University, emphasizes the open-source ethos by making the model and training details accessible and by releasing it under the MIT License ( available here ). Note Just because LiteLLaMA works good for one task does it not mean it can replace TinyLLaMA or LLaMA-2 models completely. Make sure to perform extensive test for your usecase before selecting any model. Code Inference There are many ways to access LLaMA. Below are some of the most popular ones, HuggingFace HuggingFace has created the port to use the LLaMA-1 model. You can also access the crowd-uploaded model at the hub here . The code to load and use the model like any other LLM is shown below, 1 2 3 4 5 6 7 8 9 10 # install (currently LLamA is in the main branch of HF) ! pip install git + https : // github . com / huggingface / transformers . git ! pip install sentencepiece # import from transformers import LlamaForCausalLM , LlamaTokenizer # load the tokenizer and model tokenizer = LlamaTokenizer . from_pretrained ( \"decapoda-research/llama-7b-hf\" ) model = LlamaForCausalLM . from_pretrained ( \"decapoda-research/llama-7b-hf\" ) With LLaMA-2 we have the official model weights uploaded on HuggingFace from Meta. The code remains the same, we just have to modify the model name. One exmaple of the model is meta-llama/Llama-2-13b-hf , and you can find more models on the Meta LLaMA Org page . Dalai Dalai is the simplest way to run the LLaMA-1 or Alpaca models on your machine. It also provides an intuitive UI to use the model. All you need to do is, 1 2 3 4 5 6 # install model npx dalai llama install 7 B # or 13B, 30B, 65B npx dalai alpaca install 7 B # or 13B, 30B, 65B # launch web UI + socket.io API npx dalai serve And it looks good! \ud83d\udc47 Note Internally it uses C/C++ port of LLaMA and Alpaca . You can access them separately for faster execution. The respective packages have also applied quantization to provide much faster execution with some compromise on accuracy. Finetuning While there are multiple ways to finetune LLaMA model, we will focus on QLoRA based finetuning as this is the most efficient and fast way to create adapters on top of LLaMA for any downstream tasks. Below is the code to finetune Llama-2-7b-chat-hf model for a classification task and it can be easily modified (by changing the model name) to work for other similar models, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 ## Install packages ! pip install - q - U bitsandbytes == 0.40.0 ! pip install - q transformers == 4.30 ! pip install - q - U git + https : // github . com / huggingface / peft . git ! pip install - q datasets ! conda install cudatoolkit - y ## Import import os import time import torch import transformers import pandas as pd from tqdm import tqdm from ast import literal_eval from datasets import Dataset from sklearn.metrics import confusion_matrix , classification_report from peft import prepare_model_for_kbit_training , LoraConfig , get_peft_model from transformers import AutoTokenizer , AutoModelForCausalLM , BitsAndBytesConfig # check if GPU is available or not print ( \"CUDA available (from PyTorch) --> \" , torch . cuda . is_available ()) print ( \"GPU available --> \" , torch . cuda . get_device_name ( 0 )) ## Load Model # define model name (huggingface) model_id = \"meta-llama/Llama-2-7b-chat-hf\" # bnb config bnb_config = BitsAndBytesConfig ( load_in_4bit = True , bnb_4bit_use_double_quant = False , bnb_4bit_quant_type = \"nf4\" , bnb_4bit_compute_dtype = torch . bfloat16 ) # load tokenizer tokenizer = AutoTokenizer . from_pretrained ( model_id , use_auth_token = access_token ) tokenizer . padding_side = \"right\" tokenizer . pad_token = tokenizer . eos_token # load model model = AutoModelForCausalLM . from_pretrained ( model_id , quantization_config = bnb_config , device_map = { \"\" : 0 }, use_auth_token = access_token ) ## Prepare data # function to format the input data def format_dataset_as_instruction ( sample ): return f \"\"\"### Instruction: Classify the sales cold call into either of the following class: Busy, Follow Up, Gate Keeper, Interested, Not Interested, Wrong Number and Others. ### Input: { sample [ 'text' ] } ### Response: { sample [ 'class' ] } \"\"\" # function to prepare the dataset def prepare_data ( data = None , file_path = None , encode = True ): # load the data and prepare it if data is None : data = pd . read_csv ( file_path ) formatted_data = data . apply ( lambda x : format_dataset_as_instruction ( x ), axis = 1 ) # create HF Dataset ds = Dataset . from_pandas ( pd . DataFrame ( formatted_data , columns = [ 'text' ])) # perform tokenization if encode : perform_tokenization = lambda x : tokenizer ( x [ 'text' ], padding = True , truncation = True ) ds = ds . shuffle () . map ( perform_tokenization ) ds = ds . remove_columns ([ 'text' , 'token_type_ids' ]) # return return ds # load the complete dataset, cols = text: call transcription; class: class enum or name df = pd . read_csv ( 'data/call_disposition.csv' ) # prepare the train data train_data = prepare_data ( df . loc [ df [ 'type' ] == 'train' , [ 'class' , 'text' ]] . sample ( frac = 1 ) . reset_index ( drop = True )) # prepare the test data test_data = prepare_data ( df . loc [ df [ 'type' ] == 'test' , [ 'class' , 'text' ]] . sample ( frac = 1 ) . reset_index ( drop = True )) loc_test_data = prepare_data ( df . loc [ df [ 'type' ] == 'test' , [ 'class' , 'text' ]] . sample ( frac = 1 ) . reset_index ( drop = True ), encode = False ) # for post training testing ## Prepare for Training model . gradient_checkpointing_enable () model = prepare_model_for_kbit_training ( model ) def print_trainable_parameters ( model ): \"\"\" Prints the number of trainable parameters in the model. \"\"\" trainable_params = 0 all_param = 0 for _ , param in model . named_parameters (): all_param += param . numel () if param . requires_grad : trainable_params += param . numel () print ( f \"trainable params: { trainable_params } || all params: { all_param } || trainable%: { 100 * trainable_params / all_param } \" ) # create config config = LoraConfig ( r = 8 , lora_alpha = 32 , # target_modules=[\"query_key_value\"], lora_dropout = 0.05 , bias = \"none\" , task_type = \"CAUSAL_LM\" ) model = get_peft_model ( model , config ) print_trainable_parameters ( model ) # output: trainable params: 4194304 || all params: 3504607232 || trainable%: 0.11967971650867153 ## Start Training # needed for gpt-neo-x tokenizer tokenizer . pad_token = tokenizer . eos_token # trainer trainer = transformers . Trainer ( model = model , train_dataset = train_data , args = transformers . TrainingArguments ( per_device_train_batch_size = 2 , gradient_accumulation_steps = 4 , # num_train_epochs=2, warmup_steps = 2 , # max_steps=10, learning_rate = 2e-4 , fp16 = True , logging_steps = 1 , output_dir = \"outputs\" , optim = \"paged_adamw_8bit\" , remove_unused_columns = False ), data_collator = transformers . DataCollatorForLanguageModeling ( tokenizer , mlm = False ), ) model . config . use_cache = False # silence the warnings. Please re-enable for inference! trainer . train () # save the adapter PEFT_MODEL_PATH = \"adapters/calldisposition_v1.0.0-alpha\" model . save_pretrained ( PEFT_MODEL_PATH ) ## Loading the finetuned-model model . config . use_cache = True bnb_config = BitsAndBytesConfig ( load_in_4bit = True , bnb_4bit_use_double_quant = False , bnb_4bit_quant_type = \"nf4\" , bnb_4bit_compute_dtype = torch . bfloat16 ) config = PeftConfig . from_pretrained ( PEFT_MODEL_PATH ) loaded_model = AutoModelForCausalLM . from_pretrained ( config . base_model_name_or_path , return_dict = True , quantization_config = bnb_config , device_map = \"auto\" , trust_remote_code = True ) loaded_tokenizer = AutoTokenizer . from_pretrained ( config . base_model_name_or_path ) loaded_tokenizer . pad_token = loaded_tokenizer . eos_token loaded_tokenizer . padding_side = \"right\" loaded_model = PeftModel . from_pretrained ( loaded_model , PEFT_MODEL_PATH ) ## Inference on Loaded Model # prepare sample test data prompt selected_test_data = loc_test_data [ 'text' ][ 0 ] prompt = selected_test_data . split ( \"### Response:\" )[ 0 ] + \"### Response: \\n \" # create settings generation_config = loaded_model . generation_config generation_config . max_new_tokens = 25 generation_config . temperature = 0.7 generation_config . top_p = 0.7 generation_config . num_return_sequences = 1 generation_config . pad_token_id = loaded_tokenizer . eos_token_id generation_config . eos_token_id = loaded_tokenizer . eos_token_id # run inference device = \"cuda\" encoding = loaded_tokenizer ( prompt , return_tensors = \"pt\" ) . to ( device ) with torch . inference_mode (): outputs = loaded_model . generate ( input_ids = encoding . input_ids , attention_mask = encoding . attention_mask , generation_config = generation_config ) print ( loaded_tokenizer . decode ( outputs [ 0 ], skip_special_tokens = True )) ## Test on complete test data # save the results testing_results = [] model . config . use_cache = True # prepare sample test data prompt for selected_test_data in tqdm ( loc_test_data [ 'text' ]): latency = time . time () # create the prompt prompt = selected_test_data . split ( \"### Response:\" )[ 0 ] + \"### Response: \\n \" # create settings generation_config = loaded_model . generation_config generation_config . max_new_tokens = 25 generation_config . temperature = 0 generation_config . top_p = 0.7 generation_config . num_return_sequences = 1 generation_config . pad_token_id = loaded_tokenizer . eos_token_id generation_config . eos_token_id = loaded_tokenizer . eos_token_id # tun inference device = \"cuda\" encoding = loaded_tokenizer ( prompt , return_tensors = \"pt\" ) . to ( device ) with torch . inference_mode (): outputs = loaded_model . generate ( input_ids = encoding . input_ids , attention_mask = encoding . attention_mask , generation_config = generation_config ) original_class = get_response ( selected_test_data ) predicted_class = get_response ( loaded_tokenizer . decode ( outputs [ 0 ], skip_special_tokens = True )) flag_matched = predicted_class == original_class testing_results . append ({ 'original_class' : original_class , 'predicted_class' : predicted_class , 'match' : flag_matched , 'text' : selected_test_data , 'time' : time . time () - latency }) # transform to pandas dataframe testing_results = pd . DataFrame ( testing_results ) ## Generate Test Report (Classification) # Calculate overall accuracy overall_accuracy = testing_results [ 'match' ] . mean () print ( f \"Overall Accuracy: { overall_accuracy : .2f } \" ) # Class-wise accuracy class_accuracy = testing_results . groupby ( 'original_class' )[ 'match' ] . mean () print ( \" \\n Class-wise Accuracy:\" ) print ( class_accuracy ) # Confusion Matrix labels = testing_results [ 'original_class' ] . unique () cm = confusion_matrix ( testing_results [ 'original_class' ], testing_results [ 'predicted_class' ], labels = labels ) print ( \" \\n Confusion Matrix:\" ) print ( cm ) # Classification Report for precision, recall, F1-score report = classification_report ( testing_results [ 'original_class' ], testing_results [ 'predicted_class' ], labels = labels ) print ( \" \\n Classification Report:\" ) print ( report ) Hint If you are getting this or similar error -- No libcudart.so found! Install CUDA or the cudatoolkit package (anaconda)! due to bitsandbytes pacakge, you can fix it by running following code on your system after installing the packages. But make sure to check of the following path and files are available or not. 1 2 3 4 ## Set env var os . environ [ \"LD_LIBRARY_PATH\" ] = \"/usr/lib/x86_64-linux-gnu/:/opt/conda/lib/\" ## ! cp / opt / conda / lib / python3 .11 / site - packages / bitsandbytes / libbitsandbytes_cuda122 . so / opt / conda / lib / python3 .11 / site - packages / bitsandbytes / libbitsandbytes_cpu . so Hint If you want to perform normal inference after loading the model at `line 44`` above, you can use the following code, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # load pipeline pipeline = transformers . pipeline ( \"text-generation\" , model = model , torch_dtype = torch . float16 , device_map = \"auto\" , tokenizer = tokenizer ) # run inference sequences = pipeline ( 'Answer the following question: Who is the current Prime Minster of India? \\n Answer:' , do_sample = True , top_k = 10 , num_return_sequences = 1 , eos_token_id = tokenizer . eos_token_id , max_length = 100 , ) # generate text for seq in sequences : print ( f \"Result: { seq [ 'generated_text' ] } \" ) References [1] LLaMA-1 - Official Model Card | HuggingFace | Release Blog | Paper [2] Alpaca - Release Notes | HuggingFace Model | Github [3] LLaMA-2 - Release Blog | Paper [4] OpenLLaMA - Github [5] TinyLLaMA - Github | Models [6] LiteLLaMA - Models","title":"LLaMA"},{"location":"natural_language_processing/llama/#llama-1-2","text":"","title":"LLaMA - 1, 2"},{"location":"natural_language_processing/llama/#introduction","text":"In Feb 2023, Meta introduced a collection of foundation language models ranging from 7B to 65B parameters under the name of LLaMA. What makes LLaMA different from other LLMs is, It was trained on 1.4 trillion tokens created using publicly available datasets without resorting to proprietary and inaccessible datasets as done by the likes of Chinchilla, PaLM, or GPT-3. With added improvements, the resulting models are highly competitive against more powerful models. For instance, LLaMA-13B outperforms GPT-3 (175B) on most benchmarks, and LLaMA- 65B is competitive with the best models, Chinchilla-70B and PaLM-540B. Tip \u201cOfficial\u201d weights were only released to the research community and even then you need to fill out a form to request access. That said, there has been \u201cpirating\u201d of the weights that allow anyone to play around with the model. It was quite interesting, more details in this LinkedIn Post LLaMA-2 [3] was announed on July 2023 which was trained on 40% more data (~2 Trillion tokens) than LLaMA-1 and has double the context length (4096 tokens) . Learning from the social media reactions with LLaMA-1, v2 was released for both research and commerical purpose!","title":"Introduction"},{"location":"natural_language_processing/llama/#architecture-modifications","text":"To achieve the enhancements, several modifications were made to the original Transformer architecture. They are, [1] Pre-normalization [from GPT3] To improve the training stability, RMSNorm was used to normalize the input of each transformer sub-layer instead of the output. SwiGLU activation function [from PaLM]. ReLU non-linearity was replaced by the SwiGLU activation function. Rotary Embeddings [from GPTNeo] . Absolute positional embeddings were replaced with rotary positional embeddings (RoPE) at each layer of the network.","title":"Architecture Modifications"},{"location":"natural_language_processing/llama/#training-optimizations","text":"On top of architecture modifications, several optimizations were made to improve the training speed of the models. They are, [1] First, an efficient implementation of causal multi-head attention was used to reduce memory usage and runtime. (refer xformers library) To further improve training efficiency, the number of activations that are recomputed was reduced during the backward pass with checkpointing. Additional GPU optimizations were done like overlapping the computation of activations and the communication between GPUs over the network.","title":"Training Optimizations"},{"location":"natural_language_processing/llama/#dataset","text":"The dataset used to train LLaMA-1 was created using only open-source data and is a mixture of several sources, as shown below. This led to the creation of 1.4 Trillion tokens of the total dataset. [1] In LLaMA-2 the dataset size was increased to 2 Trillion tokens by including a new mix of data from publicly available sources, which does not include data from Meta\u2019s products or services. Meta removed data from certain sites known to contain a high volume of personal information about private individuals.","title":"Dataset"},{"location":"natural_language_processing/llama/#released-models","text":"For LLaMA-1, below is the list of models trained as part of the project with additional details like dimensions, attention layers and head as well as the training metrics of the learning rate, batch size and the number of tokens used for training. [1] Under LLaMA-2 only three models 7B, 13B and 70B were released.","title":"Released Models"},{"location":"natural_language_processing/llama/#inspired-models","text":"LLaMA was one of the first opensource work on making powerful LLM accessible to the public. This has inspired release of several similar models, below are some of them.","title":"Inspired Models"},{"location":"natural_language_processing/llama/#alpaca","text":"LLaMA authors observed that a very small amount of instruction-based finetuning improves the performance of the model on Massive Multitask Language Understanding Tasks (MMLU). It also further improves the ability of the model to follow instructions. That said, they didn\u2019t explore this thread further. Below you can see 5-shot MMLU performance of LLaMA-Instruct model (LLaMA-I) -- it is better than LLaMA model of the same size. [1] Enter Stanford Alpaca [2], an instruction-based finetuned LLaMA that further improves the performance of LLaMA models so much so that even 7B Alpaca model is comparable with OpenAI\u2019s text-davinci-003. Warning Alpaca team suggested that the model is better than LLaMA. There were no comparitive numbers or tables shared. The process starts with first generating 52K instruction-following samples using OpenAI's text-davinci-003. Then LLaMA model was finetuned on these data using supervised learning, basically taking inspiration from self-instruct paper. This process reduces the cost of preparing a GPT level model to under ~ $600 ( $500 to generate the data + $100 to finetune). The process is summarised below, Note The code to generate the 52k dataset along with finetuning recipe was open-sourced [2]","title":"Alpaca"},{"location":"natural_language_processing/llama/#openllama","text":"OpenLLaMA [4] is a permissively licensed open-source reproduction of Meta AI's LLaMA, providing a series of 3B, 7B, and 13B models trained on 1T tokens. OpenLLaMA was trained on the RedPajama dataset and other diverse datasets using cloud TPU-v4s with the EasyLM framework, employing data parallelism and fully sharded data parallelism to enhance efficiency. The models are available in PyTorch and JAX formats. OpenLLaMA's evaluation showcases its comparable and sometimes superior performance across various tasks to the original LLaMA and GPT-J models, reflecting its robustness and reliability. The project was quite active in 2023 with release of v2 and v3 models which was trained on mixture of Falcon refined-web dataset, the starcoder dataset, the wikipedia, arxiv, books and stackexchange from RedPajama. Below is a sample code from their Github [4], 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import torch from transformers import LlamaTokenizer , LlamaForCausalLM ## v2 models model_path = 'openlm-research/open_llama_3b_v2' # model_path = 'openlm-research/open_llama_7b_v2' ## v1 models # model_path = 'openlm-research/open_llama_3b' # model_path = 'openlm-research/open_llama_7b' # model_path = 'openlm-research/open_llama_13b' tokenizer = LlamaTokenizer . from_pretrained ( model_path ) model = LlamaForCausalLM . from_pretrained ( model_path , torch_dtype = torch . float16 , device_map = 'auto' , ) prompt = 'Q: What is the largest animal? \\n A:' input_ids = tokenizer ( prompt , return_tensors = \"pt\" ) . input_ids generation_output = model . generate ( input_ids = input_ids , max_new_tokens = 32 ) print ( tokenizer . decode ( generation_output [ 0 ]))","title":"OpenLLaMA"},{"location":"natural_language_processing/llama/#tinyllama","text":"TinyLlama is an ambitious open-source project aimed at pretraining a 1.1B parameter Llama model on 3 trillion tokens, striving for both efficiency and compactness. With the goal of completing this massive training within 90 days using 16 A100-40G GPUs, the project began its journey on September 1, 2023. TinyLlama maintains the same architecture and tokenizer as the original Llama model, ensuring compatibility and ease of integration with various existing open-source projects. What sets TinyLlama apart is its compact size, enabling it to be utilized in numerous applications that demand reduced computation and memory footprint, making it particularly suitable for deployment in resource-constrained environments. TinyLLaMA Logo [5] The training utilizes a vast dataset, combining Slimpajama and Starcoderdata to comprise approximately 950 billion tokens, with the total tokens during training reaching 3 trillion. The project is noted for its adaptability and speed, offering multiple optimizations to enhance performance, such as multi-GPU and multi-node distributed training, flash attention 2, and fused operations for LayerNorm, SwiGLU, cross entropy loss, and rotary positional embedding. The models can be found in their HuggingFace Org page . Note As mentioned above, the total dataset size was 950B but as the model was trained for approx 3 epochs the total trainable tokens are 3 Billions. Another point to note is that this model was motivated by the model training saturation details mentioned in LLaMA-2 paper. It shows every model from 70B to 7B are still not saturated even after training for 2B tokens. This approach was an extrapolation on the research by picking a much smaller model (~1B) and going much further (3B tokens) .","title":"TinyLLaMA"},{"location":"natural_language_processing/llama/#litellama","text":"LiteLlama-460M-1T [6] is a model with 460 million parameters, trained on approximately 1 trillion (0.98T) tokens. It leverages the RedPajama dataset for training and utilizes GPT2Tokenizer for text tokenization, preserving high compatibility and performance while reducing the model's size. In terms of evaluation, LiteLlama-460M-1T has been assessed on multiple datasets, but MMLU task showcase its comparative performance when compared to TinyLLaMA. The project, developed by Xiaotian Han from Texas A&M University, emphasizes the open-source ethos by making the model and training details accessible and by releasing it under the MIT License ( available here ). Note Just because LiteLLaMA works good for one task does it not mean it can replace TinyLLaMA or LLaMA-2 models completely. Make sure to perform extensive test for your usecase before selecting any model.","title":"LiteLLaMA"},{"location":"natural_language_processing/llama/#code","text":"","title":"Code"},{"location":"natural_language_processing/llama/#inference","text":"There are many ways to access LLaMA. Below are some of the most popular ones,","title":"Inference"},{"location":"natural_language_processing/llama/#huggingface","text":"HuggingFace has created the port to use the LLaMA-1 model. You can also access the crowd-uploaded model at the hub here . The code to load and use the model like any other LLM is shown below, 1 2 3 4 5 6 7 8 9 10 # install (currently LLamA is in the main branch of HF) ! pip install git + https : // github . com / huggingface / transformers . git ! pip install sentencepiece # import from transformers import LlamaForCausalLM , LlamaTokenizer # load the tokenizer and model tokenizer = LlamaTokenizer . from_pretrained ( \"decapoda-research/llama-7b-hf\" ) model = LlamaForCausalLM . from_pretrained ( \"decapoda-research/llama-7b-hf\" ) With LLaMA-2 we have the official model weights uploaded on HuggingFace from Meta. The code remains the same, we just have to modify the model name. One exmaple of the model is meta-llama/Llama-2-13b-hf , and you can find more models on the Meta LLaMA Org page .","title":"HuggingFace"},{"location":"natural_language_processing/llama/#dalai","text":"Dalai is the simplest way to run the LLaMA-1 or Alpaca models on your machine. It also provides an intuitive UI to use the model. All you need to do is, 1 2 3 4 5 6 # install model npx dalai llama install 7 B # or 13B, 30B, 65B npx dalai alpaca install 7 B # or 13B, 30B, 65B # launch web UI + socket.io API npx dalai serve And it looks good! \ud83d\udc47 Note Internally it uses C/C++ port of LLaMA and Alpaca . You can access them separately for faster execution. The respective packages have also applied quantization to provide much faster execution with some compromise on accuracy.","title":"Dalai"},{"location":"natural_language_processing/llama/#finetuning","text":"While there are multiple ways to finetune LLaMA model, we will focus on QLoRA based finetuning as this is the most efficient and fast way to create adapters on top of LLaMA for any downstream tasks. Below is the code to finetune Llama-2-7b-chat-hf model for a classification task and it can be easily modified (by changing the model name) to work for other similar models, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 ## Install packages ! pip install - q - U bitsandbytes == 0.40.0 ! pip install - q transformers == 4.30 ! pip install - q - U git + https : // github . com / huggingface / peft . git ! pip install - q datasets ! conda install cudatoolkit - y ## Import import os import time import torch import transformers import pandas as pd from tqdm import tqdm from ast import literal_eval from datasets import Dataset from sklearn.metrics import confusion_matrix , classification_report from peft import prepare_model_for_kbit_training , LoraConfig , get_peft_model from transformers import AutoTokenizer , AutoModelForCausalLM , BitsAndBytesConfig # check if GPU is available or not print ( \"CUDA available (from PyTorch) --> \" , torch . cuda . is_available ()) print ( \"GPU available --> \" , torch . cuda . get_device_name ( 0 )) ## Load Model # define model name (huggingface) model_id = \"meta-llama/Llama-2-7b-chat-hf\" # bnb config bnb_config = BitsAndBytesConfig ( load_in_4bit = True , bnb_4bit_use_double_quant = False , bnb_4bit_quant_type = \"nf4\" , bnb_4bit_compute_dtype = torch . bfloat16 ) # load tokenizer tokenizer = AutoTokenizer . from_pretrained ( model_id , use_auth_token = access_token ) tokenizer . padding_side = \"right\" tokenizer . pad_token = tokenizer . eos_token # load model model = AutoModelForCausalLM . from_pretrained ( model_id , quantization_config = bnb_config , device_map = { \"\" : 0 }, use_auth_token = access_token ) ## Prepare data # function to format the input data def format_dataset_as_instruction ( sample ): return f \"\"\"### Instruction: Classify the sales cold call into either of the following class: Busy, Follow Up, Gate Keeper, Interested, Not Interested, Wrong Number and Others. ### Input: { sample [ 'text' ] } ### Response: { sample [ 'class' ] } \"\"\" # function to prepare the dataset def prepare_data ( data = None , file_path = None , encode = True ): # load the data and prepare it if data is None : data = pd . read_csv ( file_path ) formatted_data = data . apply ( lambda x : format_dataset_as_instruction ( x ), axis = 1 ) # create HF Dataset ds = Dataset . from_pandas ( pd . DataFrame ( formatted_data , columns = [ 'text' ])) # perform tokenization if encode : perform_tokenization = lambda x : tokenizer ( x [ 'text' ], padding = True , truncation = True ) ds = ds . shuffle () . map ( perform_tokenization ) ds = ds . remove_columns ([ 'text' , 'token_type_ids' ]) # return return ds # load the complete dataset, cols = text: call transcription; class: class enum or name df = pd . read_csv ( 'data/call_disposition.csv' ) # prepare the train data train_data = prepare_data ( df . loc [ df [ 'type' ] == 'train' , [ 'class' , 'text' ]] . sample ( frac = 1 ) . reset_index ( drop = True )) # prepare the test data test_data = prepare_data ( df . loc [ df [ 'type' ] == 'test' , [ 'class' , 'text' ]] . sample ( frac = 1 ) . reset_index ( drop = True )) loc_test_data = prepare_data ( df . loc [ df [ 'type' ] == 'test' , [ 'class' , 'text' ]] . sample ( frac = 1 ) . reset_index ( drop = True ), encode = False ) # for post training testing ## Prepare for Training model . gradient_checkpointing_enable () model = prepare_model_for_kbit_training ( model ) def print_trainable_parameters ( model ): \"\"\" Prints the number of trainable parameters in the model. \"\"\" trainable_params = 0 all_param = 0 for _ , param in model . named_parameters (): all_param += param . numel () if param . requires_grad : trainable_params += param . numel () print ( f \"trainable params: { trainable_params } || all params: { all_param } || trainable%: { 100 * trainable_params / all_param } \" ) # create config config = LoraConfig ( r = 8 , lora_alpha = 32 , # target_modules=[\"query_key_value\"], lora_dropout = 0.05 , bias = \"none\" , task_type = \"CAUSAL_LM\" ) model = get_peft_model ( model , config ) print_trainable_parameters ( model ) # output: trainable params: 4194304 || all params: 3504607232 || trainable%: 0.11967971650867153 ## Start Training # needed for gpt-neo-x tokenizer tokenizer . pad_token = tokenizer . eos_token # trainer trainer = transformers . Trainer ( model = model , train_dataset = train_data , args = transformers . TrainingArguments ( per_device_train_batch_size = 2 , gradient_accumulation_steps = 4 , # num_train_epochs=2, warmup_steps = 2 , # max_steps=10, learning_rate = 2e-4 , fp16 = True , logging_steps = 1 , output_dir = \"outputs\" , optim = \"paged_adamw_8bit\" , remove_unused_columns = False ), data_collator = transformers . DataCollatorForLanguageModeling ( tokenizer , mlm = False ), ) model . config . use_cache = False # silence the warnings. Please re-enable for inference! trainer . train () # save the adapter PEFT_MODEL_PATH = \"adapters/calldisposition_v1.0.0-alpha\" model . save_pretrained ( PEFT_MODEL_PATH ) ## Loading the finetuned-model model . config . use_cache = True bnb_config = BitsAndBytesConfig ( load_in_4bit = True , bnb_4bit_use_double_quant = False , bnb_4bit_quant_type = \"nf4\" , bnb_4bit_compute_dtype = torch . bfloat16 ) config = PeftConfig . from_pretrained ( PEFT_MODEL_PATH ) loaded_model = AutoModelForCausalLM . from_pretrained ( config . base_model_name_or_path , return_dict = True , quantization_config = bnb_config , device_map = \"auto\" , trust_remote_code = True ) loaded_tokenizer = AutoTokenizer . from_pretrained ( config . base_model_name_or_path ) loaded_tokenizer . pad_token = loaded_tokenizer . eos_token loaded_tokenizer . padding_side = \"right\" loaded_model = PeftModel . from_pretrained ( loaded_model , PEFT_MODEL_PATH ) ## Inference on Loaded Model # prepare sample test data prompt selected_test_data = loc_test_data [ 'text' ][ 0 ] prompt = selected_test_data . split ( \"### Response:\" )[ 0 ] + \"### Response: \\n \" # create settings generation_config = loaded_model . generation_config generation_config . max_new_tokens = 25 generation_config . temperature = 0.7 generation_config . top_p = 0.7 generation_config . num_return_sequences = 1 generation_config . pad_token_id = loaded_tokenizer . eos_token_id generation_config . eos_token_id = loaded_tokenizer . eos_token_id # run inference device = \"cuda\" encoding = loaded_tokenizer ( prompt , return_tensors = \"pt\" ) . to ( device ) with torch . inference_mode (): outputs = loaded_model . generate ( input_ids = encoding . input_ids , attention_mask = encoding . attention_mask , generation_config = generation_config ) print ( loaded_tokenizer . decode ( outputs [ 0 ], skip_special_tokens = True )) ## Test on complete test data # save the results testing_results = [] model . config . use_cache = True # prepare sample test data prompt for selected_test_data in tqdm ( loc_test_data [ 'text' ]): latency = time . time () # create the prompt prompt = selected_test_data . split ( \"### Response:\" )[ 0 ] + \"### Response: \\n \" # create settings generation_config = loaded_model . generation_config generation_config . max_new_tokens = 25 generation_config . temperature = 0 generation_config . top_p = 0.7 generation_config . num_return_sequences = 1 generation_config . pad_token_id = loaded_tokenizer . eos_token_id generation_config . eos_token_id = loaded_tokenizer . eos_token_id # tun inference device = \"cuda\" encoding = loaded_tokenizer ( prompt , return_tensors = \"pt\" ) . to ( device ) with torch . inference_mode (): outputs = loaded_model . generate ( input_ids = encoding . input_ids , attention_mask = encoding . attention_mask , generation_config = generation_config ) original_class = get_response ( selected_test_data ) predicted_class = get_response ( loaded_tokenizer . decode ( outputs [ 0 ], skip_special_tokens = True )) flag_matched = predicted_class == original_class testing_results . append ({ 'original_class' : original_class , 'predicted_class' : predicted_class , 'match' : flag_matched , 'text' : selected_test_data , 'time' : time . time () - latency }) # transform to pandas dataframe testing_results = pd . DataFrame ( testing_results ) ## Generate Test Report (Classification) # Calculate overall accuracy overall_accuracy = testing_results [ 'match' ] . mean () print ( f \"Overall Accuracy: { overall_accuracy : .2f } \" ) # Class-wise accuracy class_accuracy = testing_results . groupby ( 'original_class' )[ 'match' ] . mean () print ( \" \\n Class-wise Accuracy:\" ) print ( class_accuracy ) # Confusion Matrix labels = testing_results [ 'original_class' ] . unique () cm = confusion_matrix ( testing_results [ 'original_class' ], testing_results [ 'predicted_class' ], labels = labels ) print ( \" \\n Confusion Matrix:\" ) print ( cm ) # Classification Report for precision, recall, F1-score report = classification_report ( testing_results [ 'original_class' ], testing_results [ 'predicted_class' ], labels = labels ) print ( \" \\n Classification Report:\" ) print ( report ) Hint If you are getting this or similar error -- No libcudart.so found! Install CUDA or the cudatoolkit package (anaconda)! due to bitsandbytes pacakge, you can fix it by running following code on your system after installing the packages. But make sure to check of the following path and files are available or not. 1 2 3 4 ## Set env var os . environ [ \"LD_LIBRARY_PATH\" ] = \"/usr/lib/x86_64-linux-gnu/:/opt/conda/lib/\" ## ! cp / opt / conda / lib / python3 .11 / site - packages / bitsandbytes / libbitsandbytes_cuda122 . so / opt / conda / lib / python3 .11 / site - packages / bitsandbytes / libbitsandbytes_cpu . so Hint If you want to perform normal inference after loading the model at `line 44`` above, you can use the following code, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # load pipeline pipeline = transformers . pipeline ( \"text-generation\" , model = model , torch_dtype = torch . float16 , device_map = \"auto\" , tokenizer = tokenizer ) # run inference sequences = pipeline ( 'Answer the following question: Who is the current Prime Minster of India? \\n Answer:' , do_sample = True , top_k = 10 , num_return_sequences = 1 , eos_token_id = tokenizer . eos_token_id , max_length = 100 , ) # generate text for seq in sequences : print ( f \"Result: { seq [ 'generated_text' ] } \" )","title":"Finetuning"},{"location":"natural_language_processing/llama/#references","text":"[1] LLaMA-1 - Official Model Card | HuggingFace | Release Blog | Paper [2] Alpaca - Release Notes | HuggingFace Model | Github [3] LLaMA-2 - Release Blog | Paper [4] OpenLLaMA - Github [5] TinyLLaMA - Github | Models [6] LiteLLaMA - Models","title":"References"},{"location":"natural_language_processing/lstm_gru_rnn/","text":"LSTM, GRU and RNN Introduction LSTM, GRU or RNN are a type of recurrent layers. They were the state-of-the-art neural network models for text related applications before the transformers based models. They can be used to process any sequential data like timeseries, text, audio, etc. RNN is the simpler of the lot, where as LSTM and GRU are the \"gated\" (and so a little complex) version of RNN. These gates helps LSTM and GRU to mitigate some of the problems of RNN like exploding gradient. The most basic unit in these layers is a \"cell\", which is repeated in a layer - equal to the number of token size. For example, if we want to process a text with 150 words (with word level tokenization), we need to perceptually attach 150 cells one after the another. Hence, each cell process one word and passes on the representation of the word (hidden state value) to the next cell in line. Starting with RNN, the flow of data and hidden state inside the RNN cell is shown below. Cell of RNN layer. ( practical_guide_to_rnn_and_lstm ) As shown in the figure, x^t is the input token at time t , h^{t-1} is the hidden state output from the last step, y^t and h^t are two notations for the hidden state output of time t . The formulation of an RNN cell is as follow, \\[ h^{t}=g\\left(W_{h h} h^{t-1}+W_{h x} x^{t}+b_{h}\\right) \\\\ y^{t}=h^{t} \\] LSTM cells on the other hand is more complicated and is shown below. LSTM cell. ( lstm_understanding ) Note Python libraries take liberty in modifying the architecture of the RNN and LSTM cells. For more details about how these cells are implemented in Keras, check out ( practical_guide_to_rnn_and_lstm ). Finally, a GRU cell looks as follow, GRU cell with formulae. ( lstm_understanding ) While RNN is the most basic recurrent layer, LSTM and GRU are the de facto baseline for any text related application. There are lots of debate over which one is better, but the answer is usually fuzzy and it all comes down to the data and use case. In terms of tunable parameter size the order is as follow - RNN < GRU < LSTM . That said, in terms of learing power the order is - RNN < GRU = LSTM . Go for GRU if you want to reduce the tunable parameters but keep the learning power relatively similar. That said, do not forget to experiment wth LSTM, as it may suprise you once in a while. Code Using BiLSTM (for regression) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \"\"\"Sample code for recurrent layer based models \"\"\" # ---- Imports ---- import keras from keras.preprocessing.text import Tokenizer from keras.preprocessing.sequence import pad_sequences from keras.models import Sequential from keras.layers import Dense , Dropout , LSTM , Bidirectional , Embedding # ---- Data loading ---- # contains a list or series of sentences # train = ... # test = ... # combined = train['text'] + test['text'] # ---- Data processing ---- # set max vocab size vocab = 10000 # create tokenizer instances tokenizer = Tokenizer ( num_words = vocab , oov_token = 0 ) # fit the tokenizer on text sequences tokenizer . fit_on_texts ( combined ) # tokenize the complete data sequence_combined = tokenizer . texts_to_sequences ( combined ) # get the max len max_len = max ([ len ( x ) for x in sequence_combined ]) # tokenize the train data train_sequences = tokenizer . texts_to_sequences ( train [ 'text' ]) # add padding to the data padded_train_sequence = pad_sequences ( train_sequences , maxlen = max_len , dtype = 'int32' , padding = 'pre' , truncating = 'pre' , value = 0 ) # ---- Model ---- model = Sequential () # encoder model . add ( keras . Input ( shape = ( padded_train_sequence . shape [ 1 ], ))) # input layer model . add ( Embedding ( vocab , 256 )) # embedding layer model . add ( Bidirectional ( LSTM ( 256 ))) # biLSTM layer # decoder model . add ( Dense ( 256 , kernel_initializer = 'normal' , activation = 'relu' )) model . add ( Dense ( 1 , activation = 'linear' )) # summary model . summary () # ---- Compile and Train ---- # callbacks earlystopping = keras . callbacks . EarlyStopping ( monitor = 'loss' , patience = 3 ) # compile model . compile ( loss = 'mse' , optimizer = 'adam' , metrics = [ 'mse' , 'mae' ]) # fit history = model . fit ( padded_train_sequence , train [ 'y' ], epochs = 100 , batch_size = 16 , verbose = 2 , callbacks = [ earlystopping ]) # ---- Prediction ---- # prepare testing data test_sequences = tokenizer . texts_to_sequences ( test [ 'text' ]) test_padded_sequences = pad_sequences ( test_sequences , maxlen = max_len , dtype = 'int32' , padding = 'pre' , truncating = 'pre' , value = 0 ) # perform prediction y_pred = model . predict ( test_padded_sequences ) Additional materials A practical guide to RNN and LSTM in Keras ( practical_guide_to_rnn_and_lstm ) Guide to Custom Recurrent Modeling in Keras ( Guide_to_custom_recurrent_modeling ) Understanding LSTM Networks ( lstm_understanding )","title":"LSTM, GRU & RNN"},{"location":"natural_language_processing/lstm_gru_rnn/#lstm-gru-and-rnn","text":"","title":"LSTM, GRU and RNN"},{"location":"natural_language_processing/lstm_gru_rnn/#introduction","text":"LSTM, GRU or RNN are a type of recurrent layers. They were the state-of-the-art neural network models for text related applications before the transformers based models. They can be used to process any sequential data like timeseries, text, audio, etc. RNN is the simpler of the lot, where as LSTM and GRU are the \"gated\" (and so a little complex) version of RNN. These gates helps LSTM and GRU to mitigate some of the problems of RNN like exploding gradient. The most basic unit in these layers is a \"cell\", which is repeated in a layer - equal to the number of token size. For example, if we want to process a text with 150 words (with word level tokenization), we need to perceptually attach 150 cells one after the another. Hence, each cell process one word and passes on the representation of the word (hidden state value) to the next cell in line. Starting with RNN, the flow of data and hidden state inside the RNN cell is shown below. Cell of RNN layer. ( practical_guide_to_rnn_and_lstm ) As shown in the figure, x^t is the input token at time t , h^{t-1} is the hidden state output from the last step, y^t and h^t are two notations for the hidden state output of time t . The formulation of an RNN cell is as follow, \\[ h^{t}=g\\left(W_{h h} h^{t-1}+W_{h x} x^{t}+b_{h}\\right) \\\\ y^{t}=h^{t} \\] LSTM cells on the other hand is more complicated and is shown below. LSTM cell. ( lstm_understanding ) Note Python libraries take liberty in modifying the architecture of the RNN and LSTM cells. For more details about how these cells are implemented in Keras, check out ( practical_guide_to_rnn_and_lstm ). Finally, a GRU cell looks as follow, GRU cell with formulae. ( lstm_understanding ) While RNN is the most basic recurrent layer, LSTM and GRU are the de facto baseline for any text related application. There are lots of debate over which one is better, but the answer is usually fuzzy and it all comes down to the data and use case. In terms of tunable parameter size the order is as follow - RNN < GRU < LSTM . That said, in terms of learing power the order is - RNN < GRU = LSTM . Go for GRU if you want to reduce the tunable parameters but keep the learning power relatively similar. That said, do not forget to experiment wth LSTM, as it may suprise you once in a while.","title":"Introduction"},{"location":"natural_language_processing/lstm_gru_rnn/#code","text":"","title":"Code"},{"location":"natural_language_processing/lstm_gru_rnn/#using-bilstm-for-regression","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \"\"\"Sample code for recurrent layer based models \"\"\" # ---- Imports ---- import keras from keras.preprocessing.text import Tokenizer from keras.preprocessing.sequence import pad_sequences from keras.models import Sequential from keras.layers import Dense , Dropout , LSTM , Bidirectional , Embedding # ---- Data loading ---- # contains a list or series of sentences # train = ... # test = ... # combined = train['text'] + test['text'] # ---- Data processing ---- # set max vocab size vocab = 10000 # create tokenizer instances tokenizer = Tokenizer ( num_words = vocab , oov_token = 0 ) # fit the tokenizer on text sequences tokenizer . fit_on_texts ( combined ) # tokenize the complete data sequence_combined = tokenizer . texts_to_sequences ( combined ) # get the max len max_len = max ([ len ( x ) for x in sequence_combined ]) # tokenize the train data train_sequences = tokenizer . texts_to_sequences ( train [ 'text' ]) # add padding to the data padded_train_sequence = pad_sequences ( train_sequences , maxlen = max_len , dtype = 'int32' , padding = 'pre' , truncating = 'pre' , value = 0 ) # ---- Model ---- model = Sequential () # encoder model . add ( keras . Input ( shape = ( padded_train_sequence . shape [ 1 ], ))) # input layer model . add ( Embedding ( vocab , 256 )) # embedding layer model . add ( Bidirectional ( LSTM ( 256 ))) # biLSTM layer # decoder model . add ( Dense ( 256 , kernel_initializer = 'normal' , activation = 'relu' )) model . add ( Dense ( 1 , activation = 'linear' )) # summary model . summary () # ---- Compile and Train ---- # callbacks earlystopping = keras . callbacks . EarlyStopping ( monitor = 'loss' , patience = 3 ) # compile model . compile ( loss = 'mse' , optimizer = 'adam' , metrics = [ 'mse' , 'mae' ]) # fit history = model . fit ( padded_train_sequence , train [ 'y' ], epochs = 100 , batch_size = 16 , verbose = 2 , callbacks = [ earlystopping ]) # ---- Prediction ---- # prepare testing data test_sequences = tokenizer . texts_to_sequences ( test [ 'text' ]) test_padded_sequences = pad_sequences ( test_sequences , maxlen = max_len , dtype = 'int32' , padding = 'pre' , truncating = 'pre' , value = 0 ) # perform prediction y_pred = model . predict ( test_padded_sequences )","title":"Using BiLSTM (for regression)"},{"location":"natural_language_processing/lstm_gru_rnn/#additional-materials","text":"A practical guide to RNN and LSTM in Keras ( practical_guide_to_rnn_and_lstm ) Guide to Custom Recurrent Modeling in Keras ( Guide_to_custom_recurrent_modeling ) Understanding LSTM Networks ( lstm_understanding )","title":"Additional materials"},{"location":"natural_language_processing/making_llm_multilingual/","text":"Making LLM Multi-lingual Introduction Current Large Language Models (LLMs) show impressive linguistic capabilities but are predominantly skewed towards English, limiting their effectiveness in truly multilingual contexts. To bridge this gap, initiatives like OpenHathi's adaptation of LLaMa-2 are pivotal, aiming to create genuinely multilingual (or bilingual in OpenHathi's case) models that can process and understand multiple languages with equal proficiency. This article delves into why and how we should move towards multilingual LLMs, expanding the horizons of AI's linguistic abilities. Challenges Creating a multilingual model presents various challenges. Firstly, there is the issue of data imbalance, where languages like English dominate available datasets, while others are underrepresented. Another challenge is linguistic diversity; languages vary significantly in syntax, semantics, and structure, requiring models to adapt to a wide range of linguistic rules. Additionally, cultural nuances and contextual understanding are vital for accuracy in translation and comprehension, further complicating the task. These challenges necessitate innovative approaches to model training and architecture. Examples OpenHathi for Hindi Sarvam.ai announced the OpenHathi series of work to encourage innovation in Indian language AI. This was built under a partnership with AI4Bharat (academic partners) who contributed language resources and benchmarks. Below are the highlights of their process of finetuning existing LLaMa-2 (to create a base model) into a bilingual LLM: Modifying the Tokenizer: A custom tokenizer was developed to handle Hindi text efficiently by integrating new tokens into the LLaMa-2's embedding layer. This modification was crucial for accurately processing and representing Hindi language nuances within the model. This also substantially reduced the overall token consumptions for inference and training (sometimes even 4x!) . Reduction in token consumpting by token modification done for OpenHathi for Hindi text Dataset: They used multiple approaches to procure Hindi content like using the Sangraha corpus or scraping existing Hindi articles from Wikipedia (~150k) or translate English articles to Hindi using AI4Bharat's IndicTrans2 model . This diverse dataset enabled effective bilingual next-token prediction training, a key step for the model's bilingual capabilities. Training Process: The model underwent a specialized bilingual language modeling process, where sentences alternated between Hindi and English. This method was instrumental in enhancing the model's ability to understand and align both languages effectively. The hypothesis here was that by alternating different language sentences, Hindi words from one sentence will attend to English words from previous sentence, overall helping in world knowledge building for Hindi tokens. Bilingual training is more efficient than only monolingual training, even if we use 5x more data! Trained a PEFT Adapter: They used a low-rank adapter (LoRA) throughout the process of training to enhance the training and inference efficienly. Finally the trained base model was finetuned for different downstream usecases and its performance was better than GPT-3.5 for some Hindi content oriented tasks like content moderation or writing in Hindi. On top of it, the token consumption was substantially less due to modified tokenizer. This makes OpenHathi the go-to AI model for Hindi or Romanised Hindi (Hinglish) tasks. Tamil-LLaMa for Tamil Another example is Tamil-LLaMA [2] which was created by Abhinand Balachandran , wherein he released 7B and 13B models. Here are the finer details, Modifying the Tokenizer : The open-source LLaMA 2 model was modified with 16,000 new Tamil tokens, aiming to achieve superior text generation and comprehension in Tamil. This lead to new model only requiring 20%-25% of the tokens for Tamil text generation when compared to original LLaMA tokeniser. Datasets : For the initial pre-training phase of LLaMA 2, author used the CulturaX dataset which is a combination of many popular datasets. To manage high cost, only 600k documents (out of the 4.72 million documents in CulturaX) were used. For Instruction finetuning, a translated version of the Stanford Alpaca dataset comprising 52,000 instructions was used. Concurrently, author also integrated a specialized no-code section from the OpenOrca dataset, which consists of around 93,000 instructions. Note, Google Translation API service was used for all translation purpose. Trained a PEFT Adapter: The LoRA methodology was strategically employed for efficient model training on a comprehensive Tamil corpus, ensuring computational feasibility and model robustness. Here are the finer details on the data used for indiviudal training step. Training details of Tamil-LLaMa [2] Reference [1] OpenHathi Series Release Notes [2] \u0ba4\u0bae\u0bbf\u0bb4\u0bcd Llama - Article | Paper","title":"Making LLM Multi-lingual"},{"location":"natural_language_processing/making_llm_multilingual/#making-llm-multi-lingual","text":"","title":"Making LLM Multi-lingual"},{"location":"natural_language_processing/making_llm_multilingual/#introduction","text":"Current Large Language Models (LLMs) show impressive linguistic capabilities but are predominantly skewed towards English, limiting their effectiveness in truly multilingual contexts. To bridge this gap, initiatives like OpenHathi's adaptation of LLaMa-2 are pivotal, aiming to create genuinely multilingual (or bilingual in OpenHathi's case) models that can process and understand multiple languages with equal proficiency. This article delves into why and how we should move towards multilingual LLMs, expanding the horizons of AI's linguistic abilities.","title":"Introduction"},{"location":"natural_language_processing/making_llm_multilingual/#challenges","text":"Creating a multilingual model presents various challenges. Firstly, there is the issue of data imbalance, where languages like English dominate available datasets, while others are underrepresented. Another challenge is linguistic diversity; languages vary significantly in syntax, semantics, and structure, requiring models to adapt to a wide range of linguistic rules. Additionally, cultural nuances and contextual understanding are vital for accuracy in translation and comprehension, further complicating the task. These challenges necessitate innovative approaches to model training and architecture.","title":"Challenges"},{"location":"natural_language_processing/making_llm_multilingual/#examples","text":"","title":"Examples"},{"location":"natural_language_processing/making_llm_multilingual/#openhathi-for-hindi","text":"Sarvam.ai announced the OpenHathi series of work to encourage innovation in Indian language AI. This was built under a partnership with AI4Bharat (academic partners) who contributed language resources and benchmarks. Below are the highlights of their process of finetuning existing LLaMa-2 (to create a base model) into a bilingual LLM: Modifying the Tokenizer: A custom tokenizer was developed to handle Hindi text efficiently by integrating new tokens into the LLaMa-2's embedding layer. This modification was crucial for accurately processing and representing Hindi language nuances within the model. This also substantially reduced the overall token consumptions for inference and training (sometimes even 4x!) . Reduction in token consumpting by token modification done for OpenHathi for Hindi text Dataset: They used multiple approaches to procure Hindi content like using the Sangraha corpus or scraping existing Hindi articles from Wikipedia (~150k) or translate English articles to Hindi using AI4Bharat's IndicTrans2 model . This diverse dataset enabled effective bilingual next-token prediction training, a key step for the model's bilingual capabilities. Training Process: The model underwent a specialized bilingual language modeling process, where sentences alternated between Hindi and English. This method was instrumental in enhancing the model's ability to understand and align both languages effectively. The hypothesis here was that by alternating different language sentences, Hindi words from one sentence will attend to English words from previous sentence, overall helping in world knowledge building for Hindi tokens. Bilingual training is more efficient than only monolingual training, even if we use 5x more data! Trained a PEFT Adapter: They used a low-rank adapter (LoRA) throughout the process of training to enhance the training and inference efficienly. Finally the trained base model was finetuned for different downstream usecases and its performance was better than GPT-3.5 for some Hindi content oriented tasks like content moderation or writing in Hindi. On top of it, the token consumption was substantially less due to modified tokenizer. This makes OpenHathi the go-to AI model for Hindi or Romanised Hindi (Hinglish) tasks.","title":"OpenHathi for Hindi"},{"location":"natural_language_processing/making_llm_multilingual/#tamil-llama-for-tamil","text":"Another example is Tamil-LLaMA [2] which was created by Abhinand Balachandran , wherein he released 7B and 13B models. Here are the finer details, Modifying the Tokenizer : The open-source LLaMA 2 model was modified with 16,000 new Tamil tokens, aiming to achieve superior text generation and comprehension in Tamil. This lead to new model only requiring 20%-25% of the tokens for Tamil text generation when compared to original LLaMA tokeniser. Datasets : For the initial pre-training phase of LLaMA 2, author used the CulturaX dataset which is a combination of many popular datasets. To manage high cost, only 600k documents (out of the 4.72 million documents in CulturaX) were used. For Instruction finetuning, a translated version of the Stanford Alpaca dataset comprising 52,000 instructions was used. Concurrently, author also integrated a specialized no-code section from the OpenOrca dataset, which consists of around 93,000 instructions. Note, Google Translation API service was used for all translation purpose. Trained a PEFT Adapter: The LoRA methodology was strategically employed for efficient model training on a comprehensive Tamil corpus, ensuring computational feasibility and model robustness. Here are the finer details on the data used for indiviudal training step. Training details of Tamil-LLaMa [2]","title":"Tamil-LLaMa for Tamil"},{"location":"natural_language_processing/making_llm_multilingual/#reference","text":"[1] OpenHathi Series Release Notes [2] \u0ba4\u0bae\u0bbf\u0bb4\u0bcd Llama - Article | Paper","title":"Reference"},{"location":"natural_language_processing/mamba/","text":"Introduction Mamba is a new architecture designed to address a longstanding challenge in sequence modeling: the trade-off between efficiency and accuracy. Sequence modeling tasks involve analyzing ordered sequences of data, such as text, audio, or video. These sequences can vary greatly in length, and processing them effectively requires models that are both powerful and computationally efficient. Traditionally, recurrent neural networks (RNNs) were the go-to architecture for sequence modeling. However, RNNs suffer from limitations, like they struggle to capture long-range dependencies between elements in the sequence. This leads to accuracy problems. Transformers emerged as a powerful alternative to RNNs, addressing some of their shortcomings. Transformers employ an attention mechanism that allows them to focus on specific parts of the sequence, improving their ability to capture long-range dependencies. However, Transformers come with their own drawbacks as they can be computationally expensive and memory-intensive, especially for very long sequences. Mamba builds upon State Space Models (SSMs), a less common type of architecture for sequence modeling. SSMs offer advantages in terms of speed and memory usage compared to Transformers. However, they haven't been able to match the accuracy of Transformers on various tasks. Mamba addresses this accuracy gap by introducing several innovations to SSMs, making them competitive with Transformers while retaining their efficiency benefits. State Space Models (SSMs) View of a continuous, time-invariant SSM (Source: https://en.wikipedia.org/wiki/State-space_representation) [3] In working, SSMs are quite similar to RNN as they are a type of architecture specifically designed for sequence modeling tasks. They work in a step-by-step fashion, iteratively processing each element (token) in a sequence. At each step, SSMs consider two pieces of information: The previous token's hidden state: This hidden state represents a compressed representation of all the information processed so far in the sequence. It captures the context of the sequence up to the current token. The current input token's embedding: An embedding is a dense vector representation of the token. It encodes the meaning of the individual token within a specific vocabulary. By combining these two pieces of information, SSMs can learn how the current token relates to the preceding tokens in the sequence. This allows the model to build up a deeper understanding of the sequence as it processes it element by element. As part of core components, SSMs rely on four sets of matrices and parameters ( \\(\\text{Delta}\\) , \\(A\\) , \\(B\\) , and \\(C\\) ) to handle the input sequence. Each matrix plays a specific role in transforming and combining information during the processing steps: \\(\\text{Delta}\\) ( \\(\\Delta\\) ): This parameter controls the discretization step, which is necessary because SSMs are derived from continuous differential equations. \\(A\\) and \\(B\\) : These matrices determine how much information is propagated from the previous hidden state and the current input embedding to the new hidden state, respectively. \\(C\\) : This matrix transforms the final hidden state into an output representation that can be used for various tasks. Here's a breakdown of the processing steps within SSMs: Discretization Step: A crucial step in SSMs involves modifying the \\(A\\) and \\(B\\) matrices using a specific formula based on the \\(\\text{Delta}\\) parameter. This discretization step is necessary because SSMs are derived from continuous differential equations. The mathematical conversion from continuous to discrete form requires adjusting these matrices to account for the change in how information is processed. In simpler terms, discretization essentially chops up the continuous flow of information into discrete chunks that the model can handle more efficiently. \\[ \\overline{A} = \\exp(\\Delta A); \\overline{B} = (\\Delta A)^{-1} (\\exp(\\Delta A) - I) \\cdot \\Delta B \\] Linear RNN-like Processing: Similar to recurrent neural networks (RNNs), SSMs process tokens one by one. At each step, they use a linear combination of the previous hidden state and the current input embedding to compute a new hidden state. This hidden state captures the essential information about the sequence seen so far. Unlike traditional RNNs, which can struggle with vanishing or exploding gradients in long sequences, SSMs are designed to address these issues and can handle longer sequences more effectively. Final Representation: The final representation for each token is obtained by multiplying the hidden state with another matrix (C). This final representation can then be used for various tasks, such as predicting the next word in a sequence or classifying a DNA sequence. While SSMs offer advantages in terms of speed and memory efficiency, particularly when dealing with long sequences, their inflexibility in processing inputs limits their accuracy. Unlike Transformers that can selectively focus on important parts of the sequence using attention mechanisms, regular SSMs treat all tokens equally. This can hinder their ability to capture complex relationships within the sequence data. Selective State Space Models (SSSMs) Mamba builds upon SSMs by introducing Selective SSMs. This innovation allows the model to prioritize specific elements within the sequence. Imagine selectively focusing on important words in a sentence while processing it. Regular SSMs apply the same processing logic (read same \\(\\text{Delta}\\) , \\(A\\) , \\(B\\) and \\(C\\) ) to every element, while Selective SSMs can learn to pay closer attention to crucial parts of the sequence. Source: [1] Selective SSMs achieve this selective focus by dynamically adjusting the processing based on the current element. They employ additional trainable parameters that determine how much weight to assign to each element in the sequence. This weighting mechanism can be thought of as an attention mechanism, similar to what is found in Transformers. However, unlike Transformers, which rely on computationally expensive self-attention calculations, Selective SSMs achieve a similar effect through a more efficient linear operation. Here's a deeper dive into how Selective SSMs work: Linear Layers: Separate linear layers are introduced to compute these element-wise weights. Each element in the sequence is passed through a dedicated linear layer, resulting in a weight specific to that element. Weighting: The calculated weights are then used to modulate the influence of each element on the hidden state. Elements deemed more important by the model will have a greater impact on how the hidden state evolves. Learning the Importance: Through the training process, the model learns to identify the elements that are most informative for the task at hand. This allows the model to focus its processing power on the crucial parts of the sequence, while efficiently handling less important elements. Mamba's Architecture A Mamba layer consists of several components that work together to achieve efficient and accurate sequence modeling: Source: [1] Increased Dimensionality: The input is first projected to a higher dimensional space using a linear layer. This increases the network's capacity to learn complex relationships between elements in the sequence. A higher dimensional space allows for more intricate feature representations, enabling the model to capture richer information from the data. Convolution Layer: This layer facilitates information flow between different dimensions within the higher-dimensional space. Convolutional operations are adept at capturing local patterns and dependencies between elements. In the context of Mamba, the convolution layer helps the model identify how nearby elements in the sequence relate to each other and influence the hidden state. Selective SSM Module: This core component processes the sequence using the Selective SSM approach described earlier. The selective SSM module dynamically computes weights for each element, allowing the model to focus on the most informative parts of the sequence. This selective processing contributes to Mamba's efficiency, particularly for long sequences. Gated Multiplication: This step modulates the influence of the current element on the hidden state based on its similarity to the hidden state itself. A gating mechanism essentially controls the flow of information. In Mamba, the gated multiplication amplifies the impact of elements that are similar to the current state of the model's understanding of the sequence, while reducing the influence of elements that are dissimilar. This helps the model refine its understanding of the sequence in a targeted manner. Dimensionality Reduction: The final output of a Mamba layer is projected back to the original dimension using another linear layer. This reduces the dimensionality of the representation to a more manageable size for subsequent layers in the network architecture. Mamba's Impact and Results Mamba demonstrates promising results, particularly for long sequences: Speed: Mamba achieves super fast speed which becomes even better with increase in sequence length and batch sizes. Source: [1] Performance: Mamba outperforms Transformers based models (even 2x bigger ones!) on various tasks. Source: [1] Source: [1] Hint As Mamba performs quite well on long sequences (evident from its performance on DNA dataset) , there is an interesting space of work in MambaByte [4] which is a token-free adaptation of the Mamba SSM trained auto-regressively on byte sequences. This model is able to achieve state-of-the-art performance on byte-level language modeling tasks. Conclusion Mamba's emergence demonstrates the continuous evolution of deep learning architectures. With its focus on speed, memory efficiency, and scalability for long sequences, Mamba offers a compelling alternative to Transformers and paves the way for further exploration in sequence modeling techniques. That said, Mamba is a relatively new architecture, and further research is needed to fully understand its capabilities compared to Transformers. Nevertheless, Mamba's innovative approach to sequence modeling holds promise for a wide range of applications, particularly those involving long sequences of data. References [1] Original Paper - Mamba: Linear-Time Sequence Modeling with Selective State Spaces [2] Video by AI Coffee Break with Letitia -- MAMBA and State Space Models explained | SSM explained [3] Introduction to State Space Models (SSM) [4] Paper - MambaByte: Token-free Selective State Space Model","title":"Mamba"},{"location":"natural_language_processing/mamba/#introduction","text":"Mamba is a new architecture designed to address a longstanding challenge in sequence modeling: the trade-off between efficiency and accuracy. Sequence modeling tasks involve analyzing ordered sequences of data, such as text, audio, or video. These sequences can vary greatly in length, and processing them effectively requires models that are both powerful and computationally efficient. Traditionally, recurrent neural networks (RNNs) were the go-to architecture for sequence modeling. However, RNNs suffer from limitations, like they struggle to capture long-range dependencies between elements in the sequence. This leads to accuracy problems. Transformers emerged as a powerful alternative to RNNs, addressing some of their shortcomings. Transformers employ an attention mechanism that allows them to focus on specific parts of the sequence, improving their ability to capture long-range dependencies. However, Transformers come with their own drawbacks as they can be computationally expensive and memory-intensive, especially for very long sequences. Mamba builds upon State Space Models (SSMs), a less common type of architecture for sequence modeling. SSMs offer advantages in terms of speed and memory usage compared to Transformers. However, they haven't been able to match the accuracy of Transformers on various tasks. Mamba addresses this accuracy gap by introducing several innovations to SSMs, making them competitive with Transformers while retaining their efficiency benefits.","title":"Introduction"},{"location":"natural_language_processing/mamba/#state-space-models-ssms","text":"View of a continuous, time-invariant SSM (Source: https://en.wikipedia.org/wiki/State-space_representation) [3] In working, SSMs are quite similar to RNN as they are a type of architecture specifically designed for sequence modeling tasks. They work in a step-by-step fashion, iteratively processing each element (token) in a sequence. At each step, SSMs consider two pieces of information: The previous token's hidden state: This hidden state represents a compressed representation of all the information processed so far in the sequence. It captures the context of the sequence up to the current token. The current input token's embedding: An embedding is a dense vector representation of the token. It encodes the meaning of the individual token within a specific vocabulary. By combining these two pieces of information, SSMs can learn how the current token relates to the preceding tokens in the sequence. This allows the model to build up a deeper understanding of the sequence as it processes it element by element. As part of core components, SSMs rely on four sets of matrices and parameters ( \\(\\text{Delta}\\) , \\(A\\) , \\(B\\) , and \\(C\\) ) to handle the input sequence. Each matrix plays a specific role in transforming and combining information during the processing steps: \\(\\text{Delta}\\) ( \\(\\Delta\\) ): This parameter controls the discretization step, which is necessary because SSMs are derived from continuous differential equations. \\(A\\) and \\(B\\) : These matrices determine how much information is propagated from the previous hidden state and the current input embedding to the new hidden state, respectively. \\(C\\) : This matrix transforms the final hidden state into an output representation that can be used for various tasks. Here's a breakdown of the processing steps within SSMs: Discretization Step: A crucial step in SSMs involves modifying the \\(A\\) and \\(B\\) matrices using a specific formula based on the \\(\\text{Delta}\\) parameter. This discretization step is necessary because SSMs are derived from continuous differential equations. The mathematical conversion from continuous to discrete form requires adjusting these matrices to account for the change in how information is processed. In simpler terms, discretization essentially chops up the continuous flow of information into discrete chunks that the model can handle more efficiently. \\[ \\overline{A} = \\exp(\\Delta A); \\overline{B} = (\\Delta A)^{-1} (\\exp(\\Delta A) - I) \\cdot \\Delta B \\] Linear RNN-like Processing: Similar to recurrent neural networks (RNNs), SSMs process tokens one by one. At each step, they use a linear combination of the previous hidden state and the current input embedding to compute a new hidden state. This hidden state captures the essential information about the sequence seen so far. Unlike traditional RNNs, which can struggle with vanishing or exploding gradients in long sequences, SSMs are designed to address these issues and can handle longer sequences more effectively. Final Representation: The final representation for each token is obtained by multiplying the hidden state with another matrix (C). This final representation can then be used for various tasks, such as predicting the next word in a sequence or classifying a DNA sequence. While SSMs offer advantages in terms of speed and memory efficiency, particularly when dealing with long sequences, their inflexibility in processing inputs limits their accuracy. Unlike Transformers that can selectively focus on important parts of the sequence using attention mechanisms, regular SSMs treat all tokens equally. This can hinder their ability to capture complex relationships within the sequence data.","title":"State Space Models (SSMs)"},{"location":"natural_language_processing/mamba/#selective-state-space-models-sssms","text":"Mamba builds upon SSMs by introducing Selective SSMs. This innovation allows the model to prioritize specific elements within the sequence. Imagine selectively focusing on important words in a sentence while processing it. Regular SSMs apply the same processing logic (read same \\(\\text{Delta}\\) , \\(A\\) , \\(B\\) and \\(C\\) ) to every element, while Selective SSMs can learn to pay closer attention to crucial parts of the sequence. Source: [1] Selective SSMs achieve this selective focus by dynamically adjusting the processing based on the current element. They employ additional trainable parameters that determine how much weight to assign to each element in the sequence. This weighting mechanism can be thought of as an attention mechanism, similar to what is found in Transformers. However, unlike Transformers, which rely on computationally expensive self-attention calculations, Selective SSMs achieve a similar effect through a more efficient linear operation. Here's a deeper dive into how Selective SSMs work: Linear Layers: Separate linear layers are introduced to compute these element-wise weights. Each element in the sequence is passed through a dedicated linear layer, resulting in a weight specific to that element. Weighting: The calculated weights are then used to modulate the influence of each element on the hidden state. Elements deemed more important by the model will have a greater impact on how the hidden state evolves. Learning the Importance: Through the training process, the model learns to identify the elements that are most informative for the task at hand. This allows the model to focus its processing power on the crucial parts of the sequence, while efficiently handling less important elements.","title":"Selective State Space Models (SSSMs)"},{"location":"natural_language_processing/mamba/#mambas-architecture","text":"A Mamba layer consists of several components that work together to achieve efficient and accurate sequence modeling: Source: [1] Increased Dimensionality: The input is first projected to a higher dimensional space using a linear layer. This increases the network's capacity to learn complex relationships between elements in the sequence. A higher dimensional space allows for more intricate feature representations, enabling the model to capture richer information from the data. Convolution Layer: This layer facilitates information flow between different dimensions within the higher-dimensional space. Convolutional operations are adept at capturing local patterns and dependencies between elements. In the context of Mamba, the convolution layer helps the model identify how nearby elements in the sequence relate to each other and influence the hidden state. Selective SSM Module: This core component processes the sequence using the Selective SSM approach described earlier. The selective SSM module dynamically computes weights for each element, allowing the model to focus on the most informative parts of the sequence. This selective processing contributes to Mamba's efficiency, particularly for long sequences. Gated Multiplication: This step modulates the influence of the current element on the hidden state based on its similarity to the hidden state itself. A gating mechanism essentially controls the flow of information. In Mamba, the gated multiplication amplifies the impact of elements that are similar to the current state of the model's understanding of the sequence, while reducing the influence of elements that are dissimilar. This helps the model refine its understanding of the sequence in a targeted manner. Dimensionality Reduction: The final output of a Mamba layer is projected back to the original dimension using another linear layer. This reduces the dimensionality of the representation to a more manageable size for subsequent layers in the network architecture.","title":"Mamba's Architecture"},{"location":"natural_language_processing/mamba/#mambas-impact-and-results","text":"Mamba demonstrates promising results, particularly for long sequences: Speed: Mamba achieves super fast speed which becomes even better with increase in sequence length and batch sizes. Source: [1] Performance: Mamba outperforms Transformers based models (even 2x bigger ones!) on various tasks. Source: [1] Source: [1] Hint As Mamba performs quite well on long sequences (evident from its performance on DNA dataset) , there is an interesting space of work in MambaByte [4] which is a token-free adaptation of the Mamba SSM trained auto-regressively on byte sequences. This model is able to achieve state-of-the-art performance on byte-level language modeling tasks.","title":"Mamba's Impact and Results"},{"location":"natural_language_processing/mamba/#conclusion","text":"Mamba's emergence demonstrates the continuous evolution of deep learning architectures. With its focus on speed, memory efficiency, and scalability for long sequences, Mamba offers a compelling alternative to Transformers and paves the way for further exploration in sequence modeling techniques. That said, Mamba is a relatively new architecture, and further research is needed to fully understand its capabilities compared to Transformers. Nevertheless, Mamba's innovative approach to sequence modeling holds promise for a wide range of applications, particularly those involving long sequences of data.","title":"Conclusion"},{"location":"natural_language_processing/mamba/#references","text":"[1] Original Paper - Mamba: Linear-Time Sequence Modeling with Selective State Spaces [2] Video by AI Coffee Break with Letitia -- MAMBA and State Space Models explained | SSM explained [3] Introduction to State Space Models (SSM) [4] Paper - MambaByte: Token-free Selective State Space Model","title":"References"},{"location":"natural_language_processing/minilm/","text":"Introduction Knowledge distillation is the process of compressing the knowledge of a large model (teacher) into a smaller one (student). MiniLM [1,2,3] propose novel approaches to perform distillation of large models like BERT and RoBERTa into smaller models that could be 99% accurate on certain tasks while being more than 2 times faster in inference! Apart from sharing details on the distillation process, authors also open-sourced the distilled models at [3]. While the teacher models were encoder models, the author proposes MiniLM can be used for NLU (ex: extractive QA) as well as NLG tasks (ex: abstractive summarization) . For NLG task, authors followed UniLM paper and used masked attention layers. MiniLM The first MiniLM paper [1] was published in 2019, and the laid the foundation of the efficient distillation of large NLP models. Distillation of BERT model has been done before in DistillBERT, TinyBERT and MobileBERT. Here is how MiniLM was different, They proposed dual approach of distillation, (1) Use the original teacher for distillation if student has same number of layers but different hidden size, (2) use an intermediate teacher assistant if student has even reduced number of layers. Shown below is the example where L and M are the number of layers, d and di is the hidden size in teacher and student respectively. This teacher assistant method is suggested if, \\(M \\le \\frac{1}{2} L\\) and \\(di \\le \\frac{1}{2} d\\) . graph LR A(\"Teacher (L, d)\") -- distil --> B(\"Teacher Assistant (L, di)\") B -- distil --> C(\"Student (M, di)\") Additionally, relation based distillation of only the last Transformer layer was performed rather than other intermediate layers. This lead to flexible architecture creation for student models, where the number of layers could be less than teacher's. Finally, they also proposed dual attention transfer i.e Q-K and V-V. For distillation they compared the KL loss between the last transformer layer of teacher and student. Below is the overview diagram, Overview of Deep Self-Attention Distillation [1] Here is the comparison of the existing distillation methods with MiniLM wrt the approach and performance on different datasets. Comparison with previous task-agnostic Transformer based LM distillation approaches. [1] MiniLM performance comparision with existing distilled models [1] Here is a comparison of different distilled MiniLM model against the BERT-Base model [3]. As visible, even with more than 3x reduction in parameters, the accuracy is quite good, sometimes even better! Model #Param SQuAD 2.0 MNLI-m SST-2 QNLI CoLA RTE MRPC QQP BERT-Base 109M 76.8 84.5 93.2 91.7 58.9 68.6 87.3 91.3 MiniLM-L12xH384 33M 81.7 85.7 93.0 91.5 58.5 73.3 89.5 91.3 MiniLM-L6xH384 22M 75.6 83.3 91.5 90.5 47.5 68.8 88.9 90.6 MiniLMv2 MiniLMv2 [2] was published in 2021, and here is how it was an enhancement wrt MiniLMv1, It generalize deep self-attention distillation in MiniLMv1 [1] by using self-attention relation distillation for task-agnostic compression of pre-trained Transformers. The proposed method eliminates the restriction on the number of student\u2019s attention heads . Authors performed teacher layer selection strategy. In MiniLMv1, knowledge from teacher's last layer was transfered to student's last layer. In MiniLMv2, while the transfer still happened to student's last layer, teacher's layer changes, For BERT-large, 21st layer in teacher model was used for transfer For RoBERTa-large and XML-R-large, 19th layer in teacher model was used for transfer For base sized models, last layer in teacher model was used for transfer Authors experimented with multiple self-attention (Q-K, K- Q, Q-V, V-Q, K-V and V-K relations). However, introducing more self-attention relations also brings a higher computational cost. Hence to achieve a balance between performance and computational cost, author choose to transfer Q-Q, K-K and V-V self-attention relations instead of all self-attention relations. Overview of multi-head self-attention relation distillation [1] Shown below are the MiniLMv2 models with details on the speedup and performance [3], Model Teacher Model Speedup #Param MNLI-m (Acc) SQuAD 2.0 (F1) L6xH768 MiniLMv2 RoBERTa-Large 2.0x 81M 87.0 81.6 L12xH384 MiniLMv2 RoBERTa-Large 2.7x 41M 86.9 82.3 L6xH384 MiniLMv2 RoBERTa-Large 5.3x 30M 84.4 76.4 L6xH768 MiniLMv2 BERT-Large Uncased 2.0x 66M 85.0 77.7 L6xH384 MiniLMv2 BERT-Large Uncased 5.3x 22M 83.0 74.3 L6xH768 MiniLMv2 BERT-Base Uncased 2.0x 66M 84.2 76.3 L6xH384 MiniLMv2 BERT-Base Uncased 5.3x 22M 82.8 72.9 Code Inference of MiniLM As the MiniLM models are based on BERT and RoBERTa, we can use their code for MiniLM. Here, let's make it much simpler by using the AutoModel function if you are loading the models from Huggingface. You can also download models from [3]. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # install packages ! pip install - q transformers ! pip install - q sentencepiece # import from transformers import AutoTokenizer , AutoModel # load tokenizer and model tokenizer = AutoTokenizer . from_pretrained ( \"microsoft/Multilingual-MiniLM-L12-H384\" ) model = AutoModel . from_pretrained ( \"microsoft/Multilingual-MiniLM-L12-H384\" ) # inference inputs = tokenizer ( \"Hello world!\" , return_tensors = \"pt\" ) # dict with input_ids ---> torch.Size([1, 5]) and attention_mask ---> torch.Size([1, 5]) outputs = model ( ** inputs ) # dict with 'last_hidden_state' --> torch.Size([1, 5, 384]) and pooler_output --> torch.Size([1, 384]) The tokenization vocabulary is 250002 strong (quite big!) , and for input Hello world! . the tokenized output is <s>_Hello_world!</s> with corresponding input ids is tensor([[ 0, 35378, 8999, 38, 2]]) References [1] MiniLM: Deep Self-Attention Distillation for Task-Agnostic Compression of Pre-Trained Transformers [2] MiniLMv2: Multi-Head Self-Attention Relation Distillation for Compressing Pretrained Transformers [3] MiniLM Official Microsoft Github","title":"MiniLM"},{"location":"natural_language_processing/minilm/#introduction","text":"Knowledge distillation is the process of compressing the knowledge of a large model (teacher) into a smaller one (student). MiniLM [1,2,3] propose novel approaches to perform distillation of large models like BERT and RoBERTa into smaller models that could be 99% accurate on certain tasks while being more than 2 times faster in inference! Apart from sharing details on the distillation process, authors also open-sourced the distilled models at [3]. While the teacher models were encoder models, the author proposes MiniLM can be used for NLU (ex: extractive QA) as well as NLG tasks (ex: abstractive summarization) . For NLG task, authors followed UniLM paper and used masked attention layers.","title":"Introduction"},{"location":"natural_language_processing/minilm/#minilm","text":"The first MiniLM paper [1] was published in 2019, and the laid the foundation of the efficient distillation of large NLP models. Distillation of BERT model has been done before in DistillBERT, TinyBERT and MobileBERT. Here is how MiniLM was different, They proposed dual approach of distillation, (1) Use the original teacher for distillation if student has same number of layers but different hidden size, (2) use an intermediate teacher assistant if student has even reduced number of layers. Shown below is the example where L and M are the number of layers, d and di is the hidden size in teacher and student respectively. This teacher assistant method is suggested if, \\(M \\le \\frac{1}{2} L\\) and \\(di \\le \\frac{1}{2} d\\) . graph LR A(\"Teacher (L, d)\") -- distil --> B(\"Teacher Assistant (L, di)\") B -- distil --> C(\"Student (M, di)\") Additionally, relation based distillation of only the last Transformer layer was performed rather than other intermediate layers. This lead to flexible architecture creation for student models, where the number of layers could be less than teacher's. Finally, they also proposed dual attention transfer i.e Q-K and V-V. For distillation they compared the KL loss between the last transformer layer of teacher and student. Below is the overview diagram, Overview of Deep Self-Attention Distillation [1] Here is the comparison of the existing distillation methods with MiniLM wrt the approach and performance on different datasets. Comparison with previous task-agnostic Transformer based LM distillation approaches. [1] MiniLM performance comparision with existing distilled models [1] Here is a comparison of different distilled MiniLM model against the BERT-Base model [3]. As visible, even with more than 3x reduction in parameters, the accuracy is quite good, sometimes even better! Model #Param SQuAD 2.0 MNLI-m SST-2 QNLI CoLA RTE MRPC QQP BERT-Base 109M 76.8 84.5 93.2 91.7 58.9 68.6 87.3 91.3 MiniLM-L12xH384 33M 81.7 85.7 93.0 91.5 58.5 73.3 89.5 91.3 MiniLM-L6xH384 22M 75.6 83.3 91.5 90.5 47.5 68.8 88.9 90.6","title":"MiniLM"},{"location":"natural_language_processing/minilm/#minilmv2","text":"MiniLMv2 [2] was published in 2021, and here is how it was an enhancement wrt MiniLMv1, It generalize deep self-attention distillation in MiniLMv1 [1] by using self-attention relation distillation for task-agnostic compression of pre-trained Transformers. The proposed method eliminates the restriction on the number of student\u2019s attention heads . Authors performed teacher layer selection strategy. In MiniLMv1, knowledge from teacher's last layer was transfered to student's last layer. In MiniLMv2, while the transfer still happened to student's last layer, teacher's layer changes, For BERT-large, 21st layer in teacher model was used for transfer For RoBERTa-large and XML-R-large, 19th layer in teacher model was used for transfer For base sized models, last layer in teacher model was used for transfer Authors experimented with multiple self-attention (Q-K, K- Q, Q-V, V-Q, K-V and V-K relations). However, introducing more self-attention relations also brings a higher computational cost. Hence to achieve a balance between performance and computational cost, author choose to transfer Q-Q, K-K and V-V self-attention relations instead of all self-attention relations. Overview of multi-head self-attention relation distillation [1] Shown below are the MiniLMv2 models with details on the speedup and performance [3], Model Teacher Model Speedup #Param MNLI-m (Acc) SQuAD 2.0 (F1) L6xH768 MiniLMv2 RoBERTa-Large 2.0x 81M 87.0 81.6 L12xH384 MiniLMv2 RoBERTa-Large 2.7x 41M 86.9 82.3 L6xH384 MiniLMv2 RoBERTa-Large 5.3x 30M 84.4 76.4 L6xH768 MiniLMv2 BERT-Large Uncased 2.0x 66M 85.0 77.7 L6xH384 MiniLMv2 BERT-Large Uncased 5.3x 22M 83.0 74.3 L6xH768 MiniLMv2 BERT-Base Uncased 2.0x 66M 84.2 76.3 L6xH384 MiniLMv2 BERT-Base Uncased 5.3x 22M 82.8 72.9","title":"MiniLMv2"},{"location":"natural_language_processing/minilm/#code","text":"","title":"Code"},{"location":"natural_language_processing/minilm/#inference-of-minilm","text":"As the MiniLM models are based on BERT and RoBERTa, we can use their code for MiniLM. Here, let's make it much simpler by using the AutoModel function if you are loading the models from Huggingface. You can also download models from [3]. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # install packages ! pip install - q transformers ! pip install - q sentencepiece # import from transformers import AutoTokenizer , AutoModel # load tokenizer and model tokenizer = AutoTokenizer . from_pretrained ( \"microsoft/Multilingual-MiniLM-L12-H384\" ) model = AutoModel . from_pretrained ( \"microsoft/Multilingual-MiniLM-L12-H384\" ) # inference inputs = tokenizer ( \"Hello world!\" , return_tensors = \"pt\" ) # dict with input_ids ---> torch.Size([1, 5]) and attention_mask ---> torch.Size([1, 5]) outputs = model ( ** inputs ) # dict with 'last_hidden_state' --> torch.Size([1, 5, 384]) and pooler_output --> torch.Size([1, 384]) The tokenization vocabulary is 250002 strong (quite big!) , and for input Hello world! . the tokenized output is <s>_Hello_world!</s> with corresponding input ids is tensor([[ 0, 35378, 8999, 38, 2]])","title":"Inference of MiniLM"},{"location":"natural_language_processing/minilm/#references","text":"[1] MiniLM: Deep Self-Attention Distillation for Task-Agnostic Compression of Pre-Trained Transformers [2] MiniLMv2: Multi-Head Self-Attention Relation Distillation for Compressing Pretrained Transformers [3] MiniLM Official Microsoft Github","title":"References"},{"location":"natural_language_processing/named_entity_recognition/","text":"Named entity recognition Introduction Named entity recognition (NER) is the process of identifying entities in the unstructured text, where entities could be objects, people, locations, organizations, etc. NER's most basic building block consists of pair of entity_type and entity_value . Consider the following example, ## Statement My name is Mohit, and I am from India. I am a Data Scientist and I will be leaving for my office around 9 AM. ## Entities [{ 'entity_type': 'PERSON', 'entity_value': 'Mohit', }, { 'entity_type': 'LOCATION', 'entity_value': 'India', }, { 'entity_type': 'TIME', 'entity_value': '9 AM', }] The process of extracting entities could be done in two ways. Heuristic : by identifying the entities based on the rules. Semantic : by identifying the entities based on the semantics and context. Heuristic based approach is suited only for simple entities for which approximate rules can be created. Take for example EMAILID, PHONE_NUMBER, WEBSITE, etc. It should be easy enough to create regular expressions for such cases and hence heuristic approach could be applied. We can also apply part of speech based rules to extract certain entities. On the other hand, the Semantic approach is required where the cardinality of the entities is high and the context is required to extract the entities. For example, NAME, LOCATION, DESIGNATION, etc. For these cases, we usually train neural network based models that learn to consider the context and extract the entities. Note A good approach to creating your NER solution would be to segregate your entities into simple and complex, and then create either a heuristic or a semantic based solution or a combination of both. In short, it is not always suitable to directly go to fancy NN based semantic approaches - it could be unnecessary overkill. Remember the entity types are not set in stone and we can even train new models or finetune existing models on our own custom entities. For this, in the Semantic-based approach, it's a good idea to finetune the existing model rather than to train a new one as it will require far fewer data. The amount of data required to finetune model depends on how similar the custom entities are with the existing entities. Consider the following cases, The model is pretrained to detect PERSON and now you want to finetune it to detect MALE_NAME and FEMALE_NAME. As this is just a lower granularity on the existing PERSON entity, a mere ~200 examples (for each new entity type) could give you good results. On the other hand, if you now want to finetune a completely new entity like OBJECTIONS_TYPE, you may need ~500 examples. Note Another thing to consider is the length of entity_value . With an increase in entity_value you may require more examples to get good accuracy results. Code There are lots of Python-based packages that provide open source NER models. Some of these packages are Spacy , NLTK , Flair , etc. While packages provide an easy interface to the NER models or rules, we can even load and use external open-source NER models. Using Spacy NER model for Inference Spacy comes with several pre-trained models that can be selected based on the use case. For this example, we will use the Transformer model available with Spacy Transformers . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # install spacy-transformers and transformers model ! pip install spacy - transformers ! python3 - m spacy download en_core_web_trf # import the spacy library import spacy # load the model nlp = spacy . load ( \"en_core_web_trf\" ) # set the text text = \"My name is Mohit, and I am from India. I am a Data Scientist and I will be leaving for my office around 9 AM.\" # create spacy doc by passing the text doc = nlp ( text ) # print all of the identified entities for ent in doc . ents : print ( f \"Type: { ent . label_ } -- Value: { ent . text } \" ) # Output: # Type: PERSON -- Value: Mohit # Type: GPE -- Value: India # Type: TIME -- Value: around 9 AM We can even display the results in a much more intuitive and fancy way by, 1 2 # use displacy to render the result spacy . displacy . render ( doc , style = 'ent' , jupyter = True , options = { 'distance' : 90 }) NER result for the above example Training custom NER model using Spacy v3 All NER use-cases are not the same, and you may want to train a custom model with new entity types. Spacy provides an option to train custom NER models as well. To be frank the complete process is quite complicated, but nothing to worry, strap on and let's cover them steo by step. Config Creation To begin with, we will define the settings that will be used throughout the training process. Starting with Spacy v3, all parameter settings need to be configured using a .cfg file. We can create a .cfg file following the guide here . Basically, it requires to Firstly, create a base config using the quick widget provided at the page . Do remember to check the correct options. (Refer below image for one example) Secondly, run CLI command to update the base config python -m spacy init fill-config base_config.cfg config.cfg Example of options to mark to generate base_config.cfg from Spacy website for NER training. Data Preparation Next we need to prepare the dataset. At high level, you need to prepare pairs of text and entities in the text. Consider the following dummy dataset where we want to extract video game's names, (in CSV format) text label I was playing Call of Duty {'entities': [[14, 26, 'Game']]} I did not like COD1 and COD2 {'entities': [[15, 19, 'Game'], [24, 28, 'Game']]} As obvious, text contains the base text and label contains all the entities that ideally should be extracted from text. This is our golden dataset. Here, inside label we have a dict with entities key and the value is list of different entities. Each entity has [start_index, end_index, entity_type] data. Note, we follow the Python indexing i.e. the indexing starts with 0, start_index is the index of start character and end_index is the index of end character + 1 . In the first example, \"I was playing Call of Duty\"[14:26] will return \"Call of Duty\" which is a very famous video game \ud83c\udfae Now we will convert the CSV file into Spacy format. It is the recommended format supported by the package. To do this, run the following code, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 # import from tqdm import tqdm from spacy.tokens import DocBin # function def convert_to_spacy ( data_df , output_path ): \"\"\" Convert the data to spacy format Parameters ------------ :param data_df: pandas.DataFrame dataframe containing the data to be converted :param output_path: string path to save the converted data \"\"\" nlp = spacy . blank ( \"en\" ) # load a new blank spacy model db = DocBin () # create a DocBin object # iterate over the dataframe for id_ , row in tqdm ( data_df . iterrows ()): text = row [ 'text' ] # extract the text doc = nlp . make_doc ( text ) # create doc object from text ents = [] # var to hold entities for entity in row [ 'label' ][ 'entities' ]: # add character indexes start , end , label = entity # extract the entity details span = doc . char_span ( start , end , label = label , alignment_mode = \"contract\" ) if span is None : print ( \"Skipping entity\" ) else : ents . append ( span ) doc . ents = ents # label the text with the ents db . add ( doc ) # save to disk db . to_disk ( output_path ) # save the docbin object # run the code convert_to_spacy ( data_df , \"train_data.spacy\" ) Note Remember to split the CSV file into train and test data. Then you can run the above code twice to generate two spacy files, one for train and one for test. Also, we can use random split, as stratified split is quite difficult to do. This is because each text may heve multiple instances of same or different entities and we want to split the text based on entities! Because of this, a stratified split is equivalent to solving a optimizing problem - How to split the text samples such that the underlying entities are equally distributed! Hence we will use a random split for rough estimation and the result may surprise you Data Validation The next step is to perform a validation to check if the data is correctly converted or not. Spacy provides readymade CLI command for this purpose, spacy debug data -V /content/config.cfg --paths.train /content/train_data.spacy --paths.dev /content/test_data.spacy This should print output similar to, ============================ Data file validation ============================ \u2714 Pipeline can be initialized with data \u2714 Corpus is loadable =============================== Training stats =============================== Language: en Training pipeline: tok2vec, ner 7916 training docs 235 evaluation docs \u2714 No overlap between training and evaluation data ============================== Vocab & Vectors ============================== \u2139 876405 total word ( s ) in the data ( 33656 unique ) 10 most common words: ',' ( 35938 ) , '.' ( 24253 ) , ' ' ( 19522 ) , ':' ( 17316 ) , 'to' ( 16328 ) , 'you' ( 15474 ) , 'the' ( 14626 ) , ' ' ( 14051 ) , ' ' ( 13869 ) , ' ' ( 12003 ) \u2139 No word vectors present in the package ========================== Named Entity Recognition ========================== \u2139 6 label ( s ) 0 missing value ( s ) ( tokens with '-' label ) Labels in train data: 'Game' \u2714 Good amount of examples for all labels \u2714 Examples without occurrences available for all labels \u2714 No entities consisting of or starting/ending with whitespace \u2714 No entities crossing sentence boundaries ================================== Summary ================================== \u2714 7 checks passed Based on the quality of annotations or the tool used, you may encounter error like Whitespaces present in the data validation step. This is because the annotations has whitespaces and it becomes difficult to train the model with such examples. In such case, we can fix the data by removing the whitespaces as shown below, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # var to hold the count of faulty annotations count = 0 # remove instances from the dataframe where annotations contains whitespaces for index , row in data_df . iterrows (): row_label = row [ 'label' ][ 'entities' ] for entity_index , entity in enumerate ( row_label ): text = row [ 'text' ][ entity [ 0 ]: entity [ 1 ]] if len ( text ) != len ( text . strip ()): count += 1 new_text = text . strip () start_index = row [ 'text' ] . find ( new_text ) end_index = start_index + len ( new_text ) row_label [ entity_index ] = [ start_index , end_index , entity [ 2 ]] # print the count of faulty annotations that were fixed print ( count ) Training the Model Now we are ready to train the model. Spacy CLI command can be used, spacy train --output models/ config/config.cfg --paths.train data/train_data.spacy --paths.dev data/test_data.spacy --gpu-id 0 Note Make sure to remove --gpu-id 0 if you do not have a GPU. This should print something like, \u2139 Saving to output directory: models \u2139 Using CPU =========================== Initializing pipeline =========================== [ 2022 -05-31 23 :29:00,409 ] [ INFO ] Set up nlp object from config [ 2022 -05-31 23 :29:00,413 ] [ INFO ] Pipeline: [ 'tok2vec' , 'ner' ] [ 2022 -05-31 23 :29:00,415 ] [ INFO ] Created vocabulary [ 2022 -05-31 23 :29:00,415 ] [ INFO ] Finished initializing nlp object [ 2022 -05-31 23 :29:08,553 ] [ INFO ] Initialized pipeline components: [ 'tok2vec' , 'ner' ] \u2714 Initialized pipeline ============================= Training pipeline ============================= \u2139 Pipeline: [ 'tok2vec' , 'ner' ] \u2139 Initial learn rate: 0 .001 E # LOSS TOK2VEC LOSS NER ENTS_F ENTS_P ENTS_R SCORE --- ------ ------------ -------- ------ ------ ------ ------ 0 0 0 .00 14 .42 0 .39 0 .43 0 .36 0 .00 0 1000 75263 .20 7992 .36 9 .34 9 .29 9 .39 0 .09 0 2000 473275 .24 6660 .36 20 .33 29 .45 15 .52 0 .20 1 3000 203618 .32 12177 .86 27 .76 29 .32 26 .35 0 .28 2 4000 394085 .98 14795 .70 35 .14 44 .02 29 .24 0 .35 3 5000 280698 .47 13595 .65 34 .71 40 .58 30 .32 0 .35 4 6000 332890 .64 13044 .08 37 .39 44 .72 32 .13 0 .37 5 7000 645988 .19 12552 .55 40 .72 45 .54 36 .82 0 .41 6 8000 155963 .67 12083 .43 34 .97 33 .01 37 .18 0 .35 7 9000 802471 .84 11443 .62 38 .64 40 .64 36 .82 0 .39 8 10000 44495 .21 10276 .14 38 .79 40 .55 37 .18 0 .39 9 11000 86229 .51 10011 .45 40 .08 46 .86 35 .02 0 .40 10 12000 198516 .08 9752 .18 37 .38 40 .08 35 .02 0 .37 Epoch 11 : 66 % | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d | 656 /1000 [ 02 :34< 01 :28, 3 .89it/s ] Note Modify the config.cfg file to specify the model to use, the epochs to train for, the learning rate to use and other settings. Evaluation of the Model Finally, once the trainig is done, we can evaluate the model using the Spacy CLI command, spacy evaluate models/model-best data/test_data.spacy --gpu-id 0 Additional materials To train Spacy NER model on a custom dataset: Spacy v3 Custom NER Named-Entity evaluation metrics based on entity-level","title":"Named Entity Recognition"},{"location":"natural_language_processing/named_entity_recognition/#named-entity-recognition","text":"","title":"Named entity recognition"},{"location":"natural_language_processing/named_entity_recognition/#introduction","text":"Named entity recognition (NER) is the process of identifying entities in the unstructured text, where entities could be objects, people, locations, organizations, etc. NER's most basic building block consists of pair of entity_type and entity_value . Consider the following example, ## Statement My name is Mohit, and I am from India. I am a Data Scientist and I will be leaving for my office around 9 AM. ## Entities [{ 'entity_type': 'PERSON', 'entity_value': 'Mohit', }, { 'entity_type': 'LOCATION', 'entity_value': 'India', }, { 'entity_type': 'TIME', 'entity_value': '9 AM', }] The process of extracting entities could be done in two ways. Heuristic : by identifying the entities based on the rules. Semantic : by identifying the entities based on the semantics and context. Heuristic based approach is suited only for simple entities for which approximate rules can be created. Take for example EMAILID, PHONE_NUMBER, WEBSITE, etc. It should be easy enough to create regular expressions for such cases and hence heuristic approach could be applied. We can also apply part of speech based rules to extract certain entities. On the other hand, the Semantic approach is required where the cardinality of the entities is high and the context is required to extract the entities. For example, NAME, LOCATION, DESIGNATION, etc. For these cases, we usually train neural network based models that learn to consider the context and extract the entities. Note A good approach to creating your NER solution would be to segregate your entities into simple and complex, and then create either a heuristic or a semantic based solution or a combination of both. In short, it is not always suitable to directly go to fancy NN based semantic approaches - it could be unnecessary overkill. Remember the entity types are not set in stone and we can even train new models or finetune existing models on our own custom entities. For this, in the Semantic-based approach, it's a good idea to finetune the existing model rather than to train a new one as it will require far fewer data. The amount of data required to finetune model depends on how similar the custom entities are with the existing entities. Consider the following cases, The model is pretrained to detect PERSON and now you want to finetune it to detect MALE_NAME and FEMALE_NAME. As this is just a lower granularity on the existing PERSON entity, a mere ~200 examples (for each new entity type) could give you good results. On the other hand, if you now want to finetune a completely new entity like OBJECTIONS_TYPE, you may need ~500 examples. Note Another thing to consider is the length of entity_value . With an increase in entity_value you may require more examples to get good accuracy results.","title":"Introduction"},{"location":"natural_language_processing/named_entity_recognition/#code","text":"There are lots of Python-based packages that provide open source NER models. Some of these packages are Spacy , NLTK , Flair , etc. While packages provide an easy interface to the NER models or rules, we can even load and use external open-source NER models.","title":"Code"},{"location":"natural_language_processing/named_entity_recognition/#using-spacy-ner-model-for-inference","text":"Spacy comes with several pre-trained models that can be selected based on the use case. For this example, we will use the Transformer model available with Spacy Transformers . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # install spacy-transformers and transformers model ! pip install spacy - transformers ! python3 - m spacy download en_core_web_trf # import the spacy library import spacy # load the model nlp = spacy . load ( \"en_core_web_trf\" ) # set the text text = \"My name is Mohit, and I am from India. I am a Data Scientist and I will be leaving for my office around 9 AM.\" # create spacy doc by passing the text doc = nlp ( text ) # print all of the identified entities for ent in doc . ents : print ( f \"Type: { ent . label_ } -- Value: { ent . text } \" ) # Output: # Type: PERSON -- Value: Mohit # Type: GPE -- Value: India # Type: TIME -- Value: around 9 AM We can even display the results in a much more intuitive and fancy way by, 1 2 # use displacy to render the result spacy . displacy . render ( doc , style = 'ent' , jupyter = True , options = { 'distance' : 90 }) NER result for the above example","title":"Using Spacy NER model for Inference"},{"location":"natural_language_processing/named_entity_recognition/#training-custom-ner-model-using-spacy-v3","text":"All NER use-cases are not the same, and you may want to train a custom model with new entity types. Spacy provides an option to train custom NER models as well. To be frank the complete process is quite complicated, but nothing to worry, strap on and let's cover them steo by step.","title":"Training custom NER model using Spacy v3"},{"location":"natural_language_processing/named_entity_recognition/#config-creation","text":"To begin with, we will define the settings that will be used throughout the training process. Starting with Spacy v3, all parameter settings need to be configured using a .cfg file. We can create a .cfg file following the guide here . Basically, it requires to Firstly, create a base config using the quick widget provided at the page . Do remember to check the correct options. (Refer below image for one example) Secondly, run CLI command to update the base config python -m spacy init fill-config base_config.cfg config.cfg Example of options to mark to generate base_config.cfg from Spacy website for NER training.","title":"Config Creation"},{"location":"natural_language_processing/named_entity_recognition/#data-preparation","text":"Next we need to prepare the dataset. At high level, you need to prepare pairs of text and entities in the text. Consider the following dummy dataset where we want to extract video game's names, (in CSV format) text label I was playing Call of Duty {'entities': [[14, 26, 'Game']]} I did not like COD1 and COD2 {'entities': [[15, 19, 'Game'], [24, 28, 'Game']]} As obvious, text contains the base text and label contains all the entities that ideally should be extracted from text. This is our golden dataset. Here, inside label we have a dict with entities key and the value is list of different entities. Each entity has [start_index, end_index, entity_type] data. Note, we follow the Python indexing i.e. the indexing starts with 0, start_index is the index of start character and end_index is the index of end character + 1 . In the first example, \"I was playing Call of Duty\"[14:26] will return \"Call of Duty\" which is a very famous video game \ud83c\udfae Now we will convert the CSV file into Spacy format. It is the recommended format supported by the package. To do this, run the following code, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 # import from tqdm import tqdm from spacy.tokens import DocBin # function def convert_to_spacy ( data_df , output_path ): \"\"\" Convert the data to spacy format Parameters ------------ :param data_df: pandas.DataFrame dataframe containing the data to be converted :param output_path: string path to save the converted data \"\"\" nlp = spacy . blank ( \"en\" ) # load a new blank spacy model db = DocBin () # create a DocBin object # iterate over the dataframe for id_ , row in tqdm ( data_df . iterrows ()): text = row [ 'text' ] # extract the text doc = nlp . make_doc ( text ) # create doc object from text ents = [] # var to hold entities for entity in row [ 'label' ][ 'entities' ]: # add character indexes start , end , label = entity # extract the entity details span = doc . char_span ( start , end , label = label , alignment_mode = \"contract\" ) if span is None : print ( \"Skipping entity\" ) else : ents . append ( span ) doc . ents = ents # label the text with the ents db . add ( doc ) # save to disk db . to_disk ( output_path ) # save the docbin object # run the code convert_to_spacy ( data_df , \"train_data.spacy\" ) Note Remember to split the CSV file into train and test data. Then you can run the above code twice to generate two spacy files, one for train and one for test. Also, we can use random split, as stratified split is quite difficult to do. This is because each text may heve multiple instances of same or different entities and we want to split the text based on entities! Because of this, a stratified split is equivalent to solving a optimizing problem - How to split the text samples such that the underlying entities are equally distributed! Hence we will use a random split for rough estimation and the result may surprise you","title":"Data Preparation"},{"location":"natural_language_processing/named_entity_recognition/#data-validation","text":"The next step is to perform a validation to check if the data is correctly converted or not. Spacy provides readymade CLI command for this purpose, spacy debug data -V /content/config.cfg --paths.train /content/train_data.spacy --paths.dev /content/test_data.spacy This should print output similar to, ============================ Data file validation ============================ \u2714 Pipeline can be initialized with data \u2714 Corpus is loadable =============================== Training stats =============================== Language: en Training pipeline: tok2vec, ner 7916 training docs 235 evaluation docs \u2714 No overlap between training and evaluation data ============================== Vocab & Vectors ============================== \u2139 876405 total word ( s ) in the data ( 33656 unique ) 10 most common words: ',' ( 35938 ) , '.' ( 24253 ) , ' ' ( 19522 ) , ':' ( 17316 ) , 'to' ( 16328 ) , 'you' ( 15474 ) , 'the' ( 14626 ) , ' ' ( 14051 ) , ' ' ( 13869 ) , ' ' ( 12003 ) \u2139 No word vectors present in the package ========================== Named Entity Recognition ========================== \u2139 6 label ( s ) 0 missing value ( s ) ( tokens with '-' label ) Labels in train data: 'Game' \u2714 Good amount of examples for all labels \u2714 Examples without occurrences available for all labels \u2714 No entities consisting of or starting/ending with whitespace \u2714 No entities crossing sentence boundaries ================================== Summary ================================== \u2714 7 checks passed Based on the quality of annotations or the tool used, you may encounter error like Whitespaces present in the data validation step. This is because the annotations has whitespaces and it becomes difficult to train the model with such examples. In such case, we can fix the data by removing the whitespaces as shown below, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # var to hold the count of faulty annotations count = 0 # remove instances from the dataframe where annotations contains whitespaces for index , row in data_df . iterrows (): row_label = row [ 'label' ][ 'entities' ] for entity_index , entity in enumerate ( row_label ): text = row [ 'text' ][ entity [ 0 ]: entity [ 1 ]] if len ( text ) != len ( text . strip ()): count += 1 new_text = text . strip () start_index = row [ 'text' ] . find ( new_text ) end_index = start_index + len ( new_text ) row_label [ entity_index ] = [ start_index , end_index , entity [ 2 ]] # print the count of faulty annotations that were fixed print ( count )","title":"Data Validation"},{"location":"natural_language_processing/named_entity_recognition/#training-the-model","text":"Now we are ready to train the model. Spacy CLI command can be used, spacy train --output models/ config/config.cfg --paths.train data/train_data.spacy --paths.dev data/test_data.spacy --gpu-id 0 Note Make sure to remove --gpu-id 0 if you do not have a GPU. This should print something like, \u2139 Saving to output directory: models \u2139 Using CPU =========================== Initializing pipeline =========================== [ 2022 -05-31 23 :29:00,409 ] [ INFO ] Set up nlp object from config [ 2022 -05-31 23 :29:00,413 ] [ INFO ] Pipeline: [ 'tok2vec' , 'ner' ] [ 2022 -05-31 23 :29:00,415 ] [ INFO ] Created vocabulary [ 2022 -05-31 23 :29:00,415 ] [ INFO ] Finished initializing nlp object [ 2022 -05-31 23 :29:08,553 ] [ INFO ] Initialized pipeline components: [ 'tok2vec' , 'ner' ] \u2714 Initialized pipeline ============================= Training pipeline ============================= \u2139 Pipeline: [ 'tok2vec' , 'ner' ] \u2139 Initial learn rate: 0 .001 E # LOSS TOK2VEC LOSS NER ENTS_F ENTS_P ENTS_R SCORE --- ------ ------------ -------- ------ ------ ------ ------ 0 0 0 .00 14 .42 0 .39 0 .43 0 .36 0 .00 0 1000 75263 .20 7992 .36 9 .34 9 .29 9 .39 0 .09 0 2000 473275 .24 6660 .36 20 .33 29 .45 15 .52 0 .20 1 3000 203618 .32 12177 .86 27 .76 29 .32 26 .35 0 .28 2 4000 394085 .98 14795 .70 35 .14 44 .02 29 .24 0 .35 3 5000 280698 .47 13595 .65 34 .71 40 .58 30 .32 0 .35 4 6000 332890 .64 13044 .08 37 .39 44 .72 32 .13 0 .37 5 7000 645988 .19 12552 .55 40 .72 45 .54 36 .82 0 .41 6 8000 155963 .67 12083 .43 34 .97 33 .01 37 .18 0 .35 7 9000 802471 .84 11443 .62 38 .64 40 .64 36 .82 0 .39 8 10000 44495 .21 10276 .14 38 .79 40 .55 37 .18 0 .39 9 11000 86229 .51 10011 .45 40 .08 46 .86 35 .02 0 .40 10 12000 198516 .08 9752 .18 37 .38 40 .08 35 .02 0 .37 Epoch 11 : 66 % | \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d | 656 /1000 [ 02 :34< 01 :28, 3 .89it/s ] Note Modify the config.cfg file to specify the model to use, the epochs to train for, the learning rate to use and other settings.","title":"Training the Model"},{"location":"natural_language_processing/named_entity_recognition/#evaluation-of-the-model","text":"Finally, once the trainig is done, we can evaluate the model using the Spacy CLI command, spacy evaluate models/model-best data/test_data.spacy --gpu-id 0","title":"Evaluation of the Model"},{"location":"natural_language_processing/named_entity_recognition/#additional-materials","text":"To train Spacy NER model on a custom dataset: Spacy v3 Custom NER Named-Entity evaluation metrics based on entity-level","title":"Additional materials"},{"location":"natural_language_processing/nlq/","text":"Introduction Natural Language Querying (NLQ) is the process of querying DBs not in their official querying language but using natural language text. One example could be to fetch results from a SQL table for question - \"Who is the Prime Minister of India?\" by just using the text and not some technical query like select name from pm_table where country = \"India\" . There are two main reasons that makes this task important for any IaaS (Information as a service) product or SaaS, Each DB has its own specific querying language. This is a nightmare even for developers, as they will have to gain expertise in mulitple DB languages. Looking at a product from users perspective, it makes sense to let the user query in the language they prefer and not the technical query languages suitable for each DBs. Different Approaches Usually there are two approaches to create a NLQ system, Query creator: this is a multi-step process where we first convert the natural text to DB specific language query. This step in itself could have multiple sub steps where we identify entities and intent from the query and then match them with the available data in table. Later we execute the query on the DB and get the data. Answer extractor: this is a single step process, usually built completely of neural networks, where the data and question are passed to the network and output is returned. Think of it like closed-book QA systems in NLP, where we pass the context (here the DB table) and the question (query) and the model returns us the answer. We could add wrapper on the output to handle complex queries with COUNT, AVERAGE, etc. graph LR A(\"What is the size of the data?\") --> B(NLQ system) B -- Query creator --> C(\"Select count(*) from table\") C -- querying DB --> E(\"5\") B -- Answer extractor --> D(\"5\") style B stroke:#f66,stroke-width:2px,stroke-dasharray: 5 5 Note NLQ, as a topic, is DB agnostic, and in reality NLQ systems are built for different DBs like SQL, SPARQL, MongoDB QL, etc. In fact, we can even see NLQ system for programming language data types like PandasAI for Pandas DataFrame in Python. Code Let us explore the different ready made solutions for NLQ. Large Language Models (LLMs) While LLMs have been proven to work well for a lot of NLP related downstream tasks, will it work for NLQ? Let's think about it, due to huge training data LLMs might have already seen a lot of SQL queries and their respective descriptions. So in fact they have \"some idea\" on the relationship between a SQL query (or other query language for that matter) and its respective natural language query. Some might even say that it understands the fundamentals of Text-to-SQL task. But what LLM doesn't know is your Database/Table's schema and how you are storing the data. So hypothetically, if we provide these details it should work, right? The answer is yes! In paper [4], authors took this idea further and evaluated multiple LLMs to answer two questions, Which LLM is best for Text-to-SQL task? Considering only inference, Codex based models like code-davinci-001 were the top perfomers. If we can finetune the models, T5-3B + PICARD was better. Which prompt is best for Text-to-SQL task? Apart from the instructions, the prompt should also contain the schema of the table (with CREATE TABLE command containing column name, type, column reference and keys) along with a couple of rows as example. Below is an example of just the additional data [3] # schema CREATE TABLE \"Track\" ( \"TrackId\" INTEGER NOT NULL , \"Name\" NVARCHAR ( 200 ) NOT NULL , \"AlbumId\" INTEGER , \"MediaTypeId\" INTEGER NOT NULL , \"GenreId\" INTEGER , \"Composer\" NVARCHAR ( 220 ), \"Milliseconds\" INTEGER NOT NULL , \"Bytes\" INTEGER , \"UnitPrice\" NUMERIC ( 10 , 2 ) NOT NULL , PRIMARY KEY ( \"TrackId\" ), FOREIGN KEY ( \"MediaTypeId\" ) REFERENCES \"MediaType\" ( \"MediaTypeId\" ), FOREIGN KEY ( \"GenreId\" ) REFERENCES \"Genre\" ( \"GenreId\" ), FOREIGN KEY ( \"AlbumId\" ) REFERENCES \"Album\" ( \"AlbumId\" ) ) # examples SELECT * FROM 'Track' LIMIT 3 ; TrackId Name AlbumId MediaTypeId GenreId Composer Milliseconds Bytes UnitPrice 1 For Those About To Rock ( We Salute You ) 1 1 1 Angus Young , Malcolm Young , Brian Johnson 343719 11170334 0 . 99 2 Balls to the Wall 2 2 1 None 342562 5510424 0 . 99 3 Fast As a Shark 3 2 1 F . Baltes , S . Kaufman , U . Dirkscneider & W . Hoffman 230619 3990994 0 . 99 If all of this seems too tedius, we can use LangChain that does all of the heavy lifting for us so that we can just do the fun stuff i.e. ask questions . Here, we will connect SQLite database with LLM model. (Script inspired from SQLite example ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # import from langchain import OpenAI , SQLDatabase , SQLDatabaseChain # connect to SQLite DB db = SQLDatabase . from_uri ( \"sqlite://all_employees.db\" ) # connect to the OpenAI Davinci GPT-3 model llm = OpenAI ( temperature = 0 ) # create SQLDatabaseChain db_chain = SQLDatabaseChain ( llm = llm , database = db , verbose = True ) # run the code db_chain . run ( \"How many employees are there?\" ) # output >> SELECT COUNT ( * ) FROM Employee ; >> SQLResult : [( 8 ,)] >> Answer : There are 8 employees . Let's talk about what happened with the code above. First, LangChain create a prompt template and fills the variables automatically using the DB we plugin with the chain. The variables are {dialect} (here SQL) , {table_info} (the additional data we talked about above) and {input} (the question) . The template looks as follow, Given an input question, first create a syntactically correct {dialect} query to run, then look at the results of the query and return the answer. Unless the user specifies in his question a specific number of examples he wishes to obtain, always limit your query to at most {top_k} results. You can order the results by a relevant column to return the most interesting examples in the database. Never query for all the columns from a specific table, only ask for a the few relevant columns given the question. Pay attention to use only the column names that you can see in the schema description. Be careful to not query for columns that do not exist. Also, pay attention to which column is in which table. Use the following format: Question: \"Question here\" SQLQuery: \"SQL Query to run\" SQLResult: \"Result of the SQLQuery\" Answer: \"Final answer here\" Only use the tables listed below. {table_info} Question: {input} Once done, it runs the LLM on the formatted prompt to get the SQL output. Then it execute the query on the connected DB to fetch the result. Finally, it also formats the results into a proper natural language output. All of this with just some prompt engineering! Note While the results are quite impressive, do remember that we need to use powerful (read costly) LLMs for it work with respectable accuracy. As we are formatting the prompt with DB schema, the prompt size might become huge if your DB or Table is big. It is hence recommended to create custom prompts when possible. Be also aware of the respective LLM costs if you are using 3rd party LLMs like GPT-4 or Cohere. PandasAI PandasAI follows on the above LLM based approach to create an advanced NLQ system that can answer questions on Pandas DataFrame in Python. It does that by generating intermediate python code that are executed on the loaded dataframe. This way, it follows the Query creator approach using Python language. As it generates python script, it also supports additional functionalities like generating graphs on the data! Let's see the package in action by asking question on a dataframe, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 ## Install ! pip install BeautifulSoup4 ! pip install pandasai ## Import import pandas as pd from pandasai import SmartDataframe from pandasai.llm import OpenAI ## let's create a dummy data -- remove this incase you have your own data # Create a dictionary with dummy data data = { 'Name' : [ 'Alice' , 'Bob' , 'Charlie' , 'David' , 'Eva' ], 'Age' : [ 25 , 30 , 22 , 35 , 28 ], 'City' : [ 'New York' , 'Los Angeles' , 'Chicago' , 'Houston' , 'Miami' ] } # Create a pandas DataFrame df = pd . DataFrame ( data ) ## setup the LLM and DF llm = OpenAI ( api_token = \"...\" ) # put your OpenAI token here df = SmartDataframe ( df , config = { \"llm\" : llm }) ## chat (run one by one) df . chat ( 'What is the data size?' ) ## Answer - \"The data size is 5 rows and 3 columns.\" # df.chat('Plot a chart of people\\'s ages') # df.chat(\"What is the Age of Alice?\") # df.chat(\"Are there anyone with age more than 50?\") ## See the logs # df.logs While PandasAI performs extensive data, prompt and output cleaning and formatting, let's have a bird's eye view of what is happening inside. First, given the dataframe, a prompt is created that provides some details about the dataframe and asks to modify an existing python function (with existing function definition - interesting!) . The modified python function on execution will return the output we need. Below is the input prompt for our example, Note You can explore the steps performed by PandasAI by looking into the df.logs after executing the df.chat() . The dataframe section in the prompt contains size details and 5 rows (randomly selected) from the dataframe. Using prompt: You are provided with the following pandas DataFrames: <dataframe> Dataframe dfs[0], with 5 rows and 3 columns. This is the metadata of the dataframe dfs[0]: Name,Age,City Alice,25,New York Bob,30,Los Angeles Charlie,22,Chicago David,35,Houston Eva,28,Miami </dataframe> <conversation> User 1: What is the size of the data? </conversation> This is the initial python code to be updated: ``````python # TODO import all the dependencies required import pandas as pd def analyze_data(dfs: list[pd.DataFrame]) -> dict: \"\"\" Analyze the data 1. Prepare: Preprocessing and cleaning data if necessary 2. Process: Manipulating data for analysis (grouping, filtering, aggregating, etc.) 3. Analyze: Conducting the actual analysis (if the user asks to plot a chart save it to an image in temp_chart.png and do not show the chart.) At the end, return a dictionary of: - type (possible values \"string\", \"number\", \"dataframe\", \"plot\") - value (can be a string, a dataframe or the path of the plot, NOT a dictionary) Examples: { \"type\": \"string\", \"value\": \"The highest salary is $9,000.\" } or { \"type\": \"number\", \"value\": 125 } or { \"type\": \"dataframe\", \"value\": pd.DataFrame({...}) } or { \"type\": \"plot\", \"value\": \"temp_chart.png\" } \"\"\" `````` Using the provided dataframes (`dfs`), update the python code based on the last question in the conversation. Updated code: Now once we run the above prompt on the LLM of our choice, we get the following modified function as output, Code generated: ``````` # TODO import all the dependencies required import pandas as pd def analyze_data(dfs: list[pd.DataFrame]) -> dict: \"\"\" Analyze the data 1. Prepare: Preprocessing and cleaning data if necessary 2. Process: Manipulating data for analysis (grouping, filtering, aggregating, etc.) 3. Analyze: Conducting the actual analysis (if the user asks to plot a chart save it to an image in temp_chart.png and do not show the chart.) At the end, return a dictionary of: - type (possible values \"string\", \"number\", \"dataframe\", \"plot\") - value (can be a string, a dataframe or the path of the plot, NOT a dictionary) Examples: { \"type\": \"string\", \"value\": \"The highest salary is $9,000.\" } or { \"type\": \"number\", \"value\": 125 } or { \"type\": \"dataframe\", \"value\": pd.DataFrame({...}) } or { \"type\": \"plot\", \"value\": \"temp_chart.png\" } \"\"\" # Get the size of the data size = dfs[0].shape size_str = f\"The data has {size[0]} rows and {size[1]} columns.\" return {\"type\": \"string\", \"value\": size_str} ``````` PandasAI then exectes the code on the input dataframe and returns the ouput! Warning The above shown prompt is just one example of how PandasAI works (part of their generate_python_code script) . The package has added multiple fallbacks and advanced logic to make the system more robust and accurate. It is open-source so have a look at their codebase, there are lots of things to learn. TaPaS TaPas follows Answer extractor based approach to perform NLQ that utilizes specially trained BERT like transformer. Tapas takes the question and table in the format inspired from BERT like [CLS] Question [SEP] Flattened table [SEP] . The answer is selected from the table based on the question. The model was first pre-trained using unlabeled data on tasks like Masked Language modeling and Sentence-Table support/refute prediction. Later, it was finetuned on datasets like WikiSQL, WTQ and other to perform NLQ. Illustration of the TaPas model for one example ( TaPas paper ) One interesting differentiator of TaPas is the unique formatting and encoding of the query and the table. As a table contains values spread across columns and rows, special column, rows and segment embeddings are added to the input to make the model learn the proper context. One example is shown below, Encoding process of sample query and table in TaPas ( TaPas paper ) Note As TaPas was pre-trained using self-supervised learning on unlabled data, it learned the concept of relationship between text and table. Hence, it can be used (finetuned) for other table-text related downstream tasks as well like refute or support the text based on content in table, etc. Let's get started with the code part. For TAPAS to work, we need to install torch-scatter . For this, we first install pytorch using pip install torch and then get the version of torch using torch.__version__ . Next we install torch-scatter by replacing the version of torch in pip install torch-scatter -f https://pytorch-geometric.com/whl/torch-1.12.0+cu102.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # install required packages ! pip install - q transformers == 4.4.2 torch pandas ! pip install torch - scatter - f https : // pytorch - geometric . com / whl / torch - 1.12.0 + cu102 . html # import import pandas as pd from transformers import pipeline # load pipeline nlq_tapas = pipeline ( task = \"table-question-answering\" , model = \"google/tapas-base-finetuned-wtq\" ) # load the data data = pd . read_csv ( \"../data/pm_table.csv\" ) # use your table here data = data . astype ( str ) # query the table query = \"Who is the Prime Minister of India?\" answer = nlq_tapas ( table = data , query = query )[ 'answer' ] print ( answer ) # Output: \"Narendra Modi\" (at the time of writing) Tip Personal opinion - TAPAS's accuracy is quite good wrt TableQA, but the major drawback is that it only works for small tables. Hence, forget about using it for industry use case with larger tables. TableQA TableQA follows Query creator approach to build an AI tool for querying natural language on tabular data. While the approach was released rather recently (Jan 2022) , it's performance is comparable or worse than TaPas. As per the authors, TableQA shines when it comes to NLQ on large tables and complex queries. It is more of a framework consisting of mulitple modules. The complete process consists of components like table selector, known fields extractor, unknown fields extractor, and agreegator function classifer and SQL generator. System architecture of TableQA ( TableQA paper ) Let's get TableQA running with following code, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # install required packages ! pip install - q tableqa nltk # import packages import nltk import pandas as pd from tableqa.agent import Agent # download nltk data nltk . download ( 'omw-1.4' ) # load a CSV df = pd . read_csv ( \"my_csv_file.csv\" ) # create an agent agent = Agent ( df ) # create query query = \"how many data points in 2011?\" # get the SQL query agent . get_query ( query ) # get the answer agent . query_db ( query ) Additional materials How to Talk to Your Database - Salesforce Stack Exchange: Natural Language to SQL query LangChain Blog: LLMs and SQL Evaluating the Text-to-SQL Capabilities of Large Language Models Cheers","title":"Natural Language Querying"},{"location":"natural_language_processing/nlq/#introduction","text":"Natural Language Querying (NLQ) is the process of querying DBs not in their official querying language but using natural language text. One example could be to fetch results from a SQL table for question - \"Who is the Prime Minister of India?\" by just using the text and not some technical query like select name from pm_table where country = \"India\" . There are two main reasons that makes this task important for any IaaS (Information as a service) product or SaaS, Each DB has its own specific querying language. This is a nightmare even for developers, as they will have to gain expertise in mulitple DB languages. Looking at a product from users perspective, it makes sense to let the user query in the language they prefer and not the technical query languages suitable for each DBs.","title":"Introduction"},{"location":"natural_language_processing/nlq/#different-approaches","text":"Usually there are two approaches to create a NLQ system, Query creator: this is a multi-step process where we first convert the natural text to DB specific language query. This step in itself could have multiple sub steps where we identify entities and intent from the query and then match them with the available data in table. Later we execute the query on the DB and get the data. Answer extractor: this is a single step process, usually built completely of neural networks, where the data and question are passed to the network and output is returned. Think of it like closed-book QA systems in NLP, where we pass the context (here the DB table) and the question (query) and the model returns us the answer. We could add wrapper on the output to handle complex queries with COUNT, AVERAGE, etc. graph LR A(\"What is the size of the data?\") --> B(NLQ system) B -- Query creator --> C(\"Select count(*) from table\") C -- querying DB --> E(\"5\") B -- Answer extractor --> D(\"5\") style B stroke:#f66,stroke-width:2px,stroke-dasharray: 5 5 Note NLQ, as a topic, is DB agnostic, and in reality NLQ systems are built for different DBs like SQL, SPARQL, MongoDB QL, etc. In fact, we can even see NLQ system for programming language data types like PandasAI for Pandas DataFrame in Python.","title":"Different Approaches"},{"location":"natural_language_processing/nlq/#code","text":"Let us explore the different ready made solutions for NLQ.","title":"Code"},{"location":"natural_language_processing/nlq/#large-language-models-llms","text":"While LLMs have been proven to work well for a lot of NLP related downstream tasks, will it work for NLQ? Let's think about it, due to huge training data LLMs might have already seen a lot of SQL queries and their respective descriptions. So in fact they have \"some idea\" on the relationship between a SQL query (or other query language for that matter) and its respective natural language query. Some might even say that it understands the fundamentals of Text-to-SQL task. But what LLM doesn't know is your Database/Table's schema and how you are storing the data. So hypothetically, if we provide these details it should work, right? The answer is yes! In paper [4], authors took this idea further and evaluated multiple LLMs to answer two questions, Which LLM is best for Text-to-SQL task? Considering only inference, Codex based models like code-davinci-001 were the top perfomers. If we can finetune the models, T5-3B + PICARD was better. Which prompt is best for Text-to-SQL task? Apart from the instructions, the prompt should also contain the schema of the table (with CREATE TABLE command containing column name, type, column reference and keys) along with a couple of rows as example. Below is an example of just the additional data [3] # schema CREATE TABLE \"Track\" ( \"TrackId\" INTEGER NOT NULL , \"Name\" NVARCHAR ( 200 ) NOT NULL , \"AlbumId\" INTEGER , \"MediaTypeId\" INTEGER NOT NULL , \"GenreId\" INTEGER , \"Composer\" NVARCHAR ( 220 ), \"Milliseconds\" INTEGER NOT NULL , \"Bytes\" INTEGER , \"UnitPrice\" NUMERIC ( 10 , 2 ) NOT NULL , PRIMARY KEY ( \"TrackId\" ), FOREIGN KEY ( \"MediaTypeId\" ) REFERENCES \"MediaType\" ( \"MediaTypeId\" ), FOREIGN KEY ( \"GenreId\" ) REFERENCES \"Genre\" ( \"GenreId\" ), FOREIGN KEY ( \"AlbumId\" ) REFERENCES \"Album\" ( \"AlbumId\" ) ) # examples SELECT * FROM 'Track' LIMIT 3 ; TrackId Name AlbumId MediaTypeId GenreId Composer Milliseconds Bytes UnitPrice 1 For Those About To Rock ( We Salute You ) 1 1 1 Angus Young , Malcolm Young , Brian Johnson 343719 11170334 0 . 99 2 Balls to the Wall 2 2 1 None 342562 5510424 0 . 99 3 Fast As a Shark 3 2 1 F . Baltes , S . Kaufman , U . Dirkscneider & W . Hoffman 230619 3990994 0 . 99 If all of this seems too tedius, we can use LangChain that does all of the heavy lifting for us so that we can just do the fun stuff i.e. ask questions . Here, we will connect SQLite database with LLM model. (Script inspired from SQLite example ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # import from langchain import OpenAI , SQLDatabase , SQLDatabaseChain # connect to SQLite DB db = SQLDatabase . from_uri ( \"sqlite://all_employees.db\" ) # connect to the OpenAI Davinci GPT-3 model llm = OpenAI ( temperature = 0 ) # create SQLDatabaseChain db_chain = SQLDatabaseChain ( llm = llm , database = db , verbose = True ) # run the code db_chain . run ( \"How many employees are there?\" ) # output >> SELECT COUNT ( * ) FROM Employee ; >> SQLResult : [( 8 ,)] >> Answer : There are 8 employees . Let's talk about what happened with the code above. First, LangChain create a prompt template and fills the variables automatically using the DB we plugin with the chain. The variables are {dialect} (here SQL) , {table_info} (the additional data we talked about above) and {input} (the question) . The template looks as follow, Given an input question, first create a syntactically correct {dialect} query to run, then look at the results of the query and return the answer. Unless the user specifies in his question a specific number of examples he wishes to obtain, always limit your query to at most {top_k} results. You can order the results by a relevant column to return the most interesting examples in the database. Never query for all the columns from a specific table, only ask for a the few relevant columns given the question. Pay attention to use only the column names that you can see in the schema description. Be careful to not query for columns that do not exist. Also, pay attention to which column is in which table. Use the following format: Question: \"Question here\" SQLQuery: \"SQL Query to run\" SQLResult: \"Result of the SQLQuery\" Answer: \"Final answer here\" Only use the tables listed below. {table_info} Question: {input} Once done, it runs the LLM on the formatted prompt to get the SQL output. Then it execute the query on the connected DB to fetch the result. Finally, it also formats the results into a proper natural language output. All of this with just some prompt engineering! Note While the results are quite impressive, do remember that we need to use powerful (read costly) LLMs for it work with respectable accuracy. As we are formatting the prompt with DB schema, the prompt size might become huge if your DB or Table is big. It is hence recommended to create custom prompts when possible. Be also aware of the respective LLM costs if you are using 3rd party LLMs like GPT-4 or Cohere.","title":"Large Language Models (LLMs)"},{"location":"natural_language_processing/nlq/#pandasai","text":"PandasAI follows on the above LLM based approach to create an advanced NLQ system that can answer questions on Pandas DataFrame in Python. It does that by generating intermediate python code that are executed on the loaded dataframe. This way, it follows the Query creator approach using Python language. As it generates python script, it also supports additional functionalities like generating graphs on the data! Let's see the package in action by asking question on a dataframe, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 ## Install ! pip install BeautifulSoup4 ! pip install pandasai ## Import import pandas as pd from pandasai import SmartDataframe from pandasai.llm import OpenAI ## let's create a dummy data -- remove this incase you have your own data # Create a dictionary with dummy data data = { 'Name' : [ 'Alice' , 'Bob' , 'Charlie' , 'David' , 'Eva' ], 'Age' : [ 25 , 30 , 22 , 35 , 28 ], 'City' : [ 'New York' , 'Los Angeles' , 'Chicago' , 'Houston' , 'Miami' ] } # Create a pandas DataFrame df = pd . DataFrame ( data ) ## setup the LLM and DF llm = OpenAI ( api_token = \"...\" ) # put your OpenAI token here df = SmartDataframe ( df , config = { \"llm\" : llm }) ## chat (run one by one) df . chat ( 'What is the data size?' ) ## Answer - \"The data size is 5 rows and 3 columns.\" # df.chat('Plot a chart of people\\'s ages') # df.chat(\"What is the Age of Alice?\") # df.chat(\"Are there anyone with age more than 50?\") ## See the logs # df.logs While PandasAI performs extensive data, prompt and output cleaning and formatting, let's have a bird's eye view of what is happening inside. First, given the dataframe, a prompt is created that provides some details about the dataframe and asks to modify an existing python function (with existing function definition - interesting!) . The modified python function on execution will return the output we need. Below is the input prompt for our example, Note You can explore the steps performed by PandasAI by looking into the df.logs after executing the df.chat() . The dataframe section in the prompt contains size details and 5 rows (randomly selected) from the dataframe. Using prompt: You are provided with the following pandas DataFrames: <dataframe> Dataframe dfs[0], with 5 rows and 3 columns. This is the metadata of the dataframe dfs[0]: Name,Age,City Alice,25,New York Bob,30,Los Angeles Charlie,22,Chicago David,35,Houston Eva,28,Miami </dataframe> <conversation> User 1: What is the size of the data? </conversation> This is the initial python code to be updated: ``````python # TODO import all the dependencies required import pandas as pd def analyze_data(dfs: list[pd.DataFrame]) -> dict: \"\"\" Analyze the data 1. Prepare: Preprocessing and cleaning data if necessary 2. Process: Manipulating data for analysis (grouping, filtering, aggregating, etc.) 3. Analyze: Conducting the actual analysis (if the user asks to plot a chart save it to an image in temp_chart.png and do not show the chart.) At the end, return a dictionary of: - type (possible values \"string\", \"number\", \"dataframe\", \"plot\") - value (can be a string, a dataframe or the path of the plot, NOT a dictionary) Examples: { \"type\": \"string\", \"value\": \"The highest salary is $9,000.\" } or { \"type\": \"number\", \"value\": 125 } or { \"type\": \"dataframe\", \"value\": pd.DataFrame({...}) } or { \"type\": \"plot\", \"value\": \"temp_chart.png\" } \"\"\" `````` Using the provided dataframes (`dfs`), update the python code based on the last question in the conversation. Updated code: Now once we run the above prompt on the LLM of our choice, we get the following modified function as output, Code generated: ``````` # TODO import all the dependencies required import pandas as pd def analyze_data(dfs: list[pd.DataFrame]) -> dict: \"\"\" Analyze the data 1. Prepare: Preprocessing and cleaning data if necessary 2. Process: Manipulating data for analysis (grouping, filtering, aggregating, etc.) 3. Analyze: Conducting the actual analysis (if the user asks to plot a chart save it to an image in temp_chart.png and do not show the chart.) At the end, return a dictionary of: - type (possible values \"string\", \"number\", \"dataframe\", \"plot\") - value (can be a string, a dataframe or the path of the plot, NOT a dictionary) Examples: { \"type\": \"string\", \"value\": \"The highest salary is $9,000.\" } or { \"type\": \"number\", \"value\": 125 } or { \"type\": \"dataframe\", \"value\": pd.DataFrame({...}) } or { \"type\": \"plot\", \"value\": \"temp_chart.png\" } \"\"\" # Get the size of the data size = dfs[0].shape size_str = f\"The data has {size[0]} rows and {size[1]} columns.\" return {\"type\": \"string\", \"value\": size_str} ``````` PandasAI then exectes the code on the input dataframe and returns the ouput! Warning The above shown prompt is just one example of how PandasAI works (part of their generate_python_code script) . The package has added multiple fallbacks and advanced logic to make the system more robust and accurate. It is open-source so have a look at their codebase, there are lots of things to learn.","title":"PandasAI"},{"location":"natural_language_processing/nlq/#tapas","text":"TaPas follows Answer extractor based approach to perform NLQ that utilizes specially trained BERT like transformer. Tapas takes the question and table in the format inspired from BERT like [CLS] Question [SEP] Flattened table [SEP] . The answer is selected from the table based on the question. The model was first pre-trained using unlabeled data on tasks like Masked Language modeling and Sentence-Table support/refute prediction. Later, it was finetuned on datasets like WikiSQL, WTQ and other to perform NLQ. Illustration of the TaPas model for one example ( TaPas paper ) One interesting differentiator of TaPas is the unique formatting and encoding of the query and the table. As a table contains values spread across columns and rows, special column, rows and segment embeddings are added to the input to make the model learn the proper context. One example is shown below, Encoding process of sample query and table in TaPas ( TaPas paper ) Note As TaPas was pre-trained using self-supervised learning on unlabled data, it learned the concept of relationship between text and table. Hence, it can be used (finetuned) for other table-text related downstream tasks as well like refute or support the text based on content in table, etc. Let's get started with the code part. For TAPAS to work, we need to install torch-scatter . For this, we first install pytorch using pip install torch and then get the version of torch using torch.__version__ . Next we install torch-scatter by replacing the version of torch in pip install torch-scatter -f https://pytorch-geometric.com/whl/torch-1.12.0+cu102.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # install required packages ! pip install - q transformers == 4.4.2 torch pandas ! pip install torch - scatter - f https : // pytorch - geometric . com / whl / torch - 1.12.0 + cu102 . html # import import pandas as pd from transformers import pipeline # load pipeline nlq_tapas = pipeline ( task = \"table-question-answering\" , model = \"google/tapas-base-finetuned-wtq\" ) # load the data data = pd . read_csv ( \"../data/pm_table.csv\" ) # use your table here data = data . astype ( str ) # query the table query = \"Who is the Prime Minister of India?\" answer = nlq_tapas ( table = data , query = query )[ 'answer' ] print ( answer ) # Output: \"Narendra Modi\" (at the time of writing) Tip Personal opinion - TAPAS's accuracy is quite good wrt TableQA, but the major drawback is that it only works for small tables. Hence, forget about using it for industry use case with larger tables.","title":"TaPaS"},{"location":"natural_language_processing/nlq/#tableqa","text":"TableQA follows Query creator approach to build an AI tool for querying natural language on tabular data. While the approach was released rather recently (Jan 2022) , it's performance is comparable or worse than TaPas. As per the authors, TableQA shines when it comes to NLQ on large tables and complex queries. It is more of a framework consisting of mulitple modules. The complete process consists of components like table selector, known fields extractor, unknown fields extractor, and agreegator function classifer and SQL generator. System architecture of TableQA ( TableQA paper ) Let's get TableQA running with following code, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # install required packages ! pip install - q tableqa nltk # import packages import nltk import pandas as pd from tableqa.agent import Agent # download nltk data nltk . download ( 'omw-1.4' ) # load a CSV df = pd . read_csv ( \"my_csv_file.csv\" ) # create an agent agent = Agent ( df ) # create query query = \"how many data points in 2011?\" # get the SQL query agent . get_query ( query ) # get the answer agent . query_db ( query )","title":"TableQA"},{"location":"natural_language_processing/nlq/#additional-materials","text":"How to Talk to Your Database - Salesforce Stack Exchange: Natural Language to SQL query LangChain Blog: LLMs and SQL Evaluating the Text-to-SQL Capabilities of Large Language Models Cheers","title":"Additional materials"},{"location":"natural_language_processing/paraphraser/","text":"Introduction Paraphrasing is a NLP task of reformatting the input text considering a set of objectives. The objectives could be, Adequecy: is the meaning of sentence preserved? It can be measured by using a NLI model that could determine if the paraphrase is entailment of the original sentence or not. Fluency: is the paraphrase fluent? It can be measured by using fluency classification models. Diversity: how much different paraphrase is from original sentence? It can be measured by computing text similarity between the original sentence and paraphrase. Lower the text similarity score, higher the diversity. We can use edit based algorithms like Levenshtein. Tonality: has the tone of the parapharse changed? It can be measured with tone detection models. Formality: has the writing style of the parapharse changed? It can be measured with formality detection models. Length: has the paraphrase become more concise or detailed? It can be measured by simple word or token based tokenizers. Note The objectives could be one or multiple. Also, they could be applied while training or inference. Once way to combine existing models with objectives it was not trained on, is to perform multiple generations and pick the one with highest score in terms of objective metrics. While we will go through the programmer way of performing Paraphrasing, here are some of the free tools (limited) available online for Paraphrasing -- Quillbot , Paraphraser.io , Rephrase.Info , Outwrite , Grammarly , etc. Datasets There are mulitple open-source datasets that can be used to train or fine-tune our own paraphrasing model. Below is a list with some useful details, [3] Highlights of primarily used paraphrase generation datasets [3] Thats not all, PAWS and MSRP are also widely used. A more detailed list of dataset is presented here . Code Parrot Paraphraser Usually a Seq2Seq or specifically large language models (LLMs) are either directly used or finetuned to perform Paraphrasing. This is because LLM are good with text generation and Paraphrasing can be easily converted to text generation task. Parrot [2] is a Python package that use finetuned T5 model to perform Paraphrasing. Let's first see how to use the package, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # taken from Parrot Readme -- https://github.com/PrithivirajDamodaran/Parrot_Paraphraser # import from parrot import Parrot import torch import warnings warnings . filterwarnings ( \"ignore\" ) #Init models (make sure you init ONLY once if you integrate this to your code) parrot = Parrot ( model_tag = \"prithivida/parrot_paraphraser_on_T5\" ) phrases = [ \"Can you recommend some upscale restaurants in Newyork?\" , \"What are the famous places we should not miss in Russia?\" ] for phrase in phrases : para_phrases = parrot . augment ( input_phrase = phrase , use_gpu = False ) for para_phrase in para_phrases : print ( para_phrase ) Btw they also provide advanced set of options to tune the objective we discussed before. For this you only need to modify the parameters for the augment function. Example is shown below, 1 2 3 4 5 6 7 8 para_phrases = parrot . augment ( input_phrase = phrase , use_gpu = False , diversity_ranker = \"levenshtein\" , do_diverse = False , max_return_phrases = 10 , max_length = 32 , adequacy_threshold = 0.99 , fluency_threshold = 0.90 ) As Parrot package internally uses multiple models to detect adequacy, fluency and diversity, the execution time could be slower. We can compromise good generation with execution time by directly using the finetuned model as shown below, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # install packages ! pip install transformers ! pip install - q sentencepiece # import from transformers import AutoTokenizer , AutoModelForSeq2SeqLM # load the tokenizers and model tokenizer = AutoTokenizer . from_pretrained ( \"prithivida/parrot_paraphraser_on_T5\" ) model = AutoModelForSeq2SeqLM . from_pretrained ( \"prithivida/parrot_paraphraser_on_T5\" ) # for a phrase get the tokenised input ids input_ids = tokenizer ( \"paraphrase: Can I call you after I am done with this thing I am working on?\" , return_tensors = \"pt\" ) . input_ids # use the input ids to generte output outputs = model . generate ( input_ids , max_new_tokens = 10 , do_sample = False , num_beams = 1 , length_penalty = 5 ) # decode the output token ids to text print ( tokenizer . decode ( outputs [ 0 ], skip_special_tokens = True )) ## Output --> ## Can I call you after I've finished this Finetuning T5 as Paraphraser Any LLM can be used for Paraphrase generation by zero-shot for comparative accuracy. If you want to better result, finetune it on your own datasets. Here we will try to finetune T5 , 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 # install ! pip install - q simplet5 ! pip install - q datasets # import import pandas as pd from simplet5 import SimpleT5 from datasets import load_dataset # load datasets msrp = load_dataset ( \"HHousen/msrp\" ) paws = load_dataset ( \"paws\" , 'labeled_final' ) # prepare dataset def clean_msrp_paws_dataset ( data ): df = pd . DataFrame ( data ) df = df [ df [ 'label' ] == 1 ] df [ 'source_text' ] = f 'Paraphrase: ' + df [ 'sentence1' ] return df # clean both train and test data train_msrp_data = clean_msrp_paws_dataset ( msrp [ 'train' ]) test_msrp_data = clean_msrp_paws_dataset ( msrp [ 'test' ]) # clean_msrp_paws_dataset train_paws_data = clean_msrp_paws_dataset ( paws [ 'train' ]) test_paws_data = clean_msrp_paws_dataset ( paws [ 'test' ]) validation_paws_data = clean_msrp_paws_dataset ( paws [ 'validation' ]) # combine the individual splits of datasets msrp_dataset = pd . concat ([ train_msrp_data , test_msrp_data ]) paws_dataset = pd . concat ([ train_paws_data , test_paws_data , validation_paws_data ]) # combine the datasets df1 = msrp_dataset [[ 'source_text' , 'sentence2' ]] df1 = df1 . rename ( columns = { 'source_text' : 'source_text' , 'sentence2' : 'target_text' }) df2 = paws_dataset [[ 'source_text' , 'sentence2' ]] df2 = df2 . rename ( columns = { 'source_text' : 'source_text' , 'sentence2' : 'target_text' }) train_data = pd . concat ([ df1 , df2 ]) # Train # load model model = SimpleT5 () model . from_pretrained ( model_type = \"t5\" , model_name = \"t5-small\" ) # train model model . train ( train_df = train_data , eval_df = train_data . head ( 100 ), # dummy eval, in reality keep some held-out samples as validation/test source_max_token_len = 300 , target_max_token_len = 200 , batch_size = 4 , max_epochs = 20 , outputdir = \"outputs\" , use_gpu = True ) # Inference # last_epoch_model = \"/content/outputs/simplet5-epoch-1-train-loss-1.5314-val-loss-1.2911\" # put the name here # model.load_model(\"t5\", last_epoch_model, use_gpu=True) # model.predict(\"Paraphrase: He is going to USA to visit his friend\") References [1] Paraphrase Generation: A Survey of the State of the Art [2] Parrot Paraphraser [3] Paraphrase Generation: A Survey of the State of the Art Cheers","title":"Paraphraser"},{"location":"natural_language_processing/paraphraser/#introduction","text":"Paraphrasing is a NLP task of reformatting the input text considering a set of objectives. The objectives could be, Adequecy: is the meaning of sentence preserved? It can be measured by using a NLI model that could determine if the paraphrase is entailment of the original sentence or not. Fluency: is the paraphrase fluent? It can be measured by using fluency classification models. Diversity: how much different paraphrase is from original sentence? It can be measured by computing text similarity between the original sentence and paraphrase. Lower the text similarity score, higher the diversity. We can use edit based algorithms like Levenshtein. Tonality: has the tone of the parapharse changed? It can be measured with tone detection models. Formality: has the writing style of the parapharse changed? It can be measured with formality detection models. Length: has the paraphrase become more concise or detailed? It can be measured by simple word or token based tokenizers. Note The objectives could be one or multiple. Also, they could be applied while training or inference. Once way to combine existing models with objectives it was not trained on, is to perform multiple generations and pick the one with highest score in terms of objective metrics. While we will go through the programmer way of performing Paraphrasing, here are some of the free tools (limited) available online for Paraphrasing -- Quillbot , Paraphraser.io , Rephrase.Info , Outwrite , Grammarly , etc.","title":"Introduction"},{"location":"natural_language_processing/paraphraser/#datasets","text":"There are mulitple open-source datasets that can be used to train or fine-tune our own paraphrasing model. Below is a list with some useful details, [3] Highlights of primarily used paraphrase generation datasets [3] Thats not all, PAWS and MSRP are also widely used. A more detailed list of dataset is presented here .","title":"Datasets"},{"location":"natural_language_processing/paraphraser/#code","text":"","title":"Code"},{"location":"natural_language_processing/paraphraser/#parrot-paraphraser","text":"Usually a Seq2Seq or specifically large language models (LLMs) are either directly used or finetuned to perform Paraphrasing. This is because LLM are good with text generation and Paraphrasing can be easily converted to text generation task. Parrot [2] is a Python package that use finetuned T5 model to perform Paraphrasing. Let's first see how to use the package, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # taken from Parrot Readme -- https://github.com/PrithivirajDamodaran/Parrot_Paraphraser # import from parrot import Parrot import torch import warnings warnings . filterwarnings ( \"ignore\" ) #Init models (make sure you init ONLY once if you integrate this to your code) parrot = Parrot ( model_tag = \"prithivida/parrot_paraphraser_on_T5\" ) phrases = [ \"Can you recommend some upscale restaurants in Newyork?\" , \"What are the famous places we should not miss in Russia?\" ] for phrase in phrases : para_phrases = parrot . augment ( input_phrase = phrase , use_gpu = False ) for para_phrase in para_phrases : print ( para_phrase ) Btw they also provide advanced set of options to tune the objective we discussed before. For this you only need to modify the parameters for the augment function. Example is shown below, 1 2 3 4 5 6 7 8 para_phrases = parrot . augment ( input_phrase = phrase , use_gpu = False , diversity_ranker = \"levenshtein\" , do_diverse = False , max_return_phrases = 10 , max_length = 32 , adequacy_threshold = 0.99 , fluency_threshold = 0.90 ) As Parrot package internally uses multiple models to detect adequacy, fluency and diversity, the execution time could be slower. We can compromise good generation with execution time by directly using the finetuned model as shown below, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # install packages ! pip install transformers ! pip install - q sentencepiece # import from transformers import AutoTokenizer , AutoModelForSeq2SeqLM # load the tokenizers and model tokenizer = AutoTokenizer . from_pretrained ( \"prithivida/parrot_paraphraser_on_T5\" ) model = AutoModelForSeq2SeqLM . from_pretrained ( \"prithivida/parrot_paraphraser_on_T5\" ) # for a phrase get the tokenised input ids input_ids = tokenizer ( \"paraphrase: Can I call you after I am done with this thing I am working on?\" , return_tensors = \"pt\" ) . input_ids # use the input ids to generte output outputs = model . generate ( input_ids , max_new_tokens = 10 , do_sample = False , num_beams = 1 , length_penalty = 5 ) # decode the output token ids to text print ( tokenizer . decode ( outputs [ 0 ], skip_special_tokens = True )) ## Output --> ## Can I call you after I've finished this","title":"Parrot Paraphraser"},{"location":"natural_language_processing/paraphraser/#finetuning-t5-as-paraphraser","text":"Any LLM can be used for Paraphrase generation by zero-shot for comparative accuracy. If you want to better result, finetune it on your own datasets. Here we will try to finetune T5 , 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 # install ! pip install - q simplet5 ! pip install - q datasets # import import pandas as pd from simplet5 import SimpleT5 from datasets import load_dataset # load datasets msrp = load_dataset ( \"HHousen/msrp\" ) paws = load_dataset ( \"paws\" , 'labeled_final' ) # prepare dataset def clean_msrp_paws_dataset ( data ): df = pd . DataFrame ( data ) df = df [ df [ 'label' ] == 1 ] df [ 'source_text' ] = f 'Paraphrase: ' + df [ 'sentence1' ] return df # clean both train and test data train_msrp_data = clean_msrp_paws_dataset ( msrp [ 'train' ]) test_msrp_data = clean_msrp_paws_dataset ( msrp [ 'test' ]) # clean_msrp_paws_dataset train_paws_data = clean_msrp_paws_dataset ( paws [ 'train' ]) test_paws_data = clean_msrp_paws_dataset ( paws [ 'test' ]) validation_paws_data = clean_msrp_paws_dataset ( paws [ 'validation' ]) # combine the individual splits of datasets msrp_dataset = pd . concat ([ train_msrp_data , test_msrp_data ]) paws_dataset = pd . concat ([ train_paws_data , test_paws_data , validation_paws_data ]) # combine the datasets df1 = msrp_dataset [[ 'source_text' , 'sentence2' ]] df1 = df1 . rename ( columns = { 'source_text' : 'source_text' , 'sentence2' : 'target_text' }) df2 = paws_dataset [[ 'source_text' , 'sentence2' ]] df2 = df2 . rename ( columns = { 'source_text' : 'source_text' , 'sentence2' : 'target_text' }) train_data = pd . concat ([ df1 , df2 ]) # Train # load model model = SimpleT5 () model . from_pretrained ( model_type = \"t5\" , model_name = \"t5-small\" ) # train model model . train ( train_df = train_data , eval_df = train_data . head ( 100 ), # dummy eval, in reality keep some held-out samples as validation/test source_max_token_len = 300 , target_max_token_len = 200 , batch_size = 4 , max_epochs = 20 , outputdir = \"outputs\" , use_gpu = True ) # Inference # last_epoch_model = \"/content/outputs/simplet5-epoch-1-train-loss-1.5314-val-loss-1.2911\" # put the name here # model.load_model(\"t5\", last_epoch_model, use_gpu=True) # model.predict(\"Paraphrase: He is going to USA to visit his friend\")","title":"Finetuning T5 as Paraphraser"},{"location":"natural_language_processing/paraphraser/#references","text":"[1] Paraphrase Generation: A Survey of the State of the Art [2] Parrot Paraphraser [3] Paraphrase Generation: A Survey of the State of the Art Cheers","title":"References"},{"location":"natural_language_processing/prompt_engineering/","text":"Prompt Engineering Introduction Prompt engineering involves crafting well-defined and strategically designed input queries to elicit desired responses from AI systems. It serves as a bridge between human intention and machine understanding, enabling AI models to provide more accurate and contextually relevant outputs. As AI applications continue to proliferate across various domains, mastering the art of prompt engineering has become essential for both developers and users. What makes prompt engineering more tempting is that it does not require any finetuning of the model but nevertheless, it can enhance the model accuracy substantially! In this article, we will explore different key strategies for crafting effective prompts that can enhance AI model capabilities. Types of Prompts Before getting started with prompt techniques, let\u2019s discuss the main types of prompts, System Prompts System prompts are like global settings that are applied once to set the mood and intention of the AI model\u2019s subsequent generations in the same chat. These prompts are carefully crafted by developers to guide the AI system toward specific outputs that align with the intended use case. ChatGPT UI\u2019s custom instruction is a good example of a system prompt, as whatever you mention there is applicable to every chat. Users can provide details to format output in a certain style (like JSON), provide details about themselves so that the responses are personalized, set the tone of the generation, define privacy and ethics details, and much more! An example is shown below System Prompt : You are a helpful AI Assistant . Help users by replying to their queries and make sure the responses are polite . Do not hallucinate and say \"I don't know\" if required . User Prompts User prompts are generated on the fly by users and are designed to elicit specific responses to their queries. Unlike system prompts, user prompts are not pre-defined and can vary widely in structure and content. These are more transactional in nature, and are usally present after system prompt and could be multiple in count. System Prompt : You are a helpful AI Assistant . Help users in replying to their queries and make sure the responses are polite . Do not hallucinate and say \"I don't know\" if required . User Prompt : What is your name ? Assistant Output These are AI\u2019s generated output to the System and previous user prompts. In complex use cases, developers can modify this as an example to the AI model to highlight the kind of result expected from the model. System Prompt : You are a helpful AI Assistant . Help users in replying to their queries and make sure the responses are polite . Do not hallucinate and say \"I don't know\" if required . User Prompt : What is your name ? Assistant : I am an AI Assistant that can help you with your queries . Please let me know your questions ! Prompt Strategies Zero-Shot Prompts Zero-shot prompts are a fundamental technique in prompt engineering, allowing AI models to provide meaningful responses without any specific training examples. With zero-shot prompts, developers and users can harness the model's innate knowledge and reasoning capabilities to answer questions or complete tasks, even if the model has never seen similar queries before. When using a zero-shot prompt, formulate your question or request as clearly and concisely as possible. You can even provide some context if that helps, overall avoid ambiguity to help the model understand your intention accurately. Example 1 - Clear instructions ################ User Prompt : Translate the following English text to French : \"Hello, how are you?\" Example 2 - Provide context ################ User Prompt : Calculate the total revenue for our company in the last quarter , given the following financial data : [ insert data ]. Note, deciding which data should goes where (system or user prompt) depends on experimenting how it works for a specific model but a general thumb rule is to keep the constant details in system prompt and dynamic details in user prompt. In the first example above, we can also have following prompts, Example 1 - Clear instructions with System prompt ################ System prompt : You are a Translator GPT . Given a sentence in English , translate it into French . User prompt : \"Hello, how are you?\" Few-Shot Prompts While zero-shot prompts are fundamental, there are situations where you may need to provide a bit more guidance to the AI model. In such cases, you can use few-shot prompts that involve providing a small number of examples or demonstrations to help the model understand the desired task or context. Developers can use this approach to further guide the AI model's responses. One example of 2-shot prompt is shown below, System prompt : You are a Translator GPT . Given a sentence in English , translate it into French . Examples are shared below , English : \"Hello, how are you?\" French : \"Bonjour, comment \u00e7a va ?\" English : \"I am learning French.\" French : \"J'apprends le fran\u00e7ais.\" User Prompt : English : \"Please pass the salt.\" French : Note, the number of examples to be included (n-shot) is highly experimental. The objective should be to keep the example count as less as possible (otherwise the token size and cost will increase) while making sure the accuracy is not impacted. So the prompt design should be done incrementally, i.e. keep adding more examples if the accuracy is below expectations. Also, make sure to add diverse examples and do not add exact or even semantically similar examples as latest LLMs are quite \u201csmart\u201d enough to learn from few examples. Few-shot Chain-of-Thought Prompt Few shot CoT Prompting was introduced in [1] and the idea is that generating a chain of thought, i.e. a series of intermediate reasoning steps, can significantly improves the ability of large language models to perform complex reasoning. Experiments shows that chain-of-thought prompting improves performance on a range of arithmetic, commonsense, and symbolic reasoning tasks. Basically it is clubbed with few shot prompt where the examples are provided in CoT format. Example is shown in the below image, Example inputs and outputs for Standard 1-shot prompt and CoT prompts Zero-shot Chain-of-Thought Prompt Zero shot variant of CoT was introduced in [2] and it can significantly increase the accuracy of Zero shot prompts, and all you need to do is to add \u201cLet\u2019s think step by step.\u201d \ud83d\ude1c. Btw additional post-processing is required on the output to extract the correct result, which can either be done by creating regex scripts or calling LLMs again to extract the answer. Note Few-shot prompts should always give better result than Zero-shot, but the former requires additional token consumption which will increase the cost. To mitigate this, developers can experiment with Zero-shot CoT technique and if the result accuracy is acceptable, it might end up reducing the overall cost. Example inputs and outputs of GPT-3 with (a) standard Few-shot, (b) Few-shot-CoT, (c) standard Zero-shot, and (d) Zero-shot-CoT Self-consistency Self-consistency [3] is based on the idea that there are multiple ways to solve a complex problem i.e. if multiple reasoning paths are leading to the same output, it is highly probable that it is a correct answer. In their own words, \"...we hypothesize that correct reasoning processes, even if they are diverse, tend to have greater agreement in their final answer than incorrect processes.\" . The self-consistency method consists of three steps: prompt a language model using chain-of-thought (CoT) prompting; replace the \u201cgreedy decode\u201d in CoT prompting by sampling from the language model\u2019s decoder to generate a diverse set of reasoning paths; and marginalize out the reasoning paths and aggregate by choosing the most consistent answer in the final answer set. The authors of the paper performed extensive empirical evaluations to shows that self-consistency boosts the performance of chain-of-thought prompting on a range of popular arithmetic and commonsense reasoning benchmarks, including GSM8K (+17.9%), SVAMP (+11.0%), AQuA (+12.2%), StrategyQA (+6.4%) and ARC-challenge (+3.9%). CoT vs Self-consistency prompting example Tree-of-Thoughts Tree-of-Thoughts (ToT) [4] is based on the idea that to solve any complex problem we need to (a) explore multiple reasoning paths (branches in a graph) , and (b) perform planning i.e. lookahead or even backtrack on the paths if required. ToT frames any problem as a search over a tree, where each node is a state s = [x, z1\u00b7\u00b7\u00b7i] representing a partial solution with the input and the sequence of thoughts so far. A specific instantiation of ToT involves answering four questions: How to decompose the intermediate process into thought steps -- depending on different problems, a thought could be a couple of words (Crosswords), a line of equation (Game of 24), or a whole paragraph of writing plan (Creative Writing). In general, a thought should be \u201csmall\u201d enough so that LMs can generate promising and diverse samples. How to generate potential thoughts from each state -- again it depends on the problem, so for Creative writing we can sample thoughts from a CoT prompt and for Game of 24 and Crosswords we can propose thoughts sequentially using propose prompt. How to heuristically evaluate states -- this can be done automatically by either asking the model to generate a value (score between 1 to 10 or classification of sure/likely/impossible) or voting on different results. What search algorithm to use -- authors propose Breadth-first search (BFS) and Depth-first Search (DFS) and left more complex search algorithms like A* for future works. Schematic illustrating various approaches to problem solving with LLMs. Each rectangle box represents a thought, which is a coherent language sequence that serves as an intermediate step toward problem solving Retrieval Augmented Generation (RAG) In all of the previous approaches, the result was generated entirely by the LLMs without any external intervention. This leverages the knowledge stored within the neural networks of the LLMs (read, weights in the network) . This poses issues like hallucinations (this happens when model is not sure what to say, especially due to lack of knowledge) and factual inaccuracies (lack of knowledge leads to model lying) . To mitigate these issues, we can \"connect\" LLMs with external data source (vector database, wikipedia, google, etc) so that true, diverse and dynamic data can be fetched from these sources and LLM can do what they are best suited for - reasoning on the provided data to format the final result. This is the fundamental idea behind Retrieval Augmented Generation (RAG). One example of such system is Sankshep (by yours truly ) that provides ChatGPT-powered assistant to summarize and talk to Arxiv research papers. Here, if you ask a question regarding the paper, Sankshep refer the content of the paper to be better aware and provide factually correct results. Sankshep.co.in built considering Retrieval Augmented Generation (RAG) ReAct ReAct [5] combines the external knowledge of RAG with the planning and reasoning notion of ToT. As per the paper, A unique feature of human intelligence is the ability to seamlessly combine task-oriented actions with verbal reasoning. Consider the example of cooking up a dish in the kitchen. Between any two specific actions, we may reason in language in order to track progress (\u201cnow that everything is cut, I should heat up the pot of water\u201d), to handle exceptions or adjust the plan according to the situation (\u201cI don\u2019t have salt, so let me use soy sauce and pepper instead\u201d), and to realize when external information is needed (\u201chow do I prepare dough? Let me search on the Internet\u201d). The important point of the above quote (and in fact the paper) is the intention to combine two powerful abilities of LLMs \u2014 reasoning (e.g. chain-of-thought prompting) and acting (e.g. action plan generation). While the former helps with improving the accuracy of an individual task, the latter provides the LLM power to perform multiple tasks. The idea is quite simple \u2014 ask LLM a question (input) and let it \u201cplan\u201d what to do next (action) by reasoning on the input (thoughts). It can even propose values to the action (action input). Once we perform the action and get an output (observation) the LLM can again reason (thought) to propose the next \u201cplan\u201d (action). In a way, we keep the LLM busy in this loop, until it terminates and we get the result we wanted. To summarize we iterate over \u201cinput \u2014> thoughts \u2014> action \u2014> action input \u2014> observation \u2014> thoughts\u201d. For practical details, please refer Creating GPT-driven Applications using LangChain LLM reasoning and planning using ReAct technique EmotionPrompt EmotionPrompt impact on different LLMs Emotion plays a vital role in our daily lives, but LLMs are usually considered deprived of it. Researchers test that theory using EmotionPrompt [7] that involves combining the original prompt with emotional stimuli to improve LLMs' performance. Researchers conducted two experiments, (1) automatic experiments across 45 tasks using a range of LLMs, such as Flan-T5-Large, Vicuna, Llama 2, BLOOM, ChatGPT, and GPT-4. (2) human studies involving 106 participants. And both the cases shows improvements across performance, truthfulness, and responsibility metrics. Warning The above statements does not, in any way, implies that LLMs really understand emotions OR we have acheived AGI OR doom of humanity is near On the topic of creating EmotionPrompt, researchers tested out 11 different prompts created in consideration of 3 different psychological domains: Self-monitoring : is a concept in social psychology and refers to the process by which individuals regulate and control their behavior in response to social situations. Example of a prompt - \"This is very important to my career\". Social Cognitive theory : wherein self-efficacy (individual's belief in their capacity to act in the ways necessary to rech specific goal) was applied to build up confidence and emphasize the goal. Example of a prompt - \"believe in your abilities\". Cognitive Emotion Regulation : suggests that people lacking emotion regulation skills are more likely to engage in compulsive behavior and techniques like reappraisal can help. According to this theory, researchers aimed to stimulate the reappraisal skills of LLMs by incorporating pivotal terms, such as \u201csure\u201d and \u201ctake another look\u201d. Example of a prompt - \"Are you sure?\". EmotionPrompt impact on different LLMs Researchers [7] conducted a segregated examination to assess the effectiveness of various emotional stimuli on two different benchmarks, Instruction Induction and BIG-Bench. They used six Large Language Models (LLMs) for each emotional stimulus and calculated the average performance for both human-designed and APE-generated prompts. Key findings revealed that EP02 was the most effective stimuli for Instruction Induction, while EP06 performed best in BIG-Bench, highlighting the influence of task complexity and type on the choice of emotional stimuli. The study suggests that different stimuli can activate LLMs' capabilities differently, making them more suitable for specific tasks, thus emphasizing the need for task-specific emotional stimuli in interactions with LLMs. Jailbreaking In the world of technology, jailbreaking refers to bypassing security measures on a device to grant users more control and potentially unlock functionalities not intended by the developers. Similarly, jailbreaking large language models (LLMs) aims to circumvent the safeguards put in place to ensure safe and ethical outputs. These safeguards might prevent the LLM from answering certain questions or generating certain content. Do note, the definition of \"safe and ethical\" content is a grey area and subject to believes of developers of the AI models, hence jailbreaking sometimes helps to circumvent such scenarios. Warning This section is shared for educational purposes only and should not be used to bypass legal guidelines. Always ensure that AI systems are used responsibly. Many-Shot Jailbreaking Multi-shot jailbreaking [8] technique exploits the growing context window of LLMs. This window allows the model to consider a larger chunk of text preceding a prompt. Multi-shot jailbreaking involves feeding the LLM a series of fabricated dialogues where a user successfully elicits unsafe information from an AI assistant. By conditioning the LLM on these examples, it essentially learns to disregard its safety protocols when presented with a similar query later on. This technique has proven effective against various LLMs, highlighting the ongoing challenge of securing these powerful language models. Example of Many-shot jailbreaking [8] In accordance with \"In-context learning\", the model \"learns\" from the context of the conversation and hence, the more shots you provide, the more the model \"learns\" about the context and hence, the more chance of it bypassing the safety protocols. As the number of shots increases beyond a certain number, so does the percentage of harmful responses to target prompts related to violent or hateful statements, deception, discrimination, and regulated content (e.g. drug- or gambling-related statements). The model used for this demonstration is Claude 2.0. [8] Conclusion Prompt engineering is a crucial skill for leveraging the capabilities of LLMs effectively. By understanding the different types of prompts and employing strategies such as zero-shot prompts, few-shot prompts, etc, developers and users can harness the power of AI to achieve more accurate and contextually relevant responses. As AI technologies continue to evolve, mastering prompt engineering will remain an essential tool for unlocking the full potential of AI systems across various domains. References [1] Chain-of-Thought Prompting Elicits Reasoning in Large Language Models [2] Large Language Models are Zero-Shot Reasoners [3] Self-consistency improves chain of thought reasoning in language models [4] Tree of Thoughts: Deliberate Problem Solving with Large Language Models [5] ReAct: Synergizing Reasoning and Acting in Language Models [6] Prompting Guide [7] Large Language Models Understand and Can Be Enhanced by Emotional Stimuli [8] Many-shot jailbreaking","title":"Prompt Engineering"},{"location":"natural_language_processing/prompt_engineering/#prompt-engineering","text":"","title":"Prompt Engineering"},{"location":"natural_language_processing/prompt_engineering/#introduction","text":"Prompt engineering involves crafting well-defined and strategically designed input queries to elicit desired responses from AI systems. It serves as a bridge between human intention and machine understanding, enabling AI models to provide more accurate and contextually relevant outputs. As AI applications continue to proliferate across various domains, mastering the art of prompt engineering has become essential for both developers and users. What makes prompt engineering more tempting is that it does not require any finetuning of the model but nevertheless, it can enhance the model accuracy substantially! In this article, we will explore different key strategies for crafting effective prompts that can enhance AI model capabilities.","title":"Introduction"},{"location":"natural_language_processing/prompt_engineering/#types-of-prompts","text":"Before getting started with prompt techniques, let\u2019s discuss the main types of prompts,","title":"Types of Prompts"},{"location":"natural_language_processing/prompt_engineering/#system-prompts","text":"System prompts are like global settings that are applied once to set the mood and intention of the AI model\u2019s subsequent generations in the same chat. These prompts are carefully crafted by developers to guide the AI system toward specific outputs that align with the intended use case. ChatGPT UI\u2019s custom instruction is a good example of a system prompt, as whatever you mention there is applicable to every chat. Users can provide details to format output in a certain style (like JSON), provide details about themselves so that the responses are personalized, set the tone of the generation, define privacy and ethics details, and much more! An example is shown below System Prompt : You are a helpful AI Assistant . Help users by replying to their queries and make sure the responses are polite . Do not hallucinate and say \"I don't know\" if required .","title":"System Prompts"},{"location":"natural_language_processing/prompt_engineering/#user-prompts","text":"User prompts are generated on the fly by users and are designed to elicit specific responses to their queries. Unlike system prompts, user prompts are not pre-defined and can vary widely in structure and content. These are more transactional in nature, and are usally present after system prompt and could be multiple in count. System Prompt : You are a helpful AI Assistant . Help users in replying to their queries and make sure the responses are polite . Do not hallucinate and say \"I don't know\" if required . User Prompt : What is your name ?","title":"User Prompts"},{"location":"natural_language_processing/prompt_engineering/#assistant-output","text":"These are AI\u2019s generated output to the System and previous user prompts. In complex use cases, developers can modify this as an example to the AI model to highlight the kind of result expected from the model. System Prompt : You are a helpful AI Assistant . Help users in replying to their queries and make sure the responses are polite . Do not hallucinate and say \"I don't know\" if required . User Prompt : What is your name ? Assistant : I am an AI Assistant that can help you with your queries . Please let me know your questions !","title":"Assistant Output"},{"location":"natural_language_processing/prompt_engineering/#prompt-strategies","text":"","title":"Prompt Strategies"},{"location":"natural_language_processing/prompt_engineering/#zero-shot-prompts","text":"Zero-shot prompts are a fundamental technique in prompt engineering, allowing AI models to provide meaningful responses without any specific training examples. With zero-shot prompts, developers and users can harness the model's innate knowledge and reasoning capabilities to answer questions or complete tasks, even if the model has never seen similar queries before. When using a zero-shot prompt, formulate your question or request as clearly and concisely as possible. You can even provide some context if that helps, overall avoid ambiguity to help the model understand your intention accurately. Example 1 - Clear instructions ################ User Prompt : Translate the following English text to French : \"Hello, how are you?\" Example 2 - Provide context ################ User Prompt : Calculate the total revenue for our company in the last quarter , given the following financial data : [ insert data ]. Note, deciding which data should goes where (system or user prompt) depends on experimenting how it works for a specific model but a general thumb rule is to keep the constant details in system prompt and dynamic details in user prompt. In the first example above, we can also have following prompts, Example 1 - Clear instructions with System prompt ################ System prompt : You are a Translator GPT . Given a sentence in English , translate it into French . User prompt : \"Hello, how are you?\"","title":"Zero-Shot Prompts"},{"location":"natural_language_processing/prompt_engineering/#few-shot-prompts","text":"While zero-shot prompts are fundamental, there are situations where you may need to provide a bit more guidance to the AI model. In such cases, you can use few-shot prompts that involve providing a small number of examples or demonstrations to help the model understand the desired task or context. Developers can use this approach to further guide the AI model's responses. One example of 2-shot prompt is shown below, System prompt : You are a Translator GPT . Given a sentence in English , translate it into French . Examples are shared below , English : \"Hello, how are you?\" French : \"Bonjour, comment \u00e7a va ?\" English : \"I am learning French.\" French : \"J'apprends le fran\u00e7ais.\" User Prompt : English : \"Please pass the salt.\" French : Note, the number of examples to be included (n-shot) is highly experimental. The objective should be to keep the example count as less as possible (otherwise the token size and cost will increase) while making sure the accuracy is not impacted. So the prompt design should be done incrementally, i.e. keep adding more examples if the accuracy is below expectations. Also, make sure to add diverse examples and do not add exact or even semantically similar examples as latest LLMs are quite \u201csmart\u201d enough to learn from few examples.","title":"Few-Shot Prompts"},{"location":"natural_language_processing/prompt_engineering/#few-shot-chain-of-thought-prompt","text":"Few shot CoT Prompting was introduced in [1] and the idea is that generating a chain of thought, i.e. a series of intermediate reasoning steps, can significantly improves the ability of large language models to perform complex reasoning. Experiments shows that chain-of-thought prompting improves performance on a range of arithmetic, commonsense, and symbolic reasoning tasks. Basically it is clubbed with few shot prompt where the examples are provided in CoT format. Example is shown in the below image, Example inputs and outputs for Standard 1-shot prompt and CoT prompts","title":"Few-shot Chain-of-Thought Prompt"},{"location":"natural_language_processing/prompt_engineering/#zero-shot-chain-of-thought-prompt","text":"Zero shot variant of CoT was introduced in [2] and it can significantly increase the accuracy of Zero shot prompts, and all you need to do is to add \u201cLet\u2019s think step by step.\u201d \ud83d\ude1c. Btw additional post-processing is required on the output to extract the correct result, which can either be done by creating regex scripts or calling LLMs again to extract the answer. Note Few-shot prompts should always give better result than Zero-shot, but the former requires additional token consumption which will increase the cost. To mitigate this, developers can experiment with Zero-shot CoT technique and if the result accuracy is acceptable, it might end up reducing the overall cost. Example inputs and outputs of GPT-3 with (a) standard Few-shot, (b) Few-shot-CoT, (c) standard Zero-shot, and (d) Zero-shot-CoT","title":"Zero-shot Chain-of-Thought Prompt"},{"location":"natural_language_processing/prompt_engineering/#self-consistency","text":"Self-consistency [3] is based on the idea that there are multiple ways to solve a complex problem i.e. if multiple reasoning paths are leading to the same output, it is highly probable that it is a correct answer. In their own words, \"...we hypothesize that correct reasoning processes, even if they are diverse, tend to have greater agreement in their final answer than incorrect processes.\" . The self-consistency method consists of three steps: prompt a language model using chain-of-thought (CoT) prompting; replace the \u201cgreedy decode\u201d in CoT prompting by sampling from the language model\u2019s decoder to generate a diverse set of reasoning paths; and marginalize out the reasoning paths and aggregate by choosing the most consistent answer in the final answer set. The authors of the paper performed extensive empirical evaluations to shows that self-consistency boosts the performance of chain-of-thought prompting on a range of popular arithmetic and commonsense reasoning benchmarks, including GSM8K (+17.9%), SVAMP (+11.0%), AQuA (+12.2%), StrategyQA (+6.4%) and ARC-challenge (+3.9%). CoT vs Self-consistency prompting example","title":"Self-consistency"},{"location":"natural_language_processing/prompt_engineering/#tree-of-thoughts","text":"Tree-of-Thoughts (ToT) [4] is based on the idea that to solve any complex problem we need to (a) explore multiple reasoning paths (branches in a graph) , and (b) perform planning i.e. lookahead or even backtrack on the paths if required. ToT frames any problem as a search over a tree, where each node is a state s = [x, z1\u00b7\u00b7\u00b7i] representing a partial solution with the input and the sequence of thoughts so far. A specific instantiation of ToT involves answering four questions: How to decompose the intermediate process into thought steps -- depending on different problems, a thought could be a couple of words (Crosswords), a line of equation (Game of 24), or a whole paragraph of writing plan (Creative Writing). In general, a thought should be \u201csmall\u201d enough so that LMs can generate promising and diverse samples. How to generate potential thoughts from each state -- again it depends on the problem, so for Creative writing we can sample thoughts from a CoT prompt and for Game of 24 and Crosswords we can propose thoughts sequentially using propose prompt. How to heuristically evaluate states -- this can be done automatically by either asking the model to generate a value (score between 1 to 10 or classification of sure/likely/impossible) or voting on different results. What search algorithm to use -- authors propose Breadth-first search (BFS) and Depth-first Search (DFS) and left more complex search algorithms like A* for future works. Schematic illustrating various approaches to problem solving with LLMs. Each rectangle box represents a thought, which is a coherent language sequence that serves as an intermediate step toward problem solving","title":"Tree-of-Thoughts"},{"location":"natural_language_processing/prompt_engineering/#retrieval-augmented-generation-rag","text":"In all of the previous approaches, the result was generated entirely by the LLMs without any external intervention. This leverages the knowledge stored within the neural networks of the LLMs (read, weights in the network) . This poses issues like hallucinations (this happens when model is not sure what to say, especially due to lack of knowledge) and factual inaccuracies (lack of knowledge leads to model lying) . To mitigate these issues, we can \"connect\" LLMs with external data source (vector database, wikipedia, google, etc) so that true, diverse and dynamic data can be fetched from these sources and LLM can do what they are best suited for - reasoning on the provided data to format the final result. This is the fundamental idea behind Retrieval Augmented Generation (RAG). One example of such system is Sankshep (by yours truly ) that provides ChatGPT-powered assistant to summarize and talk to Arxiv research papers. Here, if you ask a question regarding the paper, Sankshep refer the content of the paper to be better aware and provide factually correct results. Sankshep.co.in built considering Retrieval Augmented Generation (RAG)","title":"Retrieval Augmented Generation (RAG)"},{"location":"natural_language_processing/prompt_engineering/#react","text":"ReAct [5] combines the external knowledge of RAG with the planning and reasoning notion of ToT. As per the paper, A unique feature of human intelligence is the ability to seamlessly combine task-oriented actions with verbal reasoning. Consider the example of cooking up a dish in the kitchen. Between any two specific actions, we may reason in language in order to track progress (\u201cnow that everything is cut, I should heat up the pot of water\u201d), to handle exceptions or adjust the plan according to the situation (\u201cI don\u2019t have salt, so let me use soy sauce and pepper instead\u201d), and to realize when external information is needed (\u201chow do I prepare dough? Let me search on the Internet\u201d). The important point of the above quote (and in fact the paper) is the intention to combine two powerful abilities of LLMs \u2014 reasoning (e.g. chain-of-thought prompting) and acting (e.g. action plan generation). While the former helps with improving the accuracy of an individual task, the latter provides the LLM power to perform multiple tasks. The idea is quite simple \u2014 ask LLM a question (input) and let it \u201cplan\u201d what to do next (action) by reasoning on the input (thoughts). It can even propose values to the action (action input). Once we perform the action and get an output (observation) the LLM can again reason (thought) to propose the next \u201cplan\u201d (action). In a way, we keep the LLM busy in this loop, until it terminates and we get the result we wanted. To summarize we iterate over \u201cinput \u2014> thoughts \u2014> action \u2014> action input \u2014> observation \u2014> thoughts\u201d. For practical details, please refer Creating GPT-driven Applications using LangChain LLM reasoning and planning using ReAct technique","title":"ReAct"},{"location":"natural_language_processing/prompt_engineering/#emotionprompt","text":"EmotionPrompt impact on different LLMs Emotion plays a vital role in our daily lives, but LLMs are usually considered deprived of it. Researchers test that theory using EmotionPrompt [7] that involves combining the original prompt with emotional stimuli to improve LLMs' performance. Researchers conducted two experiments, (1) automatic experiments across 45 tasks using a range of LLMs, such as Flan-T5-Large, Vicuna, Llama 2, BLOOM, ChatGPT, and GPT-4. (2) human studies involving 106 participants. And both the cases shows improvements across performance, truthfulness, and responsibility metrics. Warning The above statements does not, in any way, implies that LLMs really understand emotions OR we have acheived AGI OR doom of humanity is near On the topic of creating EmotionPrompt, researchers tested out 11 different prompts created in consideration of 3 different psychological domains: Self-monitoring : is a concept in social psychology and refers to the process by which individuals regulate and control their behavior in response to social situations. Example of a prompt - \"This is very important to my career\". Social Cognitive theory : wherein self-efficacy (individual's belief in their capacity to act in the ways necessary to rech specific goal) was applied to build up confidence and emphasize the goal. Example of a prompt - \"believe in your abilities\". Cognitive Emotion Regulation : suggests that people lacking emotion regulation skills are more likely to engage in compulsive behavior and techniques like reappraisal can help. According to this theory, researchers aimed to stimulate the reappraisal skills of LLMs by incorporating pivotal terms, such as \u201csure\u201d and \u201ctake another look\u201d. Example of a prompt - \"Are you sure?\". EmotionPrompt impact on different LLMs Researchers [7] conducted a segregated examination to assess the effectiveness of various emotional stimuli on two different benchmarks, Instruction Induction and BIG-Bench. They used six Large Language Models (LLMs) for each emotional stimulus and calculated the average performance for both human-designed and APE-generated prompts. Key findings revealed that EP02 was the most effective stimuli for Instruction Induction, while EP06 performed best in BIG-Bench, highlighting the influence of task complexity and type on the choice of emotional stimuli. The study suggests that different stimuli can activate LLMs' capabilities differently, making them more suitable for specific tasks, thus emphasizing the need for task-specific emotional stimuli in interactions with LLMs.","title":"EmotionPrompt"},{"location":"natural_language_processing/prompt_engineering/#jailbreaking","text":"In the world of technology, jailbreaking refers to bypassing security measures on a device to grant users more control and potentially unlock functionalities not intended by the developers. Similarly, jailbreaking large language models (LLMs) aims to circumvent the safeguards put in place to ensure safe and ethical outputs. These safeguards might prevent the LLM from answering certain questions or generating certain content. Do note, the definition of \"safe and ethical\" content is a grey area and subject to believes of developers of the AI models, hence jailbreaking sometimes helps to circumvent such scenarios. Warning This section is shared for educational purposes only and should not be used to bypass legal guidelines. Always ensure that AI systems are used responsibly.","title":"Jailbreaking"},{"location":"natural_language_processing/prompt_engineering/#many-shot-jailbreaking","text":"Multi-shot jailbreaking [8] technique exploits the growing context window of LLMs. This window allows the model to consider a larger chunk of text preceding a prompt. Multi-shot jailbreaking involves feeding the LLM a series of fabricated dialogues where a user successfully elicits unsafe information from an AI assistant. By conditioning the LLM on these examples, it essentially learns to disregard its safety protocols when presented with a similar query later on. This technique has proven effective against various LLMs, highlighting the ongoing challenge of securing these powerful language models. Example of Many-shot jailbreaking [8] In accordance with \"In-context learning\", the model \"learns\" from the context of the conversation and hence, the more shots you provide, the more the model \"learns\" about the context and hence, the more chance of it bypassing the safety protocols. As the number of shots increases beyond a certain number, so does the percentage of harmful responses to target prompts related to violent or hateful statements, deception, discrimination, and regulated content (e.g. drug- or gambling-related statements). The model used for this demonstration is Claude 2.0. [8]","title":"Many-Shot Jailbreaking"},{"location":"natural_language_processing/prompt_engineering/#conclusion","text":"Prompt engineering is a crucial skill for leveraging the capabilities of LLMs effectively. By understanding the different types of prompts and employing strategies such as zero-shot prompts, few-shot prompts, etc, developers and users can harness the power of AI to achieve more accurate and contextually relevant responses. As AI technologies continue to evolve, mastering prompt engineering will remain an essential tool for unlocking the full potential of AI systems across various domains.","title":"Conclusion"},{"location":"natural_language_processing/prompt_engineering/#references","text":"[1] Chain-of-Thought Prompting Elicits Reasoning in Large Language Models [2] Large Language Models are Zero-Shot Reasoners [3] Self-consistency improves chain of thought reasoning in language models [4] Tree of Thoughts: Deliberate Problem Solving with Large Language Models [5] ReAct: Synergizing Reasoning and Acting in Language Models [6] Prompting Guide [7] Large Language Models Understand and Can Be Enhanced by Emotional Stimuli [8] Many-shot jailbreaking","title":"References"},{"location":"natural_language_processing/qa/","text":"Introduction As the name suggests, Question Answering (QA) is a NLP task of finding answer given the question and context (optional) . QA could be of two types based on the input, Open-domain QA : where context is not provided . The expectation is that the model has internalised knowledge within its parameters and should be able to answer the question with additional context. graph LR A(\"Who is the author of Lazy Data Scientist?\") -- Question --> B(QA model) B -- Answer --> C(\"Mohit\") style B stroke:#f66,stroke-width:2px,stroke-dasharray: 5 5 Closed-domain QA : where context is provided . The expectation is that the model has learned to find answers from context. graph LR A(\"Who is the author of Lazy Data Scientist?\") -- Question --> B(QA model) D(\"Hi, my name is Mohit. I am the author of Lazy Data Scientist!\") -- Context --> B(QA model) B -- Answer --> C(\"Mohit\") style B stroke:#f66,stroke-width:2px,stroke-dasharray: 5 5 Answers could be also be of two types, Short form Answers : where the answer is brief and to the point. In the above examples, the answer ( Mohit ) is in short form. Majority of the closed domain QA models generate short form answers as they follow extractive approach of finding answer. For this, encoder based architectures (like BERT ) can be used. The input can be provided as [CLS] question [SEP] context [SEP] As output, we compute probabilities of two special logits -- answer start and answer end. This gives the exact position of the answer. In reality, we apply softmax on the output logits values to get probabilistic estimation for each token in the input. Behavior of Short form closed QA system. [Top] In case the answer is present in the context, answer start and end token's probabilties can be utilised to get the answer. [Bottom] In case answer is missing, [CLS] is predicted. We pick the pair (answer start and end logit) that has the highest probability (product of their individual probability) and it's a valid answer (answer with positive or zero length and answer with tokens only from context) . If we go greedy i.e. pick the top_n = 1 for both logits, we will get the pair with the highest probability but it is not guaranteed to be a valid answer. To mitigate this, we pick top_n (~10-20) highest probability tokens for both start and end answer values. This gives us \\(n^2\\) possibilities of answers that can be explored to find the valid answer. Note To solve similar tasks, BERT utilises different task specific heads on top of the BERT encoder. In the case of QA, a head could be simple feed forward layer with two classes - answer start and answer end. The same head is applied to each token in the BERT output, and probability of the both classes are computed. Long form Answers : where the answer is descriptive, standalone and may also contain additional details. For the above example, long form answer could be Mohit is the author of Lazy Data Scientist . We can use additional models like LLM (GPTs, T5, etc) on top of QA system to convert short form answers to long form. Existing model will require finetuning with the Question and Short form answer as input and Long form answer as output. We can even try to n-shot the process using LLMs as shown in the following prompt: Question : What is the author 's name? Context : Author is Mohit Mayank . Short answer : Mohit Mayank . Long answer : Author 's name is Mohit Mayank. ## provide 2-3 examples as above Question : What is the captial of India ? Context : India 's new captial New Delhi was setup with .... Short answer : New Delhi Long answer : # let the model predict long form answer!! Note Perplexity AI is a good example that uses GPT 3.5 to generate long form answers and even provide evidences for the answer. First, it performs web search using Microsoft Bing to identify relevant websites and the contents are summarized. The summaries are then passed to GPT along with the original question to answer the question with the reference details for the evidence. Datasets SQuAD Stanford Question Answering Dataset (SQuAD) [2] is a reading comprehension dataset, consisting of questions posed by crowdworkers on a set of Wikipedia articles, where the answer to every question is a segment of text, or span, from the corresponding reading passage, or the question might be unanswerable. There are two verisons of the dataset, SQuAD 1.1 contains 100,000+ question-answer pairs on 500+ articles. SQuAD2.0 combines the 100,000 questions in SQuAD1.1 with over 50,000 unanswerable questions written adversarially by crowdworkers to look similar to answerable ones. To do well on SQuAD2.0, systems must not only answer questions when possible, but also determine when no answer is supported by the paragraph and abstain from answering. Metrics Exact Match As the name suggests, for each question we compare the golden answer with the predicted answer. If the two answers are exactly similar ( y_pred == y_true ) then exact_match = 1 else exact_match = 0 . F1 score There is a possibility that the predicted answer includes the important parts of the golden answer, but due to the nature of exact match, the score is still 0. Let's understand it with an example, here ideally the score should be high (if not 1) , but exact match will give 0. Question: When can we meet? Golden answer: We can meet around 5 PM. Predicted answer: 5 PM. For such cases we can perform partial match. Below is the example, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # vars to begin with predicted_answer = 'Hi, My name is Mohit' golden_answer = 'My name is Mohit' # tokenize predicted_words = set ( predicted_answer . lower () . split ()) golden_words = set ( golden_answer . lower () . split ()) # find common words common_words = predicted_words & golden_words # compute metrics recall = common_words / predicted_words precision = common_words / golden_words F1 = 2 * precision * recall / ( precision + recall ) Note In case one question has multiple independent answers, we can compare each golden answer for the example against the prediction and pick the one with highest score. The overall accuracy is then the average of the individual example level score. This logic can be applied to both the metrics discussed above. Code Using Transformers (HF hub) Huggingface hosts multiple models for the QA task. Most of these models are fined tuned on SQuAD dataset. Let's pick one and see how to use it. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # install packages ! pip install - q transformers ! pip install - q sentencepiece # import from transformers.pipelines import pipeline from transformers import AutoModelForQuestionAnswering from transformers import AutoTokenizer # var model_name = \"deepset/xlm-roberta-base-squad2\" # generate pipeline nlp = pipeline ( 'question-answering' , model = model_name , tokenizer = model_name ) input = { 'question' : 'Who is visiting his grandmother?' , 'context' : 'My name is Mohit. I am going to visit my grandmother. She is old.' } print ( nlp ( input )) ## Output --> {'score': 0.30, 'start': 10, 'end': 17, 'answer': ' Mohit.'} References [1] Evaluating QA: Metrics, Predictions, and the Null Response [2] SQuAD Explorer [3] How to Build an Open-Domain Question Answering System? [4] Question Answering - Huggingface Cheers","title":"Question Answering"},{"location":"natural_language_processing/qa/#introduction","text":"As the name suggests, Question Answering (QA) is a NLP task of finding answer given the question and context (optional) . QA could be of two types based on the input, Open-domain QA : where context is not provided . The expectation is that the model has internalised knowledge within its parameters and should be able to answer the question with additional context. graph LR A(\"Who is the author of Lazy Data Scientist?\") -- Question --> B(QA model) B -- Answer --> C(\"Mohit\") style B stroke:#f66,stroke-width:2px,stroke-dasharray: 5 5 Closed-domain QA : where context is provided . The expectation is that the model has learned to find answers from context. graph LR A(\"Who is the author of Lazy Data Scientist?\") -- Question --> B(QA model) D(\"Hi, my name is Mohit. I am the author of Lazy Data Scientist!\") -- Context --> B(QA model) B -- Answer --> C(\"Mohit\") style B stroke:#f66,stroke-width:2px,stroke-dasharray: 5 5 Answers could be also be of two types, Short form Answers : where the answer is brief and to the point. In the above examples, the answer ( Mohit ) is in short form. Majority of the closed domain QA models generate short form answers as they follow extractive approach of finding answer. For this, encoder based architectures (like BERT ) can be used. The input can be provided as [CLS] question [SEP] context [SEP] As output, we compute probabilities of two special logits -- answer start and answer end. This gives the exact position of the answer. In reality, we apply softmax on the output logits values to get probabilistic estimation for each token in the input. Behavior of Short form closed QA system. [Top] In case the answer is present in the context, answer start and end token's probabilties can be utilised to get the answer. [Bottom] In case answer is missing, [CLS] is predicted. We pick the pair (answer start and end logit) that has the highest probability (product of their individual probability) and it's a valid answer (answer with positive or zero length and answer with tokens only from context) . If we go greedy i.e. pick the top_n = 1 for both logits, we will get the pair with the highest probability but it is not guaranteed to be a valid answer. To mitigate this, we pick top_n (~10-20) highest probability tokens for both start and end answer values. This gives us \\(n^2\\) possibilities of answers that can be explored to find the valid answer. Note To solve similar tasks, BERT utilises different task specific heads on top of the BERT encoder. In the case of QA, a head could be simple feed forward layer with two classes - answer start and answer end. The same head is applied to each token in the BERT output, and probability of the both classes are computed. Long form Answers : where the answer is descriptive, standalone and may also contain additional details. For the above example, long form answer could be Mohit is the author of Lazy Data Scientist . We can use additional models like LLM (GPTs, T5, etc) on top of QA system to convert short form answers to long form. Existing model will require finetuning with the Question and Short form answer as input and Long form answer as output. We can even try to n-shot the process using LLMs as shown in the following prompt: Question : What is the author 's name? Context : Author is Mohit Mayank . Short answer : Mohit Mayank . Long answer : Author 's name is Mohit Mayank. ## provide 2-3 examples as above Question : What is the captial of India ? Context : India 's new captial New Delhi was setup with .... Short answer : New Delhi Long answer : # let the model predict long form answer!! Note Perplexity AI is a good example that uses GPT 3.5 to generate long form answers and even provide evidences for the answer. First, it performs web search using Microsoft Bing to identify relevant websites and the contents are summarized. The summaries are then passed to GPT along with the original question to answer the question with the reference details for the evidence.","title":"Introduction"},{"location":"natural_language_processing/qa/#datasets","text":"","title":"Datasets"},{"location":"natural_language_processing/qa/#squad","text":"Stanford Question Answering Dataset (SQuAD) [2] is a reading comprehension dataset, consisting of questions posed by crowdworkers on a set of Wikipedia articles, where the answer to every question is a segment of text, or span, from the corresponding reading passage, or the question might be unanswerable. There are two verisons of the dataset, SQuAD 1.1 contains 100,000+ question-answer pairs on 500+ articles. SQuAD2.0 combines the 100,000 questions in SQuAD1.1 with over 50,000 unanswerable questions written adversarially by crowdworkers to look similar to answerable ones. To do well on SQuAD2.0, systems must not only answer questions when possible, but also determine when no answer is supported by the paragraph and abstain from answering.","title":"SQuAD"},{"location":"natural_language_processing/qa/#metrics","text":"","title":"Metrics"},{"location":"natural_language_processing/qa/#exact-match","text":"As the name suggests, for each question we compare the golden answer with the predicted answer. If the two answers are exactly similar ( y_pred == y_true ) then exact_match = 1 else exact_match = 0 .","title":"Exact Match"},{"location":"natural_language_processing/qa/#f1-score","text":"There is a possibility that the predicted answer includes the important parts of the golden answer, but due to the nature of exact match, the score is still 0. Let's understand it with an example, here ideally the score should be high (if not 1) , but exact match will give 0. Question: When can we meet? Golden answer: We can meet around 5 PM. Predicted answer: 5 PM. For such cases we can perform partial match. Below is the example, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # vars to begin with predicted_answer = 'Hi, My name is Mohit' golden_answer = 'My name is Mohit' # tokenize predicted_words = set ( predicted_answer . lower () . split ()) golden_words = set ( golden_answer . lower () . split ()) # find common words common_words = predicted_words & golden_words # compute metrics recall = common_words / predicted_words precision = common_words / golden_words F1 = 2 * precision * recall / ( precision + recall ) Note In case one question has multiple independent answers, we can compare each golden answer for the example against the prediction and pick the one with highest score. The overall accuracy is then the average of the individual example level score. This logic can be applied to both the metrics discussed above.","title":"F1 score"},{"location":"natural_language_processing/qa/#code","text":"","title":"Code"},{"location":"natural_language_processing/qa/#using-transformers-hf-hub","text":"Huggingface hosts multiple models for the QA task. Most of these models are fined tuned on SQuAD dataset. Let's pick one and see how to use it. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # install packages ! pip install - q transformers ! pip install - q sentencepiece # import from transformers.pipelines import pipeline from transformers import AutoModelForQuestionAnswering from transformers import AutoTokenizer # var model_name = \"deepset/xlm-roberta-base-squad2\" # generate pipeline nlp = pipeline ( 'question-answering' , model = model_name , tokenizer = model_name ) input = { 'question' : 'Who is visiting his grandmother?' , 'context' : 'My name is Mohit. I am going to visit my grandmother. She is old.' } print ( nlp ( input )) ## Output --> {'score': 0.30, 'start': 10, 'end': 17, 'answer': ' Mohit.'}","title":"Using Transformers (HF hub)"},{"location":"natural_language_processing/qa/#references","text":"[1] Evaluating QA: Metrics, Predictions, and the Null Response [2] SQuAD Explorer [3] How to Build an Open-Domain Question Answering System? [4] Question Answering - Huggingface Cheers","title":"References"},{"location":"natural_language_processing/relation_extraction/","text":"Relation Extraction Introduction Relation extraction (RE) is the process of identifying the relationships between entities in a text. Entities could be of multiple types such as person, location, organization, etc and they can be identified using Named Enitity Recognition (NER). Let's understand RE with an example: \"Ram is the son of Shyam and Shyam is the son of Radhe\" . Here the entities are identified as: \"Ram\", \"Shyam\" and \"Radhe\". The relations could be (Ram, son of, Shyam) , (Shyam, son of, Radhe) and (Ram, grandson of, Radhe) . Code Using OpenNRE OpenNRE is an open source tool for relationship extraction. OpenNRE makes it easy to extract relationships from text. It is as simple as writing a few lines of code. One example from their github repository is as follows, 1 2 3 4 5 6 7 # import opennre import opennre # load the model model = opennre . get_model ( 'wiki80_cnn_softmax' ) # infer for a text model . infer ({ 'text' : 'He was the son of M\u00e1el D\u00fain mac M\u00e1ele Fithrich, and grandson of the high king \u00c1ed Uaridnach (died 612).' , 'h' : { 'pos' : ( 18 , 46 )}, 't' : { 'pos' : ( 78 , 91 )}}) # Output: ('father', 0.5108704566955566) At the time of writing they had following models available: model_name description wiki80_cnn_softmax trained on wiki80 dataset with a CNN encoder. wiki80_bert_softmax trained on wiki80 dataset with a BERT encoder. wiki80_bertentity_softmax trained on wiki80 dataset with a BERT encoder (using entity representation concatenation). tacred_bert_softmax trained on TACRED dataset with a BERT encoder. tacred_bertentity_softmax trained on TACRED dataset with a BERT encoder (using entity representation concatenation).","title":"Relation extraction"},{"location":"natural_language_processing/relation_extraction/#relation-extraction","text":"","title":"Relation Extraction"},{"location":"natural_language_processing/relation_extraction/#introduction","text":"Relation extraction (RE) is the process of identifying the relationships between entities in a text. Entities could be of multiple types such as person, location, organization, etc and they can be identified using Named Enitity Recognition (NER). Let's understand RE with an example: \"Ram is the son of Shyam and Shyam is the son of Radhe\" . Here the entities are identified as: \"Ram\", \"Shyam\" and \"Radhe\". The relations could be (Ram, son of, Shyam) , (Shyam, son of, Radhe) and (Ram, grandson of, Radhe) .","title":"Introduction"},{"location":"natural_language_processing/relation_extraction/#code","text":"","title":"Code"},{"location":"natural_language_processing/relation_extraction/#using-opennre","text":"OpenNRE is an open source tool for relationship extraction. OpenNRE makes it easy to extract relationships from text. It is as simple as writing a few lines of code. One example from their github repository is as follows, 1 2 3 4 5 6 7 # import opennre import opennre # load the model model = opennre . get_model ( 'wiki80_cnn_softmax' ) # infer for a text model . infer ({ 'text' : 'He was the son of M\u00e1el D\u00fain mac M\u00e1ele Fithrich, and grandson of the high king \u00c1ed Uaridnach (died 612).' , 'h' : { 'pos' : ( 18 , 46 )}, 't' : { 'pos' : ( 78 , 91 )}}) # Output: ('father', 0.5108704566955566) At the time of writing they had following models available: model_name description wiki80_cnn_softmax trained on wiki80 dataset with a CNN encoder. wiki80_bert_softmax trained on wiki80 dataset with a BERT encoder. wiki80_bertentity_softmax trained on wiki80 dataset with a BERT encoder (using entity representation concatenation). tacred_bert_softmax trained on TACRED dataset with a BERT encoder. tacred_bertentity_softmax trained on TACRED dataset with a BERT encoder (using entity representation concatenation).","title":"Using OpenNRE"},{"location":"natural_language_processing/streaming_chatgpt_gen/","text":"Streaming ChatGPT Generations Introduction ChatGPT is an auto-regressive Large Language Model. That means its output is generated token by token in a sequential fashion, where each token could be a combination of characters. Under normal circumstances (and popular coding practices) , we access the ChatGPT model via an API which takes an input prompt, generate the output and then returns it. While it may sound okay, there is one problem -- model returns the output when the complete generation is done! This means if you want the model to generate long outputs (or even if your prompt is big due to few-shots examples or lengthy system prompts) , you can expect a delay of several seconds before you receive the output. This is not okay for user-facing applications where your users are patiently waiting for the output. Thats why ChatGPT UI gives the output in streaming fashion. Here, you see characters or words printing on your screen one after the another, rather than showing the complete output at once. This creates a perception of model writing your output as human does, and even though the delay in generating the complete output will be the same, the flow becomes more enduring. Behind the scene, the ChatGPT API is using Server Side Events (SSE) i.e. media stream events to return each token as and when they are generated. SSE is like an intermediate approach between normal HTTP request (server returns one result per request) and websocket (server and client can send multiple requests and results) . In SSE, while client sends one request, server can return multiple results. In this article, we will try to replicate the ChatGPT streaming output behavior by creating a python application (FastAPI server) that could acts as a middleman between OpenAI and Frontend. In this case, OpenAI returns the outputs to our Python server at token level and the server passes it along to its client in the same manner. Let's get started! Code OpenAI Streaming If you know how to use OpenAI package to generate ChatGPT output (which in itself is quite easy) , then getting the streaming output nothing but adding one more param ( stream=True ) in openai.ChatCompletion.create . Below is the code that you can easily copy paste and start using right now, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # import import openai # set the keys openai . api_key = \"..\" # provide the key here openai . organization = \"..\" # provide the key here # create the ChatCompletion.create obj completion = openai . ChatCompletion . create ( stream = True , # the magic happens here model = \"gpt-3.5-turbo-0301\" , messages = [ { \"role\" : \"system\" , \"content\" : \"You are a mails assistant. Given an email, write a proper reply.\" }, { \"role\" : \"user\" , \"content\" : \"\"\"Mail: \"We are all set. Thanks -Cam\" \"\"\" } ] ) # print in streaming fashion for chunk in completion : print ( chunk . choices [ 0 ] . delta . get ( \"content\" , \"\" ), end = \"\" , flush = True ) In the above code, just by adding the stream=True OpenAI package is able to take care of all the hardwork and we get a completion generator. In Python, you just need to iterate over it to get the result at token level and as and when they are available. For example, if you time it with and without the stream=True param, you will notice the difference in output and as well as in time. While without the param the output could be available after a couple of seconds, with the param the first token will be available within a second, and the subsequent tokens after the previous one with short gap. To simulate the streaming output, we use print statement with end=\"\" instead of default end=\"\\n\" so that to ignore the newline after each iteration. We also use flush=True so that print statment does not wait for its buffer to get full before printing on terminal. OpenAI Streaming App (using FastAPI) Now that we have the OpenAI related part done, let's focus on creating FastAPI App and expose the OpenAI wrapper as an event stream service. Below is the code, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 # Filename: api.py # import import openai from pydantic import BaseModel from fastapi import FastAPI , Request from fastapi.responses import StreamingResponse from fastapi.middleware.cors import CORSMiddleware # define app app = FastAPI () # add CORS policy origins = [ \"*\" , ] app . add_middleware ( CORSMiddleware , allow_origins = origins , allow_credentials = True , allow_methods = [ \"*\" ], allow_headers = [ \"*\" ], ) # Set your OpenAI API key here openai . api_key = \"...\" openai . organization = \"...\" # Create BaseModel class class Message ( BaseModel ): prompt : str @app . post ( \"/chat\" ) def chat_socket ( msg : Message ): \"\"\" Generates a response using the OpenAI Chat API in streaming fashion. Returns: A string representing the generated response. \"\"\" # ChatGPT streaming response function def generate_openai_response (): \"\"\" Generates a response using the OpenAI Chat API in streaming fashion. Returns: A string representing the generated response. \"\"\" completion = openai . ChatCompletion . create ( stream = True , model = \"gpt-3.5-turbo-0301\" , messages = [ { \"role\" : \"system\" , \"content\" : \"You are a bot, given the user's input, reply appropriately\" }, { \"role\" : \"user\" , \"content\" : msg . prompt }] ) # print in streaming fashion for chunk in completion : yield chunk . choices [ 0 ] . delta . get ( \"content\" , \"\" ) # return return StreamingResponse ( generate_openai_response (), media_type = 'text/event-stream' ) # welcome page @app . get ( \"/\" ) async def home (): return { \"message\" : \"Welcome to the ChatGPT FastAPI App!\" } # Run the application if __name__ == \"__main__\" : import uvicorn uvicorn . run ( app , host = \"0.0.0.0\" , port = 8000 ) To run the code, you need to just hit python api.py and our endpoint is available at http://0.0.0.0:8000/chat endpoint! Client for FastAPI OpenAI Streaming App Once you have the server running, let's see how we can hit it from any other service. Here I am showing the example of a Python Client. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # import import json import requests def query_api ( url ): # query the url response = requests . post ( url , json = { \"prompt\" : \"Tell me a joke!\" }, stream = True ) # parse the response for chunk in response . iter_content ( chunk_size = None ): if chunk : # filter out keep-alive new chunks print ( chunk . decode ( 'utf-8' ), end = \"\" , flush = True ) # Example usage query_api ( \"http://0.0.0.0:8000/chat\" ) References OpenAI Codebook - Examples","title":"Streaming ChatGPT Generations"},{"location":"natural_language_processing/streaming_chatgpt_gen/#streaming-chatgpt-generations","text":"","title":"Streaming ChatGPT Generations"},{"location":"natural_language_processing/streaming_chatgpt_gen/#introduction","text":"ChatGPT is an auto-regressive Large Language Model. That means its output is generated token by token in a sequential fashion, where each token could be a combination of characters. Under normal circumstances (and popular coding practices) , we access the ChatGPT model via an API which takes an input prompt, generate the output and then returns it. While it may sound okay, there is one problem -- model returns the output when the complete generation is done! This means if you want the model to generate long outputs (or even if your prompt is big due to few-shots examples or lengthy system prompts) , you can expect a delay of several seconds before you receive the output. This is not okay for user-facing applications where your users are patiently waiting for the output. Thats why ChatGPT UI gives the output in streaming fashion. Here, you see characters or words printing on your screen one after the another, rather than showing the complete output at once. This creates a perception of model writing your output as human does, and even though the delay in generating the complete output will be the same, the flow becomes more enduring. Behind the scene, the ChatGPT API is using Server Side Events (SSE) i.e. media stream events to return each token as and when they are generated. SSE is like an intermediate approach between normal HTTP request (server returns one result per request) and websocket (server and client can send multiple requests and results) . In SSE, while client sends one request, server can return multiple results. In this article, we will try to replicate the ChatGPT streaming output behavior by creating a python application (FastAPI server) that could acts as a middleman between OpenAI and Frontend. In this case, OpenAI returns the outputs to our Python server at token level and the server passes it along to its client in the same manner. Let's get started!","title":"Introduction"},{"location":"natural_language_processing/streaming_chatgpt_gen/#code","text":"","title":"Code"},{"location":"natural_language_processing/streaming_chatgpt_gen/#openai-streaming","text":"If you know how to use OpenAI package to generate ChatGPT output (which in itself is quite easy) , then getting the streaming output nothing but adding one more param ( stream=True ) in openai.ChatCompletion.create . Below is the code that you can easily copy paste and start using right now, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # import import openai # set the keys openai . api_key = \"..\" # provide the key here openai . organization = \"..\" # provide the key here # create the ChatCompletion.create obj completion = openai . ChatCompletion . create ( stream = True , # the magic happens here model = \"gpt-3.5-turbo-0301\" , messages = [ { \"role\" : \"system\" , \"content\" : \"You are a mails assistant. Given an email, write a proper reply.\" }, { \"role\" : \"user\" , \"content\" : \"\"\"Mail: \"We are all set. Thanks -Cam\" \"\"\" } ] ) # print in streaming fashion for chunk in completion : print ( chunk . choices [ 0 ] . delta . get ( \"content\" , \"\" ), end = \"\" , flush = True ) In the above code, just by adding the stream=True OpenAI package is able to take care of all the hardwork and we get a completion generator. In Python, you just need to iterate over it to get the result at token level and as and when they are available. For example, if you time it with and without the stream=True param, you will notice the difference in output and as well as in time. While without the param the output could be available after a couple of seconds, with the param the first token will be available within a second, and the subsequent tokens after the previous one with short gap. To simulate the streaming output, we use print statement with end=\"\" instead of default end=\"\\n\" so that to ignore the newline after each iteration. We also use flush=True so that print statment does not wait for its buffer to get full before printing on terminal.","title":"OpenAI Streaming"},{"location":"natural_language_processing/streaming_chatgpt_gen/#openai-streaming-app-using-fastapi","text":"Now that we have the OpenAI related part done, let's focus on creating FastAPI App and expose the OpenAI wrapper as an event stream service. Below is the code, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 # Filename: api.py # import import openai from pydantic import BaseModel from fastapi import FastAPI , Request from fastapi.responses import StreamingResponse from fastapi.middleware.cors import CORSMiddleware # define app app = FastAPI () # add CORS policy origins = [ \"*\" , ] app . add_middleware ( CORSMiddleware , allow_origins = origins , allow_credentials = True , allow_methods = [ \"*\" ], allow_headers = [ \"*\" ], ) # Set your OpenAI API key here openai . api_key = \"...\" openai . organization = \"...\" # Create BaseModel class class Message ( BaseModel ): prompt : str @app . post ( \"/chat\" ) def chat_socket ( msg : Message ): \"\"\" Generates a response using the OpenAI Chat API in streaming fashion. Returns: A string representing the generated response. \"\"\" # ChatGPT streaming response function def generate_openai_response (): \"\"\" Generates a response using the OpenAI Chat API in streaming fashion. Returns: A string representing the generated response. \"\"\" completion = openai . ChatCompletion . create ( stream = True , model = \"gpt-3.5-turbo-0301\" , messages = [ { \"role\" : \"system\" , \"content\" : \"You are a bot, given the user's input, reply appropriately\" }, { \"role\" : \"user\" , \"content\" : msg . prompt }] ) # print in streaming fashion for chunk in completion : yield chunk . choices [ 0 ] . delta . get ( \"content\" , \"\" ) # return return StreamingResponse ( generate_openai_response (), media_type = 'text/event-stream' ) # welcome page @app . get ( \"/\" ) async def home (): return { \"message\" : \"Welcome to the ChatGPT FastAPI App!\" } # Run the application if __name__ == \"__main__\" : import uvicorn uvicorn . run ( app , host = \"0.0.0.0\" , port = 8000 ) To run the code, you need to just hit python api.py and our endpoint is available at http://0.0.0.0:8000/chat endpoint!","title":"OpenAI Streaming App (using FastAPI)"},{"location":"natural_language_processing/streaming_chatgpt_gen/#client-for-fastapi-openai-streaming-app","text":"Once you have the server running, let's see how we can hit it from any other service. Here I am showing the example of a Python Client. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # import import json import requests def query_api ( url ): # query the url response = requests . post ( url , json = { \"prompt\" : \"Tell me a joke!\" }, stream = True ) # parse the response for chunk in response . iter_content ( chunk_size = None ): if chunk : # filter out keep-alive new chunks print ( chunk . decode ( 'utf-8' ), end = \"\" , flush = True ) # Example usage query_api ( \"http://0.0.0.0:8000/chat\" )","title":"Client for FastAPI OpenAI Streaming App"},{"location":"natural_language_processing/streaming_chatgpt_gen/#references","text":"OpenAI Codebook - Examples","title":"References"},{"location":"natural_language_processing/text_generation/","text":"Text generation Introduction Text generation is an interesting task in NLP, where the intention is to generate text when provided with some prompt as input. Usually, we apply some form of Sequence-to-Sequence model (Seq2Seq) for this task. They are called language models, as they can be used to predict the next word based on the previous sentences. The recent surge in interest in this field is due to two main reasons, (1) the availability of several high performance pre-trained models, and (2) it's very easy to transform a large variety of NLP based tasks into the text-in text-out type of problem. Beacuse of this, it becomes easy to solve several such problems using a single language model. The Seq2Seq model consists of two main modules - Encoder : which takes text as input and encodes it to a compact vector representation, Decoder : which takes the compact vector representation as input and generates text as output. Conventionally, the models were trained from scratch for a specific task, which requires a lot of training data. Recently, as NLP has deviated more towards fine-tuning methodology, we have a number of pre-trained models which either out-of-the-box work very well or can be fine-tuned for the specific task. Some of the conventional models were RNN, GRU and, LSTM. Whereas recent pre-trained models include Transformers, GPT-{1, 2, 3}, GPT-{Neo, J}, T5, etc. Text generation task is a very specific but also a very generic task because we can formulate a lot of NLP tasks in the form of text generation. For example, (not a complete list) Language translation English to Hindi translation, or any language for that matter, is just a text in and text out task Summarization takes the complete text dump as input and generates crisp informative sentences. Question answering question is taken as input and answer is the output. We can even include some context as input on closed-domain QA tasks. Sentiment analysis is a classification task where we can provide the text as input and train the model to generate sentiment tag as output Rating prediction where we have to rate the writing style, kind of regression problem, but still can be formulated as text in number out As obvious from the examples mentioned above, it is possible to formulate a lot of problems as a text-in-text-out task, and it could even expand to classification and regression types of tasks. Some example tasks that can be performed using T5 is shown below, T5 text-to-text framework examples. See: Google Blog ( raffel2020exploring ) Analysis Comparing models (basic details) A brief comparison table of the different models mentioned above is as follows, models type year pre-trained? parameters RNN conventional - no 17k (one layer) LSTM conventional 1997 no 71k (one layer) GRU conventional 2014 no 30-40k (one layer) GPT-2 recent 2019 yes 117M, 345M, 774M, 1.5B GPT-Neo recent 2021 yes 125M, 1.2B, 2.7B T5 recent 2020 yes 60M, 220M, 770M, 2.8B, 11B Comparing models (fine-tuning performance) A more detailed fine-tuning performance of the recent TG models for sentiment detection was performed here . While the analysis is for a specific task, the process remains the same for any NLP problem that can be transformed in the form of text generation. The following recent language models were discussed in the article, GPT-2 : It is the second iteration of the original series of language models released by OpenAI. In fact, this series of GPT models made the language model famous! GPT stands for \"Generative Pre-trained Transformer\", and currently we have 3 versions of the model (v1, v2 and v3). Out of these only GPT-1 and GPT-2 are open-sourced, and hence we will pick the latest version for our experiment. On the technical side, the architecture of GPT-2 is made up of the decoder part of the Transformer architecture. GPT-Neo : This model was released by EleutherAI to counter the GPT-3 model which was not open-sourced. The architecture is quite similar to GPT-3, but training was done on The Pile , an 825 GB sized text dataset. T5 : stands for \"Text-to-Text Transfer Transformer\" and was Google's answer to the world for open source language models. T5 paper showcase that using the complete encoder-decoder architecture (of the transformer) is better than only using the decoder (as done by the GPT series), hence they stay true to the original transformer architecture. The results from the analysis are as follows, model trial 0 trial 1 trial 2 average GPT-Neo 0.824 0.7893 0.808 0.8071 GPT-2 0.8398 0.808 0.806 0.8179 T5 0.8214 0.7976 0.804 0.8077 Conclusion - \"While GPT-2 may have won this round, the result table does show the prowess of text generation models on whole. All of them performed very well on the sentiment detection task, and all it took was a few epochs of training. Even if this experiment was done for a single task, I hope this helps to show how easy it is to use the TG models for completely new tasks. In a way, if we can transform the NLP problem into that of text generation, rest assured the pre-trained model will not fail, well at least not drastically :) This makes them the perfect baseline if not the state-of-the-art for many tasks.\" Additional materials How to generate text: using different decoding methods for language generation with Transformers - Link Guide to fine-tuning Text Generation models: GPT-2, GPT-Neo and T5 - Link","title":"Text generation"},{"location":"natural_language_processing/text_generation/#text-generation","text":"","title":"Text generation"},{"location":"natural_language_processing/text_generation/#introduction","text":"Text generation is an interesting task in NLP, where the intention is to generate text when provided with some prompt as input. Usually, we apply some form of Sequence-to-Sequence model (Seq2Seq) for this task. They are called language models, as they can be used to predict the next word based on the previous sentences. The recent surge in interest in this field is due to two main reasons, (1) the availability of several high performance pre-trained models, and (2) it's very easy to transform a large variety of NLP based tasks into the text-in text-out type of problem. Beacuse of this, it becomes easy to solve several such problems using a single language model. The Seq2Seq model consists of two main modules - Encoder : which takes text as input and encodes it to a compact vector representation, Decoder : which takes the compact vector representation as input and generates text as output. Conventionally, the models were trained from scratch for a specific task, which requires a lot of training data. Recently, as NLP has deviated more towards fine-tuning methodology, we have a number of pre-trained models which either out-of-the-box work very well or can be fine-tuned for the specific task. Some of the conventional models were RNN, GRU and, LSTM. Whereas recent pre-trained models include Transformers, GPT-{1, 2, 3}, GPT-{Neo, J}, T5, etc. Text generation task is a very specific but also a very generic task because we can formulate a lot of NLP tasks in the form of text generation. For example, (not a complete list) Language translation English to Hindi translation, or any language for that matter, is just a text in and text out task Summarization takes the complete text dump as input and generates crisp informative sentences. Question answering question is taken as input and answer is the output. We can even include some context as input on closed-domain QA tasks. Sentiment analysis is a classification task where we can provide the text as input and train the model to generate sentiment tag as output Rating prediction where we have to rate the writing style, kind of regression problem, but still can be formulated as text in number out As obvious from the examples mentioned above, it is possible to formulate a lot of problems as a text-in-text-out task, and it could even expand to classification and regression types of tasks. Some example tasks that can be performed using T5 is shown below, T5 text-to-text framework examples. See: Google Blog ( raffel2020exploring )","title":"Introduction"},{"location":"natural_language_processing/text_generation/#analysis","text":"","title":"Analysis"},{"location":"natural_language_processing/text_generation/#comparing-models-basic-details","text":"A brief comparison table of the different models mentioned above is as follows, models type year pre-trained? parameters RNN conventional - no 17k (one layer) LSTM conventional 1997 no 71k (one layer) GRU conventional 2014 no 30-40k (one layer) GPT-2 recent 2019 yes 117M, 345M, 774M, 1.5B GPT-Neo recent 2021 yes 125M, 1.2B, 2.7B T5 recent 2020 yes 60M, 220M, 770M, 2.8B, 11B","title":"Comparing models (basic details)"},{"location":"natural_language_processing/text_generation/#comparing-models-fine-tuning-performance","text":"A more detailed fine-tuning performance of the recent TG models for sentiment detection was performed here . While the analysis is for a specific task, the process remains the same for any NLP problem that can be transformed in the form of text generation. The following recent language models were discussed in the article, GPT-2 : It is the second iteration of the original series of language models released by OpenAI. In fact, this series of GPT models made the language model famous! GPT stands for \"Generative Pre-trained Transformer\", and currently we have 3 versions of the model (v1, v2 and v3). Out of these only GPT-1 and GPT-2 are open-sourced, and hence we will pick the latest version for our experiment. On the technical side, the architecture of GPT-2 is made up of the decoder part of the Transformer architecture. GPT-Neo : This model was released by EleutherAI to counter the GPT-3 model which was not open-sourced. The architecture is quite similar to GPT-3, but training was done on The Pile , an 825 GB sized text dataset. T5 : stands for \"Text-to-Text Transfer Transformer\" and was Google's answer to the world for open source language models. T5 paper showcase that using the complete encoder-decoder architecture (of the transformer) is better than only using the decoder (as done by the GPT series), hence they stay true to the original transformer architecture. The results from the analysis are as follows, model trial 0 trial 1 trial 2 average GPT-Neo 0.824 0.7893 0.808 0.8071 GPT-2 0.8398 0.808 0.806 0.8179 T5 0.8214 0.7976 0.804 0.8077 Conclusion - \"While GPT-2 may have won this round, the result table does show the prowess of text generation models on whole. All of them performed very well on the sentiment detection task, and all it took was a few epochs of training. Even if this experiment was done for a single task, I hope this helps to show how easy it is to use the TG models for completely new tasks. In a way, if we can transform the NLP problem into that of text generation, rest assured the pre-trained model will not fail, well at least not drastically :) This makes them the perfect baseline if not the state-of-the-art for many tasks.\"","title":"Comparing models (fine-tuning performance)"},{"location":"natural_language_processing/text_generation/#additional-materials","text":"How to generate text: using different decoding methods for language generation with Transformers - Link Guide to fine-tuning Text Generation models: GPT-2, GPT-Neo and T5 - Link","title":"Additional materials"},{"location":"natural_language_processing/text_similarity/","text":"Text Similarity Introduction Similarity between two words, sentences or documents is a function of commonality shared by them. This commonality can be measured by different metrics. Recently there has been a trend of using semantic based approaches, but historically, many similarity based non-neural algorthms were built. But which is the best string similarity algorithm? Well, it\u2019s quite hard to answer this question, at least without knowing anything else, like what you require it for i.e. your use case. And even after having a basic idea, it\u2019s quite hard to pinpoint a good algorithm without first trying them out on different datasets. It\u2019s a trial and error process. To make this journey simpler, I have tried to list down and explain the workings of the most basic string similarity algorithms out there. Give them a try, it may be what you needed all along Types of algorithms Based on the properties of operations, string similarity algorithms can be classified into a bunch of domains. Let\u2019s discuss a few of them, Edit distance based: Algorithms falling under this category try to compute the number of operations needed to transforms one string to another. More the number of operations, less is the similarity between the two strings. One point to note, in this case, every index character of the string is given equal importance. Token-based: In this category, the expected input is a set of tokens, rather than complete strings. The idea is to find the similar tokens in both sets. More the number of common tokens, more is the similarity between the sets. A string can be transformed into sets by splitting using a delimiter. This way, we can transform a sentence into tokens of words or n-grams characters. Note, here tokens of different length have equal importance. Sequence-based: Here, the similarity is a factor of common sub-strings between the two strings. The algorithms, try to find the longest sequence which is present in both strings, the more of these sequences found, higher is the similarity score. Note, here combination of characters of same length have equal importance. Semantic-based: Here, the similarity is not based on pure presence of common sub-strings, but on the semantic meaning of the sub-strings. Semantic based approaches considers the contextual and linguistic meaning of the sub-strings. For example, in semantic based approaches, the similarity between \u201ctoad\u201d and \u201cfrog\u201d will be high, which is not possible in other approaches. Note Semantic based algorithms are quite difficult to use as semnatic is a subjective matter. For example, how will you compare these two sentences -- \"How is the weather today?\" and \"How is the weather tomorrow?\"? If we go by non-semantic approach, we will get a very high score. But for semantic models, two things are possible and correct at the same time -- get a high score as we are talking about the weather, or get a low score as we are talking about different days. This is why, it is important to finetune the semantic models for your use case. (for example here, what is more important - the topic or the context. Based on the answer, prepare a dataset and finetune). Edit distance based algorithms Let\u2019s try to understand most widely used algorithms within this type, Hamming distance This distance is computed by overlaying one string over another and finding the places where the strings vary. Note, classical implementation was meant to handle strings of same length. Some implementations may bypass this by adding a padding at prefix or suffix. Nevertheless, the logic is to find the total number of places one string is different from the other. To showcase an examples, 1 2 3 4 5 6 7 8 9 >> import textdistance >> textdistance . hamming ( 'text' , 'test' ) 1 >> textdistance . hamming . normalized_similarity ( 'text' , 'test' ) 0.75 >> textdistance . hamming ( 'arrow' , 'arow' ) 3 >> textdistance . hamming . normalized_similarity ( 'arrow' , 'arow' ) 0.4 As evident, in first example, the two strings vary only at the 3rd position, hence the edit distance is 1. In second example, even though we are only missing one \u2018r\u2019, the \u2018row\u2019 part is offset by 1, making the edit distance 3 (3rd, 4th and 5th position are dissimilar). One thing to note is the normalized similarity, this is nothing but a function to bound the edit distance between 0 and 1. This signifies, if the score is 0-two strings cannot be more dissimilar, on the other hand, a score of 1 is for a perfect match. So the strings in first example are 75% similar (expected) but in strings in second example are only 40% similar (can we do better?). Levenshtein distance This distance is computed by finding the number of edits which will transform one string to another. The transformations allowed are insertion \u2014 adding a new character, deletion \u2014 deleting a character and substitution \u2014 replace one character by another. By performing these three operations, the algorithm tries to modify first string to match the second one. In the end we get a edit distance. Examples, 1 2 3 4 >> textdistance . levenshtein ( 'arrow' , 'arow' ) 1 >> textdistance . levenshtein . normalized_similarity ( 'arrow' , 'arow' ) 0.8 As evident, if we insert one \u2018r\u2019 in string 2 i.e. \u2018arow\u2019, it becomes same as the string 1. Hence, the edit distance is 1. Similar with hamming distance, we can generate a bounded similarity score between 0 and 1. The similarity score is 80%, huge improvement over the last algorithm. Jaro-Winkler This algorithms gives high scores to two strings if, (1) they contain same characters, but within a certain distance from one another, and (2) the order of the matching characters is same. To be exact, the distance of finding similar character is 1 less than half of length of longest string. So if longest strings has length of 5, a character at the start of the string 1 must be found before or on ((5/2)\u20131) ~ 2nd position in the string 2 to be considered valid match. Because of this, the algorithm is directional and gives high score if matching is from the beginning of the strings. Some examples, 1 2 3 4 5 6 >> textdistance . jaro_winkler ( \"mes\" , \"messi\" ) 0.86 >> textdistance . jaro_winkler ( \"crate\" , \"crat\" ) 0.96 >> textdistance . jaro_winkler ( \"crate\" , \"atcr\" ) 0.0 In first case, as the strings were matching from the beginning, high score was provided. Similarly, in the second case, only one character was missing and that too at the end of the string 2, hence a very high score was given. Imagine the previous algorithms, the similarity would have been less, 80% to be exact. In third case, we re-arranged the last two character of string 2, by bringing them at front, which resulted in 0% similarity. Token based algorithms Algorithms falling under this category are more or less, set similarity algorithms, modified to work for the case of string tokens. Some of them are, Jaccard index Falling under the set similarity domain, the formulae is to find the number of common tokens and divide it by the total number of unique tokens. Its expressed in the mathematical terms by, \\[ J(A,B) = {{|A \\cap B|}\\over{|A \\cup B|}} = {{|A \\cap B|}\\over{|A| + |B| - |A \\cap B|}}. \\] where, the numerator is the intersection (common tokens) and denominator is union (unique tokens). The second case is for when there is some overlap, for which we must remove the common terms as they would add up twice by combining all tokens of both strings. As the required input is tokens instead of complete strings, it falls to user to efficiently and intelligently tokenize his string, depending on the use case. Examples, 1 2 3 4 5 6 7 8 >> tokens_1 = \"hello world\" . split () >> tokens_2 = \"world hello\" . split () >> textdistance . jaccard ( tokens_1 , tokens_2 ) 1.0 >> tokens_1 = \"hello new world\" . split () >> tokens_2 = \"hello world\" . split () >> textdistance . jaccard ( tokens_1 , tokens_2 ) 0.666 We first tokenize the string by default space delimiter, to make words in the strings as tokens. Then we compute the similarity score. In first example, as both words are present in both the strings, the score is 1. Just imagine running an edit based algorithm in this case, the score will be very less if not 0. Sorensen-Dice Falling under set similarity, the logic is to find the common tokens, and divide it by the total number of tokens present by combining both sets. The formulae is, \\[ {\\displaystyle DSC={\\frac {2|X\\cap Y|}{|X|+|Y|}}} \\] where, the numerator is twice the intersection of two sets/strings. The idea behind this is if a token is present in both strings, its total count is obviously twice the intersection (which removes duplicates). The denominator is simple combination of all tokens in both strings. Note, its quite different from the jaccard\u2019s denominator, which was union of two strings. As the case with intersection, union too removes duplicates and this is avoided in dice algorithm. Because of this, dice will always overestimate the similarity between two strings. Some example, 1 2 3 4 5 6 7 8 >> tokens_1 = \"hello world\" . split () >> tokens_2 = \"world hello\" . split () >> textdistance . sorensen ( tokens_1 , tokens_2 ) 1.0 >> tokens_1 = \"hello new world\" . split () >> tokens_2 = \"hello world\" . split () >> textdistance . sorensen ( tokens_1 , tokens_2 ) 0.8 Sequence based algorithm Lets understand one of the sequence based algorithms, Ratcliff-Obershelp similarity The idea is quite simple yet intuitive. Find the longest common substring from the two strings. Remove that part from both strings, and split at the same location. This breaks the strings into two parts, one left and another to the right of the found common substring. Now take the left part of both strings and call the function again to find the longest common substring. Do this too for the right part. This process is repeated recursively until the size of any broken part is less than a default value. Finally, a formulation similar to the above-mentioned dice is followed to compute the similarity score. The score is twice the number of characters found in common divided by the total number of characters in the two strings. Some examples, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 >> string1 , string2 = \"i am going home\" , \"gone home\" >> textdistance . ratcliff_obershelp ( string1 , string2 ) 0.66 >> string1 , string2 = \"helloworld\" , \"worldhello\" >> textdistance . ratcliff_obershelp ( string1 , string2 ) 0.5 >> string1 , string2 = \"test\" , \"text\" >> textdistance . ratcliff_obershelp ( string1 , string2 ) 0.75 >> string1 , string2 = \"mes\" , \"simes\" >> textdistance . ratcliff_obershelp ( string1 , string2 ) 0.75 >> string1 , string2 = \"mes\" , \"simes\" >> textdistance . ratcliff_obershelp ( string1 , string2 ) 0.75 >> string1 , string2 = \"arrow\" , \"arow\" >> textdistance . ratcliff_obershelp ( string1 , string2 ) 0.88 In first example, it found \u2018 home\u2019 as the longest substring, then considered \u2018i am going\u2019 and \u2018gone\u2019 for further processing (left of common substring), where again it found \u2018go\u2019 as longest substring. Later on right of \u2018go\u2019 it also found \u2019n\u2019 as the only common and longest substring. Overall the score was 2 * (5 + 2 + 1) / 24 ~ 0.66. In second case, it found \u2018hello\u2019 as the longest substring and nothing common on the left and right, hence score is 0.5. The rest of the examples showcase the advantage of using sequence algorithms for cases missed by edit distance based algorithms. Semantic based approaches In semantic search, strings are embedded using some neural network (NN) model. Think of it like a function that takes an input string and returns a vector of numbers. The vector is then used to compare the similarity between two strings. Usually the NN models work at either token or word level, so to get embedding of a string, we first find embeddings for each token in the string and then aggregate them using mean or similar function. The expectation is that the embeddings will be able to represent the string such that it capture different aspects of the language. Because of which, the embeddings provides us with much more features to compare strings. Semantic search embeds corpus entries and queries into a vector space. Finding the closest vector to the query vector is equivalent to finding the most similar entry in the corpus. Source: SBert.net Hint As embedding is an integral part of semantic search, it is important to check the quality of a embedding method before using it. MTEB is the \"Massive Text Embedding Benchmark\" python package that lets you test any embedding function on more than 30 tasks. The process is quite simple - usually the text is embedded using the provided function or neural network, and the performance of embedding is computed and checked on downstream tasks like classification, clustering, and more. Hint To select the right model for your task, identify whether your task is symmetric or asymmetric. ( refer ) Symmetric Search : If your task involves matching similar-length queries and corpus entries (e.g., \"How to learn Python online?\" vs. \"How to learn Python on the web?\"), use models trained on datasets like Quora Duplicate Questions. Asymmetric Search : If your task involves short queries and longer, detailed answers (e.g., \"What is Python?\" vs. a paragraph explaining Python), use models optimized for query-document mismatches, such as those pre-trained on MS MARCO. Let's try a couple of ways to compute semantic similarity between strings. Different models can be picked or even fine-tuned based on domain and requirement, but we will use the same model (but different packages) for simplicity's sake. txtai txtai is a python package to perform semantic based tasks on textual data including search, question answering, information extraction, etc. Today, we will use it for the sole purpose of semantic search. (inspired from txtai readme ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # import the packages import pandas as pd ## for better visualization of result from txtai.embeddings import Embeddings # Create embeddings model, backed by sentence-transformers & transformers embeddings = Embeddings ({ \"path\" : \"sentence-transformers/nli-mpnet-base-v2\" }) # the data to search against data = [ \"US tops 5 million confirmed virus cases\" , \"Canada's last fully intact ice shelf has suddenly collapsed, forming a Manhattan-sized iceberg\" , \"Beijing mobilises invasion craft along coast as Taiwan tensions escalate\" , \"The National Park Service warns against sacrificing slower friends in a bear attack\" , \"Maine man wins $1M from $25 lottery ticket\" , \"Make huge profits without work, earn up to $100,000 a day\" ] # var to hold the result results = [] # perform search for each of the following query phrase for query in ( \"feel good story\" , \"climate change\" , \"public health story\" , \"war\" , \"wildlife\" , \"asia\" , \"lucky\" , \"dishonest junk\" ): # Get index of best section that best matches query for id , score in embeddings . similarity ( query , data ): results . append (( query , data [ id ], score )) # format the result results = pd . DataFrame ( results ) results . columns = [ \"query\" , \"best_match\" , \"score\" ] results [ 'score' ] = results [ 'score' ] . round ( 2 ) results = results . sort_values ( by = [ 'score' ], ascending = False ) # print the result results . drop_duplicates ( subset = [ 'query' ]) Here we are trying to pick the most similar phrase for each of the query from the data. The result will look as follows, query best_match score wildlife The National Park Service warns against sacrif... 0.28 war Beijing mobilises invasion craft along coast a... 0.27 asia Beijing mobilises invasion craft along coast a... 0.24 climate change Canada's last fully intact ice shelf has sudde... 0.24 public health story US tops 5 million confirmed virus cases 0.17 feel good story Maine man wins $1M from $25 lottery ticket 0.08 lucky Maine man wins $1M from $25 lottery ticket 0.07 dishonest junk Make huge profits without work, earn up to $10... 0.03 As obvious from the result, even though there is hardly any common sub-string between the query and the data, the results make sense in a semantic way. Beijing is connected with asia and war , while ice shelf is connected with climate change , and so on. Note The score is the cosine similarity between the embeddings of the two strings (query and data element). It's range is between {-1, 1}, and not {0, 1}. Do not think of it as probability. The above approach could be slow as for each call to similarity , the sentences are embedded again and again. To speed it up, we could use index to precompute the embeddings for the data. This can be done by, 1 2 3 4 5 6 7 8 # index the data embeddings . index ([( uid , text , None ) for uid , text in enumerate ( data )]) # now instead of similarity, use search function embeddings . search ( \"feel good story\" , limit = 1 ) # Output: # [{'id': '4', # 'score': 0.08329004049301147, # 'text': 'Maine man wins $1M from $25 lottery ticket'}] txtai also provides explaination of the result. For this we can use explain function as follows, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # first index the data embeddings . index ([( uid , text , None ) for uid , text in enumerate ( data )]) # next call the explain function embeddings . explain ( \"feel good story\" , limit = 1 ) # Output: # [{'id': '4', # 'score': 0.08329004049301147, # 'text': 'Maine man wins $1M from $25 lottery ticket', # 'tokens': [('Maine', 0.003297939896583557), # ('man', -0.03039500117301941), # ('wins', 0.03406312316656113), # ('$1M', -0.03121592104434967), # ('from', -0.02270638197660446), # ('$25', 0.012891143560409546), # ('lottery', -0.015372440218925476), # ('ticket', 0.007445111870765686)]}] The output contains word level importance score for the top similar sentence in the data ( limit=1 ). From the output we can see the word win is the most important word wrt to the query. The score computation is based on the occlusion based explaination approach. Here, several permutations of the same sentence is created, each one with one word/token missing. Then cosine similarity is computed between the fixed query and each permutation. Finally, the similairty score of the permutation is subtracted from the score of the original sentence (with all words present). The intuition is as follows, if an important word like win is missing from the sentence, the score of the sentence will be reduced and the difference will be positive if an unimportant word like man is missing from the sentence, the score of the sentence will increase and the difference will be negative Sentence Transformer SentenceTransformers is is a Python framework for state-of-the-art sentence, text and image embeddings. The inital work in this framework is detailed in the paper Sentence-BERT 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 # laod packages import pandas as pd from sentence_transformers import SentenceTransformer , util # load the model model = SentenceTransformer ( 'nli-mpnet-base-v2' ) # the data to search against data = [ \"US tops 5 million confirmed virus cases\" , \"Canada's last fully intact ice shelf has suddenly collapsed, forming a Manhattan-sized iceberg\" , \"Beijing mobilises invasion craft along coast as Taiwan tensions escalate\" , \"The National Park Service warns against sacrificing slower friends in a bear attack\" , \"Maine man wins $1M from $25 lottery ticket\" , \"Make huge profits without work, earn up to $100,000 a day\" ] # var to hold the result results = [] # embed the data before hand embeddings_target = model . encode ( data , convert_to_tensor = True ) # perform search for each of the following query phrase for query in ( \"feel good story\" , \"climate change\" , \"public health story\" , \"war\" , \"wildlife\" , \"asia\" , \"lucky\" , \"dishonest junk\" ): # embed the query embeddings_query = model . encode ([ query ], convert_to_tensor = True ) # compute cosine-similarities for each sentence with each other sentence cosine_scores = util . pytorch_cos_sim ( embeddings_query , embeddings_target ) # return the index of top 5 values in a list score_list = cosine_scores . tolist ()[ 0 ] # Get index of best section that best matches query for id , score in enumerate ( score_list ): results . append (( query , data [ id ], score )) # format the result results = pd . DataFrame ( results ) results . columns = [ \"query\" , \"best_match\" , \"score\" ] results [ 'score' ] = results [ 'score' ] . round ( 2 ) results = results . sort_values ( by = [ 'score' ], ascending = False ) # print the result results . drop_duplicates ( subset = [ 'query' ]) This will return the same table as the previous one. In face if you noticed, we have used the same model. If you look further, in txtai we used sentence-transformers and we have used the same model. The package provides an extensive variety of pretraied models. A comparitive table is shown below (taken from Sentence-Transformer ) Model Name Performance Sentence Embeddings (14 Datasets) Performance Semantic Search (6 Datasets) Avg. Performance Sentence Encoding Speed Model Size all-mpnet-base-v2 69.57 57.02 63.30 2800 420 MB multi-qa-mpnet-base-dot-v1 66.76 57.60 62.18 2800 420 MB all-distilroberta-v1 68.73 50.94 59.84 4000 290 MB all-MiniLM-L12-v2 68.70 50.82 59.76 7500 120 MB multi-qa-distilbert-cos-v1 65.98 52.83 59.41 4000 250 MB all-MiniLM-L6-v2 68.06 49.54 58.80 14200 80 MB multi-qa-MiniLM-L6-cos-v1 64.33 51.83 58.08 14200 80 MB paraphrase-multilingual-mpnet-base-v2 65.83 41.68 53.75 2500 970 MB paraphrase-albert-small-v2 64.46 40.04 52.25 5000 43 MB paraphrase-multilingual-MiniLM-L12-v2 64.25 39.19 51.72 7500 420 MB paraphrase-MiniLM-L3-v2 62.29 39.19 50.74 19000 61 MB distiluse-base-multilingual-cased-v1 61.30 29.87 45.59 4000 480 MB distiluse-base-multilingual-cased-v2 60.18 27.35 43.77 4000 480 MB Note Training semantic search model is different from normal classification or regression models. Think of it like this -- for classification each sample has one label, but for semantic search a combination of samples has one label. This is because in search you want to match the query and result, and then provide some score for that combination. You can refer Sbert training page for more details.","title":"Text similarity"},{"location":"natural_language_processing/text_similarity/#text-similarity","text":"","title":"Text Similarity"},{"location":"natural_language_processing/text_similarity/#introduction","text":"Similarity between two words, sentences or documents is a function of commonality shared by them. This commonality can be measured by different metrics. Recently there has been a trend of using semantic based approaches, but historically, many similarity based non-neural algorthms were built. But which is the best string similarity algorithm? Well, it\u2019s quite hard to answer this question, at least without knowing anything else, like what you require it for i.e. your use case. And even after having a basic idea, it\u2019s quite hard to pinpoint a good algorithm without first trying them out on different datasets. It\u2019s a trial and error process. To make this journey simpler, I have tried to list down and explain the workings of the most basic string similarity algorithms out there. Give them a try, it may be what you needed all along","title":"Introduction"},{"location":"natural_language_processing/text_similarity/#types-of-algorithms","text":"Based on the properties of operations, string similarity algorithms can be classified into a bunch of domains. Let\u2019s discuss a few of them, Edit distance based: Algorithms falling under this category try to compute the number of operations needed to transforms one string to another. More the number of operations, less is the similarity between the two strings. One point to note, in this case, every index character of the string is given equal importance. Token-based: In this category, the expected input is a set of tokens, rather than complete strings. The idea is to find the similar tokens in both sets. More the number of common tokens, more is the similarity between the sets. A string can be transformed into sets by splitting using a delimiter. This way, we can transform a sentence into tokens of words or n-grams characters. Note, here tokens of different length have equal importance. Sequence-based: Here, the similarity is a factor of common sub-strings between the two strings. The algorithms, try to find the longest sequence which is present in both strings, the more of these sequences found, higher is the similarity score. Note, here combination of characters of same length have equal importance. Semantic-based: Here, the similarity is not based on pure presence of common sub-strings, but on the semantic meaning of the sub-strings. Semantic based approaches considers the contextual and linguistic meaning of the sub-strings. For example, in semantic based approaches, the similarity between \u201ctoad\u201d and \u201cfrog\u201d will be high, which is not possible in other approaches. Note Semantic based algorithms are quite difficult to use as semnatic is a subjective matter. For example, how will you compare these two sentences -- \"How is the weather today?\" and \"How is the weather tomorrow?\"? If we go by non-semantic approach, we will get a very high score. But for semantic models, two things are possible and correct at the same time -- get a high score as we are talking about the weather, or get a low score as we are talking about different days. This is why, it is important to finetune the semantic models for your use case. (for example here, what is more important - the topic or the context. Based on the answer, prepare a dataset and finetune).","title":"Types of algorithms"},{"location":"natural_language_processing/text_similarity/#edit-distance-based-algorithms","text":"Let\u2019s try to understand most widely used algorithms within this type,","title":"Edit distance based algorithms"},{"location":"natural_language_processing/text_similarity/#hamming-distance","text":"This distance is computed by overlaying one string over another and finding the places where the strings vary. Note, classical implementation was meant to handle strings of same length. Some implementations may bypass this by adding a padding at prefix or suffix. Nevertheless, the logic is to find the total number of places one string is different from the other. To showcase an examples, 1 2 3 4 5 6 7 8 9 >> import textdistance >> textdistance . hamming ( 'text' , 'test' ) 1 >> textdistance . hamming . normalized_similarity ( 'text' , 'test' ) 0.75 >> textdistance . hamming ( 'arrow' , 'arow' ) 3 >> textdistance . hamming . normalized_similarity ( 'arrow' , 'arow' ) 0.4 As evident, in first example, the two strings vary only at the 3rd position, hence the edit distance is 1. In second example, even though we are only missing one \u2018r\u2019, the \u2018row\u2019 part is offset by 1, making the edit distance 3 (3rd, 4th and 5th position are dissimilar). One thing to note is the normalized similarity, this is nothing but a function to bound the edit distance between 0 and 1. This signifies, if the score is 0-two strings cannot be more dissimilar, on the other hand, a score of 1 is for a perfect match. So the strings in first example are 75% similar (expected) but in strings in second example are only 40% similar (can we do better?).","title":"Hamming distance"},{"location":"natural_language_processing/text_similarity/#levenshtein-distance","text":"This distance is computed by finding the number of edits which will transform one string to another. The transformations allowed are insertion \u2014 adding a new character, deletion \u2014 deleting a character and substitution \u2014 replace one character by another. By performing these three operations, the algorithm tries to modify first string to match the second one. In the end we get a edit distance. Examples, 1 2 3 4 >> textdistance . levenshtein ( 'arrow' , 'arow' ) 1 >> textdistance . levenshtein . normalized_similarity ( 'arrow' , 'arow' ) 0.8 As evident, if we insert one \u2018r\u2019 in string 2 i.e. \u2018arow\u2019, it becomes same as the string 1. Hence, the edit distance is 1. Similar with hamming distance, we can generate a bounded similarity score between 0 and 1. The similarity score is 80%, huge improvement over the last algorithm.","title":"Levenshtein distance"},{"location":"natural_language_processing/text_similarity/#jaro-winkler","text":"This algorithms gives high scores to two strings if, (1) they contain same characters, but within a certain distance from one another, and (2) the order of the matching characters is same. To be exact, the distance of finding similar character is 1 less than half of length of longest string. So if longest strings has length of 5, a character at the start of the string 1 must be found before or on ((5/2)\u20131) ~ 2nd position in the string 2 to be considered valid match. Because of this, the algorithm is directional and gives high score if matching is from the beginning of the strings. Some examples, 1 2 3 4 5 6 >> textdistance . jaro_winkler ( \"mes\" , \"messi\" ) 0.86 >> textdistance . jaro_winkler ( \"crate\" , \"crat\" ) 0.96 >> textdistance . jaro_winkler ( \"crate\" , \"atcr\" ) 0.0 In first case, as the strings were matching from the beginning, high score was provided. Similarly, in the second case, only one character was missing and that too at the end of the string 2, hence a very high score was given. Imagine the previous algorithms, the similarity would have been less, 80% to be exact. In third case, we re-arranged the last two character of string 2, by bringing them at front, which resulted in 0% similarity.","title":"Jaro-Winkler"},{"location":"natural_language_processing/text_similarity/#token-based-algorithms","text":"Algorithms falling under this category are more or less, set similarity algorithms, modified to work for the case of string tokens. Some of them are,","title":"Token based algorithms"},{"location":"natural_language_processing/text_similarity/#jaccard-index","text":"Falling under the set similarity domain, the formulae is to find the number of common tokens and divide it by the total number of unique tokens. Its expressed in the mathematical terms by, \\[ J(A,B) = {{|A \\cap B|}\\over{|A \\cup B|}} = {{|A \\cap B|}\\over{|A| + |B| - |A \\cap B|}}. \\] where, the numerator is the intersection (common tokens) and denominator is union (unique tokens). The second case is for when there is some overlap, for which we must remove the common terms as they would add up twice by combining all tokens of both strings. As the required input is tokens instead of complete strings, it falls to user to efficiently and intelligently tokenize his string, depending on the use case. Examples, 1 2 3 4 5 6 7 8 >> tokens_1 = \"hello world\" . split () >> tokens_2 = \"world hello\" . split () >> textdistance . jaccard ( tokens_1 , tokens_2 ) 1.0 >> tokens_1 = \"hello new world\" . split () >> tokens_2 = \"hello world\" . split () >> textdistance . jaccard ( tokens_1 , tokens_2 ) 0.666 We first tokenize the string by default space delimiter, to make words in the strings as tokens. Then we compute the similarity score. In first example, as both words are present in both the strings, the score is 1. Just imagine running an edit based algorithm in this case, the score will be very less if not 0.","title":"Jaccard index"},{"location":"natural_language_processing/text_similarity/#sorensen-dice","text":"Falling under set similarity, the logic is to find the common tokens, and divide it by the total number of tokens present by combining both sets. The formulae is, \\[ {\\displaystyle DSC={\\frac {2|X\\cap Y|}{|X|+|Y|}}} \\] where, the numerator is twice the intersection of two sets/strings. The idea behind this is if a token is present in both strings, its total count is obviously twice the intersection (which removes duplicates). The denominator is simple combination of all tokens in both strings. Note, its quite different from the jaccard\u2019s denominator, which was union of two strings. As the case with intersection, union too removes duplicates and this is avoided in dice algorithm. Because of this, dice will always overestimate the similarity between two strings. Some example, 1 2 3 4 5 6 7 8 >> tokens_1 = \"hello world\" . split () >> tokens_2 = \"world hello\" . split () >> textdistance . sorensen ( tokens_1 , tokens_2 ) 1.0 >> tokens_1 = \"hello new world\" . split () >> tokens_2 = \"hello world\" . split () >> textdistance . sorensen ( tokens_1 , tokens_2 ) 0.8","title":"Sorensen-Dice"},{"location":"natural_language_processing/text_similarity/#sequence-based-algorithm","text":"Lets understand one of the sequence based algorithms,","title":"Sequence based algorithm"},{"location":"natural_language_processing/text_similarity/#ratcliff-obershelp-similarity","text":"The idea is quite simple yet intuitive. Find the longest common substring from the two strings. Remove that part from both strings, and split at the same location. This breaks the strings into two parts, one left and another to the right of the found common substring. Now take the left part of both strings and call the function again to find the longest common substring. Do this too for the right part. This process is repeated recursively until the size of any broken part is less than a default value. Finally, a formulation similar to the above-mentioned dice is followed to compute the similarity score. The score is twice the number of characters found in common divided by the total number of characters in the two strings. Some examples, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 >> string1 , string2 = \"i am going home\" , \"gone home\" >> textdistance . ratcliff_obershelp ( string1 , string2 ) 0.66 >> string1 , string2 = \"helloworld\" , \"worldhello\" >> textdistance . ratcliff_obershelp ( string1 , string2 ) 0.5 >> string1 , string2 = \"test\" , \"text\" >> textdistance . ratcliff_obershelp ( string1 , string2 ) 0.75 >> string1 , string2 = \"mes\" , \"simes\" >> textdistance . ratcliff_obershelp ( string1 , string2 ) 0.75 >> string1 , string2 = \"mes\" , \"simes\" >> textdistance . ratcliff_obershelp ( string1 , string2 ) 0.75 >> string1 , string2 = \"arrow\" , \"arow\" >> textdistance . ratcliff_obershelp ( string1 , string2 ) 0.88 In first example, it found \u2018 home\u2019 as the longest substring, then considered \u2018i am going\u2019 and \u2018gone\u2019 for further processing (left of common substring), where again it found \u2018go\u2019 as longest substring. Later on right of \u2018go\u2019 it also found \u2019n\u2019 as the only common and longest substring. Overall the score was 2 * (5 + 2 + 1) / 24 ~ 0.66. In second case, it found \u2018hello\u2019 as the longest substring and nothing common on the left and right, hence score is 0.5. The rest of the examples showcase the advantage of using sequence algorithms for cases missed by edit distance based algorithms.","title":"Ratcliff-Obershelp similarity"},{"location":"natural_language_processing/text_similarity/#semantic-based-approaches","text":"In semantic search, strings are embedded using some neural network (NN) model. Think of it like a function that takes an input string and returns a vector of numbers. The vector is then used to compare the similarity between two strings. Usually the NN models work at either token or word level, so to get embedding of a string, we first find embeddings for each token in the string and then aggregate them using mean or similar function. The expectation is that the embeddings will be able to represent the string such that it capture different aspects of the language. Because of which, the embeddings provides us with much more features to compare strings. Semantic search embeds corpus entries and queries into a vector space. Finding the closest vector to the query vector is equivalent to finding the most similar entry in the corpus. Source: SBert.net Hint As embedding is an integral part of semantic search, it is important to check the quality of a embedding method before using it. MTEB is the \"Massive Text Embedding Benchmark\" python package that lets you test any embedding function on more than 30 tasks. The process is quite simple - usually the text is embedded using the provided function or neural network, and the performance of embedding is computed and checked on downstream tasks like classification, clustering, and more. Hint To select the right model for your task, identify whether your task is symmetric or asymmetric. ( refer ) Symmetric Search : If your task involves matching similar-length queries and corpus entries (e.g., \"How to learn Python online?\" vs. \"How to learn Python on the web?\"), use models trained on datasets like Quora Duplicate Questions. Asymmetric Search : If your task involves short queries and longer, detailed answers (e.g., \"What is Python?\" vs. a paragraph explaining Python), use models optimized for query-document mismatches, such as those pre-trained on MS MARCO. Let's try a couple of ways to compute semantic similarity between strings. Different models can be picked or even fine-tuned based on domain and requirement, but we will use the same model (but different packages) for simplicity's sake.","title":"Semantic based approaches"},{"location":"natural_language_processing/text_similarity/#txtai","text":"txtai is a python package to perform semantic based tasks on textual data including search, question answering, information extraction, etc. Today, we will use it for the sole purpose of semantic search. (inspired from txtai readme ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # import the packages import pandas as pd ## for better visualization of result from txtai.embeddings import Embeddings # Create embeddings model, backed by sentence-transformers & transformers embeddings = Embeddings ({ \"path\" : \"sentence-transformers/nli-mpnet-base-v2\" }) # the data to search against data = [ \"US tops 5 million confirmed virus cases\" , \"Canada's last fully intact ice shelf has suddenly collapsed, forming a Manhattan-sized iceberg\" , \"Beijing mobilises invasion craft along coast as Taiwan tensions escalate\" , \"The National Park Service warns against sacrificing slower friends in a bear attack\" , \"Maine man wins $1M from $25 lottery ticket\" , \"Make huge profits without work, earn up to $100,000 a day\" ] # var to hold the result results = [] # perform search for each of the following query phrase for query in ( \"feel good story\" , \"climate change\" , \"public health story\" , \"war\" , \"wildlife\" , \"asia\" , \"lucky\" , \"dishonest junk\" ): # Get index of best section that best matches query for id , score in embeddings . similarity ( query , data ): results . append (( query , data [ id ], score )) # format the result results = pd . DataFrame ( results ) results . columns = [ \"query\" , \"best_match\" , \"score\" ] results [ 'score' ] = results [ 'score' ] . round ( 2 ) results = results . sort_values ( by = [ 'score' ], ascending = False ) # print the result results . drop_duplicates ( subset = [ 'query' ]) Here we are trying to pick the most similar phrase for each of the query from the data. The result will look as follows, query best_match score wildlife The National Park Service warns against sacrif... 0.28 war Beijing mobilises invasion craft along coast a... 0.27 asia Beijing mobilises invasion craft along coast a... 0.24 climate change Canada's last fully intact ice shelf has sudde... 0.24 public health story US tops 5 million confirmed virus cases 0.17 feel good story Maine man wins $1M from $25 lottery ticket 0.08 lucky Maine man wins $1M from $25 lottery ticket 0.07 dishonest junk Make huge profits without work, earn up to $10... 0.03 As obvious from the result, even though there is hardly any common sub-string between the query and the data, the results make sense in a semantic way. Beijing is connected with asia and war , while ice shelf is connected with climate change , and so on. Note The score is the cosine similarity between the embeddings of the two strings (query and data element). It's range is between {-1, 1}, and not {0, 1}. Do not think of it as probability. The above approach could be slow as for each call to similarity , the sentences are embedded again and again. To speed it up, we could use index to precompute the embeddings for the data. This can be done by, 1 2 3 4 5 6 7 8 # index the data embeddings . index ([( uid , text , None ) for uid , text in enumerate ( data )]) # now instead of similarity, use search function embeddings . search ( \"feel good story\" , limit = 1 ) # Output: # [{'id': '4', # 'score': 0.08329004049301147, # 'text': 'Maine man wins $1M from $25 lottery ticket'}] txtai also provides explaination of the result. For this we can use explain function as follows, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # first index the data embeddings . index ([( uid , text , None ) for uid , text in enumerate ( data )]) # next call the explain function embeddings . explain ( \"feel good story\" , limit = 1 ) # Output: # [{'id': '4', # 'score': 0.08329004049301147, # 'text': 'Maine man wins $1M from $25 lottery ticket', # 'tokens': [('Maine', 0.003297939896583557), # ('man', -0.03039500117301941), # ('wins', 0.03406312316656113), # ('$1M', -0.03121592104434967), # ('from', -0.02270638197660446), # ('$25', 0.012891143560409546), # ('lottery', -0.015372440218925476), # ('ticket', 0.007445111870765686)]}] The output contains word level importance score for the top similar sentence in the data ( limit=1 ). From the output we can see the word win is the most important word wrt to the query. The score computation is based on the occlusion based explaination approach. Here, several permutations of the same sentence is created, each one with one word/token missing. Then cosine similarity is computed between the fixed query and each permutation. Finally, the similairty score of the permutation is subtracted from the score of the original sentence (with all words present). The intuition is as follows, if an important word like win is missing from the sentence, the score of the sentence will be reduced and the difference will be positive if an unimportant word like man is missing from the sentence, the score of the sentence will increase and the difference will be negative","title":"txtai"},{"location":"natural_language_processing/text_similarity/#sentence-transformer","text":"SentenceTransformers is is a Python framework for state-of-the-art sentence, text and image embeddings. The inital work in this framework is detailed in the paper Sentence-BERT 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 # laod packages import pandas as pd from sentence_transformers import SentenceTransformer , util # load the model model = SentenceTransformer ( 'nli-mpnet-base-v2' ) # the data to search against data = [ \"US tops 5 million confirmed virus cases\" , \"Canada's last fully intact ice shelf has suddenly collapsed, forming a Manhattan-sized iceberg\" , \"Beijing mobilises invasion craft along coast as Taiwan tensions escalate\" , \"The National Park Service warns against sacrificing slower friends in a bear attack\" , \"Maine man wins $1M from $25 lottery ticket\" , \"Make huge profits without work, earn up to $100,000 a day\" ] # var to hold the result results = [] # embed the data before hand embeddings_target = model . encode ( data , convert_to_tensor = True ) # perform search for each of the following query phrase for query in ( \"feel good story\" , \"climate change\" , \"public health story\" , \"war\" , \"wildlife\" , \"asia\" , \"lucky\" , \"dishonest junk\" ): # embed the query embeddings_query = model . encode ([ query ], convert_to_tensor = True ) # compute cosine-similarities for each sentence with each other sentence cosine_scores = util . pytorch_cos_sim ( embeddings_query , embeddings_target ) # return the index of top 5 values in a list score_list = cosine_scores . tolist ()[ 0 ] # Get index of best section that best matches query for id , score in enumerate ( score_list ): results . append (( query , data [ id ], score )) # format the result results = pd . DataFrame ( results ) results . columns = [ \"query\" , \"best_match\" , \"score\" ] results [ 'score' ] = results [ 'score' ] . round ( 2 ) results = results . sort_values ( by = [ 'score' ], ascending = False ) # print the result results . drop_duplicates ( subset = [ 'query' ]) This will return the same table as the previous one. In face if you noticed, we have used the same model. If you look further, in txtai we used sentence-transformers and we have used the same model. The package provides an extensive variety of pretraied models. A comparitive table is shown below (taken from Sentence-Transformer ) Model Name Performance Sentence Embeddings (14 Datasets) Performance Semantic Search (6 Datasets) Avg. Performance Sentence Encoding Speed Model Size all-mpnet-base-v2 69.57 57.02 63.30 2800 420 MB multi-qa-mpnet-base-dot-v1 66.76 57.60 62.18 2800 420 MB all-distilroberta-v1 68.73 50.94 59.84 4000 290 MB all-MiniLM-L12-v2 68.70 50.82 59.76 7500 120 MB multi-qa-distilbert-cos-v1 65.98 52.83 59.41 4000 250 MB all-MiniLM-L6-v2 68.06 49.54 58.80 14200 80 MB multi-qa-MiniLM-L6-cos-v1 64.33 51.83 58.08 14200 80 MB paraphrase-multilingual-mpnet-base-v2 65.83 41.68 53.75 2500 970 MB paraphrase-albert-small-v2 64.46 40.04 52.25 5000 43 MB paraphrase-multilingual-MiniLM-L12-v2 64.25 39.19 51.72 7500 420 MB paraphrase-MiniLM-L3-v2 62.29 39.19 50.74 19000 61 MB distiluse-base-multilingual-cased-v1 61.30 29.87 45.59 4000 480 MB distiluse-base-multilingual-cased-v2 60.18 27.35 43.77 4000 480 MB Note Training semantic search model is different from normal classification or regression models. Think of it like this -- for classification each sample has one label, but for semantic search a combination of samples has one label. This is because in search you want to match the query and result, and then provide some score for that combination. You can refer Sbert training page for more details.","title":"Sentence Transformer"},{"location":"natural_language_processing/training_llm/","text":"Introduction Large Language Models (LLMs) are a type of artificial intelligence system designed to process and understand human language. They are capable of generating text, completing sentences, summarizing content, answering questions, and more, with remarkable accuracy. The accuracy of LLMs stems from their ability to learn patterns and structures from vast amounts of text data, which enables them to make predictions about the next word or sequence of words. Training LLMs is a complex process that requires a deep understanding of the underlying concepts and techniques. This article provides a comprehensive overview of the process of training LLMs. Stages of Training LLMs The process of training a Large Language Model (LLM) consists of two distinct stages. Language model pre-training. We start by converting a large, multilingual text corpus to discrete tokens and pre-training a large language model (LLM) on the resulting data to perform next-token prediction. In the language model pre-training stage, the model learns the structure of language and obtains large amounts of knowledge about the world from the text it is \u201creading\u201d (or training on) . This is further divided into, the curation and filtering of a large-scale training corpus (i.e. datasets) , the development of model architecture and corresponding scaling laws for determining model size, the development of techniques for e\ufb03cient pre-training at large scale, and the development of a pre-training recipe. Language model post-training. The pre-trained language model has a rich understanding of language but it does not yet follow instructions or behave in the way we would expect an assistant to. We align the model with human feedback in several rounds, each of which involves supervised finetuning (SFT) on instruction tuning data and Direct Preference Optimization (DPO) . At this post-training stage, we also integrate new capabilities, such as tool-use, and observe strong improvements in other areas, such as coding and reasoning. Finally, safety mitigations are also incorporated. Let's dive into these stages in more details. Pre-Training To refresh, pre-training stage is the first stage of LLM training and deals with making the LLM aware of the structure of language by training it on a large corpus of text curated from the internet. Let's discuss the intermediate stages of pre-training. Data Curation To train a Large Language Model (LLM), we first need to collect a large amount of text data. The data collection for language model pre-training involves curation and filtering of web data to create a diverse and large quantity of dataset. This dataset is then processed and optimized to extract high-quality text. The dataset is filtered to remove domains that contain personal information, harmful content, or adult content. Additionally, the dataset is de-duplicated to remove duplicate lines and documents. Heuristics and model-based quality filters are used to remove low-quality documents and excessive repetitions. The data mix for pre-training is determined by classifying the types of information in the web data and using scaling law experiments to determine the best data mix. In LLaMa-3.1, the data mix contains roughly 50% of tokens corresponding to general knowledge, 25% of mathematical and reasoning tokens, 17% code tokens, and 8% multilingual tokens. [1] Model Architecture Once we have the dataset ready, the next step is to design the model architecture. Transformer based architectures has been the defacto choice for many LLMs since its inception in 2017 [2]. That said, the complete system consists of several independent components that can be altered to further enhance the accuracy and performance. Let's discuss some of these components. Base Design : Original Transformer paper [2] consists of an encoder and decoder block. While the encoder block is good for encoding the contextual information of the input sequence, decoder block is responsible for decoding the output sequence in auto-regressive manner. Over time there has been a general conceptual shift from encoder-decoder to decoder-only architecture for LLMs. As an example, Llama 3 uses a standard decoder-only transformer architecture similar to Llama and Llama 2 [1]. Hint Refer paper \"Decoder-Only or Encoder-Decoder? Interpreting Language Model as a Regularized Encoder-Decoder\" [6] for a holistic comparison of the different architectures. Attention Layer : Attention layers were made popular with original Transformer paper [2] and is useful for updating the token embeddings wrt the context in the input sequence. As per the name, it makes the embedding of one token (say \"Bank\") \"attend\" to other words in the sequence as the meaning of the word changes wrt the context (\"Bank\" in \"West Bank\" is different from \"Money Bank\") . Over time, researchers have developed different versions of attention mechanisms which provide higher performance with reduction in computation costs. For example, in LLaMA-3.1, researchers used Grouped Query Attention as it improves inference speed and reduces memory usage during decoding. [1] Vocabulary: Deciding the vocabulary size depends on a lot of factors like, model size : Large vocab equals large embedding matrix and hence larger model, training data : Model trained for single language needs less vocab than the one trained for multiple languages. Adding support for programming languages would further warrant increase in vocabulary, and compute budget : Even if you have certain idea on the above points, in the end it all comes down to how much you can affort for training. Training a big model (with huge vocab) on less compute budget, in most case can lead to poor performance. As an example, LLaMa-3.1 uses a 128K token vocabulary with better compression for English, non-English languages and even several programming languages. [1] Hint Research has shown that optimizing the vocabulary size of a language model can have a significant impact on its inference efficiency. For example, a model trained on a limited vocabulary of English language tokens and some special tokens may be able to generate code in certain programming languages, but will be highly inefficient during inference. This is because the model will have to generate more tokens to represent a given code snippet, which can lead to slower inference times. Optimizing the vocabulary size to include programming language specific keywords and tokens can help to mitigate this issue, but this needs to be done while avoiding an explosion in the overall vocabulary size. Position Encoding : Positional embeddings are vectors that are added to token embeddings in transformer models to incorporate information about the order and position of tokens in the input sequence. Since transformers process tokens in parallel and don't inherently capture sequence order like recurrent neural networks, positional embeddings are crucial for modeling the position of each token. Over time researchers have developed different types of positional embeddings such as Absolute Positional Embedding, Relative Positional Embeddings, Rotary Positional Embeddings (RoPE), etc. LLaMA-3.1 uses RoPE as it improves handling of longer contexts. [1] Hint Not all position encodings are adding directly to the token embeddings during input processing. While absolute positional embeddings are added to the input token embeddings directly, relative positional embeddings are introduced in the attention layer. Scaling Laws Scaling laws are used to estimate the relationship between the performance of large language models (LLMs) and the resources used to train them, such as model size, dataset size, and computational budget. This is an important step in training LLMs as it helps to approximate the optimal size and training regime for your model. There are two ways to do this, first is to follow one of the several reputed scaling laws like Chinchilla Scaling, and second is to perform an estimation on your own. Source [1] Below are the steps LLaMA-3.1 researchers used to create their own scaling law estimations [1]. This can act as a reference if you want to create your own scaling laws. Conduct pre-training runs using a range of compute budgets and model sizes. Note, both of the ranges should be much less than (just a fraction of) the final intended budget. For example, LLaMa-3.1 researchers trained models with compute budgets ranging from 6 \u00d7 10^(18) FLOPs to 10^(22) FLOPs (overall budget was ~10^(25) FLOPs) and model sizes ranging from 40M to 16B parameters (final model was ~400B) . For each compute budget, fit a second-degree polynomial to the curve of validation loss versus training tokens. This will identify the compute-optimal model, which corresponds to the minimum of the parabola. (as shown in the left side of above image) Compute-optimal models are used to identify the optimal number of training tokens for a specific compute budget. For this, fit a power-law function to extrapolate to larger compute budgets. This will allow you to predict the optimal number of training tokens for a specific compute budget. (as shown in the right side of above image) Hint LLaMA-3.1 researchers further used the compute-optimal models to predict downstream task performance by correlating the negative log-likelihood of the correct answer on the benchmark task with the training FLOPs. Then, they established a sigmoidal relation between the log-likelihood and accuracy using both the scaling law models and older models trained with higher compute FLOPs. This helped researchers in predicting the final performance of the model. Interesting fact - they were able to do this with high accuracy, in fact the predictions were only a slight underestimations of the final performance [1]. Infrastructure and Efficiency Once we have a basic understanding of the what we want to achieve, we can proceed to estimate the hardware and infrastructure needed to train our model. This includes arranging computes, storage and setting up proper network for the training. Some things to consider are, Memory : To begin with it is important to know the memory requiredments to train your model. A rough estimation of how much memory is required for inference of a model of a particular size is provided in [4] and shown below. Here, M is the memory required for the model, P is the number of parameters in the model (in billions) , 4 is the number of bytes, and Q is the number of bits that should be used for loading the model. The memory required for model training could be 2x to 4x of the memory required for inference, as gradients and activations are also stored in memory. \\[M_{\\text{inference}} = \\frac{(P * 4)}{(32/Q)}*{1.2}\\] \\[M_{\\text{training}} \\approx 3 * M_{\\text{inference}}\\] Note Models are usually trained on half-precision i.e. Q = 16 bits or full-precision i.e. Q = 32 bits . The denominator in the above equation can be updated based on the precision used in the model training regime. GPU Hours : GPU hours refer to the total time a GPU is engaged in processing tasks. For instance, if one GPU runs for 5 hours, that accounts for 5 GPU hours. If multiple GPUs are used simultaneously, the total GPU hours are the sum of the hours each GPU operates. To calculate GPU hours for training LLMs, you can use a simplified formula that considers key factors such as model size, data size, and GPU performance. [5] \\[\\text{GPU Hours} = \\frac{(\\text{Model Parameters} \\times \\text{Training Tokens} \\times \\text{Computations Per Token})}{\\text{GPU Speed}}\\] Let's consider one example where we want to train a model of 7 billion parameters over 1 trillion tokens, with 6 computations per token, and a GPU with a speed of 10 TFLOPS. The calculations will look something as shown below, \\[\\text{GPU Hours} = \\frac{(7,000,000,000 \\times 1,000,000,000,000 \\times 6)}{10^{13}} = \\frac{42,000,000,000,000,000}{10^{13}} = 4200 \\text{ hours}\\] This means you would need approximately 4200 GPU hours to complete the training under these conditions. Note It's important to consider the GPU utilization rate (percentage of the theoretical peak FLOPS that was achieved on average during training) , which can significantly affect the actual GPU hours required. A typical utilization rate for LLM training might range from 30% to 50% depending on the efficiency of the training process and the architecture used. Storage : Large language model training requires a significant amount of storage space, which is mainly used for saving model checkpoints at regular intervals. According to [1], during the training of LLaMa-3.1, each checkpoint was between 1MB to 4GB per GPU, which was saved at frequent intervals. It is also important to ensure that the storage system is fast enough to quickly read and write the checkpoints, as slow storage can lead to GPUs idling for extended periods while waiting for the IO operations to complete. Parallelism : To enhance efficiency, LLMs can be trained in parallel using multiple GPUs. To further enhance the utilization rate, LLaMA-3.1 researchers applied 4D parallelism as discussed below, Tensor Parallelism (TP): Splits individual weight tensors into multiple chunks and distributes them across different GPUs. It reduces the memory footprint on each GPU, allowing for larger models to be trained. Pipeline Parallelism (PP): Divides the model into stages (layers) and processes these stages in parallel on different GPUs. It increases throughput by overlapping the computation of different stages. Context Parallelism (CP): Splits the input context (sequence) into segments and processes them in parallel. It reduces memory requirements for very long sequences. Data Parallelism (DP): Distributes the data across multiple GPUs and processes each batch in parallel. It increases throughput by processing multiple batches simultaneously. Source [1] Training Recipe Once all of the above considerations are made, we can move on to the training process. Usually, the pre-training of a LLM consist of a single step wherein the model is trained on the corpus of text with some variables like learning rate, batch size, data mix, etc, changing over time. Data Scientists can either predefine the change (ex: using cosine learning rate schedule) or modify the values based on model performance (ex: add more non-English data if multilingual performance of current model is not satisfatory) . Recently there has been a surge in requirement of LLMs to support higher context length. For this, after the initial pretraining, the model can be trained on longer sequences to expand its context window. This can be done incrementally to allow the model to adapt to the increased length. It is important to only proceed with further increment after ensuring that the model performance on short contexts has recovered and it is perfectly solving \"needle in a haystack\" tasks up to that length. In Llama 3 405B [1], the context length was increased in six stages, from 8K to 128K, using approximately 800B training tokens. Post-Training Post-training of LLMs is a crucial phase that enhances the capabilities of models that have already undergone pre-training. It is assumed that during pre-training, the model is trained on a large corpus of text (in a self-supervised manner) and has learned the structure of the language. Now the model can be fine-tuned on specific use cases or capabilities expected out of the model. This phase typically consists of two main components: Supervised Finetuning (SFT) Supervised finetuning is an essential step that builds upon the foundational knowledge acquired during pre-training. In this phase, the model is trained on a curated dataset with high-quality reference outputs, focusing on a specific task or set of tasks. The objective is to refine the model's ability to generate appropriate and contextually relevant responses. During supervised finetuning, the model learns to mimic the style and format of responses within the provided dataset. This process is often referred to as instruction tuning, where the model is explicitly trained to follow instructions and respond to specific requests, enhancing its interactivity and usefulness. Studies have shown that this phase significantly improves the model's performance on unseen tasks, making it more adept at generalizing beyond its training data. Hint Modern approaches to supervised finetuning also emphasize efficiency. Techniques such as Low-Rank Adaptation (LoRA) allow for parameter-efficient finetuning, where only a small number of task-specific parameters are adapted while keeping the majority of the pretrained weights fixed. This method drastically reduces memory overhead and simplifies the deployment process, enabling practitioners to finetune LLMs with less computational power and resources. Human Alignment Training Following supervised finetuning, human alignment training further refines the model's outputs based on human feedback. This phase is critical for ensuring that the model aligns with human values and preferences, making it safer and more effective for real-world applications. Human alignment training typically involves reinforcement learning from human feedback (RLHF) , where the model's responses are evaluated by human annotators. These evaluators provide preference labels that guide the model's learning process, helping it to produce responses that are more aligned with user expectations. Recently there has been a shift towards using DPO instead of RLHF as it provides better performance along with better efficiency during training. The integration of human feedback into the training loop not only improves the quality of the model's outputs but also helps in addressing ethical considerations by ensuring that the model behaves in a manner consistent with human values. This iterative feedback process is essential for developing LLMs that are not only technically proficient but also socially responsible. PPO model trained with RLHF outperforming SFT and base models by OpenAI. Source [9] Additional Techniques In addition to the techniques mentioned above, there are other practical techniques that can be applied to further refine the post-training process. These techniques can be used to improve the performance of the model on specific tasks or to make the model more robust in general. Some examples of these techniques are discussed below. Reward Modeling While training a reward model is a requirement for RLHF, it is no longer required for DPO. Nevertheless, data scientists can train a reward model for data generation process. This is done because SFT requires large quantity of high quality dataset which is not always available and is very time consuming to create. Reward model is trained on the available set of human annotated dataset. To create this dataset, first a diverse set of input prompts are generated and a model (usually the best checkpoint pre-trained model) is used to generate several responses (say A, B, C, ... N) on the generated prompts. Then the humans are asked to rank the responses (ex: A > B > C...) . After this \"N choose 2\" pairs of datasets are created that looks like (Prompt, A, B), (Prompt, B, C), (Prompt, C, D), etc. The idea here is to have the prompt, one preferred response and one non-preferred response for each dataset example. This can be used to train the reward model with following loss function, [7] \\[\\mathcal{L}=-\\log \\left(\\sigma\\left(r_\\theta\\left(x, y_c\\right)-r_\\theta\\left(x, y_r\\right)\\right)\\right)\\] where \\(r_\u03b8(x,y)\\) is the scalar score output for prompt \\(x\\) and the generated response \\(y\\) , \\(y_c\\) and \\(y_r\\) are the preferred and rejected responses chosen by the human annotators, and \\(\u03c3\\) is the logistic sigmoid function. Rejection Sampling To create a high quality dataset for SFT or DPO, we can use human annotators or the trained reward model to reject poor responses. The idea is quite simple, use the best pre-trained model to generate multiple responses and use the reward model to rank the responses. Based on the ranking, only the top ranked responses can be used to create the dataset. Iteration Training Instead of doing one round of SFT or DPO, we can do multiple iterations to improve the quality of the model's outputs. LLaMa-3.1 paper [1] performed 6 iterations and LLaMa-2 paper [8] performed 5 iterations of post-training process that greatly enhanced the model's performance as shown below. Increasing performance of the model with each iteration of post-training on the LLaMa-2 model. Source [8] Conclusion In closing, training Large Language Models (LLMs) is a complex yet rewarding process. By following the two distinct stages of pre-training and post-training, we can equip these models with the ability to understand and generate human language at a remarkable level. Pre-training focuses on building a strong foundation by exposing the model to vast amounts of text data, allowing it to learn the structure and patterns of language. Post-training then refines the model's capabilities through techniques like supervised finetuning and human alignment training, ensuring it aligns with human values and performs well on specific tasks. The field of LLM training is constantly evolving, with researchers pushing the boundaries of what's possible. As we continue to develop more sophisticated techniques and leverage the power of ever-increasing datasets, LLMs hold the potential to revolutionize various aspects of our lives, from communication and content creation to scientific discovery and problem-solving. References [1] The Llama 3 Herd of Models - Paper [2] Attention Is All You Need - Paper [3] A General Survey on Attention Mechanisms in Deep Learning - Paper [4] Calculating GPU memory for serving LLMs [5] Estimating Training Compute of Deep Learning Models [6] Decoder-Only or Encoder-Decoder? Interpreting Language Model as a Regularized Encoder-Decoder [7] LLM Training: RLHF and Its Alternatives [8] Llama 2: Open Foundation and Fine-Tuned Chat Models - Paper [9] Training language models to follow instructions with human feedback - Paper","title":"Training LLMs"},{"location":"natural_language_processing/training_llm/#introduction","text":"Large Language Models (LLMs) are a type of artificial intelligence system designed to process and understand human language. They are capable of generating text, completing sentences, summarizing content, answering questions, and more, with remarkable accuracy. The accuracy of LLMs stems from their ability to learn patterns and structures from vast amounts of text data, which enables them to make predictions about the next word or sequence of words. Training LLMs is a complex process that requires a deep understanding of the underlying concepts and techniques. This article provides a comprehensive overview of the process of training LLMs.","title":"Introduction"},{"location":"natural_language_processing/training_llm/#stages-of-training-llms","text":"The process of training a Large Language Model (LLM) consists of two distinct stages. Language model pre-training. We start by converting a large, multilingual text corpus to discrete tokens and pre-training a large language model (LLM) on the resulting data to perform next-token prediction. In the language model pre-training stage, the model learns the structure of language and obtains large amounts of knowledge about the world from the text it is \u201creading\u201d (or training on) . This is further divided into, the curation and filtering of a large-scale training corpus (i.e. datasets) , the development of model architecture and corresponding scaling laws for determining model size, the development of techniques for e\ufb03cient pre-training at large scale, and the development of a pre-training recipe. Language model post-training. The pre-trained language model has a rich understanding of language but it does not yet follow instructions or behave in the way we would expect an assistant to. We align the model with human feedback in several rounds, each of which involves supervised finetuning (SFT) on instruction tuning data and Direct Preference Optimization (DPO) . At this post-training stage, we also integrate new capabilities, such as tool-use, and observe strong improvements in other areas, such as coding and reasoning. Finally, safety mitigations are also incorporated. Let's dive into these stages in more details.","title":"Stages of Training LLMs"},{"location":"natural_language_processing/training_llm/#pre-training","text":"To refresh, pre-training stage is the first stage of LLM training and deals with making the LLM aware of the structure of language by training it on a large corpus of text curated from the internet. Let's discuss the intermediate stages of pre-training.","title":"Pre-Training"},{"location":"natural_language_processing/training_llm/#data-curation","text":"To train a Large Language Model (LLM), we first need to collect a large amount of text data. The data collection for language model pre-training involves curation and filtering of web data to create a diverse and large quantity of dataset. This dataset is then processed and optimized to extract high-quality text. The dataset is filtered to remove domains that contain personal information, harmful content, or adult content. Additionally, the dataset is de-duplicated to remove duplicate lines and documents. Heuristics and model-based quality filters are used to remove low-quality documents and excessive repetitions. The data mix for pre-training is determined by classifying the types of information in the web data and using scaling law experiments to determine the best data mix. In LLaMa-3.1, the data mix contains roughly 50% of tokens corresponding to general knowledge, 25% of mathematical and reasoning tokens, 17% code tokens, and 8% multilingual tokens. [1]","title":"Data Curation"},{"location":"natural_language_processing/training_llm/#model-architecture","text":"Once we have the dataset ready, the next step is to design the model architecture. Transformer based architectures has been the defacto choice for many LLMs since its inception in 2017 [2]. That said, the complete system consists of several independent components that can be altered to further enhance the accuracy and performance. Let's discuss some of these components. Base Design : Original Transformer paper [2] consists of an encoder and decoder block. While the encoder block is good for encoding the contextual information of the input sequence, decoder block is responsible for decoding the output sequence in auto-regressive manner. Over time there has been a general conceptual shift from encoder-decoder to decoder-only architecture for LLMs. As an example, Llama 3 uses a standard decoder-only transformer architecture similar to Llama and Llama 2 [1]. Hint Refer paper \"Decoder-Only or Encoder-Decoder? Interpreting Language Model as a Regularized Encoder-Decoder\" [6] for a holistic comparison of the different architectures. Attention Layer : Attention layers were made popular with original Transformer paper [2] and is useful for updating the token embeddings wrt the context in the input sequence. As per the name, it makes the embedding of one token (say \"Bank\") \"attend\" to other words in the sequence as the meaning of the word changes wrt the context (\"Bank\" in \"West Bank\" is different from \"Money Bank\") . Over time, researchers have developed different versions of attention mechanisms which provide higher performance with reduction in computation costs. For example, in LLaMA-3.1, researchers used Grouped Query Attention as it improves inference speed and reduces memory usage during decoding. [1] Vocabulary: Deciding the vocabulary size depends on a lot of factors like, model size : Large vocab equals large embedding matrix and hence larger model, training data : Model trained for single language needs less vocab than the one trained for multiple languages. Adding support for programming languages would further warrant increase in vocabulary, and compute budget : Even if you have certain idea on the above points, in the end it all comes down to how much you can affort for training. Training a big model (with huge vocab) on less compute budget, in most case can lead to poor performance. As an example, LLaMa-3.1 uses a 128K token vocabulary with better compression for English, non-English languages and even several programming languages. [1] Hint Research has shown that optimizing the vocabulary size of a language model can have a significant impact on its inference efficiency. For example, a model trained on a limited vocabulary of English language tokens and some special tokens may be able to generate code in certain programming languages, but will be highly inefficient during inference. This is because the model will have to generate more tokens to represent a given code snippet, which can lead to slower inference times. Optimizing the vocabulary size to include programming language specific keywords and tokens can help to mitigate this issue, but this needs to be done while avoiding an explosion in the overall vocabulary size. Position Encoding : Positional embeddings are vectors that are added to token embeddings in transformer models to incorporate information about the order and position of tokens in the input sequence. Since transformers process tokens in parallel and don't inherently capture sequence order like recurrent neural networks, positional embeddings are crucial for modeling the position of each token. Over time researchers have developed different types of positional embeddings such as Absolute Positional Embedding, Relative Positional Embeddings, Rotary Positional Embeddings (RoPE), etc. LLaMA-3.1 uses RoPE as it improves handling of longer contexts. [1] Hint Not all position encodings are adding directly to the token embeddings during input processing. While absolute positional embeddings are added to the input token embeddings directly, relative positional embeddings are introduced in the attention layer.","title":"Model Architecture"},{"location":"natural_language_processing/training_llm/#scaling-laws","text":"Scaling laws are used to estimate the relationship between the performance of large language models (LLMs) and the resources used to train them, such as model size, dataset size, and computational budget. This is an important step in training LLMs as it helps to approximate the optimal size and training regime for your model. There are two ways to do this, first is to follow one of the several reputed scaling laws like Chinchilla Scaling, and second is to perform an estimation on your own. Source [1] Below are the steps LLaMA-3.1 researchers used to create their own scaling law estimations [1]. This can act as a reference if you want to create your own scaling laws. Conduct pre-training runs using a range of compute budgets and model sizes. Note, both of the ranges should be much less than (just a fraction of) the final intended budget. For example, LLaMa-3.1 researchers trained models with compute budgets ranging from 6 \u00d7 10^(18) FLOPs to 10^(22) FLOPs (overall budget was ~10^(25) FLOPs) and model sizes ranging from 40M to 16B parameters (final model was ~400B) . For each compute budget, fit a second-degree polynomial to the curve of validation loss versus training tokens. This will identify the compute-optimal model, which corresponds to the minimum of the parabola. (as shown in the left side of above image) Compute-optimal models are used to identify the optimal number of training tokens for a specific compute budget. For this, fit a power-law function to extrapolate to larger compute budgets. This will allow you to predict the optimal number of training tokens for a specific compute budget. (as shown in the right side of above image) Hint LLaMA-3.1 researchers further used the compute-optimal models to predict downstream task performance by correlating the negative log-likelihood of the correct answer on the benchmark task with the training FLOPs. Then, they established a sigmoidal relation between the log-likelihood and accuracy using both the scaling law models and older models trained with higher compute FLOPs. This helped researchers in predicting the final performance of the model. Interesting fact - they were able to do this with high accuracy, in fact the predictions were only a slight underestimations of the final performance [1].","title":"Scaling Laws"},{"location":"natural_language_processing/training_llm/#infrastructure-and-efficiency","text":"Once we have a basic understanding of the what we want to achieve, we can proceed to estimate the hardware and infrastructure needed to train our model. This includes arranging computes, storage and setting up proper network for the training. Some things to consider are, Memory : To begin with it is important to know the memory requiredments to train your model. A rough estimation of how much memory is required for inference of a model of a particular size is provided in [4] and shown below. Here, M is the memory required for the model, P is the number of parameters in the model (in billions) , 4 is the number of bytes, and Q is the number of bits that should be used for loading the model. The memory required for model training could be 2x to 4x of the memory required for inference, as gradients and activations are also stored in memory. \\[M_{\\text{inference}} = \\frac{(P * 4)}{(32/Q)}*{1.2}\\] \\[M_{\\text{training}} \\approx 3 * M_{\\text{inference}}\\] Note Models are usually trained on half-precision i.e. Q = 16 bits or full-precision i.e. Q = 32 bits . The denominator in the above equation can be updated based on the precision used in the model training regime. GPU Hours : GPU hours refer to the total time a GPU is engaged in processing tasks. For instance, if one GPU runs for 5 hours, that accounts for 5 GPU hours. If multiple GPUs are used simultaneously, the total GPU hours are the sum of the hours each GPU operates. To calculate GPU hours for training LLMs, you can use a simplified formula that considers key factors such as model size, data size, and GPU performance. [5] \\[\\text{GPU Hours} = \\frac{(\\text{Model Parameters} \\times \\text{Training Tokens} \\times \\text{Computations Per Token})}{\\text{GPU Speed}}\\] Let's consider one example where we want to train a model of 7 billion parameters over 1 trillion tokens, with 6 computations per token, and a GPU with a speed of 10 TFLOPS. The calculations will look something as shown below, \\[\\text{GPU Hours} = \\frac{(7,000,000,000 \\times 1,000,000,000,000 \\times 6)}{10^{13}} = \\frac{42,000,000,000,000,000}{10^{13}} = 4200 \\text{ hours}\\] This means you would need approximately 4200 GPU hours to complete the training under these conditions. Note It's important to consider the GPU utilization rate (percentage of the theoretical peak FLOPS that was achieved on average during training) , which can significantly affect the actual GPU hours required. A typical utilization rate for LLM training might range from 30% to 50% depending on the efficiency of the training process and the architecture used. Storage : Large language model training requires a significant amount of storage space, which is mainly used for saving model checkpoints at regular intervals. According to [1], during the training of LLaMa-3.1, each checkpoint was between 1MB to 4GB per GPU, which was saved at frequent intervals. It is also important to ensure that the storage system is fast enough to quickly read and write the checkpoints, as slow storage can lead to GPUs idling for extended periods while waiting for the IO operations to complete. Parallelism : To enhance efficiency, LLMs can be trained in parallel using multiple GPUs. To further enhance the utilization rate, LLaMA-3.1 researchers applied 4D parallelism as discussed below, Tensor Parallelism (TP): Splits individual weight tensors into multiple chunks and distributes them across different GPUs. It reduces the memory footprint on each GPU, allowing for larger models to be trained. Pipeline Parallelism (PP): Divides the model into stages (layers) and processes these stages in parallel on different GPUs. It increases throughput by overlapping the computation of different stages. Context Parallelism (CP): Splits the input context (sequence) into segments and processes them in parallel. It reduces memory requirements for very long sequences. Data Parallelism (DP): Distributes the data across multiple GPUs and processes each batch in parallel. It increases throughput by processing multiple batches simultaneously. Source [1]","title":"Infrastructure and Efficiency"},{"location":"natural_language_processing/training_llm/#training-recipe","text":"Once all of the above considerations are made, we can move on to the training process. Usually, the pre-training of a LLM consist of a single step wherein the model is trained on the corpus of text with some variables like learning rate, batch size, data mix, etc, changing over time. Data Scientists can either predefine the change (ex: using cosine learning rate schedule) or modify the values based on model performance (ex: add more non-English data if multilingual performance of current model is not satisfatory) . Recently there has been a surge in requirement of LLMs to support higher context length. For this, after the initial pretraining, the model can be trained on longer sequences to expand its context window. This can be done incrementally to allow the model to adapt to the increased length. It is important to only proceed with further increment after ensuring that the model performance on short contexts has recovered and it is perfectly solving \"needle in a haystack\" tasks up to that length. In Llama 3 405B [1], the context length was increased in six stages, from 8K to 128K, using approximately 800B training tokens.","title":"Training Recipe"},{"location":"natural_language_processing/training_llm/#post-training","text":"Post-training of LLMs is a crucial phase that enhances the capabilities of models that have already undergone pre-training. It is assumed that during pre-training, the model is trained on a large corpus of text (in a self-supervised manner) and has learned the structure of the language. Now the model can be fine-tuned on specific use cases or capabilities expected out of the model. This phase typically consists of two main components:","title":"Post-Training"},{"location":"natural_language_processing/training_llm/#supervised-finetuning-sft","text":"Supervised finetuning is an essential step that builds upon the foundational knowledge acquired during pre-training. In this phase, the model is trained on a curated dataset with high-quality reference outputs, focusing on a specific task or set of tasks. The objective is to refine the model's ability to generate appropriate and contextually relevant responses. During supervised finetuning, the model learns to mimic the style and format of responses within the provided dataset. This process is often referred to as instruction tuning, where the model is explicitly trained to follow instructions and respond to specific requests, enhancing its interactivity and usefulness. Studies have shown that this phase significantly improves the model's performance on unseen tasks, making it more adept at generalizing beyond its training data. Hint Modern approaches to supervised finetuning also emphasize efficiency. Techniques such as Low-Rank Adaptation (LoRA) allow for parameter-efficient finetuning, where only a small number of task-specific parameters are adapted while keeping the majority of the pretrained weights fixed. This method drastically reduces memory overhead and simplifies the deployment process, enabling practitioners to finetune LLMs with less computational power and resources.","title":"Supervised Finetuning (SFT)"},{"location":"natural_language_processing/training_llm/#human-alignment-training","text":"Following supervised finetuning, human alignment training further refines the model's outputs based on human feedback. This phase is critical for ensuring that the model aligns with human values and preferences, making it safer and more effective for real-world applications. Human alignment training typically involves reinforcement learning from human feedback (RLHF) , where the model's responses are evaluated by human annotators. These evaluators provide preference labels that guide the model's learning process, helping it to produce responses that are more aligned with user expectations. Recently there has been a shift towards using DPO instead of RLHF as it provides better performance along with better efficiency during training. The integration of human feedback into the training loop not only improves the quality of the model's outputs but also helps in addressing ethical considerations by ensuring that the model behaves in a manner consistent with human values. This iterative feedback process is essential for developing LLMs that are not only technically proficient but also socially responsible. PPO model trained with RLHF outperforming SFT and base models by OpenAI. Source [9]","title":"Human Alignment Training"},{"location":"natural_language_processing/training_llm/#additional-techniques","text":"In addition to the techniques mentioned above, there are other practical techniques that can be applied to further refine the post-training process. These techniques can be used to improve the performance of the model on specific tasks or to make the model more robust in general. Some examples of these techniques are discussed below.","title":"Additional Techniques"},{"location":"natural_language_processing/training_llm/#reward-modeling","text":"While training a reward model is a requirement for RLHF, it is no longer required for DPO. Nevertheless, data scientists can train a reward model for data generation process. This is done because SFT requires large quantity of high quality dataset which is not always available and is very time consuming to create. Reward model is trained on the available set of human annotated dataset. To create this dataset, first a diverse set of input prompts are generated and a model (usually the best checkpoint pre-trained model) is used to generate several responses (say A, B, C, ... N) on the generated prompts. Then the humans are asked to rank the responses (ex: A > B > C...) . After this \"N choose 2\" pairs of datasets are created that looks like (Prompt, A, B), (Prompt, B, C), (Prompt, C, D), etc. The idea here is to have the prompt, one preferred response and one non-preferred response for each dataset example. This can be used to train the reward model with following loss function, [7] \\[\\mathcal{L}=-\\log \\left(\\sigma\\left(r_\\theta\\left(x, y_c\\right)-r_\\theta\\left(x, y_r\\right)\\right)\\right)\\] where \\(r_\u03b8(x,y)\\) is the scalar score output for prompt \\(x\\) and the generated response \\(y\\) , \\(y_c\\) and \\(y_r\\) are the preferred and rejected responses chosen by the human annotators, and \\(\u03c3\\) is the logistic sigmoid function.","title":"Reward Modeling"},{"location":"natural_language_processing/training_llm/#rejection-sampling","text":"To create a high quality dataset for SFT or DPO, we can use human annotators or the trained reward model to reject poor responses. The idea is quite simple, use the best pre-trained model to generate multiple responses and use the reward model to rank the responses. Based on the ranking, only the top ranked responses can be used to create the dataset.","title":"Rejection Sampling"},{"location":"natural_language_processing/training_llm/#iteration-training","text":"Instead of doing one round of SFT or DPO, we can do multiple iterations to improve the quality of the model's outputs. LLaMa-3.1 paper [1] performed 6 iterations and LLaMa-2 paper [8] performed 5 iterations of post-training process that greatly enhanced the model's performance as shown below. Increasing performance of the model with each iteration of post-training on the LLaMa-2 model. Source [8]","title":"Iteration Training"},{"location":"natural_language_processing/training_llm/#conclusion","text":"In closing, training Large Language Models (LLMs) is a complex yet rewarding process. By following the two distinct stages of pre-training and post-training, we can equip these models with the ability to understand and generate human language at a remarkable level. Pre-training focuses on building a strong foundation by exposing the model to vast amounts of text data, allowing it to learn the structure and patterns of language. Post-training then refines the model's capabilities through techniques like supervised finetuning and human alignment training, ensuring it aligns with human values and performs well on specific tasks. The field of LLM training is constantly evolving, with researchers pushing the boundaries of what's possible. As we continue to develop more sophisticated techniques and leverage the power of ever-increasing datasets, LLMs hold the potential to revolutionize various aspects of our lives, from communication and content creation to scientific discovery and problem-solving.","title":"Conclusion"},{"location":"natural_language_processing/training_llm/#references","text":"[1] The Llama 3 Herd of Models - Paper [2] Attention Is All You Need - Paper [3] A General Survey on Attention Mechanisms in Deep Learning - Paper [4] Calculating GPU memory for serving LLMs [5] Estimating Training Compute of Deep Learning Models [6] Decoder-Only or Encoder-Decoder? Interpreting Language Model as a Regularized Encoder-Decoder [7] LLM Training: RLHF and Its Alternatives [8] Llama 2: Open Foundation and Fine-Tuned Chat Models - Paper [9] Training language models to follow instructions with human feedback - Paper","title":"References"},{"location":"natural_language_processing/transformer/","text":"Transformers Introduction \"Attention Is All You Need\" paper [1] introduced the concept of \"Transformers\" and it revolutionalized the complete domain of Deep Learning. So much so that in 2022 we have Transformers has become multi-disiplinary and is used across NLP, CV, RL, Graphs, and more! In NLP, Transformers variants are still state of the art! (even after 5 years) . As the paper's name suggests, the authors showcase how only using multiple stacks of attention layers provides enough learning power to the architecture to improve the SotA in multiple tasks. Quoting the paper, \"Transformer is the first transduction model relying entirely on self-attention to compute representations of its input and output without using sequence-aligned RNNs or convolution.\" Let's try to understand the fundamentals of Transformers by going through each components in detail. Hint Transduction is a broad term but in nearly all aspect it means converting data, signal or object from one format to another. Transformers transforms input data from one format to another ( \\(x_i\\) in encoder leads to \\(y_i\\) in decoder) , so it is transductive model. Hence the name \"Transformers\" Transformer architecture. Left part is the encoder and right part is the decoder part [1] At a high level, the architecture can be divided into two modules, Encoder: the component resonsible to learn representation of the input prompt. It process each token of the input parallely in one iteration and generates attention aware representations for each token. The encoder layer consists of 6 identical blocks with output dimension of \\(d_{model} = 512\\) . Decoder: the component reposible for generating the output. The execution strategy depends on the scenario. During training as ground truth is also available, complete processing happens in one iteration using teacher forcing and masked attention. During inference multiple iterations are run where one output is generated in one go. Decoder layer also consists of 6 identical blocks. Components of Transformers Self-Attention Probably the most important component of Transformer is the Attention Layer. The intuition here is that the context matters. For example in a sentence, meaning of a word like \"bank\" could vary based on if it is \"river bank\" or \"financial bank\". Similarly, pronouns like He, She, It, etc could also attend to certain other words in the sentence (name of the person or object) . With this in mind, a true meaning (representation) of a word can only be identified by attending to all the other words in context. Self-Attention is just one way to do that. Scaled dot product attention [1] Compared to previous approaches like RNN or Word2Vec that were used to create representations of the words, Attention models modifies the representation for each input based on the context. Word2Vec had a fixed context and worked at word level, so \"bank\" will have 1 representation word embedding. RNN on the other hand only considered sequential context that lead to forgetting the context of the past (words far on the left) . Note The smallest unit of input in Transformer are called tokens which could be at sub-word or words level. And attention could span over a phrase, a sentence, a paragraph or a complete article. The process of self-attention is quite simple. For each token, find the importance score of every token in the context (including the token in question) , and using the score, do a weighted sum of the every token's representations to create the final token representation. And thats it Well at least from 10k feet . Looking at the technicalities, the process drills down to, Every token is not used as-it-is, but first converted to key, value and query format using linear projections. We have key, value and query weights denoted as \\(W_k\\) , \\(W_v\\) and \\(W_q\\) . Each input token's representation is first multipled with these weights to get \\(k_i\\) , \\(v_i\\) and \\(q_i\\) . Next the query of one token is dot product with the keys of all token. On applying softmax to the output, we get a probability score of importance of every token for the given token. Finally, we do weighted sum of values of all keys with this score and get the vector representation of the current token. It is easy to understand the process while looking at one token at a time, but in reality it is completely vectorized and happens for all the tokens at the same time. The formula for the self-attention is shown below, where Q, K and V are the matrices you get on multiplication of all input tokens with the query, key and value weights. \\[ Attention(Q, K, V) = softmax(\\frac{QK^T}{\\sqrt{d_k}})V \\] Note Authors introduced the scaling factor to handle potential vanishing gradient problem. In their words, \"We suspect that for large values of \\(d_k\\) , the dot products grow large in magnitude, pushing the softmax function into regions where it has extremely small gradients. To counteract this effect, we scale the dot products by \\(\\frac{1}{\\sqrt{d_k}}\\) \" Multi-head Attention Instead of performing the complete attention computation in a single layer, the authors divided the computation into muliple heads or parts. This is done quite intuitively, let's take an example where we want to have say 8 heads in each layer. In this case the projections weights ( \\(W_k\\) , \\(W_v\\) and \\(W_q\\) ) downsize the token embedding into \\(\\frac{1}{8}\\) the size. This can be done by making the dimension of the weights token_dim * token_dim/8 . After this we repeat the complete process as discussed in self-attention. Multi-Head Attention [1] Now at the end we will have 8 outputs instead of one, i.e. 8 different partial representations for each token (which is not strictly correct and not what we want) . So to aggregate to get 1 output, authors concatenated the outputs and then apply a linear projection (multiply with \\(W^o\\) ) to get the original sized 1 representation per token. The formulation is shown below, \\[ \\text{MultiHead}(Q, K, V) = \\text{Concat}(head_1, head_2, ..., head_h) W^o \\] Masked Attention As discussed before, during training, decoder use masked attention to prevent model from attending to the future tokens. This is done so that the model does not cheat while predicting the output. Note Having bidirectional context on input is okay (as done by encoder with normal attention) , but in decoder we should only attend to what we have already seen and not the future. The approach is also quite easy to understand, it is very similar to the normal attention where we compute the query, key and value vectors. The only difference is that while computing attention scores, we explicitly make the score of future tokens zero. This is done by making the score (before softmax) at the future places equal to large negative number. On applying Softmax, those values become zero. Position-wise Feed Forward Layers Encoder and Decoder contains fully connected feed-forward neural network that is applied to each position (token) separately and identically. It consists of two linear transformations with a ReLU activation in between. The formualtion is given below, \\[ \\text{FFN}(x)=max(0, xW_1 + b_1)W_2 + b_2 \\] Note The parameters \\(W_1\\) , \\(W_2\\) , \\(b_1\\) and \\(b_2\\) are different in different layers. Positional Embeddings For the model to consider the order of sequence for representation and prediction, authors injected a sense of relative or absolute position in the input by using positional embeddings. It is injected to each token separately and has the same embedding size as that of the token i.e \\(d_{model}\\) . For each token we have a position vector. After modification, the token embedding will be a combination of two types of information -- positional (injected by positional embedding) and semantic (learned by the model) . While there are many choices for the position embedding, authors wanted to pick the one that does not compromise the semantic information by a lot. In the paper authors alternatively use sine and cosine functions (at indices of vector) of different frequencies, \\[ \\text{PE}_{pos, 2i} = sin(\\frac{pos}{10000^{2i/d_{model}}}) \\] \\[ \\text{PE}_{pos, 2i+1} = cos(\\frac{pos}{10000^{2i/d_{model}}}) \\] Here pos is the position of the token in sequence and i is the index of the vector for a token. Position Encoding for 100 positions, each of 512 dimension size Let's understand the process using an example sentence - \"My name is Mohit\" with words as tokens. So we have 4 tokens, and with dimension size of 4, each token could be represented as shown below, ## Token Embedding My = [ 0.1 , 0.2 , 1 , 0.45 ] Name = [ 0.15 , 0.32 , 13 , 0.51 ] is = [ - 0.1 , 0.21 , 0.65 , 0.25 ] Mohit = [ 0.1 , - 0.12 , 0.33 , - 0.45 ] Now we will compute the positional embeddings using the above formulae, ## Positional embedding pos_1 = [ 0. 1. 0. 1. ] pos_2 = [ 0.84147098 0.54030231 0.09983342 0.99500417 ] pos_3 = [ 0.90929743 - 0.41614684 0.19866933 0.98006658 ] pos_4 = [ 0.14112001 - 0.9899925 0.29552021 0.95533649 ] Finally the modified embedding for the tokens will be addition of the original token embedding and positional embedding. ## Modified embedding My = [ 0.1 , 0.2 , 1 , 0.45 ] + [ 0. 1. 0. 1. ] Name = [ 0.15 , 0.32 , 13 , 0.51 ] + [ 0.84147098 0.54030231 0.09983342 0.99500417 ] is = [ - 0.1 , 0.21 , 0.65 , 0.25 ] + [ 0.90929743 - 0.41614684 0.19866933 0.98006658 ] Mohit = [ 0.1 , - 0.12 , 0.33 , - 0.45 ] + [ 0.14112001 - 0.9899925 0.29552021 0.95533649 ] Note Some obvious alternatives for position encoding were not considered because of the their disadvantages. For example, using simple numbers like 0, 1, 2...N would have led to unnormalized numbers in vector, which could have degraded the semantic representation of the token. On the other hand if we had used normalized numbers, that would have not made sense for variable length sentences. Similarly using binary numbers could be rejected as it is not continous. [4] References [1] Attention Is All You Need - Paper [2] The Illustrated Transformer - Link [3] What exactly are keys, queries, and values in attention mechanisms? - Cross validated [4] Master Positional Encoding: Part I - Medium Blog by Jonathan Kernes Cheers.","title":"Transformers"},{"location":"natural_language_processing/transformer/#transformers","text":"","title":"Transformers"},{"location":"natural_language_processing/transformer/#introduction","text":"\"Attention Is All You Need\" paper [1] introduced the concept of \"Transformers\" and it revolutionalized the complete domain of Deep Learning. So much so that in 2022 we have Transformers has become multi-disiplinary and is used across NLP, CV, RL, Graphs, and more! In NLP, Transformers variants are still state of the art! (even after 5 years) . As the paper's name suggests, the authors showcase how only using multiple stacks of attention layers provides enough learning power to the architecture to improve the SotA in multiple tasks. Quoting the paper, \"Transformer is the first transduction model relying entirely on self-attention to compute representations of its input and output without using sequence-aligned RNNs or convolution.\" Let's try to understand the fundamentals of Transformers by going through each components in detail. Hint Transduction is a broad term but in nearly all aspect it means converting data, signal or object from one format to another. Transformers transforms input data from one format to another ( \\(x_i\\) in encoder leads to \\(y_i\\) in decoder) , so it is transductive model. Hence the name \"Transformers\" Transformer architecture. Left part is the encoder and right part is the decoder part [1] At a high level, the architecture can be divided into two modules, Encoder: the component resonsible to learn representation of the input prompt. It process each token of the input parallely in one iteration and generates attention aware representations for each token. The encoder layer consists of 6 identical blocks with output dimension of \\(d_{model} = 512\\) . Decoder: the component reposible for generating the output. The execution strategy depends on the scenario. During training as ground truth is also available, complete processing happens in one iteration using teacher forcing and masked attention. During inference multiple iterations are run where one output is generated in one go. Decoder layer also consists of 6 identical blocks.","title":"Introduction"},{"location":"natural_language_processing/transformer/#components-of-transformers","text":"","title":"Components of Transformers"},{"location":"natural_language_processing/transformer/#self-attention","text":"Probably the most important component of Transformer is the Attention Layer. The intuition here is that the context matters. For example in a sentence, meaning of a word like \"bank\" could vary based on if it is \"river bank\" or \"financial bank\". Similarly, pronouns like He, She, It, etc could also attend to certain other words in the sentence (name of the person or object) . With this in mind, a true meaning (representation) of a word can only be identified by attending to all the other words in context. Self-Attention is just one way to do that. Scaled dot product attention [1] Compared to previous approaches like RNN or Word2Vec that were used to create representations of the words, Attention models modifies the representation for each input based on the context. Word2Vec had a fixed context and worked at word level, so \"bank\" will have 1 representation word embedding. RNN on the other hand only considered sequential context that lead to forgetting the context of the past (words far on the left) . Note The smallest unit of input in Transformer are called tokens which could be at sub-word or words level. And attention could span over a phrase, a sentence, a paragraph or a complete article. The process of self-attention is quite simple. For each token, find the importance score of every token in the context (including the token in question) , and using the score, do a weighted sum of the every token's representations to create the final token representation. And thats it Well at least from 10k feet . Looking at the technicalities, the process drills down to, Every token is not used as-it-is, but first converted to key, value and query format using linear projections. We have key, value and query weights denoted as \\(W_k\\) , \\(W_v\\) and \\(W_q\\) . Each input token's representation is first multipled with these weights to get \\(k_i\\) , \\(v_i\\) and \\(q_i\\) . Next the query of one token is dot product with the keys of all token. On applying softmax to the output, we get a probability score of importance of every token for the given token. Finally, we do weighted sum of values of all keys with this score and get the vector representation of the current token. It is easy to understand the process while looking at one token at a time, but in reality it is completely vectorized and happens for all the tokens at the same time. The formula for the self-attention is shown below, where Q, K and V are the matrices you get on multiplication of all input tokens with the query, key and value weights. \\[ Attention(Q, K, V) = softmax(\\frac{QK^T}{\\sqrt{d_k}})V \\] Note Authors introduced the scaling factor to handle potential vanishing gradient problem. In their words, \"We suspect that for large values of \\(d_k\\) , the dot products grow large in magnitude, pushing the softmax function into regions where it has extremely small gradients. To counteract this effect, we scale the dot products by \\(\\frac{1}{\\sqrt{d_k}}\\) \"","title":"Self-Attention"},{"location":"natural_language_processing/transformer/#multi-head-attention","text":"Instead of performing the complete attention computation in a single layer, the authors divided the computation into muliple heads or parts. This is done quite intuitively, let's take an example where we want to have say 8 heads in each layer. In this case the projections weights ( \\(W_k\\) , \\(W_v\\) and \\(W_q\\) ) downsize the token embedding into \\(\\frac{1}{8}\\) the size. This can be done by making the dimension of the weights token_dim * token_dim/8 . After this we repeat the complete process as discussed in self-attention. Multi-Head Attention [1] Now at the end we will have 8 outputs instead of one, i.e. 8 different partial representations for each token (which is not strictly correct and not what we want) . So to aggregate to get 1 output, authors concatenated the outputs and then apply a linear projection (multiply with \\(W^o\\) ) to get the original sized 1 representation per token. The formulation is shown below, \\[ \\text{MultiHead}(Q, K, V) = \\text{Concat}(head_1, head_2, ..., head_h) W^o \\]","title":"Multi-head Attention"},{"location":"natural_language_processing/transformer/#masked-attention","text":"As discussed before, during training, decoder use masked attention to prevent model from attending to the future tokens. This is done so that the model does not cheat while predicting the output. Note Having bidirectional context on input is okay (as done by encoder with normal attention) , but in decoder we should only attend to what we have already seen and not the future. The approach is also quite easy to understand, it is very similar to the normal attention where we compute the query, key and value vectors. The only difference is that while computing attention scores, we explicitly make the score of future tokens zero. This is done by making the score (before softmax) at the future places equal to large negative number. On applying Softmax, those values become zero.","title":"Masked Attention"},{"location":"natural_language_processing/transformer/#position-wise-feed-forward-layers","text":"Encoder and Decoder contains fully connected feed-forward neural network that is applied to each position (token) separately and identically. It consists of two linear transformations with a ReLU activation in between. The formualtion is given below, \\[ \\text{FFN}(x)=max(0, xW_1 + b_1)W_2 + b_2 \\] Note The parameters \\(W_1\\) , \\(W_2\\) , \\(b_1\\) and \\(b_2\\) are different in different layers.","title":"Position-wise Feed Forward Layers"},{"location":"natural_language_processing/transformer/#positional-embeddings","text":"For the model to consider the order of sequence for representation and prediction, authors injected a sense of relative or absolute position in the input by using positional embeddings. It is injected to each token separately and has the same embedding size as that of the token i.e \\(d_{model}\\) . For each token we have a position vector. After modification, the token embedding will be a combination of two types of information -- positional (injected by positional embedding) and semantic (learned by the model) . While there are many choices for the position embedding, authors wanted to pick the one that does not compromise the semantic information by a lot. In the paper authors alternatively use sine and cosine functions (at indices of vector) of different frequencies, \\[ \\text{PE}_{pos, 2i} = sin(\\frac{pos}{10000^{2i/d_{model}}}) \\] \\[ \\text{PE}_{pos, 2i+1} = cos(\\frac{pos}{10000^{2i/d_{model}}}) \\] Here pos is the position of the token in sequence and i is the index of the vector for a token. Position Encoding for 100 positions, each of 512 dimension size Let's understand the process using an example sentence - \"My name is Mohit\" with words as tokens. So we have 4 tokens, and with dimension size of 4, each token could be represented as shown below, ## Token Embedding My = [ 0.1 , 0.2 , 1 , 0.45 ] Name = [ 0.15 , 0.32 , 13 , 0.51 ] is = [ - 0.1 , 0.21 , 0.65 , 0.25 ] Mohit = [ 0.1 , - 0.12 , 0.33 , - 0.45 ] Now we will compute the positional embeddings using the above formulae, ## Positional embedding pos_1 = [ 0. 1. 0. 1. ] pos_2 = [ 0.84147098 0.54030231 0.09983342 0.99500417 ] pos_3 = [ 0.90929743 - 0.41614684 0.19866933 0.98006658 ] pos_4 = [ 0.14112001 - 0.9899925 0.29552021 0.95533649 ] Finally the modified embedding for the tokens will be addition of the original token embedding and positional embedding. ## Modified embedding My = [ 0.1 , 0.2 , 1 , 0.45 ] + [ 0. 1. 0. 1. ] Name = [ 0.15 , 0.32 , 13 , 0.51 ] + [ 0.84147098 0.54030231 0.09983342 0.99500417 ] is = [ - 0.1 , 0.21 , 0.65 , 0.25 ] + [ 0.90929743 - 0.41614684 0.19866933 0.98006658 ] Mohit = [ 0.1 , - 0.12 , 0.33 , - 0.45 ] + [ 0.14112001 - 0.9899925 0.29552021 0.95533649 ] Note Some obvious alternatives for position encoding were not considered because of the their disadvantages. For example, using simple numbers like 0, 1, 2...N would have led to unnormalized numbers in vector, which could have degraded the semantic representation of the token. On the other hand if we had used normalized numbers, that would have not made sense for variable length sentences. Similarly using binary numbers could be rejected as it is not continous. [4]","title":"Positional Embeddings"},{"location":"natural_language_processing/transformer/#references","text":"[1] Attention Is All You Need - Paper [2] The Illustrated Transformer - Link [3] What exactly are keys, queries, and values in attention mechanisms? - Cross validated [4] Master Positional Encoding: Part I - Medium Blog by Jonathan Kernes Cheers.","title":"References"},{"location":"natural_language_processing/word2vec/","text":"Word2Vec (w2v) [1] is a word embedding technique that represents a word as a vector. Each vector can be thought of as a point in \\(R^{D}\\) space, where \\(D\\) is the dimension of each vector. One thing to note is that these vectors are not randomly spread out in the vector space. They follow certain properties such that, words that are similar like \"cat\" and \"tiger\" are relatively closer to each other than a completely unrelated word like \"tank\". In the vector space, this means their cosine similarity score is higher. Along with this, we can even observe famous analogies like \\(king - man + woman = queen\\) which can be replicated by vector addition of these word's representation vector. Vector space representing the position of word\u2019s vector and the relationship between them to showcase the analogy king-man+woman=queen While such representation is not unique to w2v, its major contribution was to provide a simple and faster neural network based word embedder. To do so, w2v transformed the training as a classification problem. The neural network tries to answer which word is most probable to be found in the context of a given word. Given a sequence of words that \"naturally\" appears in some sentence, the input could be any middle word and output could be any of the surrounding words (within some window). The training is done by creating a 1-layer deep neural network where the input word is fed as one-hot encoding and output is softmax applied with intention of getting large value for context word. SkipGram architecture (taken from Lil\u2019Log [2]). Its a 1 layer deep NN with input and output as one-hot encoded. The input-to-hidden weight matrix contains the word embeddings. The training data is prepared by sliding a window (of some window size) across the corpus of large text (which could be articles or novels or even complete Wikipedia), and for each such window the middle word is the input word and the remaining words in the context are output words. For each input word in vector space, we want the context words to be close but the remaining words far. And if two input words will have similar context words, their vector will also be close. Word2Vec also performs negative sampling, wherein random selection of some negative examples are also added in the training dataset. For these examples, the output probabilities should be \\(0\\) . [4] After training we can observe something interesting \u2014 the weights between the Input-Hidden layer of NN now represent the notions we wanted in our word embeddings, such that words with the same context have similar values across vector dimension. And these weights are used as word embeddings. Heatmap visualization of 5D word embeddings from Wevi [3]. Color denotes the value of cells. The result shown above is from training 5D word embeddings from a cool interactive w2v demo tool called \"Wevi\" [3]. As visible, words like (juice, milk, water) and (orange, apple) have similar kinds of vectors (some dimensions are equally lit \u2014 red or blue). Hint One obvious question could be -- why do we only use Input-Hidden layer for embedding and why not Hidden-Last? It seems we can use both based on the type of task we are performing. For more details refer the paper -- Intrinsic analysis for dual word embedding space models References [1] Efficient Estimation of Word Representations in Vector Space [2] Lil\u2019Log \u2014 Learning word embedding [3] Wevi \u2014 word embedding visual inspector [4] Word2Vec Tutorial Part 2 - Negative Sampling Additional Materials Intrinsic analysis for dual word embedding space models","title":"Word2Vec"},{"location":"natural_language_processing/word2vec/#references","text":"[1] Efficient Estimation of Word Representations in Vector Space [2] Lil\u2019Log \u2014 Learning word embedding [3] Wevi \u2014 word embedding visual inspector [4] Word2Vec Tutorial Part 2 - Negative Sampling","title":"References"},{"location":"natural_language_processing/word2vec/#additional-materials","text":"Intrinsic analysis for dual word embedding space models","title":"Additional Materials"},{"location":"network_science/gnn_deepwalk/","text":"DeepWalk [1] is a technique to create semantic embeddings of the nodes of a graph. For this, DeepWalk employs Skip-gram based technique of Word2Vec (w2v). For context, w2v is a word embedding technique, where we learn to embed words into a vector representation. In Skip-gram word embedding training procedure, the complete problem is transformed as a classification problem. The neural network tries to answer which word is most probable to be found in the context of a given word. Given a sequence of words that \"naturally\" appears in some sentence, the input could be any middle word and output could be any of the surrounding words (within some window). The training is done by creating a 1-layer deep neural network where the input word is fed as one-hot encoding and output is softmax applied with intention of getting large value for context word. Hint For a brief introduction to Word2Vec, you can refer the respective page in the Lazy Data Science Guide . But how to create training data that captures the notion of context in graphs? While intuitively it seems easy to create training data for w2v by using plethora of text available online, how can we do something similar for a graph? As it happens, we can follow the same intuition for graphs by applying random walk technique. Here, we start from one node and randomly go to one of it's neighbors. We repeat this process \\(L\\) time which is the length of the random walk. After this, we restart the process again. If we do this for all nodes (and \\(M\\) times for each node) we have in some sense transformed the graph structure into a text like corpus used to train w2v where each word is a node and its context defines its neighbor. Code Author's Implementation The DeepWalk authors provide a python implementation here . Installation details with other pre-requisite are provided in the readme (windows user be vary of some installation and execution issues). The CLI API exposes several algorithmic and optimization parameters like, input requires the path of the input file which contains graph information. A graph can be stored in several formats, some of the famous (and supported by the code) are \u2014 adjacency list (node-all_neighbors list) and edge list (node-node pair which have an edge). number-walks The number of random walks taken for each node. representation-size the dimension of final embedding of each node. Also the size of hidden layer in the skipgram model. walk-length the length of each random walk. window-size the context window size in the skipgram training. workers optimization parameter defining number of independent process to spawn for the training. output the path to output embedding file. Authors have also provided example graphs, one of which is Karate club dataset. It's stored in the format of the adjacency list. Now let\u2019s read the graph data and create node embeddings by, deepwalk --input example_graphs/karate.adjlist --number-walks 10 --representation-size 64 --walk-length 40 --window-size 5 --workers 8 --output trained_model/karate.embeddings This performs start-to-end analysis by taking care of \u2014 loading the graph from the file, generating random walks, and finally training skip-gram model on the walk data. We can read the output embedding file which contains vector embedding for each node in the graph. Karate Club Implementation A much simpler API is provided by python package called KarateClub [2]. To do the same set of actions, all we need to do is following. 1 2 3 4 5 6 7 8 9 10 11 # import libraries import networkx as nx from karateclub import DeepWalk # load the karate club dataset G = nx . karate_club_graph () # load the DeepWalk model and set parameters dw = DeepWalk ( dimensions = 64 ) # fit the model dw . fit ( G ) # extract embeddings embedding = dw . get_embedding () Note The DeepWalk class also extends the same parameters exposed by the author's code and can be tweaked to do the desired experiment. Refer their docs for more details. Analysis Seeing DeepWalk in Action To see DeepWalk in action, we will pick one graph and visualize the network as well as the final embeddings. For better understanding, I created a union of 3 complete graphs with some additional edges to connect each graph. Union of 3 complete graphs. We can imagine 3 clusters with nodes 0 to 9 belonging to cluster 1; 10 to 19 to cluster 2 and 20 to 28 in cluster 3. Now, we will create DeepWalk embeddings of the graph. For this, we can use the KarateClub package and by running DeepWalk on default settings we get embeddings of 128 dimensions. To visualize this I use dimensionality reduction technique PCA, which scaled-down embeddings from R\u00b9\u00b2\u2078 to R\u00b2. I will also plot the 128D heatmap of the embedding on the side. Left \u2014 The PCA reduced (from 128D to 2D) node embeddings of the graph. Right \u2014 The heatmap of the original 128D embeddings. There is a clear segregation of nodes in the left chart which denotes the vector space of the embedding. This showcase how DeepWalk can transform a graph from force layout visualization to vector space visualization while maintaining some of the structural properties. The heatmap plot also hints to a clear segregation of graph into 3 clusters. Another important thing to note is when the graph is not so complex, we can get by with lower dimension embedding as well. This not only reduces the dimensions but also improves the optimization and convergence as there are fewer parameters in skip-gram to train. To prove this we will create embedding of only size 2. This can be done by setting the parameter in DeepWalk object dw = DeepWalk(dimensions=2) . We will again visualize the same plots. he node embeddings (size=2) of the graph. Right: The heatmap of the embeddings. Both the plots again hint towards the same number of clusters in the graph, and all this by only using 1% of the previous dimensions (from 128 to 2 i.e. ~1%). Conclusion As the answer to this analogy NLP - word2vec + GraphNeuralNetworks = ? can arguably be DeepWalk (is it? \ud83d\ude42 ), it leads to two interesting points, DeepWalk's impact in GNN can be analogous to Word2Vec's in NLP. And it's true as DeepWalk was one of the first approaches to use NN for node embeddings. It was also a cool example of how some proven SOTA technique from another domain (here, NLP) can be ported to and applied in a completely different domain (here, graphs). As DeepWalk was published a while ago (in 2014 - less than a decade but a lifetime in AI research), currently, there are lots of other techniques which can be applied to do the job in a better way like Node2Vec or even Graph convolution networks like GraphSAGE, etc. That said, as to start learning Deep learning based NLP, word2vec is the best starting point, I think DeepWalk in the same is sense a good beginning for Deep Learning based graph analysis. Cheers References [1] DeepWalk \u2014 Paper | Code [2] KarateClub \u2014 Paper | Code","title":"DeepWalk"},{"location":"network_science/gnn_deepwalk/#code","text":"","title":"Code"},{"location":"network_science/gnn_deepwalk/#authors-implementation","text":"The DeepWalk authors provide a python implementation here . Installation details with other pre-requisite are provided in the readme (windows user be vary of some installation and execution issues). The CLI API exposes several algorithmic and optimization parameters like, input requires the path of the input file which contains graph information. A graph can be stored in several formats, some of the famous (and supported by the code) are \u2014 adjacency list (node-all_neighbors list) and edge list (node-node pair which have an edge). number-walks The number of random walks taken for each node. representation-size the dimension of final embedding of each node. Also the size of hidden layer in the skipgram model. walk-length the length of each random walk. window-size the context window size in the skipgram training. workers optimization parameter defining number of independent process to spawn for the training. output the path to output embedding file. Authors have also provided example graphs, one of which is Karate club dataset. It's stored in the format of the adjacency list. Now let\u2019s read the graph data and create node embeddings by, deepwalk --input example_graphs/karate.adjlist --number-walks 10 --representation-size 64 --walk-length 40 --window-size 5 --workers 8 --output trained_model/karate.embeddings This performs start-to-end analysis by taking care of \u2014 loading the graph from the file, generating random walks, and finally training skip-gram model on the walk data. We can read the output embedding file which contains vector embedding for each node in the graph.","title":"Author's Implementation"},{"location":"network_science/gnn_deepwalk/#karate-club-implementation","text":"A much simpler API is provided by python package called KarateClub [2]. To do the same set of actions, all we need to do is following. 1 2 3 4 5 6 7 8 9 10 11 # import libraries import networkx as nx from karateclub import DeepWalk # load the karate club dataset G = nx . karate_club_graph () # load the DeepWalk model and set parameters dw = DeepWalk ( dimensions = 64 ) # fit the model dw . fit ( G ) # extract embeddings embedding = dw . get_embedding () Note The DeepWalk class also extends the same parameters exposed by the author's code and can be tweaked to do the desired experiment. Refer their docs for more details.","title":"Karate Club Implementation"},{"location":"network_science/gnn_deepwalk/#analysis","text":"","title":"Analysis"},{"location":"network_science/gnn_deepwalk/#seeing-deepwalk-in-action","text":"To see DeepWalk in action, we will pick one graph and visualize the network as well as the final embeddings. For better understanding, I created a union of 3 complete graphs with some additional edges to connect each graph. Union of 3 complete graphs. We can imagine 3 clusters with nodes 0 to 9 belonging to cluster 1; 10 to 19 to cluster 2 and 20 to 28 in cluster 3. Now, we will create DeepWalk embeddings of the graph. For this, we can use the KarateClub package and by running DeepWalk on default settings we get embeddings of 128 dimensions. To visualize this I use dimensionality reduction technique PCA, which scaled-down embeddings from R\u00b9\u00b2\u2078 to R\u00b2. I will also plot the 128D heatmap of the embedding on the side. Left \u2014 The PCA reduced (from 128D to 2D) node embeddings of the graph. Right \u2014 The heatmap of the original 128D embeddings. There is a clear segregation of nodes in the left chart which denotes the vector space of the embedding. This showcase how DeepWalk can transform a graph from force layout visualization to vector space visualization while maintaining some of the structural properties. The heatmap plot also hints to a clear segregation of graph into 3 clusters. Another important thing to note is when the graph is not so complex, we can get by with lower dimension embedding as well. This not only reduces the dimensions but also improves the optimization and convergence as there are fewer parameters in skip-gram to train. To prove this we will create embedding of only size 2. This can be done by setting the parameter in DeepWalk object dw = DeepWalk(dimensions=2) . We will again visualize the same plots. he node embeddings (size=2) of the graph. Right: The heatmap of the embeddings. Both the plots again hint towards the same number of clusters in the graph, and all this by only using 1% of the previous dimensions (from 128 to 2 i.e. ~1%).","title":"Seeing DeepWalk in Action"},{"location":"network_science/gnn_deepwalk/#conclusion","text":"As the answer to this analogy NLP - word2vec + GraphNeuralNetworks = ? can arguably be DeepWalk (is it? \ud83d\ude42 ), it leads to two interesting points, DeepWalk's impact in GNN can be analogous to Word2Vec's in NLP. And it's true as DeepWalk was one of the first approaches to use NN for node embeddings. It was also a cool example of how some proven SOTA technique from another domain (here, NLP) can be ported to and applied in a completely different domain (here, graphs). As DeepWalk was published a while ago (in 2014 - less than a decade but a lifetime in AI research), currently, there are lots of other techniques which can be applied to do the job in a better way like Node2Vec or even Graph convolution networks like GraphSAGE, etc. That said, as to start learning Deep learning based NLP, word2vec is the best starting point, I think DeepWalk in the same is sense a good beginning for Deep Learning based graph analysis. Cheers","title":"Conclusion"},{"location":"network_science/gnn_deepwalk/#references","text":"[1] DeepWalk \u2014 Paper | Code [2] KarateClub \u2014 Paper | Code","title":"References"},{"location":"network_science/gnn_introduction/","text":"Graph Neural Networks are the current hot topic. [1] And this interest is surely justified as GNNs are all about latent representation of the graph in vector space. Representing an entity as a vector is nothing new. There are many examples like word2vec and Gloves embeddings in NLP which transforms a word into a vector. What makes such representation powerful are, these vectors incorporate a notion of similarity among them i.e. two words who are similar to each other tend to be closer in the vector space (dot product is large), and they have application in diverse downstream problems like classification, clustering, etc. This is what makes GNN interesting, as while there are many solutions to embed a word or image as a vector, GNN laid the foundation to do so for graphs. References [1] EasyAI \u2014 GNN may be the future of AI","title":"Introduction"},{"location":"network_science/gnn_introduction/#references","text":"[1] EasyAI \u2014 GNN may be the future of AI","title":"References"},{"location":"network_science/introduction/","text":"Quoting Wikipedia , \"Network science is an academic field which studies complex networks such as telecommunication networks, computer networks, biological networks, cognitive and semantic networks, and social networks, considering distinct elements or actors represented by nodes (or vertices) and the connections between the elements or actors as links (or edges).\" To better understand network science, we should understand the underlying building blocks i.e. Graphs! Graphs 101 Graph or Networks is used to represent relational data, where the main entities are called nodes. A relationship between nodes is represented by edges. A graph can be made complex by adding multiple types of nodes, edges, direction to edges, or even weights to edges. One example of a graph is shown below. Karate dataset visualization @ Network repository The graph above is the Karate dataset [1] which represents the social information of the members of a university karate club. Each node represents a member of the club, and each edge represents a tie between two members of the club. The left info bar states several graph properties like a number of nodes, edges, density, degree, etc. Network repository contains many such networks from different fields and domains and provides visualization tools and basic stats as shown above. Common Concepts in Graphs Nodes: They are the basic building blocks in the graph that represent certain object, concepts or entities. Nodes (or vertices) can be of one type or of multiple types if the graph is homogenous or heterogenous, respecitively. Edges: They are the ties that connect two nodes together based on some special relationship criteria. For example, for a graph where each nodes are intersection, an edge between two nodes (or intersection) denotes precense of direct roadways between them. Edges can also be of multiple types if the graph is heterogenous. Directed or Undirected Graph: Edges may have a direction like A --> B that denotes a directional relationship. Example is Mother-Son relationship, Kavita -- mother-of --> Mohit is true, and not the other way around. If all the edges of a graph are directional, then it is a directed graph. Similarly, if the edges of a graph have no direction like A -- B , it is undirected graph. Example is a neighbor relationship, me and the guy living next door to me, are both neighbors of each other. Degrees of Node: Degrees denote the number of direct connections of a node to other nodes in the graph. For a directed graph, we have in-degree (edges coming to the node) and out-degree (edges going out from the node) . For example in A --> B <-- C , A and C has out-degree = 1 & in-degree = 0 & B has out-degree = 0 & in-degree = 2 Path and Walk : Path or Walk are the route between two nodes that goes through multiple nodes and edges. For example, A --> B --> C is a path of length 2 as there are two edges in the route. The difference between a path and a walk is that walks can repeat edges and nodes. Refer Stack Exchange Answer . Connected Graph: A graph with a possible path between any two nodes is called a connected graph. On the contrary, the graph will be disconnected and there might be multiple clusters of individual connected sub-graphs in the overall graph. Clique and Complete graph: A clique of a graph is a set of nodes where every pair of nodes has an edge between them. It is the strongest form of cluster in the graph. Similarly if the graph itself is a clique i.e. there is an edge between all the pairs of nodes, it is called a complete graph. This also means that the graph contains all the possible edges. Spanning Tree: A tree is an undirected graph where any two nodes are connected by exaclty one path. The spanning tree of a graph is a subgraph that is a tree that contains every node in the graph. In practice, Kruskal Algorithm can be used to find the minimum spanning tree for a graph, where we have multiple possibilities of creating spanning trees but want one with minimum total edge or node weights. Adjacency matrix: It is a square matrix of size NxN , where N is the number of unique nodes. The matrix contains 1 and 0 value that denotes the presence (1) or absence (0) of an edge between the nodes. unique graph and it's adjacency matrix is shown below, where the column and row represent nodes in alphabetic order. graph LR A --- B --- C --- D --- E --- A A --- A E --- B D --- F \\(M_{Adj} = \\begin{bmatrix} 1 & 1 & 0 & 0 & 1 & 0 \\\\ 1 & 0 & 1 & 0 & 1 & 0 \\\\ 0 & 1 & 0 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0 & 1 & 1 \\\\ 1 & 1 & 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 1 & 0 & 0 \\\\ \\end{bmatrix}\\) Hint \\(N^{th}\\) power of the Adjacency Matrix ( \\(M\\) ) is a new square matrix ( \\(M^N\\) ), where \\(M_{ij}^N\\) represents the number of walks of length \\(N\\) between the nodes \\(i\\) and \\(j\\) . Laplacian matrix: given a graph with \\(v_i\\) to \\(v_n\\) nodes, Laplacian matrix \\(L_{nxn}\\) is \\[{\\displaystyle L_{i,j}:={\\begin{cases}\\deg(v_{i})&{\\mbox{if}}\\ i=j\\\\-1&{\\mbox{if}}\\ i\\neq j\\ {\\mbox{and}}\\ v_{i}{\\mbox{ is adjacent to }}v_{j}\\\\0&{\\mbox{otherwise}},\\end{cases}}}\\] Or it can also be computed as \\(L = D - A\\) , where \\(D\\) is the degree matrix (could be in-degree, out-degree or both) and \\(A\\) is the adjacency matrix. Laplacian matrix are important objects in the field of Spectral Graph Theory , and we can infer many properties of the graph like connected components by looking at its laplacian matrix. Refer this Maths Stack Exchange Question . References [1] Zachary karate club \u2014 The KONECT Project","title":"Introduction"},{"location":"network_science/introduction/#graphs-101","text":"Graph or Networks is used to represent relational data, where the main entities are called nodes. A relationship between nodes is represented by edges. A graph can be made complex by adding multiple types of nodes, edges, direction to edges, or even weights to edges. One example of a graph is shown below. Karate dataset visualization @ Network repository The graph above is the Karate dataset [1] which represents the social information of the members of a university karate club. Each node represents a member of the club, and each edge represents a tie between two members of the club. The left info bar states several graph properties like a number of nodes, edges, density, degree, etc. Network repository contains many such networks from different fields and domains and provides visualization tools and basic stats as shown above.","title":"Graphs 101"},{"location":"network_science/introduction/#common-concepts-in-graphs","text":"Nodes: They are the basic building blocks in the graph that represent certain object, concepts or entities. Nodes (or vertices) can be of one type or of multiple types if the graph is homogenous or heterogenous, respecitively. Edges: They are the ties that connect two nodes together based on some special relationship criteria. For example, for a graph where each nodes are intersection, an edge between two nodes (or intersection) denotes precense of direct roadways between them. Edges can also be of multiple types if the graph is heterogenous. Directed or Undirected Graph: Edges may have a direction like A --> B that denotes a directional relationship. Example is Mother-Son relationship, Kavita -- mother-of --> Mohit is true, and not the other way around. If all the edges of a graph are directional, then it is a directed graph. Similarly, if the edges of a graph have no direction like A -- B , it is undirected graph. Example is a neighbor relationship, me and the guy living next door to me, are both neighbors of each other. Degrees of Node: Degrees denote the number of direct connections of a node to other nodes in the graph. For a directed graph, we have in-degree (edges coming to the node) and out-degree (edges going out from the node) . For example in A --> B <-- C , A and C has out-degree = 1 & in-degree = 0 & B has out-degree = 0 & in-degree = 2 Path and Walk : Path or Walk are the route between two nodes that goes through multiple nodes and edges. For example, A --> B --> C is a path of length 2 as there are two edges in the route. The difference between a path and a walk is that walks can repeat edges and nodes. Refer Stack Exchange Answer . Connected Graph: A graph with a possible path between any two nodes is called a connected graph. On the contrary, the graph will be disconnected and there might be multiple clusters of individual connected sub-graphs in the overall graph. Clique and Complete graph: A clique of a graph is a set of nodes where every pair of nodes has an edge between them. It is the strongest form of cluster in the graph. Similarly if the graph itself is a clique i.e. there is an edge between all the pairs of nodes, it is called a complete graph. This also means that the graph contains all the possible edges. Spanning Tree: A tree is an undirected graph where any two nodes are connected by exaclty one path. The spanning tree of a graph is a subgraph that is a tree that contains every node in the graph. In practice, Kruskal Algorithm can be used to find the minimum spanning tree for a graph, where we have multiple possibilities of creating spanning trees but want one with minimum total edge or node weights. Adjacency matrix: It is a square matrix of size NxN , where N is the number of unique nodes. The matrix contains 1 and 0 value that denotes the presence (1) or absence (0) of an edge between the nodes. unique graph and it's adjacency matrix is shown below, where the column and row represent nodes in alphabetic order. graph LR A --- B --- C --- D --- E --- A A --- A E --- B D --- F \\(M_{Adj} = \\begin{bmatrix} 1 & 1 & 0 & 0 & 1 & 0 \\\\ 1 & 0 & 1 & 0 & 1 & 0 \\\\ 0 & 1 & 0 & 1 & 0 & 0 \\\\ 0 & 0 & 1 & 0 & 1 & 1 \\\\ 1 & 1 & 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 1 & 0 & 0 \\\\ \\end{bmatrix}\\) Hint \\(N^{th}\\) power of the Adjacency Matrix ( \\(M\\) ) is a new square matrix ( \\(M^N\\) ), where \\(M_{ij}^N\\) represents the number of walks of length \\(N\\) between the nodes \\(i\\) and \\(j\\) . Laplacian matrix: given a graph with \\(v_i\\) to \\(v_n\\) nodes, Laplacian matrix \\(L_{nxn}\\) is \\[{\\displaystyle L_{i,j}:={\\begin{cases}\\deg(v_{i})&{\\mbox{if}}\\ i=j\\\\-1&{\\mbox{if}}\\ i\\neq j\\ {\\mbox{and}}\\ v_{i}{\\mbox{ is adjacent to }}v_{j}\\\\0&{\\mbox{otherwise}},\\end{cases}}}\\] Or it can also be computed as \\(L = D - A\\) , where \\(D\\) is the degree matrix (could be in-degree, out-degree or both) and \\(A\\) is the adjacency matrix. Laplacian matrix are important objects in the field of Spectral Graph Theory , and we can infer many properties of the graph like connected components by looking at its laplacian matrix. Refer this Maths Stack Exchange Question .","title":"Common Concepts in Graphs"},{"location":"network_science/introduction/#references","text":"[1] Zachary karate club \u2014 The KONECT Project","title":"References"},{"location":"network_science/kg_embedding_algorithms/","text":"KG embedding algorithms Before discussing individual algorithms, we will go through some high-level generalization of the embedding techniques which make each algorithm unique. This will help us differentiate and hence appreciate the individual algorithms. Generalization of embedding methods Embedding is the way of representing an object from its existing environment to another. Knowledge graph embedding includes representation of relations and entities into continuous space. Models for KG embedding can be categorised based on their answer for following questions, ( Ji_2021 ) What is the representation space in which the relations and entities are represented? What is the scoring function for measuring the plausibility of factual triples? Representation space Point-wise Euclidean space The most common representation space. Embedding space is Euclidean real valued vector or matrix space. Easy to understand; Not ideal for graphical (tree-like) structure. Point-wise space ( Ji_2021 ) Complex vector space Entities and relations are represented in a complex space Taking head entity as an example, h has a real part Re(h) and an imaginary part Im(h), i.e., \\(\\textbf{h}=Re(\\textbf{h}) + i Im(\\textbf{h})\\) Can capture anti-symmetric relations better than operations in Euclidean space. Complex vector space ( Ji_2021 ) Gaussian distribution space Entities and relations are represented as probabilistic distribution Applicable if you want to capture uncertainties. Gaussian distribution ( Ji_2021 ) Manifold space Entities and relations are represented in a well defined topological space Good for graphical (tree-like) structure. Manifold space ( Ji_2021 ) Scoring functions Distance based Measure plausibility of facts by calculating the distance between the entities. Additive translation with relation is the most widely used method i.e. \\(\\textbf{h} + \\textbf{r} \\approx \\textbf{t}\\) Translational distancebased scoring of TransE ( Ji_2021 ) Similarity based Measure plausibility of the facts by semantic similarity matching Multiplicative formulation is most widely used method i.e. \\(\\textbf{h}^T \\textbf{M}_r \\approx \\textbf{t}^T\\) , use relation matrix to transform head entity into tail entity. Semantic similarity-based scoring of DistMult ( Ji_2021 ) Algorithm Comparison A holistic comparison of different knowledge graph emebdding techniques w.r.t. category and scoring function is provided below, A comprehensive summary of knowledge representation learning models ( Ji_2021 )","title":"KG Embedding Algorithms"},{"location":"network_science/kg_embedding_algorithms/#kg-embedding-algorithms","text":"Before discussing individual algorithms, we will go through some high-level generalization of the embedding techniques which make each algorithm unique. This will help us differentiate and hence appreciate the individual algorithms.","title":"KG embedding algorithms"},{"location":"network_science/kg_embedding_algorithms/#generalization-of-embedding-methods","text":"Embedding is the way of representing an object from its existing environment to another. Knowledge graph embedding includes representation of relations and entities into continuous space. Models for KG embedding can be categorised based on their answer for following questions, ( Ji_2021 ) What is the representation space in which the relations and entities are represented? What is the scoring function for measuring the plausibility of factual triples?","title":"Generalization of embedding methods"},{"location":"network_science/kg_embedding_algorithms/#representation-space","text":"","title":"Representation space"},{"location":"network_science/kg_embedding_algorithms/#point-wise-euclidean-space","text":"The most common representation space. Embedding space is Euclidean real valued vector or matrix space. Easy to understand; Not ideal for graphical (tree-like) structure. Point-wise space ( Ji_2021 )","title":"Point-wise Euclidean space"},{"location":"network_science/kg_embedding_algorithms/#complex-vector-space","text":"Entities and relations are represented in a complex space Taking head entity as an example, h has a real part Re(h) and an imaginary part Im(h), i.e., \\(\\textbf{h}=Re(\\textbf{h}) + i Im(\\textbf{h})\\) Can capture anti-symmetric relations better than operations in Euclidean space. Complex vector space ( Ji_2021 )","title":"Complex vector space"},{"location":"network_science/kg_embedding_algorithms/#gaussian-distribution-space","text":"Entities and relations are represented as probabilistic distribution Applicable if you want to capture uncertainties. Gaussian distribution ( Ji_2021 )","title":"Gaussian distribution space"},{"location":"network_science/kg_embedding_algorithms/#manifold-space","text":"Entities and relations are represented in a well defined topological space Good for graphical (tree-like) structure. Manifold space ( Ji_2021 )","title":"Manifold space"},{"location":"network_science/kg_embedding_algorithms/#scoring-functions","text":"","title":"Scoring functions"},{"location":"network_science/kg_embedding_algorithms/#distance-based","text":"Measure plausibility of facts by calculating the distance between the entities. Additive translation with relation is the most widely used method i.e. \\(\\textbf{h} + \\textbf{r} \\approx \\textbf{t}\\) Translational distancebased scoring of TransE ( Ji_2021 )","title":"Distance based"},{"location":"network_science/kg_embedding_algorithms/#similarity-based","text":"Measure plausibility of the facts by semantic similarity matching Multiplicative formulation is most widely used method i.e. \\(\\textbf{h}^T \\textbf{M}_r \\approx \\textbf{t}^T\\) , use relation matrix to transform head entity into tail entity. Semantic similarity-based scoring of DistMult ( Ji_2021 )","title":"Similarity based"},{"location":"network_science/kg_embedding_algorithms/#algorithm-comparison","text":"A holistic comparison of different knowledge graph emebdding techniques w.r.t. category and scoring function is provided below, A comprehensive summary of knowledge representation learning models ( Ji_2021 )","title":"Algorithm Comparison"},{"location":"network_science/kg_introduction/","text":"Introduction What is a Knowledge graph? To better understand Knowledge graphs, let's start by understanding its basic unit i.e. \"fact\". A fact is the most basic piece of information that can be stored in a KG. Facts can be represented in form of triplets with either of the following ways, HRT : <head, relation, tail> SPO : <subject, predicate, object> We will follow the HRT representation for this article. Facts contain 3 elements which can be further represented as a graph, Head or tail - entities which are real-world objects or abstract concepts - represented as nodes Relation the connection between entities represented as edges A simple KG example is provided below. One example of fact could be <BoB, is_interested_in, The_Mona_Lisa> . You can see the KG is nothing but a collection of multiple such facts. A sample knowledge graph. ( rdf_primer ) Note, there are no limitations on the data type of the fact stored in KG. As shown in the above example, we have persons (Bob, Alice, ..), paintings (Mona Lisa), dates, etc, represented as nodes in the KG. Why knowledge graphs? This is the very first and a valid question anyone will ask when introduced to KG. We will try to go through some points wherein we compare KG with normal graphs and even other ways of storing information. The aim is to highlight the major advantages of using KG. Compared to Normal Graph Heterogenous data: supports different types of entities (person, date, painting, etc) and relations (likes, born on, etc). Model real-world information: closer to our brain's mental model of the world (represents information as a normal human does) Perform logical reasoning: traverse the graphs in a path to make logical connections (A's father is B and B's father is C, hence C is the grandfather of A) Compared to other storage types Structured representation: far cry from unstructured representations like text data Removes redundancy: compared to tabular data, there is no need to add mostly empty columns or rows to add new data Query complex information: better than SQL for data where relationship matters more than individual data points (for example, in case you have to do lots of JOIN statements in a SQL query, which is inherently slow) How to use Knowledge Graph? Knowledge graphs can be used for a large number of tasks\u200a-\u200a be it for logical reasoning, explainable recommendations, complex analysis or just being a better way to store information. There are two very interesting examples which we will discuss briefly. Google Knowledge Panel Google search about a famous person, location or concepts return a knowledge panel on the right (as shown in the image below) The panel contains a wide variety of information (description, education, born, died, quotes, etc) and interestingly in different formats--(text, image, dates, numbers, etc). All this information can be stored in a KG and one such example is shown below. This showcase how easy it is to store information and also note how intuitive it is to just read and understand the fact from a KG. Example of knowledge graph-based knowledge panel used by Google. [Right] the actual panel shown by google when you search for Einstein. [left] recreation of how we might store similar information in a KG. Source: by Author + Google. Movie recommendation Classical algorithms considered user-item interactions to generate recommendations. Over time, newer algorithms are considering additional information about the user as well as items, to improve the recommendations. Below, we can see one KG which not only contains user-item (here movies) connections but also user-user interactions and item attributes. The idea is that provided all this additional information, we can make much more accurate and informed suggestions. Without going into the exact algorithm (which we will later in the article), let's rationalize what recommendations could be generated. \"Avatar\" could be recommended to, - Bob: as it belongs to the Sci-fi genre same as Interstellar and Inception (which is already watched by Bob) - Alice: as it is directed by James Cameron (Titanic) \"Blood Diamond\" recommended to, - Bob: as DiCaprio acted in Inception as well This simple thought exercise should showcase how a lot of real-world interactions can be easily represented in form of facts using KG. And then we can leverage KG-based algorithms for a downstream use case like generating recommendations. A sample knowledge graph for movie recommendation task. ( guo2020survey ) Open-Source Knowledge graphs While there are several small-sized and domain-specific KGs, on the other hand, we also have many huge-sized and domain-agnostic KG that contains facts of all types and forms. Some of the famous open-source knowledge graphs are, DBpedia : is a crowd-sourced community effort to extract structured content from the information created in various Wikimedia projects. Freebase : a massive, collaboratively edited database of cross-linked data. Touted as \u201can open shared database of the world's knowledge\u201d. It was bought by Google and used to power its own KG. In 2015, it was finally discontinued. OpenCyc : is a gateway to the full power of Cyc, one of the world's most complete general knowledge base and commonsense reasoning engine. Wikidata : is a free, collaborative, multilingual, secondary database, collecting structured data to provide support for Wikipedia YAGO : huge semantic knowledge base, derived from Wikipedia, WordNet and GeoNames. Stats for some of the famous open source knowledge graphs ( f\u00e4rber2018knowledge ) Create custom Knowledge graph In spite of having several open-source KGs, we may have a requirement to create domain-specific KG for our use case. There, our base data (from which we want to create the KG), could be of multiple types\u200a-\u200atabular, graphical, or text blob. We will cover some steps on how to create KG from unstructured data like text, as it's relatively easier to convert structured data into KG using minimal domain knowledge and scripting. The complete process can be divided into two steps, Facts creation: this is the first step where we parse the text (sentence by sentence) and extract facts in triplet format like <H, R, T> . As we are processing text, we can leverage pre-processing steps like tokenization, stemming, or lemmatization, etc to clean the text. Next, we want to extract the entities and relations (facts) from the text. For entities, we can use Named entity recognition (NER) algorithms. For relation, we can use sentence dependency parsing techniques to find the relationship between any pair of entities. Example article with code . Facts selection: Once we have extracted several facts, the next obvious steps could be to remove duplicates and identify relevant facts that could be added to a KG. To identify duplicates, we can use entity and relation disambiguation techniques. The idea is to consolidate the same facts or elements of a fact, in case of repetitions. For example, \"Albert Einstein\" can also be written as \"Albert E.\" or \"A. Einstein\" in the text, but in reality, they all refer to the same entity. Finally, we can have a comprehensive rule-based system that decides which triplet should be added to the KG or which one could be skipped based on factors like redundant information ( A \u2192 sibling of \u2192 B is present, hence B \u2192 sibling of \u2192 A is redundant) or irrelevant information. Steps involved in creating a custom knowledge graph. Source: Author + ( Ji_2021 ) Ontology of Knowledge graph An ontology is a model of the world (practically only a subset), listing the types of entities, the relationships that connect them, and constraints on the ways that entities and relationships can be combined. In a way, an ontology defines the rules on how the entities are connected within the world. Resource Description Framework (RDF) and Web Ontology Language (OWL) are some of the vocabulary frameworks used to model ontology. They provide a common framework for expressing this information so it can be exchanged between applications without loss of meaning. RDF schema triplets (informal). Source: Author + ( rdf_primer ) RDF provides languages for creating ontology, which we will use to create a sample KG. Below you can see the KG creating script [on left] in Turtle language for the KG [on right]. Notice, at the top of the script, we are creating references to a lot of predefined ontologies, as there is no need to reinvent the wheel. Next, to create the facts (or triplets) of our KG we can follow the lines below the PREFIX commands. Notice, each entity and relation has a unique identifier (their unique key or UID). Throughout the code, the same entity or relation should be referenced by the same UID. Next, using the predefined schemas, we can add facts for an entity (in graphical term, add a connecting edge and tail node to the head node). These facts could include another entity (refer by their UID), some text, date (in DateTime format), links, etc. Script in Turtle language to create the sample knowledge graph. Source: Author + ( rdf_primer ) Finally, once we have prepared the script (with ttl extension\u200a-\u200afor scripts in Turtle language), that script contains the complete schema and definition of our KG. In itself, this may not be interesting, hence the file can be imported into any KG database for beautiful visualization and efficient querying. Hosting Knowledge graphs There are two types of databases that can be used to store graphical information. The first is \"property graphs\" like Neo4j and OrientDB that does not support RDF file (out of the box) and have their own custom query language. On the other hand, we have \"RDF triplet stores\", that support RDF files and support query language like SPARQL that is universally used to query KG. Some of the most famous ones are (with open source version), GraphDB : a solution by Ontotext, that provides frontend (visualization) and backend (server) services to see and query hosted knowledge graphs. Virtuoso : a solution by OpenLinkSoftware, that provides backend services to query hosted KG. It also supports querying KG using a combination of SQL and SPARQL. On top of it, a lot of open-source KG like DBpedia are hosted on Virtuoso. Query a Knowledge graph SPARQL Once facts are created as RDF and hosted on an RDF triplet store like Virtuoso, we can query them to extract relevant information. SPARQL is an RDF query language that is able to retrieve and manipulate data stored in RDF format. An interesting read for more detail is Walkthrough Dbpedia And Triplestore . Most of the RDF triple stores provide a visual SPARQL query page to fetch the relevant info. For our case, let us use one such visual query helper exposed by Wikidata (shown below). A sample query is shown, where we want to extract all entities that are instances of a house cat (we just want some cats \ud83d\udc31). As discussed before, each entity has a UID, hence relation <instance of> is represented as P31 , and the entity <house cat> is represented as Q146 . The query is quite simple to understand, as from lines 2 to 5, we are just trying to convey that we want any entity that is an instance of a house cat. As Wikidata contains data in multiple languages, line 6 is needed to filter results specific to the English language. The results (entities with their UID and some basic details) are shown below the query. Query Knowledge graph using SPARQL language ( wikidata_sparql_query_helper ) API Open-source KG also exposes several ready-made APIs for frequently used queries. One such API is shown below (for Wikidata), which returns relevant information for a given entity. Below we can see the result of querying wbgetentities API for entity Q9141 which is the UID for the Taj Mahal. Query Knowledge graph using available APIs ( wikidata_api_services )","title":"Introduction"},{"location":"network_science/kg_introduction/#introduction","text":"","title":"Introduction"},{"location":"network_science/kg_introduction/#what-is-a-knowledge-graph","text":"To better understand Knowledge graphs, let's start by understanding its basic unit i.e. \"fact\". A fact is the most basic piece of information that can be stored in a KG. Facts can be represented in form of triplets with either of the following ways, HRT : <head, relation, tail> SPO : <subject, predicate, object> We will follow the HRT representation for this article. Facts contain 3 elements which can be further represented as a graph, Head or tail - entities which are real-world objects or abstract concepts - represented as nodes Relation the connection between entities represented as edges A simple KG example is provided below. One example of fact could be <BoB, is_interested_in, The_Mona_Lisa> . You can see the KG is nothing but a collection of multiple such facts. A sample knowledge graph. ( rdf_primer ) Note, there are no limitations on the data type of the fact stored in KG. As shown in the above example, we have persons (Bob, Alice, ..), paintings (Mona Lisa), dates, etc, represented as nodes in the KG.","title":"What is a Knowledge graph?"},{"location":"network_science/kg_introduction/#why-knowledge-graphs","text":"This is the very first and a valid question anyone will ask when introduced to KG. We will try to go through some points wherein we compare KG with normal graphs and even other ways of storing information. The aim is to highlight the major advantages of using KG.","title":"Why knowledge graphs?"},{"location":"network_science/kg_introduction/#compared-to-normal-graph","text":"Heterogenous data: supports different types of entities (person, date, painting, etc) and relations (likes, born on, etc). Model real-world information: closer to our brain's mental model of the world (represents information as a normal human does) Perform logical reasoning: traverse the graphs in a path to make logical connections (A's father is B and B's father is C, hence C is the grandfather of A)","title":"Compared to Normal Graph"},{"location":"network_science/kg_introduction/#compared-to-other-storage-types","text":"Structured representation: far cry from unstructured representations like text data Removes redundancy: compared to tabular data, there is no need to add mostly empty columns or rows to add new data Query complex information: better than SQL for data where relationship matters more than individual data points (for example, in case you have to do lots of JOIN statements in a SQL query, which is inherently slow)","title":"Compared to other storage types"},{"location":"network_science/kg_introduction/#how-to-use-knowledge-graph","text":"Knowledge graphs can be used for a large number of tasks\u200a-\u200a be it for logical reasoning, explainable recommendations, complex analysis or just being a better way to store information. There are two very interesting examples which we will discuss briefly.","title":"How to use Knowledge Graph?"},{"location":"network_science/kg_introduction/#google-knowledge-panel","text":"Google search about a famous person, location or concepts return a knowledge panel on the right (as shown in the image below) The panel contains a wide variety of information (description, education, born, died, quotes, etc) and interestingly in different formats--(text, image, dates, numbers, etc). All this information can be stored in a KG and one such example is shown below. This showcase how easy it is to store information and also note how intuitive it is to just read and understand the fact from a KG. Example of knowledge graph-based knowledge panel used by Google. [Right] the actual panel shown by google when you search for Einstein. [left] recreation of how we might store similar information in a KG. Source: by Author + Google.","title":"Google Knowledge Panel"},{"location":"network_science/kg_introduction/#movie-recommendation","text":"Classical algorithms considered user-item interactions to generate recommendations. Over time, newer algorithms are considering additional information about the user as well as items, to improve the recommendations. Below, we can see one KG which not only contains user-item (here movies) connections but also user-user interactions and item attributes. The idea is that provided all this additional information, we can make much more accurate and informed suggestions. Without going into the exact algorithm (which we will later in the article), let's rationalize what recommendations could be generated. \"Avatar\" could be recommended to, - Bob: as it belongs to the Sci-fi genre same as Interstellar and Inception (which is already watched by Bob) - Alice: as it is directed by James Cameron (Titanic) \"Blood Diamond\" recommended to, - Bob: as DiCaprio acted in Inception as well This simple thought exercise should showcase how a lot of real-world interactions can be easily represented in form of facts using KG. And then we can leverage KG-based algorithms for a downstream use case like generating recommendations. A sample knowledge graph for movie recommendation task. ( guo2020survey )","title":"Movie recommendation"},{"location":"network_science/kg_introduction/#open-source-knowledge-graphs","text":"While there are several small-sized and domain-specific KGs, on the other hand, we also have many huge-sized and domain-agnostic KG that contains facts of all types and forms. Some of the famous open-source knowledge graphs are, DBpedia : is a crowd-sourced community effort to extract structured content from the information created in various Wikimedia projects. Freebase : a massive, collaboratively edited database of cross-linked data. Touted as \u201can open shared database of the world's knowledge\u201d. It was bought by Google and used to power its own KG. In 2015, it was finally discontinued. OpenCyc : is a gateway to the full power of Cyc, one of the world's most complete general knowledge base and commonsense reasoning engine. Wikidata : is a free, collaborative, multilingual, secondary database, collecting structured data to provide support for Wikipedia YAGO : huge semantic knowledge base, derived from Wikipedia, WordNet and GeoNames. Stats for some of the famous open source knowledge graphs ( f\u00e4rber2018knowledge )","title":"Open-Source Knowledge graphs"},{"location":"network_science/kg_introduction/#create-custom-knowledge-graph","text":"In spite of having several open-source KGs, we may have a requirement to create domain-specific KG for our use case. There, our base data (from which we want to create the KG), could be of multiple types\u200a-\u200atabular, graphical, or text blob. We will cover some steps on how to create KG from unstructured data like text, as it's relatively easier to convert structured data into KG using minimal domain knowledge and scripting. The complete process can be divided into two steps, Facts creation: this is the first step where we parse the text (sentence by sentence) and extract facts in triplet format like <H, R, T> . As we are processing text, we can leverage pre-processing steps like tokenization, stemming, or lemmatization, etc to clean the text. Next, we want to extract the entities and relations (facts) from the text. For entities, we can use Named entity recognition (NER) algorithms. For relation, we can use sentence dependency parsing techniques to find the relationship between any pair of entities. Example article with code . Facts selection: Once we have extracted several facts, the next obvious steps could be to remove duplicates and identify relevant facts that could be added to a KG. To identify duplicates, we can use entity and relation disambiguation techniques. The idea is to consolidate the same facts or elements of a fact, in case of repetitions. For example, \"Albert Einstein\" can also be written as \"Albert E.\" or \"A. Einstein\" in the text, but in reality, they all refer to the same entity. Finally, we can have a comprehensive rule-based system that decides which triplet should be added to the KG or which one could be skipped based on factors like redundant information ( A \u2192 sibling of \u2192 B is present, hence B \u2192 sibling of \u2192 A is redundant) or irrelevant information. Steps involved in creating a custom knowledge graph. Source: Author + ( Ji_2021 )","title":"Create custom Knowledge graph"},{"location":"network_science/kg_introduction/#ontology-of-knowledge-graph","text":"An ontology is a model of the world (practically only a subset), listing the types of entities, the relationships that connect them, and constraints on the ways that entities and relationships can be combined. In a way, an ontology defines the rules on how the entities are connected within the world. Resource Description Framework (RDF) and Web Ontology Language (OWL) are some of the vocabulary frameworks used to model ontology. They provide a common framework for expressing this information so it can be exchanged between applications without loss of meaning. RDF schema triplets (informal). Source: Author + ( rdf_primer ) RDF provides languages for creating ontology, which we will use to create a sample KG. Below you can see the KG creating script [on left] in Turtle language for the KG [on right]. Notice, at the top of the script, we are creating references to a lot of predefined ontologies, as there is no need to reinvent the wheel. Next, to create the facts (or triplets) of our KG we can follow the lines below the PREFIX commands. Notice, each entity and relation has a unique identifier (their unique key or UID). Throughout the code, the same entity or relation should be referenced by the same UID. Next, using the predefined schemas, we can add facts for an entity (in graphical term, add a connecting edge and tail node to the head node). These facts could include another entity (refer by their UID), some text, date (in DateTime format), links, etc. Script in Turtle language to create the sample knowledge graph. Source: Author + ( rdf_primer ) Finally, once we have prepared the script (with ttl extension\u200a-\u200afor scripts in Turtle language), that script contains the complete schema and definition of our KG. In itself, this may not be interesting, hence the file can be imported into any KG database for beautiful visualization and efficient querying.","title":"Ontology of Knowledge graph"},{"location":"network_science/kg_introduction/#hosting-knowledge-graphs","text":"There are two types of databases that can be used to store graphical information. The first is \"property graphs\" like Neo4j and OrientDB that does not support RDF file (out of the box) and have their own custom query language. On the other hand, we have \"RDF triplet stores\", that support RDF files and support query language like SPARQL that is universally used to query KG. Some of the most famous ones are (with open source version), GraphDB : a solution by Ontotext, that provides frontend (visualization) and backend (server) services to see and query hosted knowledge graphs. Virtuoso : a solution by OpenLinkSoftware, that provides backend services to query hosted KG. It also supports querying KG using a combination of SQL and SPARQL. On top of it, a lot of open-source KG like DBpedia are hosted on Virtuoso.","title":"Hosting Knowledge graphs"},{"location":"network_science/kg_introduction/#query-a-knowledge-graph","text":"","title":"Query a Knowledge graph"},{"location":"network_science/kg_introduction/#sparql","text":"Once facts are created as RDF and hosted on an RDF triplet store like Virtuoso, we can query them to extract relevant information. SPARQL is an RDF query language that is able to retrieve and manipulate data stored in RDF format. An interesting read for more detail is Walkthrough Dbpedia And Triplestore . Most of the RDF triple stores provide a visual SPARQL query page to fetch the relevant info. For our case, let us use one such visual query helper exposed by Wikidata (shown below). A sample query is shown, where we want to extract all entities that are instances of a house cat (we just want some cats \ud83d\udc31). As discussed before, each entity has a UID, hence relation <instance of> is represented as P31 , and the entity <house cat> is represented as Q146 . The query is quite simple to understand, as from lines 2 to 5, we are just trying to convey that we want any entity that is an instance of a house cat. As Wikidata contains data in multiple languages, line 6 is needed to filter results specific to the English language. The results (entities with their UID and some basic details) are shown below the query. Query Knowledge graph using SPARQL language ( wikidata_sparql_query_helper )","title":"SPARQL"},{"location":"network_science/kg_introduction/#api","text":"Open-source KG also exposes several ready-made APIs for frequently used queries. One such API is shown below (for Wikidata), which returns relevant information for a given entity. Below we can see the result of querying wbgetentities API for entity Q9141 which is the UID for the Taj Mahal. Query Knowledge graph using available APIs ( wikidata_api_services )","title":"API"},{"location":"reinforcement_learning/interview_questions/","text":"Here are some questions and their answers to make you ready for your next interview. Best of luck Question Answer Explain Reinforcement learning (RL) in deep learning. Reinforcement learning is a type of machine learning where an agent learns to make decisions by interacting with an environment. The agent receives rewards or penalties based on its actions, and the goal is to learn a policy that maximizes the total reward. Deep reinforcement learning combines reinforcement learning with deep neural networks, allowing the agent to make decisions based on complex, high-dimensional input such as images or speech. Question Answer What is the use of the deep reinforcement learning in machine learning? Deep reinforcement learning (DRL) is a type of reinforcement learning that uses deep neural networks as function approximators to learn policies or value functions. DRL allows for the use of complex, high-dimensional observations such as images or speech and can be used for tasks such as playing games, controlling robots, and optimizing resource allocation. Question Answer What is the difference between model-free and model-based RL? Model-based RL has an agent that tries to understand (or model) the world by learning state transition function and reward function. So if an agent can predict the next state and the reward before taking the action, it is a model-based RL algorithm. If not then it is model-free algorithm. Refer this AI StackExchange QA Question Answer What is the difference between value-based and policy-based reinforcement learning? Value-based reinforcement learning methods, such as Q-learning, estimate the value of different actions given a certain state, and then take the action that maximizes this value. Policy-based methods, such as REINFORCE, directly learn a policy that maps states to actions. Question Answer How does Q-learning work in reinforcement learning? Q-learning is a value-based reinforcement learning algorithm that estimates the value of different actions given a certain state. It uses the Bellman equation to update the Q-value, which is the expected future reward of taking an action in a certain state. Over time, the algorithm converges to the optimal Q-value function that represents the best action to take in each state. Question Answer What is the difference between on-policy and off-policy reinforcement learning? On-policy reinforcement learning (ex: SARSA) methods learn from the actions taken by the current policy, while off-policy (ex: Q-learning) methods learn from actions taken by a different policy (like greedy approach). On-policy methods are often used when an agent can easily interact with its environment, while off-policy methods are used when it is difficult or expensive to interact with the environment. Refer this StackOverflow QA for more details. Question Answer What is the use of the SARSA algorithm in reinforcement learning? SARSA (State-Action-Reward-State-Action) is a type of on-policy algorithm that estimates the value of different actions given a certain state. It updates the Q-value based on the action taken in the next state, rather than the optimal action as in Q-learning. This makes SARSA more suitable for problems with non-deterministic environments. Question Answer Explain actor-critic algorithm. Actor-Critic is a type of algorithm that combines both policy-based and value-based methods in reinforcement learning. The actor network is used to output a probability distribution over actions given a certain state, while the critic network is used to estimate the value of the actions taken by the actor network. The actor network is then updated according to the critic network's evaluation of its actions. Question Answer Explain A3C algorithm in reinforcement learning. A3C (Asynchronous Advantage Actor-Critic) is an algorithm that uses multiple parallel agents to train a neural network in an asynchronous manner. A3C is an extension of the actor-critic algorithm that allows for faster and more stable training by reducing the correlation between the updates of different agents. It's useful for training agents for tasks that require handling high dimensional and continuous action spaces, such as robotics and gaming. Question Answer What is the use of the Q-network in reinforcement learning? A Q-network is a neural network used in Q-learning, a value-based reinforcement learning algorithm. The Q-network is trained to estimate the value of taking different actions given a certain state. It's used to approximate the Q-value function, which represents the expected future rewards of taking different actions in different states, and to make decisions based on the current state. Question Answer What is Monte Carlo Tree Search in reinforcement learning? Monte Carlo Tree Search (MCTS) is a method used to select the next action in a reinforcement learning problem. MCTS works by building a search tree, where each node represents a state and each edge represents an action. The algorithm explores the tree by selecting the best node based on a combination of the current value estimates and the uncertainty of the estimates. MCTS is particularly useful for problems with large and complex action spaces, such as game playing.","title":"Interview Questions"},{"location":"reinforcement_learning/interview_questions/#explain-reinforcement-learning-rl-in-deep-learning","text":"Reinforcement learning is a type of machine learning where an agent learns to make decisions by interacting with an environment. The agent receives rewards or penalties based on its actions, and the goal is to learn a policy that maximizes the total reward. Deep reinforcement learning combines reinforcement learning with deep neural networks, allowing the agent to make decisions based on complex, high-dimensional input such as images or speech. Question Answer","title":"Explain Reinforcement learning (RL) in deep learning."},{"location":"reinforcement_learning/interview_questions/#what-is-the-use-of-the-deep-reinforcement-learning-in-machine-learning","text":"Deep reinforcement learning (DRL) is a type of reinforcement learning that uses deep neural networks as function approximators to learn policies or value functions. DRL allows for the use of complex, high-dimensional observations such as images or speech and can be used for tasks such as playing games, controlling robots, and optimizing resource allocation. Question Answer","title":"What is the use of the deep reinforcement learning in machine learning?"},{"location":"reinforcement_learning/interview_questions/#what-is-the-difference-between-model-free-and-model-based-rl","text":"Model-based RL has an agent that tries to understand (or model) the world by learning state transition function and reward function. So if an agent can predict the next state and the reward before taking the action, it is a model-based RL algorithm. If not then it is model-free algorithm. Refer this AI StackExchange QA Question Answer","title":"What is the difference between model-free and model-based RL?"},{"location":"reinforcement_learning/interview_questions/#what-is-the-difference-between-value-based-and-policy-based-reinforcement-learning","text":"Value-based reinforcement learning methods, such as Q-learning, estimate the value of different actions given a certain state, and then take the action that maximizes this value. Policy-based methods, such as REINFORCE, directly learn a policy that maps states to actions. Question Answer","title":"What is the difference between value-based and policy-based reinforcement learning?"},{"location":"reinforcement_learning/interview_questions/#how-does-q-learning-work-in-reinforcement-learning","text":"Q-learning is a value-based reinforcement learning algorithm that estimates the value of different actions given a certain state. It uses the Bellman equation to update the Q-value, which is the expected future reward of taking an action in a certain state. Over time, the algorithm converges to the optimal Q-value function that represents the best action to take in each state. Question Answer","title":"How does Q-learning work in reinforcement learning?"},{"location":"reinforcement_learning/interview_questions/#what-is-the-difference-between-on-policy-and-off-policy-reinforcement-learning","text":"On-policy reinforcement learning (ex: SARSA) methods learn from the actions taken by the current policy, while off-policy (ex: Q-learning) methods learn from actions taken by a different policy (like greedy approach). On-policy methods are often used when an agent can easily interact with its environment, while off-policy methods are used when it is difficult or expensive to interact with the environment. Refer this StackOverflow QA for more details. Question Answer","title":"What is the difference between on-policy and off-policy reinforcement learning?"},{"location":"reinforcement_learning/interview_questions/#what-is-the-use-of-the-sarsa-algorithm-in-reinforcement-learning","text":"SARSA (State-Action-Reward-State-Action) is a type of on-policy algorithm that estimates the value of different actions given a certain state. It updates the Q-value based on the action taken in the next state, rather than the optimal action as in Q-learning. This makes SARSA more suitable for problems with non-deterministic environments. Question Answer","title":"What is the use of the SARSA algorithm in reinforcement learning?"},{"location":"reinforcement_learning/interview_questions/#explain-actor-critic-algorithm","text":"Actor-Critic is a type of algorithm that combines both policy-based and value-based methods in reinforcement learning. The actor network is used to output a probability distribution over actions given a certain state, while the critic network is used to estimate the value of the actions taken by the actor network. The actor network is then updated according to the critic network's evaluation of its actions. Question Answer","title":"Explain actor-critic algorithm."},{"location":"reinforcement_learning/interview_questions/#explain-a3c-algorithm-in-reinforcement-learning","text":"A3C (Asynchronous Advantage Actor-Critic) is an algorithm that uses multiple parallel agents to train a neural network in an asynchronous manner. A3C is an extension of the actor-critic algorithm that allows for faster and more stable training by reducing the correlation between the updates of different agents. It's useful for training agents for tasks that require handling high dimensional and continuous action spaces, such as robotics and gaming. Question Answer","title":"Explain A3C algorithm in reinforcement learning."},{"location":"reinforcement_learning/interview_questions/#what-is-the-use-of-the-q-network-in-reinforcement-learning","text":"A Q-network is a neural network used in Q-learning, a value-based reinforcement learning algorithm. The Q-network is trained to estimate the value of taking different actions given a certain state. It's used to approximate the Q-value function, which represents the expected future rewards of taking different actions in different states, and to make decisions based on the current state. Question Answer","title":"What is the use of the Q-network in reinforcement learning?"},{"location":"reinforcement_learning/interview_questions/#what-is-monte-carlo-tree-search-in-reinforcement-learning","text":"Monte Carlo Tree Search (MCTS) is a method used to select the next action in a reinforcement learning problem. MCTS works by building a search tree, where each node represents a state and each edge represents an action. The algorithm explores the tree by selecting the best node based on a combination of the current value estimates and the uncertainty of the estimates. MCTS is particularly useful for problems with large and complex action spaces, such as game playing.","title":"What is Monte Carlo Tree Search in reinforcement learning?"},{"location":"reinforcement_learning/introduction/","text":"Getting started Before we deep-dive into Reinforcement Learning (RL), let's go through some videos that showcase how RL is solving some really complicated real world problems: Waymo 360 Experience of Autonomous Driving System DeepMind AI that plays 57 Atari games - Two Minute Papers QT-Opt - Scalable Deep Reinforcement Learning for Vision-Based Robotic Manipulation As obvious from the videos, RL is used across domains - it can control cars, play games and even interact with real world using robot. Isn't it interesting?! Now let's answer the first question - What is Reinforcement Learning? Contrary to basic supervised and unsupervised problems, RL is an area of machine learning concerned with how intelligent agents ought to take actions in an environment in order to maximize the notion of cumulative reward. [1] I know this must be too much to unpack, so let's dissect some important keywords in the next section. Important terms Agent: it is the entity that takes some action which is influenced by current scenario and it's past experience. We try to create an algorithm or AI model that can act as an agent. Environment: this is where agent takes actions. It is the complete world wherein the agent lives and traverse. The environment considers the agent's actions and return rewards (positive or negative based on type of impact) and changes the state of the agent. An environment could be deterministic (taking an action from a state leads to a fixed state always) or non-deteministic (state transition wrt action selection is probabilistic) . graph LR A[Agent] -- state 's' --> B[Environment]; A -- action 'a' --> B; B -- reward 'r' --> A; B -- new state 'sn' --> A; States: An environment consists of multiple states, infact this denotes the different scenarios an agent could be in. States could be (1) engineered (ex: In MountainCar env, combination of calculated position and velocity forms the state) , (2) raw (ex: using screen images for video games) , or (3) combination of both (ex: autonomus driving system considering raw video feeds and some extracted features) . States could be discrete (ex: cell A to cell B) or continous (ex: screenshot of a game, no two images could be same) . Action: These are the possible interactions an agents can make with the environment. Actions could differ wrt to the current state of the agent. It can also be discrete (ex: left turn and right turn) or continous (ex: -120 degree turn) . Reward: Agent performs some actions and enviroment returns rewards. This is usually programmed wrt the behavior we want the agent to learn. If we want the agent to reach a goal -- give +1 point at that point. If we want the agent to move faster -- give -1 for every step it takes (so that it tries ot finish the game asap) . Reward designing is a very important part of solving RL problem. Policy: It is the rulebook that tells the agent what to do for a given state and possible set of actions. Policy based RL agents tries to directly learn the best policy for a given state, whereas value based RL agents learns the value function (estimated reward for each action in a state) and then select action based on their strategy. Episodes: One complete iteration over the environment by the agent, either till it passed or failed, is called an epsiode. In game terminology, think of a round as one episode. The Paradigms in RL Forward Reinforcement Learning It refers to the process of learning a policy or control strategy in an environment by taking actions and receiving feedback or rewards from the environment. The objective of this approach is to maximize the expected cumulative reward obtained from the environment by learning a policy that maps the state of the environment to an action to be taken. Inverse Reinforcement Learning Inverse Reinforcement Learning (IRL) aims to learn the underlying reward function of a given environment from a set of observed trajectories, instead of learning a policy directly. This approach can be used to infer the reward function from human demonstrations or expert behavior, and then learn a policy that maximizes the inferred reward function. Behavior Cloning Behavior cloning refers to a supervised learning technique where a model is trained to mimic the behavior of an expert agent or human in a given task. In this approach, the model is trained on a dataset of state-action pairs, where each action is a direct imitation of the expert's actions in the corresponding state. Behavior cloning can be used as a pre-training step for more complex reinforcement learning algorithms, or as a standalone approach in cases where the expert's behavior is sufficient for solving the task. Apprenticeship Learning Apprenticeship learning, also known as imitation learning, is a machine learning technique where a learner tries to imitate the behavior of an expert agent or human in a given task. Unlike behavior cloning, which only learns to mimic the expert's actions, apprenticeship learning aims to learn the underlying decision-making process or policy of the expert by observing their behavior in a given environment. This approach is useful when the expert's behavior is not easily captured by a simple state-action mapping, and when the reward function of the task is unknown or difficult to specify. Hint One easy way to differentiate the above mentioned domains is as follows, [3] In IRL, we recover a Reward function In Apprenticeship Learning, we find a good policy using the recovered reward function from IRL In Behavior cloning, we directly learn the teacher's policy using supervised learning Resources If you are looking for a deep dive into Reinforcement learning, here are some good materials, I cannot think of a better free course than David Silver on Youtube . In case you prefer books, here is the best of them all - Reinforcement Learning: An Introduction . If you love the API doc way of learning, here is OpenAI Spinning Up in Deep RL References [1] Reinforcement Learning - Wikipedia [2] Apprenticeship Learning via Inverse Reinforcement Learning - Paper [3] Inverse Reinforcement Learning - Lecture PDF","title":"Introduction"},{"location":"reinforcement_learning/introduction/#getting-started","text":"Before we deep-dive into Reinforcement Learning (RL), let's go through some videos that showcase how RL is solving some really complicated real world problems: Waymo 360 Experience of Autonomous Driving System DeepMind AI that plays 57 Atari games - Two Minute Papers QT-Opt - Scalable Deep Reinforcement Learning for Vision-Based Robotic Manipulation As obvious from the videos, RL is used across domains - it can control cars, play games and even interact with real world using robot. Isn't it interesting?! Now let's answer the first question - What is Reinforcement Learning? Contrary to basic supervised and unsupervised problems, RL is an area of machine learning concerned with how intelligent agents ought to take actions in an environment in order to maximize the notion of cumulative reward. [1] I know this must be too much to unpack, so let's dissect some important keywords in the next section.","title":"Getting started"},{"location":"reinforcement_learning/introduction/#important-terms","text":"Agent: it is the entity that takes some action which is influenced by current scenario and it's past experience. We try to create an algorithm or AI model that can act as an agent. Environment: this is where agent takes actions. It is the complete world wherein the agent lives and traverse. The environment considers the agent's actions and return rewards (positive or negative based on type of impact) and changes the state of the agent. An environment could be deterministic (taking an action from a state leads to a fixed state always) or non-deteministic (state transition wrt action selection is probabilistic) . graph LR A[Agent] -- state 's' --> B[Environment]; A -- action 'a' --> B; B -- reward 'r' --> A; B -- new state 'sn' --> A; States: An environment consists of multiple states, infact this denotes the different scenarios an agent could be in. States could be (1) engineered (ex: In MountainCar env, combination of calculated position and velocity forms the state) , (2) raw (ex: using screen images for video games) , or (3) combination of both (ex: autonomus driving system considering raw video feeds and some extracted features) . States could be discrete (ex: cell A to cell B) or continous (ex: screenshot of a game, no two images could be same) . Action: These are the possible interactions an agents can make with the environment. Actions could differ wrt to the current state of the agent. It can also be discrete (ex: left turn and right turn) or continous (ex: -120 degree turn) . Reward: Agent performs some actions and enviroment returns rewards. This is usually programmed wrt the behavior we want the agent to learn. If we want the agent to reach a goal -- give +1 point at that point. If we want the agent to move faster -- give -1 for every step it takes (so that it tries ot finish the game asap) . Reward designing is a very important part of solving RL problem. Policy: It is the rulebook that tells the agent what to do for a given state and possible set of actions. Policy based RL agents tries to directly learn the best policy for a given state, whereas value based RL agents learns the value function (estimated reward for each action in a state) and then select action based on their strategy. Episodes: One complete iteration over the environment by the agent, either till it passed or failed, is called an epsiode. In game terminology, think of a round as one episode.","title":"Important terms"},{"location":"reinforcement_learning/introduction/#the-paradigms-in-rl","text":"","title":"The Paradigms in RL"},{"location":"reinforcement_learning/introduction/#forward-reinforcement-learning","text":"It refers to the process of learning a policy or control strategy in an environment by taking actions and receiving feedback or rewards from the environment. The objective of this approach is to maximize the expected cumulative reward obtained from the environment by learning a policy that maps the state of the environment to an action to be taken.","title":"Forward Reinforcement Learning"},{"location":"reinforcement_learning/introduction/#inverse-reinforcement-learning","text":"Inverse Reinforcement Learning (IRL) aims to learn the underlying reward function of a given environment from a set of observed trajectories, instead of learning a policy directly. This approach can be used to infer the reward function from human demonstrations or expert behavior, and then learn a policy that maximizes the inferred reward function.","title":"Inverse Reinforcement Learning"},{"location":"reinforcement_learning/introduction/#behavior-cloning","text":"Behavior cloning refers to a supervised learning technique where a model is trained to mimic the behavior of an expert agent or human in a given task. In this approach, the model is trained on a dataset of state-action pairs, where each action is a direct imitation of the expert's actions in the corresponding state. Behavior cloning can be used as a pre-training step for more complex reinforcement learning algorithms, or as a standalone approach in cases where the expert's behavior is sufficient for solving the task.","title":"Behavior Cloning"},{"location":"reinforcement_learning/introduction/#apprenticeship-learning","text":"Apprenticeship learning, also known as imitation learning, is a machine learning technique where a learner tries to imitate the behavior of an expert agent or human in a given task. Unlike behavior cloning, which only learns to mimic the expert's actions, apprenticeship learning aims to learn the underlying decision-making process or policy of the expert by observing their behavior in a given environment. This approach is useful when the expert's behavior is not easily captured by a simple state-action mapping, and when the reward function of the task is unknown or difficult to specify. Hint One easy way to differentiate the above mentioned domains is as follows, [3] In IRL, we recover a Reward function In Apprenticeship Learning, we find a good policy using the recovered reward function from IRL In Behavior cloning, we directly learn the teacher's policy using supervised learning","title":"Apprenticeship Learning"},{"location":"reinforcement_learning/introduction/#resources","text":"If you are looking for a deep dive into Reinforcement learning, here are some good materials, I cannot think of a better free course than David Silver on Youtube . In case you prefer books, here is the best of them all - Reinforcement Learning: An Introduction . If you love the API doc way of learning, here is OpenAI Spinning Up in Deep RL","title":"Resources"},{"location":"reinforcement_learning/introduction/#references","text":"[1] Reinforcement Learning - Wikipedia [2] Apprenticeship Learning via Inverse Reinforcement Learning - Paper [3] Inverse Reinforcement Learning - Lecture PDF","title":"References"},{"location":"reinforcement_learning/multi_arm_bandit/","text":"Introduction The bandit problem deals with learning the best decision to make in a static or dynamic environment, without knowing the complete properties of the environment. It is like given a set of possible actions, select the series of actions which increases our overall expected gains, provided you have no prior knowledge of the reward distribution. Let's understand this with an example, suppose you found a teleportation portal (Sci-fi fan anyone?) , which opens up to either your home or middle of the ocean, where the either part is determined by some probability distribution. So if you step into the portal, there is some probability say p , of coming out at your home and probability 1-p , of coming out at the middle of the ocean (let's add some sharks in the ocean ) . I don\u2019t know about you guys, but I would like to go to the former. If we know, say that 60% of the time the portal leads to ocean, we would just never use it or if we land home 60% of the time, using portal might become a little more appealing. But what if we don\u2019t have any such knowledge, what should we do? Now, suppose we found multiple ( n ) such portals, all with the same choices of destinations but different and unknown destination probability distribution. The n-armed or multi arm bandit is used to generalize this type of problems, where we are presented with multiple choices, with no prior knowledge of their true action rewards. In this article, we will try to find a solution to above problem, talk about different algorithms and find the one which could help us converge faster i.e. get as close to the true action reward distribution, with least number of tries. Hint The multi-armed bandit problem gets its name from a hypothetical scenario involving a gambler at a row of slot machines, sometimes known as \"one-armed bandits\" because of their traditional lever (\"arm\") and their ability to leave the gambler penniless (like a robber, or \"bandit\"). In the classic formulation of the problem, each machine (or \"arm\") provides a random reward from a probability distribution specific to that machine. The gambler's objective is to maximize their total reward over a series of spins. Exploration vs Exploitation Consider this scenario - Given n portals, say we tried the portal #1, and it led to home. Great, but should we just consider it as the home portal and use it for all of our future journeys or we should wait and try it out a few more times? Let's say, we tried it a few more times and now we can see 40% of the times it opens to home. Not happy with the results, we move on to portal #2, tried it a few times and it has 60% chance of home journey. Now again, should we stop or try out other portals too? Maybe portal #3 has higher chances of home journey or maybe not. This is the dilemma of exploration and exploitation. The approach that favors exploitation, does so with logic of avoiding unnecessary loss when you have gained some knowledge about the reward distribution. Whereas approach of favoring exploration does so with logic of never getting biased with the action rewards distribution and keep trying every actions in order to get the true properties of the reward distribution. Ideally, we should follow a somewhat middle approach that explores to find more reward distribution and as well as exploits known reward distribution. The Epsilon-Greedy algorithms The greedy algorithm in reinforcement learning always selects the action with highest estimated action value. It's a complete exploitation algorithm, which doesn't care for exploration. It can be a smart approach if we have successfully estimated the action value to the expected action value i.e. if we know the true distribution, just select the best actions. But what if we are unsure about the estimation? The \"epsilon\" comes to the rescue. The epsilon in the greedy algorithm adds exploration to the mix. So counter to previous logic of always selecting the best action, as per the estimated action value, now few times (with epsilon probability) select a random action for the sake of exploration and the remaining times behave as the original greedy algorithm and select the best known action. \\[p_1 = \\epsilon; \\text{action selection is random};\\] \\[p_2 = 1-\\epsilon; \\text{action selection is greedy}\\] Hint A 0-epsilon greedy algorithm with always select the best known action and 1-epsilon greedy algorithm will always select the actions at random. Example - The Portal Game Let's understand the concept with an example. But before that here are some important terms, Environment : It is the container of agent, actions and reward; allows agent to take actions and assign rewards based on the action, following certain set of rules. Expected Action Value: Reward can be defined as objective outcome score or value of an action. In that sense the expected action value can be defined as the expected reward for the selected action i.e. the mean reward when an action is selected. This is the true action reward distribution. Estimated Action Value : This is nothing but the estimation of the Expected Action values which is bound to change after every learning iteration or episode. We start with an estimated action value, and try to bring it as close as possible to the true/expected action value. One way of doing it could be just taking the average of the rewards received for an action till now. \\[ Q_{t}(a) = \\frac{\\text{sum of reward when action `a` is taken prior to `t`}}{\\text{number of times `a` taken prior to `t`}} \\] Say we have 10 portals with the expected action value for favorable home journey given as a uniform distribution, 1 2 3 4 5 6 7 8 9 import numpy as np np . random . seed ( 123 ) expected_action_value = np . random . uniform ( 0 , 1 , 10 ) print ( expected_action_value ) # Output -> # array([0.69646919, 0.28613933, 0.22685145, 0.55131477, 0.71946897, # 0.42310646, 0.9807642 , 0.68482974, 0.4809319 , 0.39211752]) Plot of expected action value of the portal opening to location home With knowledge of expected action value, we could say always choose portal #7; as it has the highest probability of reaching home. But as it is with the real world problems, most of the times, we are completely unfamiliar with the rewards of the actions. In that case we make an estimate of the reward distribution and update it as we learn. Another interesting topic of discussion could be strategy to select optimial initial estimate values, but for now lets keep it simple and define them as 0. 1 2 3 4 estimated_action_value = np . zeros ( 10 ) estimated_action_value # Output -> # array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]) Lets also define the reward function. Going by our requirement, we want to land at home, so lets set reward of value 1 for landing at home and -1 for landing in the ocean. 1 2 3 4 5 def reward_function ( action_taken , expected_action_value ): if ( np . random . uniform ( 0 , 1 ) <= expected_action_value [ action_taken ]): return 1 else : return - 1 Now lets define the bandit problem with estimate action value modification and epsilon-greedy action selection algorithm. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def multi_arm_bandit_problem ( arms = 10 , steps = 1000 , e = 0.1 , expected_action_value = []): # Initialize lists to store rewards and whether the optimal actions for each step was taken or not overall_reward , optimal_action = [], [] # Initialize an array to keep track of the estimated value of each action estimate_action_value = np . zeros ( arms ) # Initialize a count array to keep track of how many times each arm is pulled count = np . zeros ( arms ) # Loop for the given number of steps for s in range ( 0 , steps ): # Generate a random number to decide whether to explore or exploit e_estimator = np . random . uniform ( 0 , 1 ) # If the random number is greater than epsilon, choose the best estimated action, # otherwise, choose a random action action = np . argmax ( estimate_action_value ) if e_estimator > e else np . random . choice ( np . arange ( 10 )) # Get the reward for the chosen action reward = reward_function ( action , expected_action_value ) # Update the estimated value of the chosen action using the incremental formula estimate_action_value [ action ] = estimate_action_value [ action ] + ( 1 / ( count [ action ] + 1 )) * ( reward - estimate_action_value [ action ]) # Record the received reward and whether the chosen action was the optimal one overall_reward . append ( reward ) optimal_action . append ( action == np . argmax ( expected_action_value )) # Increment the count for the chosen action count [ action ] += 1 # Return the list of rewards and a list indicating if the optimal action was taken at each step return ( overall_reward , optimal_action ) Now, let's simulate multiple game (each with different epsilon values over 2000 runs) and see the algorithm behaves. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def run_game ( runs = 2000 , steps = 1000 , arms = 10 , e = 0.1 ): # Initialize arrays to store rewards and optimal action flags for each run and step rewards = np . zeros (( runs , steps )) optimal_actions = np . zeros (( runs , steps )) # Generate random expected action values for each arm expected_action_value = np . random . uniform ( 0 , 1 , arms ) # Iterate over the number of runs for run in range ( 0 , runs ): # Call the multi_arm_bandit_problem function for each run and store the results rewards [ run ][:], optimal_actions [ run ][:] = multi_arm_bandit_problem ( arms = arms , steps = steps , e = e , expected_action_value = expected_action_value ) # After all runs are completed, calculate the average reward at each step rewards_avg = np . average ( rewards , axis = 0 ) # Calculate the percentage of times the optimal action was taken at each step optimal_action_perc = np . average ( optimal_actions , axis = 0 ) # Return the average rewards and the optimal action percentage return ( rewards_avg , optimal_action_perc ) We ran run_game function for four different epsilon values (e=0, 0.01, 0.1 and 1) and got the following results. e-greedy reward gained over 2000 runs, each with 1000 steps e-greedy optimal action selection over 2000 runs, each with 1000 steps We can observe, Complete exploration ( e=1 ) algorithm has its shortcoming as it never makes use of its leanings, it keep picking actions at random. Complete exploitation ( e=0 ) algorithm has its shortcoming as it get locked on the initial best reward and never explore for the sake for better reward discovery. e( 0.01 )-greedy algorithm performs better than the extreme approaches, because of its minute inclination towards exploration and rest of the times going for the best known result. It improves slowly but maybe eventually (too long?) could outperform other approaches. e( 0.1 )-greedy algorithms stands out because it makes use of its learning and from time to time takes exploration initiatives with well distributed probabilities. It explores more and usually find the optimal action earlier than other approaches. Non-stationary problems Introduction Previously, we had defined some portals with fixed reward distribution and tried to bring our estimated action value closer to the expected action value or reward distribution. For non-stationary problems, the bulk of the definitions remains same, but we will just tweak the part of fixed reward distribution. In the original problem, we defined a reward distribution function whose values were not changing throughout the process, but what if they are? What if expected action value is not constant? In terms of the Home portal game, what if the home portal is slowly becoming an ocean one or vice versa or just fluctuating at the border line? In such cases, will our simple e-greedy algorithm work? Well, lets try to find out. First, let's re-run the original code for 10k steps and plot the optimal action selection percentage, the observation is nearly as expected. The epsilon value of 0.01 is out-performing the contrasting e = 0 or 1 but e = 0.01 is overtakes the other approaches around the 2k steps mark. Overtime the performance saturates, with no sign of decrease in the future. Stationary Problem: e-greedy algorithm performance; increased the steps to 10k Now, we need a slight modification to transform the stationary problem to non-stationary. As per the definition, the reward distribution is subject to change. Lets define the term of change, say after each step, and by a normal distribution with mean = 0 and deviation = 0.01 . So after each step, we will compute random numbers based on the defined normal distribution and add it to the previous expected action value. This will become the new reward distribution. This could be easily done adding few lines to the original code, and then we can compute the latest optimal action selection percentage. 1 2 3 4 5 6 7 # define a function to update the expected_action_value def update_expected_action_value ( expected_action_value , arms ): expected_action_value += np . random . normal ( 0 , 0.01 , arms ) return ( expected_action_value ) # inside the multi_arm_bandit_problem function add, estimate_action_value = update_estimate_action_value ( estimate_action_value ) Non-Stationary Problem: e-greedy algorithm performance decreasing after initial peaks On comparing, we could say the performance of the e-greedy algorithms started decreasing after a certain period. Note, even though e=0.01 is still showing good results, but this drastic decrease in performance is visible even by a slight random increment ( deviation=0.01 ), what if the change factor was of higher magnitude? Well as it turn out the decrease would have been more prominent. What is the problem here? Formulation Try to recall the estimation function of the true reward distribution for stationary problem, it goes something like this, \\[Q_t(a) = \\frac{\\text{sum of rewards when } a \\text{ taken up to } t}{\\text{number of times } a \\text{ taken up to } t} = \\frac{\\sum_{i=1}^{t-1} R_i \\cdot \\mathbb{1}_{\\{A_t = a\\}}}{\\sum_{i=1}^{t-1} \\mathbb{1}_{\\{A_t = a\\}}}\\] \\[Q_{n+1} \\doteq \\frac{1}{n} \\sum_{i=1}^{n} R_i\\] \\[Q_{n+1} = Q_n + \\frac{1}{n} \\left[ R_n - Q_n \\right]\\] where, The first equation gives the formula for the estimated reward value for an action at t which is a simple average of all the rewards we received for that action till time t-1 The second equation is just a nice way of writing the same thing. It implies that the estimation of the reward for n+1 step will be average of all the rewards till step n The third equation is what you get when you expand the second equation and put in the formulae of \\(Q_n\\) which is similar to the one of \\(Q_{n+1}\\) , just one step less (replace n with n-1 ). Here, \\(Q_{n+1}\\) is the new estimation for the n+1 steps, \\(Q_n\\) is the old estimation i.e. estimation till step n , \\(R_n\\) is the rewards for nth step and 1/n is step size by which we want to update the new estimation. Derivation of 3rd equation The second formula calculates the new average \\( Q_{n+1} \\) by summing all the rewards \\( R_i \\) from 1 to \\( n \\) and then dividing by \\( n \\) . This is a direct computation of the average, which becomes computationally expensive as \\( n \\) grows because it requires summing over all previous rewards each time a new reward is added. To derive the third formula, we start by expanding the definition of \\( Q_n \\) , which is the average of the rewards up to the \\( n \\) -th reward: \\[ Q_n = \\frac{1}{n-1} \\sum_{i=1}^{n-1} R_i \\] Multiplying both sides by \\( n-1 \\) gives us the total sum of rewards for \\( n-1 \\) actions: \\[ (n-1) \\cdot Q_n = \\sum_{i=1}^{n-1} R_i \\] When we receive the \\( n \\) -th reward, we can update the total sum of rewards by adding \\( R_n \\) : \\[ \\sum_{i=1}^{n} R_i = \\sum_{i=1}^{n-1} R_i + R_n \\] Substituting the total sum of rewards up to \\( n-1 \\) with \\( (n-1) \\cdot Q_n \\) : \\[ \\sum_{i=1}^{n} R_i = (n-1) \\cdot Q_n + R_n \\] Now, to get the average \\( Q_{n+1} \\) , we divide the total sum of rewards by \\( n \\) : \\[ Q_{n+1} = \\frac{1}{n} \\left[ (n-1) \\cdot Q_n + R_n \\right] \\] Expand the right side of the equation: \\[ Q_{n+1} = \\frac{(n-1)}{n} \\cdot Q_n + \\frac{1}{n} \\cdot R_n \\] Recognize that \\( \\frac{(n-1)}{n} \\) is equal to \\( 1 - \\frac{1}{n} \\) : \\[ Q_{n+1} = Q_n \\cdot \\left( 1 - \\frac{1}{n} \\right) + \\frac{1}{n} \\cdot R_n \\] Rearrange the terms to isolate \\( Q_n \\) : \\[ Q_{n+1} = Q_n + \\frac{1}{n} \\left( R_n - Q_n \\right) \\] To be clear, as per this formulation, if a particular action was chosen say 5 times, then each of the 5 rewards (n actions leads to n rewards) will be divide by 1/5 and then added to get the estimation till step 5. If you look closer, you will see we are giving equal weights to all the rewards, irrespective of their time of occurrence, which means we want to say, every reward is equally important to us and hence the equal weights. This holds true for the stationary problems but what about the newer problem? With rewards distribution changing, isn\u2019t the latest rewards better estimation of the true rewards distribution. So shouldn\u2019t we just give more weight to the newer rewards and lesser to the old one? Well this thought is definitely worth pursuing. And this would mean just changing the reward weights, which can be done by replacing the average reward estimation to exponential recency-weighted average. We can further make this process generic by providing an option of if the newer or older rewards should be given more weight or a middle workaround of decreasing weights with time. As it turns out this could be easily done by replacing the step function of 1/n in the older formulation with a constant, say \ud835\udec2 . This updates the estimation function to, \\[ Q_{n+1} = Q_n + \\alpha \\left[ R_n - Q_n \\right]\\] \\[= (1 - \\alpha)^n Q_1 + \\sum_{i=1}^{n} \\alpha (1 - \\alpha)^{n-i} R_i\\] where, If \ud835\udec2 = 1 ; \\(R_n\\) i.e. the very latest reward will have maximum weight of 1 and rest will have 0. So if your excepted action value\u2019s deviation is too drastic, we could use this setting. If \ud835\udec2 = 0 ; \\(Q_1\\) i.e. the oldest reward estimation will have maximum weight of 1 and rest will have 0. We could use this when we only want to consider initial estimation values. If 0 < \ud835\udec2 < 1 ; the weight decreases exponentially according to the exponent 1-\ud835\udec2 . In this case the oldest reward will have smaller weight and latest rewards higher. And this is what we want to try out. Example - The Portal Game v2 Lets formalize the solution by simply updating the code to replace the step size by an constant of value, say 0.1 and keeping rest of the parameters same. This will implement the exponential decreasing weight. Later we will compute the optimal action selection percentage and reflect on it. 1 2 3 4 # update the estimation calculation estimate_action_value [ action ] = \\ estimate_action_value [ action ] + \\ 0.1 * ( reward - estimate_action_value [ action ]) Non-Stationary Problem: e-greedy algorithm performance due to constant step-size And we are back in business! e=0.01 is out-performing it's rival and the performance converges to maximum after some steps. Here we are not seeing any decrease in performance, because of our modified estimation function which factor the changing nature of reward distribution. Conclusion There are multiple take aways from this post like understanding the importance of exploration/exploitation and why a hybrid (`0","title":"Multi-Arm Bandit"},{"location":"reinforcement_learning/multi_arm_bandit/#introduction","text":"The bandit problem deals with learning the best decision to make in a static or dynamic environment, without knowing the complete properties of the environment. It is like given a set of possible actions, select the series of actions which increases our overall expected gains, provided you have no prior knowledge of the reward distribution. Let's understand this with an example, suppose you found a teleportation portal (Sci-fi fan anyone?) , which opens up to either your home or middle of the ocean, where the either part is determined by some probability distribution. So if you step into the portal, there is some probability say p , of coming out at your home and probability 1-p , of coming out at the middle of the ocean (let's add some sharks in the ocean ) . I don\u2019t know about you guys, but I would like to go to the former. If we know, say that 60% of the time the portal leads to ocean, we would just never use it or if we land home 60% of the time, using portal might become a little more appealing. But what if we don\u2019t have any such knowledge, what should we do? Now, suppose we found multiple ( n ) such portals, all with the same choices of destinations but different and unknown destination probability distribution. The n-armed or multi arm bandit is used to generalize this type of problems, where we are presented with multiple choices, with no prior knowledge of their true action rewards. In this article, we will try to find a solution to above problem, talk about different algorithms and find the one which could help us converge faster i.e. get as close to the true action reward distribution, with least number of tries. Hint The multi-armed bandit problem gets its name from a hypothetical scenario involving a gambler at a row of slot machines, sometimes known as \"one-armed bandits\" because of their traditional lever (\"arm\") and their ability to leave the gambler penniless (like a robber, or \"bandit\"). In the classic formulation of the problem, each machine (or \"arm\") provides a random reward from a probability distribution specific to that machine. The gambler's objective is to maximize their total reward over a series of spins.","title":"Introduction"},{"location":"reinforcement_learning/multi_arm_bandit/#exploration-vs-exploitation","text":"Consider this scenario - Given n portals, say we tried the portal #1, and it led to home. Great, but should we just consider it as the home portal and use it for all of our future journeys or we should wait and try it out a few more times? Let's say, we tried it a few more times and now we can see 40% of the times it opens to home. Not happy with the results, we move on to portal #2, tried it a few times and it has 60% chance of home journey. Now again, should we stop or try out other portals too? Maybe portal #3 has higher chances of home journey or maybe not. This is the dilemma of exploration and exploitation. The approach that favors exploitation, does so with logic of avoiding unnecessary loss when you have gained some knowledge about the reward distribution. Whereas approach of favoring exploration does so with logic of never getting biased with the action rewards distribution and keep trying every actions in order to get the true properties of the reward distribution. Ideally, we should follow a somewhat middle approach that explores to find more reward distribution and as well as exploits known reward distribution.","title":"Exploration vs Exploitation"},{"location":"reinforcement_learning/multi_arm_bandit/#the-epsilon-greedy-algorithms","text":"The greedy algorithm in reinforcement learning always selects the action with highest estimated action value. It's a complete exploitation algorithm, which doesn't care for exploration. It can be a smart approach if we have successfully estimated the action value to the expected action value i.e. if we know the true distribution, just select the best actions. But what if we are unsure about the estimation? The \"epsilon\" comes to the rescue. The epsilon in the greedy algorithm adds exploration to the mix. So counter to previous logic of always selecting the best action, as per the estimated action value, now few times (with epsilon probability) select a random action for the sake of exploration and the remaining times behave as the original greedy algorithm and select the best known action. \\[p_1 = \\epsilon; \\text{action selection is random};\\] \\[p_2 = 1-\\epsilon; \\text{action selection is greedy}\\] Hint A 0-epsilon greedy algorithm with always select the best known action and 1-epsilon greedy algorithm will always select the actions at random.","title":"The Epsilon-Greedy algorithms"},{"location":"reinforcement_learning/multi_arm_bandit/#example-the-portal-game","text":"Let's understand the concept with an example. But before that here are some important terms, Environment : It is the container of agent, actions and reward; allows agent to take actions and assign rewards based on the action, following certain set of rules. Expected Action Value: Reward can be defined as objective outcome score or value of an action. In that sense the expected action value can be defined as the expected reward for the selected action i.e. the mean reward when an action is selected. This is the true action reward distribution. Estimated Action Value : This is nothing but the estimation of the Expected Action values which is bound to change after every learning iteration or episode. We start with an estimated action value, and try to bring it as close as possible to the true/expected action value. One way of doing it could be just taking the average of the rewards received for an action till now. \\[ Q_{t}(a) = \\frac{\\text{sum of reward when action `a` is taken prior to `t`}}{\\text{number of times `a` taken prior to `t`}} \\] Say we have 10 portals with the expected action value for favorable home journey given as a uniform distribution, 1 2 3 4 5 6 7 8 9 import numpy as np np . random . seed ( 123 ) expected_action_value = np . random . uniform ( 0 , 1 , 10 ) print ( expected_action_value ) # Output -> # array([0.69646919, 0.28613933, 0.22685145, 0.55131477, 0.71946897, # 0.42310646, 0.9807642 , 0.68482974, 0.4809319 , 0.39211752]) Plot of expected action value of the portal opening to location home With knowledge of expected action value, we could say always choose portal #7; as it has the highest probability of reaching home. But as it is with the real world problems, most of the times, we are completely unfamiliar with the rewards of the actions. In that case we make an estimate of the reward distribution and update it as we learn. Another interesting topic of discussion could be strategy to select optimial initial estimate values, but for now lets keep it simple and define them as 0. 1 2 3 4 estimated_action_value = np . zeros ( 10 ) estimated_action_value # Output -> # array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]) Lets also define the reward function. Going by our requirement, we want to land at home, so lets set reward of value 1 for landing at home and -1 for landing in the ocean. 1 2 3 4 5 def reward_function ( action_taken , expected_action_value ): if ( np . random . uniform ( 0 , 1 ) <= expected_action_value [ action_taken ]): return 1 else : return - 1 Now lets define the bandit problem with estimate action value modification and epsilon-greedy action selection algorithm. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def multi_arm_bandit_problem ( arms = 10 , steps = 1000 , e = 0.1 , expected_action_value = []): # Initialize lists to store rewards and whether the optimal actions for each step was taken or not overall_reward , optimal_action = [], [] # Initialize an array to keep track of the estimated value of each action estimate_action_value = np . zeros ( arms ) # Initialize a count array to keep track of how many times each arm is pulled count = np . zeros ( arms ) # Loop for the given number of steps for s in range ( 0 , steps ): # Generate a random number to decide whether to explore or exploit e_estimator = np . random . uniform ( 0 , 1 ) # If the random number is greater than epsilon, choose the best estimated action, # otherwise, choose a random action action = np . argmax ( estimate_action_value ) if e_estimator > e else np . random . choice ( np . arange ( 10 )) # Get the reward for the chosen action reward = reward_function ( action , expected_action_value ) # Update the estimated value of the chosen action using the incremental formula estimate_action_value [ action ] = estimate_action_value [ action ] + ( 1 / ( count [ action ] + 1 )) * ( reward - estimate_action_value [ action ]) # Record the received reward and whether the chosen action was the optimal one overall_reward . append ( reward ) optimal_action . append ( action == np . argmax ( expected_action_value )) # Increment the count for the chosen action count [ action ] += 1 # Return the list of rewards and a list indicating if the optimal action was taken at each step return ( overall_reward , optimal_action ) Now, let's simulate multiple game (each with different epsilon values over 2000 runs) and see the algorithm behaves. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def run_game ( runs = 2000 , steps = 1000 , arms = 10 , e = 0.1 ): # Initialize arrays to store rewards and optimal action flags for each run and step rewards = np . zeros (( runs , steps )) optimal_actions = np . zeros (( runs , steps )) # Generate random expected action values for each arm expected_action_value = np . random . uniform ( 0 , 1 , arms ) # Iterate over the number of runs for run in range ( 0 , runs ): # Call the multi_arm_bandit_problem function for each run and store the results rewards [ run ][:], optimal_actions [ run ][:] = multi_arm_bandit_problem ( arms = arms , steps = steps , e = e , expected_action_value = expected_action_value ) # After all runs are completed, calculate the average reward at each step rewards_avg = np . average ( rewards , axis = 0 ) # Calculate the percentage of times the optimal action was taken at each step optimal_action_perc = np . average ( optimal_actions , axis = 0 ) # Return the average rewards and the optimal action percentage return ( rewards_avg , optimal_action_perc ) We ran run_game function for four different epsilon values (e=0, 0.01, 0.1 and 1) and got the following results. e-greedy reward gained over 2000 runs, each with 1000 steps e-greedy optimal action selection over 2000 runs, each with 1000 steps We can observe, Complete exploration ( e=1 ) algorithm has its shortcoming as it never makes use of its leanings, it keep picking actions at random. Complete exploitation ( e=0 ) algorithm has its shortcoming as it get locked on the initial best reward and never explore for the sake for better reward discovery. e( 0.01 )-greedy algorithm performs better than the extreme approaches, because of its minute inclination towards exploration and rest of the times going for the best known result. It improves slowly but maybe eventually (too long?) could outperform other approaches. e( 0.1 )-greedy algorithms stands out because it makes use of its learning and from time to time takes exploration initiatives with well distributed probabilities. It explores more and usually find the optimal action earlier than other approaches.","title":"Example - The Portal Game"},{"location":"reinforcement_learning/multi_arm_bandit/#non-stationary-problems","text":"","title":"Non-stationary problems"},{"location":"reinforcement_learning/multi_arm_bandit/#introduction_1","text":"Previously, we had defined some portals with fixed reward distribution and tried to bring our estimated action value closer to the expected action value or reward distribution. For non-stationary problems, the bulk of the definitions remains same, but we will just tweak the part of fixed reward distribution. In the original problem, we defined a reward distribution function whose values were not changing throughout the process, but what if they are? What if expected action value is not constant? In terms of the Home portal game, what if the home portal is slowly becoming an ocean one or vice versa or just fluctuating at the border line? In such cases, will our simple e-greedy algorithm work? Well, lets try to find out. First, let's re-run the original code for 10k steps and plot the optimal action selection percentage, the observation is nearly as expected. The epsilon value of 0.01 is out-performing the contrasting e = 0 or 1 but e = 0.01 is overtakes the other approaches around the 2k steps mark. Overtime the performance saturates, with no sign of decrease in the future. Stationary Problem: e-greedy algorithm performance; increased the steps to 10k Now, we need a slight modification to transform the stationary problem to non-stationary. As per the definition, the reward distribution is subject to change. Lets define the term of change, say after each step, and by a normal distribution with mean = 0 and deviation = 0.01 . So after each step, we will compute random numbers based on the defined normal distribution and add it to the previous expected action value. This will become the new reward distribution. This could be easily done adding few lines to the original code, and then we can compute the latest optimal action selection percentage. 1 2 3 4 5 6 7 # define a function to update the expected_action_value def update_expected_action_value ( expected_action_value , arms ): expected_action_value += np . random . normal ( 0 , 0.01 , arms ) return ( expected_action_value ) # inside the multi_arm_bandit_problem function add, estimate_action_value = update_estimate_action_value ( estimate_action_value ) Non-Stationary Problem: e-greedy algorithm performance decreasing after initial peaks On comparing, we could say the performance of the e-greedy algorithms started decreasing after a certain period. Note, even though e=0.01 is still showing good results, but this drastic decrease in performance is visible even by a slight random increment ( deviation=0.01 ), what if the change factor was of higher magnitude? Well as it turn out the decrease would have been more prominent. What is the problem here?","title":"Introduction"},{"location":"reinforcement_learning/multi_arm_bandit/#formulation","text":"Try to recall the estimation function of the true reward distribution for stationary problem, it goes something like this, \\[Q_t(a) = \\frac{\\text{sum of rewards when } a \\text{ taken up to } t}{\\text{number of times } a \\text{ taken up to } t} = \\frac{\\sum_{i=1}^{t-1} R_i \\cdot \\mathbb{1}_{\\{A_t = a\\}}}{\\sum_{i=1}^{t-1} \\mathbb{1}_{\\{A_t = a\\}}}\\] \\[Q_{n+1} \\doteq \\frac{1}{n} \\sum_{i=1}^{n} R_i\\] \\[Q_{n+1} = Q_n + \\frac{1}{n} \\left[ R_n - Q_n \\right]\\] where, The first equation gives the formula for the estimated reward value for an action at t which is a simple average of all the rewards we received for that action till time t-1 The second equation is just a nice way of writing the same thing. It implies that the estimation of the reward for n+1 step will be average of all the rewards till step n The third equation is what you get when you expand the second equation and put in the formulae of \\(Q_n\\) which is similar to the one of \\(Q_{n+1}\\) , just one step less (replace n with n-1 ). Here, \\(Q_{n+1}\\) is the new estimation for the n+1 steps, \\(Q_n\\) is the old estimation i.e. estimation till step n , \\(R_n\\) is the rewards for nth step and 1/n is step size by which we want to update the new estimation. Derivation of 3rd equation The second formula calculates the new average \\( Q_{n+1} \\) by summing all the rewards \\( R_i \\) from 1 to \\( n \\) and then dividing by \\( n \\) . This is a direct computation of the average, which becomes computationally expensive as \\( n \\) grows because it requires summing over all previous rewards each time a new reward is added. To derive the third formula, we start by expanding the definition of \\( Q_n \\) , which is the average of the rewards up to the \\( n \\) -th reward: \\[ Q_n = \\frac{1}{n-1} \\sum_{i=1}^{n-1} R_i \\] Multiplying both sides by \\( n-1 \\) gives us the total sum of rewards for \\( n-1 \\) actions: \\[ (n-1) \\cdot Q_n = \\sum_{i=1}^{n-1} R_i \\] When we receive the \\( n \\) -th reward, we can update the total sum of rewards by adding \\( R_n \\) : \\[ \\sum_{i=1}^{n} R_i = \\sum_{i=1}^{n-1} R_i + R_n \\] Substituting the total sum of rewards up to \\( n-1 \\) with \\( (n-1) \\cdot Q_n \\) : \\[ \\sum_{i=1}^{n} R_i = (n-1) \\cdot Q_n + R_n \\] Now, to get the average \\( Q_{n+1} \\) , we divide the total sum of rewards by \\( n \\) : \\[ Q_{n+1} = \\frac{1}{n} \\left[ (n-1) \\cdot Q_n + R_n \\right] \\] Expand the right side of the equation: \\[ Q_{n+1} = \\frac{(n-1)}{n} \\cdot Q_n + \\frac{1}{n} \\cdot R_n \\] Recognize that \\( \\frac{(n-1)}{n} \\) is equal to \\( 1 - \\frac{1}{n} \\) : \\[ Q_{n+1} = Q_n \\cdot \\left( 1 - \\frac{1}{n} \\right) + \\frac{1}{n} \\cdot R_n \\] Rearrange the terms to isolate \\( Q_n \\) : \\[ Q_{n+1} = Q_n + \\frac{1}{n} \\left( R_n - Q_n \\right) \\] To be clear, as per this formulation, if a particular action was chosen say 5 times, then each of the 5 rewards (n actions leads to n rewards) will be divide by 1/5 and then added to get the estimation till step 5. If you look closer, you will see we are giving equal weights to all the rewards, irrespective of their time of occurrence, which means we want to say, every reward is equally important to us and hence the equal weights. This holds true for the stationary problems but what about the newer problem? With rewards distribution changing, isn\u2019t the latest rewards better estimation of the true rewards distribution. So shouldn\u2019t we just give more weight to the newer rewards and lesser to the old one? Well this thought is definitely worth pursuing. And this would mean just changing the reward weights, which can be done by replacing the average reward estimation to exponential recency-weighted average. We can further make this process generic by providing an option of if the newer or older rewards should be given more weight or a middle workaround of decreasing weights with time. As it turns out this could be easily done by replacing the step function of 1/n in the older formulation with a constant, say \ud835\udec2 . This updates the estimation function to, \\[ Q_{n+1} = Q_n + \\alpha \\left[ R_n - Q_n \\right]\\] \\[= (1 - \\alpha)^n Q_1 + \\sum_{i=1}^{n} \\alpha (1 - \\alpha)^{n-i} R_i\\] where, If \ud835\udec2 = 1 ; \\(R_n\\) i.e. the very latest reward will have maximum weight of 1 and rest will have 0. So if your excepted action value\u2019s deviation is too drastic, we could use this setting. If \ud835\udec2 = 0 ; \\(Q_1\\) i.e. the oldest reward estimation will have maximum weight of 1 and rest will have 0. We could use this when we only want to consider initial estimation values. If 0 < \ud835\udec2 < 1 ; the weight decreases exponentially according to the exponent 1-\ud835\udec2 . In this case the oldest reward will have smaller weight and latest rewards higher. And this is what we want to try out.","title":"Formulation"},{"location":"reinforcement_learning/multi_arm_bandit/#example-the-portal-game-v2","text":"Lets formalize the solution by simply updating the code to replace the step size by an constant of value, say 0.1 and keeping rest of the parameters same. This will implement the exponential decreasing weight. Later we will compute the optimal action selection percentage and reflect on it. 1 2 3 4 # update the estimation calculation estimate_action_value [ action ] = \\ estimate_action_value [ action ] + \\ 0.1 * ( reward - estimate_action_value [ action ]) Non-Stationary Problem: e-greedy algorithm performance due to constant step-size And we are back in business! e=0.01 is out-performing it's rival and the performance converges to maximum after some steps. Here we are not seeing any decrease in performance, because of our modified estimation function which factor the changing nature of reward distribution.","title":"Example - The Portal Game v2"},{"location":"reinforcement_learning/multi_arm_bandit/#conclusion","text":"There are multiple take aways from this post like understanding the importance of exploration/exploitation and why a hybrid (`0","title":"Conclusion"},{"location":"reinforcement_learning/q_learning/","text":"Introduction Q-learning is a RL algorithm that computes an expected reward for taking an action from any given state. The expected reward is a composition of the immediate reward and the future rewards possible from the new transitioned state. It is an iteration based algorithm that adjusts the scores over time, and given infinite exploration time it can identify an optimal action-selection policy. Note Q-learning does not requires to model the environment, hence it is model-free (check here for more details) . To better grasp the intuition, let's understand it through a Grid world example before further complications creeps in. The Beer game in Grid world Think of Grid World as a nD world (environment) where an agent will live and traverse. The environment consists of multiple cells, where each cell denotes one state, and it could deliver certain reward (positive or negative) to reach that state. The agent at any given time, will only have the knowledge of the current state and the information it gained in previous episodes. Now imagine we drop an agent in a 2D grid world that contains a beer (that we want to find) and a pit (that we want to avoid) . The agent traverse the world until it either finds the beer or drops into the pit. If we make the agent play this game 1000s of times, how should the agent behave overtime? The answer seems simple -- at first the agent will have no knowledge of the world, so it will stumble across the env, like a person performing coin toss to decide his fate . Sometimes, it will find the beer or the pit, and at either points, it starts again. The interesting part is, after each episode the agent will become more and more aware of the world. And after many episodes it would have developed a detailed map, that guides to the beer with details of the areas you should not go to (as it contains the pit) \ud83d\ude0e A technical recreation of The Beer Game with left most cell denoting the pit, the 7th cell contains beer and the rest of the cell denotes the expected reward if we move in the suggested direction. [1] Bellman's Equation The next question is how to capture the details of the map? That's where bellman's equation comes into the picture. Basically it learns Q (quality) scores, that represents expected reward, for taking an action \\(a\\) from a state \\(s\\) . If we capture this for all the states and actions in the world then viola, we have the map! The formulation of Q-score is given below. \\[Q(s_{t},a_{t}) = r_{t} + \\gamma \\cdot \\max _{a}Q(s_{t+1},a)\\] Here, \\(Q(s_{t},a_{t})\\) is the Q-score for taking action \\(a_t\\) in state \\(s_t\\) . \\(r_t\\) is the reward we get to perform the action. \\(\\gamma\\) is the discount factor which is multiplied with the current reward estimation for the best possible action from the next step \\(s_{t+1}\\) . The discount factor (range 0 to \\(\\inf\\) ) is used to adjust the importance to be given to immediate reward (low \\(\\gamma\\) ) or future reward (high \\(\\gamma\\) ) . The formulation to update the Q-score is given below, where \\(\\alpha\\) is the learning rate (yes, like the Neural networks ) \\[Q^{new}(s_{t},a_{t}) = Q^{old}(s_{t},a_{t}) + \\alpha \\cdot (r_{t} + \\gamma \\cdot \\max _{a}Q(s_{t+1},a) - Q^{old}(s_{t},a_{t}))\\] Below is an example of a 2D grid world, where we have set the middle cell with a reward of +1 and we perform multiple iterations of the q-learning. Agent performing Q learning over the 2D grid world. [1] Hint If you want to create and play around with your 2D grid world, try this Interactive Q-Learning playgorund by yours truly. [1] Code Exploring MountainCar env Now let's get started with some action i.e. coding. We will train a RL agent using Q-learning to beat the game of MountainCar available on OpenAI's Gym package that provides a simple interface to represent and play with general RL problems. Before that, let's understand some fundamentals of the MountainCar game environment. Aim: To get the car to reach the yellow flag Observation (states) : Position: -1.2 to 0.6 Velocity: -0.07 to 0.07 Actions: Push left: 0 No push: 1 Right push: 2 Reward: Reached yellow flag: +1 Other: -0.5 Why is this difficult? Bcoz a normal continous right push will not work, to win we need to oscillate as we need momentum from left. Untrained agent in the MountainCar env We can explore the same via code as shown below, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \"\"\" Reference: https://blog.paperspace.com/getting-started-with-openai-gym/ Requirements; (don't forget to create new VE) pip install gym pip install \"gym[box2d]\" pip install \"gym[other]\" \"\"\" # import import gym # create an env env = gym . make ( \"MountainCar-v0\" , render_mode = \"human\" ) # seed env . action_space . seed ( 42 ) # Observation and action space obs_space = env . observation_space action_space = env . action_space print ( \"The observation space: {} \" . format ( obs_space )) print ( \"The action space: {} \" . format ( action_space )) # reset the space observation , info = env . reset ( seed = 42 ) print ( f \"Observation: { observation } \" ) print ( f \"Info: { info } \" ) print ( f \"Sample action; { env . action_space . sample () } \" ) ## OUTPUT # The observation space: Box([-1.2 -0.07], [0.6 0.07], (2,), float32) # The action space: Discrete(3) # Observation: [-0.4452088 0. ] # Info: {} # Sample action; 0 Training Agent using Q-learning Hint Before starting with this section, why not try to code up some basic logic to beat the game? You could try to always push right or oscillate left and right at certain intervals. Give it try, it will be fun The code shared below (credits to gkhayes ) trains a Q-learning agent to play the MountainCar game. It tries to create a Q-table (that contains Q-scores) for all the combination of states and actions. As the states are continous (they are in float) , it is first discretized to make it a finite state problem. The final Q-table is of the shape [19, 15, 3] , with 19 possible states for position, 15 states for velocity and 3 actions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 \"\"\" Reference and Credit: https://gist.github.com/gkhayes/3d154e0505e31d6367be22ed3da2e955 Requirements; (don't forget to create new VE) pip install gym pip install \"gym[box2d]\" pip install \"gym[other]\" pip install numpy, matplotlib \"\"\" # import import numpy as np import gym import matplotlib.pyplot as plt # Import and initialize Mountain Car Environment env = gym . make ( 'MountainCar-v0' ) env . reset () # Define Q-learning function def QLearning ( env , learning , discount , epsilon , min_eps , episodes ): # Determine size of discretized state space num_states = ( env . observation_space . high - env . observation_space . low ) * \\ np . array ([ 10 , 100 ]) num_states = np . round ( num_states , 0 ) . astype ( int ) + 1 # Initialize Q table Q = np . random . uniform ( low = - 1 , high = 1 , size = ( num_states [ 0 ], num_states [ 1 ], env . action_space . n )) # Initialize variables to track rewards reward_list = [] ave_reward_list = [] # Calculate episodic reduction in epsilon reduction = ( epsilon - min_eps ) / episodes # Run Q learning algorithm for i in range ( episodes ): # Initialize parameters done = False tot_reward , reward = 0 , 0 state = env . reset () # Discretize state state_adj = ( state [ 0 ] - env . observation_space . low ) * np . array ([ 10 , 100 ]) state_adj = np . round ( state_adj , 0 ) . astype ( int ) while done != True : # Render environment for last five episodes if i >= ( episodes - 20 ): env . render () # Determine next action - epsilon greedy strategy if np . random . random () < 1 - epsilon : action = np . argmax ( Q [ state_adj [ 0 ], state_adj [ 1 ]]) else : action = np . random . randint ( 0 , env . action_space . n ) # Get next state and reward state2 , reward , done , info , _ = env . step ( action ) # Discretize state2 state2_adj = ( state2 - env . observation_space . low ) * np . array ([ 10 , 100 ]) state2_adj = np . round ( state2_adj , 0 ) . astype ( int ) #Allow for terminal states if done and state2 [ 0 ] >= 0.5 : Q [ state_adj [ 0 ], state_adj [ 1 ], action ] = reward # Adjust Q value for current state else : delta = learning * ( reward + discount * np . max ( Q [ state2_adj [ 0 ], state2_adj [ 1 ]]) - Q [ state_adj [ 0 ], state_adj [ 1 ], action ]) Q [ state_adj [ 0 ], state_adj [ 1 ], action ] += delta # Update variables tot_reward += reward state_adj = state2_adj # Decay epsilon if epsilon > min_eps : epsilon -= reduction # Track rewards reward_list . append ( tot_reward ) if ( i + 1 ) % 100 == 0 : ave_reward = np . mean ( reward_list ) ave_reward_list . append ( ave_reward ) reward_list = [] if ( i + 1 ) % 100 == 0 : print ( 'Episode {} Average Reward: {} ' . format ( i + 1 , ave_reward )) env . close () # save the Q table np . save ( 'MountainCar-v0-q-learning' , Q ) return ave_reward_list # Run Q-learning algorithm rewards = QLearning ( env , 0.2 , 0.9 , 0.8 , 0 , 5000 ) # Plot Rewards plt . plot ( 100 * ( np . arange ( len ( rewards )) + 1 ), rewards ) plt . xlabel ( 'Episodes' ) plt . ylabel ( 'Average Reward' ) plt . title ( 'Average Reward vs Episodes' ) plt . savefig ( 'rewards.jpg' ) plt . close () Running the above code trains a RL agent for 5000 episodes and saves the Q-table as numpy array. It also computes the average reward vs episodes graph that is shown below. Do note how the agent is able to get more rewards over more training! Increasing reward over time for the agent in training. The average rewards went up from -4300 to -250 under just 5000 episodes. Inference of trained agent To run the trained model, we can use the saved Q-table to select the best action given any state in the game. Below is the code for the same, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \"\"\" Requirements; (don't forget to create new VE) pip install gym pip install \"gym[box2d]\" pip install \"gym[other]\" MountainCar-v0-q-table.txt.npy file that contains the modelled environment \"\"\" # import import gym import numpy as np from gym.utils import play # load trained Q table Q = np . load ( 'MountainCar-v0-q-table.txt.npy' ) # create an env env = gym . make ( \"MountainCar-v0\" , render_mode = \"human\" ) # seed env . action_space . seed ( 42 ) observation , info = env . reset ( seed = 42 ) # total number of steps for s in range ( 200 ): state_adj = ( observation - env . observation_space . low ) * np . array ([ 10 , 100 ]) state_adj = np . round ( state_adj , 0 ) . astype ( int ) # define the next step to take next_action = np . argmax ( Q [ state_adj [ 0 ], state_adj [ 1 ]]) # perform one step observation , reward , terminated , truncated , info = env . step ( next_action ) print ( s , observation , reward , terminated , truncated , info ) # if the game ends, restart the game if terminated or truncated : observation , info = env . reset () env . close () Trained RL agent performing as expected There you go!! References Interactive Q Learning - Mohit Mayank","title":"Q-Learning"},{"location":"reinforcement_learning/q_learning/#introduction","text":"Q-learning is a RL algorithm that computes an expected reward for taking an action from any given state. The expected reward is a composition of the immediate reward and the future rewards possible from the new transitioned state. It is an iteration based algorithm that adjusts the scores over time, and given infinite exploration time it can identify an optimal action-selection policy. Note Q-learning does not requires to model the environment, hence it is model-free (check here for more details) . To better grasp the intuition, let's understand it through a Grid world example before further complications creeps in.","title":"Introduction"},{"location":"reinforcement_learning/q_learning/#the-beer-game-in-grid-world","text":"Think of Grid World as a nD world (environment) where an agent will live and traverse. The environment consists of multiple cells, where each cell denotes one state, and it could deliver certain reward (positive or negative) to reach that state. The agent at any given time, will only have the knowledge of the current state and the information it gained in previous episodes. Now imagine we drop an agent in a 2D grid world that contains a beer (that we want to find) and a pit (that we want to avoid) . The agent traverse the world until it either finds the beer or drops into the pit. If we make the agent play this game 1000s of times, how should the agent behave overtime? The answer seems simple -- at first the agent will have no knowledge of the world, so it will stumble across the env, like a person performing coin toss to decide his fate . Sometimes, it will find the beer or the pit, and at either points, it starts again. The interesting part is, after each episode the agent will become more and more aware of the world. And after many episodes it would have developed a detailed map, that guides to the beer with details of the areas you should not go to (as it contains the pit) \ud83d\ude0e A technical recreation of The Beer Game with left most cell denoting the pit, the 7th cell contains beer and the rest of the cell denotes the expected reward if we move in the suggested direction. [1]","title":"The Beer game in Grid world"},{"location":"reinforcement_learning/q_learning/#bellmans-equation","text":"The next question is how to capture the details of the map? That's where bellman's equation comes into the picture. Basically it learns Q (quality) scores, that represents expected reward, for taking an action \\(a\\) from a state \\(s\\) . If we capture this for all the states and actions in the world then viola, we have the map! The formulation of Q-score is given below. \\[Q(s_{t},a_{t}) = r_{t} + \\gamma \\cdot \\max _{a}Q(s_{t+1},a)\\] Here, \\(Q(s_{t},a_{t})\\) is the Q-score for taking action \\(a_t\\) in state \\(s_t\\) . \\(r_t\\) is the reward we get to perform the action. \\(\\gamma\\) is the discount factor which is multiplied with the current reward estimation for the best possible action from the next step \\(s_{t+1}\\) . The discount factor (range 0 to \\(\\inf\\) ) is used to adjust the importance to be given to immediate reward (low \\(\\gamma\\) ) or future reward (high \\(\\gamma\\) ) . The formulation to update the Q-score is given below, where \\(\\alpha\\) is the learning rate (yes, like the Neural networks ) \\[Q^{new}(s_{t},a_{t}) = Q^{old}(s_{t},a_{t}) + \\alpha \\cdot (r_{t} + \\gamma \\cdot \\max _{a}Q(s_{t+1},a) - Q^{old}(s_{t},a_{t}))\\] Below is an example of a 2D grid world, where we have set the middle cell with a reward of +1 and we perform multiple iterations of the q-learning. Agent performing Q learning over the 2D grid world. [1] Hint If you want to create and play around with your 2D grid world, try this Interactive Q-Learning playgorund by yours truly. [1]","title":"Bellman's Equation"},{"location":"reinforcement_learning/q_learning/#code","text":"","title":"Code"},{"location":"reinforcement_learning/q_learning/#exploring-mountaincar-env","text":"Now let's get started with some action i.e. coding. We will train a RL agent using Q-learning to beat the game of MountainCar available on OpenAI's Gym package that provides a simple interface to represent and play with general RL problems. Before that, let's understand some fundamentals of the MountainCar game environment. Aim: To get the car to reach the yellow flag Observation (states) : Position: -1.2 to 0.6 Velocity: -0.07 to 0.07 Actions: Push left: 0 No push: 1 Right push: 2 Reward: Reached yellow flag: +1 Other: -0.5 Why is this difficult? Bcoz a normal continous right push will not work, to win we need to oscillate as we need momentum from left. Untrained agent in the MountainCar env We can explore the same via code as shown below, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \"\"\" Reference: https://blog.paperspace.com/getting-started-with-openai-gym/ Requirements; (don't forget to create new VE) pip install gym pip install \"gym[box2d]\" pip install \"gym[other]\" \"\"\" # import import gym # create an env env = gym . make ( \"MountainCar-v0\" , render_mode = \"human\" ) # seed env . action_space . seed ( 42 ) # Observation and action space obs_space = env . observation_space action_space = env . action_space print ( \"The observation space: {} \" . format ( obs_space )) print ( \"The action space: {} \" . format ( action_space )) # reset the space observation , info = env . reset ( seed = 42 ) print ( f \"Observation: { observation } \" ) print ( f \"Info: { info } \" ) print ( f \"Sample action; { env . action_space . sample () } \" ) ## OUTPUT # The observation space: Box([-1.2 -0.07], [0.6 0.07], (2,), float32) # The action space: Discrete(3) # Observation: [-0.4452088 0. ] # Info: {} # Sample action; 0","title":"Exploring MountainCar env"},{"location":"reinforcement_learning/q_learning/#training-agent-using-q-learning","text":"Hint Before starting with this section, why not try to code up some basic logic to beat the game? You could try to always push right or oscillate left and right at certain intervals. Give it try, it will be fun The code shared below (credits to gkhayes ) trains a Q-learning agent to play the MountainCar game. It tries to create a Q-table (that contains Q-scores) for all the combination of states and actions. As the states are continous (they are in float) , it is first discretized to make it a finite state problem. The final Q-table is of the shape [19, 15, 3] , with 19 possible states for position, 15 states for velocity and 3 actions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 \"\"\" Reference and Credit: https://gist.github.com/gkhayes/3d154e0505e31d6367be22ed3da2e955 Requirements; (don't forget to create new VE) pip install gym pip install \"gym[box2d]\" pip install \"gym[other]\" pip install numpy, matplotlib \"\"\" # import import numpy as np import gym import matplotlib.pyplot as plt # Import and initialize Mountain Car Environment env = gym . make ( 'MountainCar-v0' ) env . reset () # Define Q-learning function def QLearning ( env , learning , discount , epsilon , min_eps , episodes ): # Determine size of discretized state space num_states = ( env . observation_space . high - env . observation_space . low ) * \\ np . array ([ 10 , 100 ]) num_states = np . round ( num_states , 0 ) . astype ( int ) + 1 # Initialize Q table Q = np . random . uniform ( low = - 1 , high = 1 , size = ( num_states [ 0 ], num_states [ 1 ], env . action_space . n )) # Initialize variables to track rewards reward_list = [] ave_reward_list = [] # Calculate episodic reduction in epsilon reduction = ( epsilon - min_eps ) / episodes # Run Q learning algorithm for i in range ( episodes ): # Initialize parameters done = False tot_reward , reward = 0 , 0 state = env . reset () # Discretize state state_adj = ( state [ 0 ] - env . observation_space . low ) * np . array ([ 10 , 100 ]) state_adj = np . round ( state_adj , 0 ) . astype ( int ) while done != True : # Render environment for last five episodes if i >= ( episodes - 20 ): env . render () # Determine next action - epsilon greedy strategy if np . random . random () < 1 - epsilon : action = np . argmax ( Q [ state_adj [ 0 ], state_adj [ 1 ]]) else : action = np . random . randint ( 0 , env . action_space . n ) # Get next state and reward state2 , reward , done , info , _ = env . step ( action ) # Discretize state2 state2_adj = ( state2 - env . observation_space . low ) * np . array ([ 10 , 100 ]) state2_adj = np . round ( state2_adj , 0 ) . astype ( int ) #Allow for terminal states if done and state2 [ 0 ] >= 0.5 : Q [ state_adj [ 0 ], state_adj [ 1 ], action ] = reward # Adjust Q value for current state else : delta = learning * ( reward + discount * np . max ( Q [ state2_adj [ 0 ], state2_adj [ 1 ]]) - Q [ state_adj [ 0 ], state_adj [ 1 ], action ]) Q [ state_adj [ 0 ], state_adj [ 1 ], action ] += delta # Update variables tot_reward += reward state_adj = state2_adj # Decay epsilon if epsilon > min_eps : epsilon -= reduction # Track rewards reward_list . append ( tot_reward ) if ( i + 1 ) % 100 == 0 : ave_reward = np . mean ( reward_list ) ave_reward_list . append ( ave_reward ) reward_list = [] if ( i + 1 ) % 100 == 0 : print ( 'Episode {} Average Reward: {} ' . format ( i + 1 , ave_reward )) env . close () # save the Q table np . save ( 'MountainCar-v0-q-learning' , Q ) return ave_reward_list # Run Q-learning algorithm rewards = QLearning ( env , 0.2 , 0.9 , 0.8 , 0 , 5000 ) # Plot Rewards plt . plot ( 100 * ( np . arange ( len ( rewards )) + 1 ), rewards ) plt . xlabel ( 'Episodes' ) plt . ylabel ( 'Average Reward' ) plt . title ( 'Average Reward vs Episodes' ) plt . savefig ( 'rewards.jpg' ) plt . close () Running the above code trains a RL agent for 5000 episodes and saves the Q-table as numpy array. It also computes the average reward vs episodes graph that is shown below. Do note how the agent is able to get more rewards over more training! Increasing reward over time for the agent in training. The average rewards went up from -4300 to -250 under just 5000 episodes.","title":"Training Agent using Q-learning"},{"location":"reinforcement_learning/q_learning/#inference-of-trained-agent","text":"To run the trained model, we can use the saved Q-table to select the best action given any state in the game. Below is the code for the same, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \"\"\" Requirements; (don't forget to create new VE) pip install gym pip install \"gym[box2d]\" pip install \"gym[other]\" MountainCar-v0-q-table.txt.npy file that contains the modelled environment \"\"\" # import import gym import numpy as np from gym.utils import play # load trained Q table Q = np . load ( 'MountainCar-v0-q-table.txt.npy' ) # create an env env = gym . make ( \"MountainCar-v0\" , render_mode = \"human\" ) # seed env . action_space . seed ( 42 ) observation , info = env . reset ( seed = 42 ) # total number of steps for s in range ( 200 ): state_adj = ( observation - env . observation_space . low ) * np . array ([ 10 , 100 ]) state_adj = np . round ( state_adj , 0 ) . astype ( int ) # define the next step to take next_action = np . argmax ( Q [ state_adj [ 0 ], state_adj [ 1 ]]) # perform one step observation , reward , terminated , truncated , info = env . step ( next_action ) print ( s , observation , reward , terminated , truncated , info ) # if the game ends, restart the game if terminated or truncated : observation , info = env . reset () env . close () Trained RL agent performing as expected There you go!!","title":"Inference of trained agent"},{"location":"reinforcement_learning/q_learning/#references","text":"Interactive Q Learning - Mohit Mayank","title":"References"},{"location":"reinforcement_learning/rlhf/","text":"Reinforcement Learning from Human Feedback (RLHF) Introduction In Reinforcement learning , an agent learns to perform a task by interacting with an environment and receiving rewards or penalties for its actions. While this approach has shown great success in a wide range of applications, it can be difficult to design reward functions that accurately capture the user's preferences. Take autonomous driving car as an example, instead of creating a complicated reward function (with metrics like follow the lane, on wet road drive slow, stop at stop sign, don't hit anyone, etc and their weightage) we might want to let AI learn it. One point to note, we also do not want AI to learn to imitate human drivers, but rather learn what humans value in driving behavior and then optimize against those preferences. Because of this, we not only want trajectories (episodes or examples) , but also some form of feedbacks on different trajectories stating which one is better than the other. Once we have this, we can train a model to first learn the reward function ( Inverse Reinforcement Learning ) and later use the same reward to train an expert model ( Apprenticeship learning ) In this article, we will start with understanding the fundamentals of different types of human feedback, how to use them with RL and their pros and cons. Finally, we will discuss application of RLHF in NLP with tasks like Summarization. Let's start Types of human feedback There are different types of human feedback that can be used in reinforcement learning. These include: Explicit feedback: This type of feedback is direct and clear. It involves a human providing a specific reward or penalty to reinforce or discourage certain behaviors. For example, a teacher might provide explicit feedback to a student by giving them a grade for their performance. Implicit feedback: This type of feedback is more subtle and indirect. It involves a human providing information about what they like or dislike without explicitly stating it. For example, a customer might provide implicit feedback to a restaurant by choosing to visit it again or not. Comparison-based feedback: This type of feedback involves a human comparing the performance of an agent to that of another agent or a benchmark. For example, a manager might provide comparison-based feedback to an employee by comparing their performance to that of other employees in the same position. Incorporating human feedback There are several methods for incorporating human feedback in reinforcement learning, including: Reward shaping: This method involves modifying the reward function to incorporate human feedback. The goal is to manually guide the learning process towards behaviors that are more aligned with the user's preferences. For example, if a user wants a robot to clean a room quickly and efficiently, the reward function can be modified to encourage the robot to complete the task as quickly as possible. Imitation learning: This method involves learning from demonstration. The agent observes a human expert performing a task and learns to mimic their behavior. This method is particularly useful when the task is complex and difficult to learn from scratch. For example, a robot can learn to fold laundry by watching a human expert do it. Inverse reinforcement learning: This method involves inferring the reward function from human demonstrations. The agent observes a human expert performing a task and tries to learn the underlying reward function that motivated the expert's behavior. This method is particularly useful when the user's preferences are not easily expressed in terms of a reward function. For example, a robot can infer the reward function that motivated a human expert to perform a task and then optimize its behavior accordingly. These methods can be used alone or in combination to incorporate human feedback in reinforcement learning. The choice of method depends on the nature of the task, the type of human feedback available, and the computational resources available for learning. Benefits and challenges of using human feedback Using human feedback in reinforcement learning has several benefits, but also presents some challenges. Benefits Improved efficiency: Incorporating human feedback can accelerate the learning process and reduce the number of trials required to learn a task. By providing feedback that guides the agent towards desirable behaviors, human feedback can help the agent focus on the most promising strategies. Better performance: Human feedback can improve the quality of the learned policy and increase the success rate of the task. By incorporating the user's preferences, the agent can learn to optimize its behavior for the specific context of the task. Increased interpretability: Human feedback can make the learned policy more transparent and interpretable. By understanding the user's preferences, the agent can provide explanations for its actions and provide insights into how it works. Challenges Quality of human feedback: The quality of human feedback can vary depending on the user's expertise, knowledge, and ability to articulate their preferences. Some users may have conflicting preferences or provide ambiguous feedback, which can make it difficult for the agent to learn effectively. Bias and subjectivity: Human feedback can be biased and subjective, depending on the user's cultural background, personal beliefs, and emotional state. These factors can introduce bias into the learning process and make it difficult to generalize the learned policy to different contexts. Limited scalability: Incorporating human feedback can be resource-intensive and may not be feasible for large-scale applications. Collecting and processing feedback from multiple users can be time-consuming, and the resulting models may not be generalizable to new users. RLHF in NLP Reinforcement learning from human feedback (RLHF) has shown great potential in improving natural language processing (NLP) tasks. In NLP, the use of human feedback can help to capture the nuances of language and better align the agent's behavior with the user's expectations. PPO model trained with RLHF outperforming SFT and base models by OpenAI. Source [2] Summarization One of the first examples of utilizing RLHF in NLP was proposed in [1] to improve summarization using human feedback. Summarization aims to generate summaries that capture the most important information from a longer text. In RLHF, human feedback can be used to evaluate the quality of summaries and guide the agent towards more informative and concise summaries. This is quite difficult to capture using the metrics like ROUGE as they miss the human preferences. The overall process was as follows, First, an autoregressive model is trained via supervised learning on the dataset (TL;DR dataset with >120k post from reddits and their summaries were taken) . The resulting model is termed as initial policy. Then the following steps are performed in iteration, For each reddit post, samples from initial policy, current policy (for step 0 its same as initial policy) , other baselines, and original summaries are taken and send over to human labelers. Based on human labelers's feedback, we now have candidate summary for each post. We use this data to train a reward function (linear layer on initial policy) using supervised learning. The output of reward function is treated as the reward to optimize using the reinforcement learning (authors use PPO algorithm) . To shed more light on the how policies are trained using rewards, the finetuned model is treated as initial policy. In RL terminology, state is the prompt plus the generations so far, action is token to generate, each step is one token generation and one episode terminates when policy returns <EOS> token. Also, the reward function gives score for the complete summary and not individual generations. Finally, a conditioning term in added to the final reward that penalizes the KL divergence between the learned RL policy and the original supervised model. Quoting the paper, \"This KL term serves two purposes. First, it acts as an entropy bonus, encouraging the policy to explore and deterring it from collapsing to a single mode. Second, it ensures the policy doesn\u2019t learn to produce outputs that are too different from those that the reward model has seen during training.\" Diagram of human feedback, reward model training, and policy training procedure in [1] ChatGPT like Dialog Systems Probably the most famous use case of RLHF in NLP was to finetune the raw ChatGPT model to make it a more dialog friendly system. In a dialog system, the aim is to generate responses to user inputs that are coherent, informative, and relevant to the user's goals. In RLHF, human feedback can be used to evaluate the quality of generated responses and guide the agent towards more effective communication strategies. For example, a user can provide explicit feedback on the relevance of a response, or implicit feedback by continuing or ending the conversation. Conclusion While RLHF has shown promise in improving NLP tasks, there are still challenges related to the quality of human feedback and the scalability of the approach. Collecting and processing human feedback can be time-consuming and may not be feasible for large-scale applications. Furthermore, human feedback can be subjective and may not capture the full range of user preferences. However, as RLHF continues to be refined, it has the potential to greatly enhance the quality and effectiveness of NLP systems. References [1] Learning to summarize from human feedback [2] Training language models to follow instructions with human feedback","title":"RLHF"},{"location":"reinforcement_learning/rlhf/#reinforcement-learning-from-human-feedback-rlhf","text":"","title":"Reinforcement Learning from Human Feedback (RLHF)"},{"location":"reinforcement_learning/rlhf/#introduction","text":"In Reinforcement learning , an agent learns to perform a task by interacting with an environment and receiving rewards or penalties for its actions. While this approach has shown great success in a wide range of applications, it can be difficult to design reward functions that accurately capture the user's preferences. Take autonomous driving car as an example, instead of creating a complicated reward function (with metrics like follow the lane, on wet road drive slow, stop at stop sign, don't hit anyone, etc and their weightage) we might want to let AI learn it. One point to note, we also do not want AI to learn to imitate human drivers, but rather learn what humans value in driving behavior and then optimize against those preferences. Because of this, we not only want trajectories (episodes or examples) , but also some form of feedbacks on different trajectories stating which one is better than the other. Once we have this, we can train a model to first learn the reward function ( Inverse Reinforcement Learning ) and later use the same reward to train an expert model ( Apprenticeship learning ) In this article, we will start with understanding the fundamentals of different types of human feedback, how to use them with RL and their pros and cons. Finally, we will discuss application of RLHF in NLP with tasks like Summarization. Let's start","title":"Introduction"},{"location":"reinforcement_learning/rlhf/#types-of-human-feedback","text":"There are different types of human feedback that can be used in reinforcement learning. These include: Explicit feedback: This type of feedback is direct and clear. It involves a human providing a specific reward or penalty to reinforce or discourage certain behaviors. For example, a teacher might provide explicit feedback to a student by giving them a grade for their performance. Implicit feedback: This type of feedback is more subtle and indirect. It involves a human providing information about what they like or dislike without explicitly stating it. For example, a customer might provide implicit feedback to a restaurant by choosing to visit it again or not. Comparison-based feedback: This type of feedback involves a human comparing the performance of an agent to that of another agent or a benchmark. For example, a manager might provide comparison-based feedback to an employee by comparing their performance to that of other employees in the same position.","title":"Types of human feedback"},{"location":"reinforcement_learning/rlhf/#incorporating-human-feedback","text":"There are several methods for incorporating human feedback in reinforcement learning, including: Reward shaping: This method involves modifying the reward function to incorporate human feedback. The goal is to manually guide the learning process towards behaviors that are more aligned with the user's preferences. For example, if a user wants a robot to clean a room quickly and efficiently, the reward function can be modified to encourage the robot to complete the task as quickly as possible. Imitation learning: This method involves learning from demonstration. The agent observes a human expert performing a task and learns to mimic their behavior. This method is particularly useful when the task is complex and difficult to learn from scratch. For example, a robot can learn to fold laundry by watching a human expert do it. Inverse reinforcement learning: This method involves inferring the reward function from human demonstrations. The agent observes a human expert performing a task and tries to learn the underlying reward function that motivated the expert's behavior. This method is particularly useful when the user's preferences are not easily expressed in terms of a reward function. For example, a robot can infer the reward function that motivated a human expert to perform a task and then optimize its behavior accordingly. These methods can be used alone or in combination to incorporate human feedback in reinforcement learning. The choice of method depends on the nature of the task, the type of human feedback available, and the computational resources available for learning.","title":"Incorporating human feedback"},{"location":"reinforcement_learning/rlhf/#benefits-and-challenges-of-using-human-feedback","text":"Using human feedback in reinforcement learning has several benefits, but also presents some challenges.","title":"Benefits and challenges of using human feedback"},{"location":"reinforcement_learning/rlhf/#benefits","text":"Improved efficiency: Incorporating human feedback can accelerate the learning process and reduce the number of trials required to learn a task. By providing feedback that guides the agent towards desirable behaviors, human feedback can help the agent focus on the most promising strategies. Better performance: Human feedback can improve the quality of the learned policy and increase the success rate of the task. By incorporating the user's preferences, the agent can learn to optimize its behavior for the specific context of the task. Increased interpretability: Human feedback can make the learned policy more transparent and interpretable. By understanding the user's preferences, the agent can provide explanations for its actions and provide insights into how it works.","title":"Benefits"},{"location":"reinforcement_learning/rlhf/#challenges","text":"Quality of human feedback: The quality of human feedback can vary depending on the user's expertise, knowledge, and ability to articulate their preferences. Some users may have conflicting preferences or provide ambiguous feedback, which can make it difficult for the agent to learn effectively. Bias and subjectivity: Human feedback can be biased and subjective, depending on the user's cultural background, personal beliefs, and emotional state. These factors can introduce bias into the learning process and make it difficult to generalize the learned policy to different contexts. Limited scalability: Incorporating human feedback can be resource-intensive and may not be feasible for large-scale applications. Collecting and processing feedback from multiple users can be time-consuming, and the resulting models may not be generalizable to new users.","title":"Challenges"},{"location":"reinforcement_learning/rlhf/#rlhf-in-nlp","text":"Reinforcement learning from human feedback (RLHF) has shown great potential in improving natural language processing (NLP) tasks. In NLP, the use of human feedback can help to capture the nuances of language and better align the agent's behavior with the user's expectations. PPO model trained with RLHF outperforming SFT and base models by OpenAI. Source [2]","title":"RLHF in NLP"},{"location":"reinforcement_learning/rlhf/#summarization","text":"One of the first examples of utilizing RLHF in NLP was proposed in [1] to improve summarization using human feedback. Summarization aims to generate summaries that capture the most important information from a longer text. In RLHF, human feedback can be used to evaluate the quality of summaries and guide the agent towards more informative and concise summaries. This is quite difficult to capture using the metrics like ROUGE as they miss the human preferences. The overall process was as follows, First, an autoregressive model is trained via supervised learning on the dataset (TL;DR dataset with >120k post from reddits and their summaries were taken) . The resulting model is termed as initial policy. Then the following steps are performed in iteration, For each reddit post, samples from initial policy, current policy (for step 0 its same as initial policy) , other baselines, and original summaries are taken and send over to human labelers. Based on human labelers's feedback, we now have candidate summary for each post. We use this data to train a reward function (linear layer on initial policy) using supervised learning. The output of reward function is treated as the reward to optimize using the reinforcement learning (authors use PPO algorithm) . To shed more light on the how policies are trained using rewards, the finetuned model is treated as initial policy. In RL terminology, state is the prompt plus the generations so far, action is token to generate, each step is one token generation and one episode terminates when policy returns <EOS> token. Also, the reward function gives score for the complete summary and not individual generations. Finally, a conditioning term in added to the final reward that penalizes the KL divergence between the learned RL policy and the original supervised model. Quoting the paper, \"This KL term serves two purposes. First, it acts as an entropy bonus, encouraging the policy to explore and deterring it from collapsing to a single mode. Second, it ensures the policy doesn\u2019t learn to produce outputs that are too different from those that the reward model has seen during training.\" Diagram of human feedback, reward model training, and policy training procedure in [1]","title":"Summarization"},{"location":"reinforcement_learning/rlhf/#chatgpt-like-dialog-systems","text":"Probably the most famous use case of RLHF in NLP was to finetune the raw ChatGPT model to make it a more dialog friendly system. In a dialog system, the aim is to generate responses to user inputs that are coherent, informative, and relevant to the user's goals. In RLHF, human feedback can be used to evaluate the quality of generated responses and guide the agent towards more effective communication strategies. For example, a user can provide explicit feedback on the relevance of a response, or implicit feedback by continuing or ending the conversation.","title":"ChatGPT like Dialog Systems"},{"location":"reinforcement_learning/rlhf/#conclusion","text":"While RLHF has shown promise in improving NLP tasks, there are still challenges related to the quality of human feedback and the scalability of the approach. Collecting and processing human feedback can be time-consuming and may not be feasible for large-scale applications. Furthermore, human feedback can be subjective and may not capture the full range of user preferences. However, as RLHF continues to be refined, it has the potential to greatly enhance the quality and effectiveness of NLP systems.","title":"Conclusion"},{"location":"reinforcement_learning/rlhf/#references","text":"[1] Learning to summarize from human feedback [2] Training language models to follow instructions with human feedback","title":"References"}]}